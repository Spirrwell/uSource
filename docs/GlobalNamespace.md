# Global Namespace



## Namespaces

AppFramework

mathlib

logger

dbg

basetypes

UI

bsp20

reflection

NetworkSystem

rendersystem

__func_command_screen_stats_namespace

CUtlRBTreeInternal

platform

threadtools

xprof

__func_command_ShowNewOptionsMenu_namespace

__func_command_getpos_namespace

Images

__func_command_FrameTest_namespace

__func_command_ResumeGame_namespace

__func_command_Disconnect_namespace

__func_command_OpenNewGameDialog_namespace

__func_command_OpenLoadGameDialog_namespace

__func_command_OpenSaveGameDialog_namespace

__func_command_OpenServerBrowser_namespace

__func_command_OpenCreateMultiplayerGameDialog_namespace

__func_command_OpenChangeGameDialog_namespace

__func_command_OpenOptionsDialog_namespace

__func_command_QuitGame_namespace

__func_command_ShowConsole_namespace

__func_command_StartHazardCourse_namespace

__func_command_assert_break_all_namespace

__func_command_assert_unbreak_all_namespace

__func_command_assert_break_namespace

__func_command_assert_unbreak_namespace

__func_command_assert_disable_all_namespace

__func_command_assert_enable_all_namespace

__func_command_assert_disable_namespace

__func_command_assert_enable_namespace

__func_command_assert_all_once_namespace

__func_command_assert_all_unlimited_namespace

__func_command_assert_list_namespace

__func_command_assert_test_namespace

__func_command_assert_test2_namespace

__func_command_raise_namespace

__func_command_xprof_show_budget_namespace

__func_command_xprof_list_categories_namespace

__func_command_xprof_set_budget_namespace

__func_command_xprof_get_budget_namespace

__func_command_xprof_dump_nodes_namespace

__func_command_xprof_reset_budgets_namespace

__func_command_ent_create_namespace



## Records

AllocatorBase

DefaultAllocator

StaticAllocator

List

IAppInterface

iface_t

String

StringView

mplane_s

file_s

wfile_s

stream_s

dllfunc_s

dll_info_s

color24

colorVec

link_s

edict_s

plane_t

trace_t

_resourceinfo_t

resourceinfo_s

resource_s

customization_s

cvar_s

TraceResult

CDStatus

delta_s

entity_state_s

enginefuncs_s

entvars_s

KeyValueData_s

LEVELLIST

ENTITYTABLE

saverestore_s

TYPEDESCRIPTION

weapon_data_s

playermove_s

clientdata_s

usercmd_s

netadr_s

DLL_FUNCTIONS

NEW_DLL_FUNCTIONS

IEngineDebug

IEngineFilesystem

IEngineTrace

IEngineCvar

IEngineInterface

ILogSystem

log_hdr_t

log_msg_register_channel_t

log_msg_log_t

log_msg_stdin_t

Convar

ConCommand

Vector2D

Vector

tagPOINT

dlump_t

dheader_t

dextrahdr_t

dmodel_t

dmiptexlump_t

dvertex_t

dplane_t

dnode_t

dnode32_t

dleaf_t

dleaf32_t

dclipnode_t

dclipnode32_t

dtexinfo_t

dfaceinfo_t

dedge_t

dedge32_t

dface_t

dface32_t

mvertex_t

mclipnode_t

medge_t

texture_s

msurface_s

mfaceinfo_t

mfacebevel_t

mtexinfo_t

glpoly_s

mnode_s

decal_s

mleaf_s

efrag_s

mextrasurf_s

cl_entity_s

grasshdr_s

hull_s

cache_user_s

model_s

alight_s

auxvert_s

player_info_s

mspriteframe_s

mspritegroup_t

mspriteframedesc_t

msprite_t

trivertex_t

maliasframedesc_t

aliashdr_t

mouth_t

latchedvars_t

position_history_t

local_state_s

event_args_s

lightstyle_t

dlight_s

modelstate_s

decallist_s

ref_viewpass_s

render_api_s

mstudiotex_s

ref_overview_s

render_interface_s

gl_frustum_s

bpc_desc_s

rgbdata_s

vpoint_t

vguiapi_s

triangleapi_s

studiohdr_s

studiohdr2_t

studioseqhdr_t

mstudiobone_s

mstudioboneinfo_t

mstudiobonecontroller_t

mstudiobbox_t

mstudioseqgroup_t

mstudioseqgroup32_t

mstudioseqdesc_s

mstudioevent_s

mstudiopivot_t

mstudioattachment_t

mstudioanim_s

globalvars_t

mstudioanimvalue_t

mstudiobodyparts_t

mstudioboneweight_t

cmdalias_s

wrect_s

mstudiomodel_t

SCREENINFO_s

mstudiomesh_t

client_data_s

mstudiotrivert_t

client_sprite_s

client_textmessage_s

particle_s

hud_player_info_s

beam_s

screenfade_s

tempent_s

pmtrace_s

efx_api_s

cl_enginefuncs_s

con_nprint_s

event_api_s

demo_api_s

net_api_s

IVoiceTweak_s

IClientInterface

ref_params_s

physent_s

IInputSystem

net_response_s

net_adrlist_s

net_status_s

IEngineNetAPI

IEngineNetsystem

sortedface_t

ref_globals_s

remap_info_s

engine_studio_api_s

r_studio_interface_s

IEngineEfx

ref_api_s

world_static_s

movevars_s

mip_s

ref_interface_s

IRenderBackend

IEngineEvents

IEngineDemo

mobile_engfuncs_s

mpg123_handle_s

synth_s

frame_index_s

buffy_s

bufferchain_s

reader_data_s

reader_s

gltexture_s

ref_instance_t

al_table_t

draw_list_t

outbuffer_s

audioformat_s

gl_globals_t

mpg123_parm_s

ref_speeds_t

mpg123_id3v1

WEAPON

POSITION

RGBA

CHudBase

HUDLIST

overviewInfo_s

overviewEntity_s

CHudSpectator

CHudAmmo

CHudAmmoSecondary

DAMAGE_IMAGE

CHudHealth

CHudGeiger

glconfig_t

CHudTrain

glstate_t

glwstate_t

CHudMOTD

CHudScoreboard

CHudStatusBar

extra_player_info_t

team_info_t

CHudDeathNotice

CHudMenu

CHudSayText

CHudBattery

CHudFlashlight

message_parms_t

CHudTextMessage

CHudMessage

activity_map_t

areanode_s

server_physics_api_s

physics_interface_s

CBaseEntity

CHudStatusIcons

CHud

CBasePlayerItem

CBasePlayer

hudtextparms_s

UTIL_GroupTrace

EHANDLE

CSave

CRestore

CSaveRestoreBuffer

pmplane_t

HEADER

globalentity_s

CGlobalState

Task_t

Schedule_t

WayPoint_t

MonsterEvent_t

CBaseMonster

CSquadMonster

CPointEntity

CMultiSource

CBaseDelay

CBaseAnimating

CBaseToggle

Array

CSound

CCineMonster

ItemInfo

AmmoInfo

locksounds

CBaseButton

_SelAmmo

CWorld

skilldata_t

CGib

CNode

CLink

DIST_INFO

CACHE_ENTRY

CGraph

CNodeEnt

CStack

CQueue

CQueuePriority

CSoundEnt

CHoundeye

CSprite

CBeam

CLaser

CBasePlayerWeapon

CBasePlayerAmmo

MULTIDAMAGE

CWeaponBox

CLaserSpot

CGrenade

CBaseGrenade

CApache

CApacheHVR

CNihilanth

CNihilanthHVR



_SDL_iconv_t

SDL_AssertData

SDL_atomic_t

SDL_mutex

SDL_semaphore

SDL_cond

SDL_Thread

SDL_RWops

SDL_AudioSpec

SDL_AudioCVT

_SDL_AudioStream

SDL_Color

SDL_Palette

SDL_PixelFormat

SDL_Point

SDL_FPoint

SDL_Rect

SDL_FRect

SDL_Surface

SDL_BlitMap

SDL_DisplayMode

SDL_Window

SDL_Keysym

SDL_Cursor

_SDL_Joystick

SDL_JoystickGUID

_SDL_GameController

SDL_GameControllerButtonBind

SDL_Finger

SDL_CommonEvent

SDL_DisplayEvent

SDL_WindowEvent

SDL_KeyboardEvent

SDL_TextEditingEvent

SDL_TextInputEvent

SDL_MouseMotionEvent

SDL_MouseButtonEvent

SDL_MouseWheelEvent

SDL_JoyAxisEvent

SDL_JoyBallEvent

SDL_JoyHatEvent

SDL_JoyButtonEvent

SDL_JoyDeviceEvent

SDL_ControllerAxisEvent

SDL_ControllerButtonEvent

SDL_ControllerDeviceEvent

SDL_AudioDeviceEvent

SDL_TouchFingerEvent

SDL_MultiGestureEvent

SDL_DollarGestureEvent

SDL_DropEvent

SDL_SensorEvent

SDL_QuitEvent

SDL_OSEvent

SDL_UserEvent

SDL_SysWMmsg

SDL_SysWMEvent

SDL_Event

_SDL_Haptic

SDL_HapticDirection

SDL_HapticConstant

SDL_HapticPeriodic

SDL_HapticCondition

SDL_HapticRamp

SDL_HapticLeftRight

SDL_HapticCustom

SDL_HapticEffect

SDL_MessageBoxButtonData

SDL_MessageBoxColor

SDL_MessageBoxColorScheme

SDL_MessageBoxData

SDL_RendererInfo

SDL_Renderer

SDL_Texture

_SDL_Sensor

SDL_WindowShapeParams

SDL_WindowShapeMode

SDL_version

search_t

vidmode_s

convar_s

MD5Context_t

KeyValues

gameinfo_s

sysinfo_s

game_status_t

field_t

host_redirect_s

soundlist_t

tentlist_t

host_parm_s

wavdata_t

movie_state_s

sv_client_s

sizebuf_s

cmd_s

GAMEINFO

ui_globalvars_s

ui_enginefuncs_s

UI_FUNCTIONS

ui_extendedfuncs_s

UI_EXTENDED_FUNCTIONS

sequenceEntry_

sentenceEntry_

dpackheader_t

dpackfile_t

dwadinfo_t

dlumpinfo_t

hpak_header_t

hpak_lump_t

hpak_info_t

zip_header_s

zip_header_extra_s

zip_cdf_header_s

zip_header_eocd_s

hash_pack_queue_s

CSqueak

CItem

CGameRules

CHalfLifeRules

CHalfLifeMultiplay

CRuleEntity

CRulePointEntity

CRuleBrushEntity

CGameScore

CGameEnd

CGameText

CGameTeamMaster

CGameTeamSet

CGamePlayerZone

CGamePlayerHurt

CGameCounter

CGameCounterSet

CGamePlayerEquip

CGamePlayerTeam

Size

Point

Rect

EngFuncs

CUtlMemory

CUtlVector

CUtlMemoryBase

CUtlMemoryFixed

CUtlVectorFixed

CCopyableUtlVectorFixed

CCopyableUtlVector

CUtlVectorAutoPurge

CUtlStringList

CFontBuilder

CBaseFont

CFontManager

bmp_t

rgbquad_t

CBMP

CMenuBaseItem

CMenuItemsHolder

CEventCallback

CUtlLinkedList

CMenuBaseWindow

CWindowStack

IGuiInterface

uiStatic_t

font_t

color_t

CMenuEntry

CMenu

uiFileDialogGlobal_t

CColor

CMenuBitmap

CMenuBannerBitmap

CMenuBackgroundBitmap

CMenuPicButton

CMenuFramework

CMenuAction

CMenuYesNoMessageBox

CMenuTabView

CMenuOptions

CPlayerMonster

consistency_s

model_info_t

hullnode_s

winding_s

hull_model_t

IModelLoader

IMapLoader

netsplit_chain_packet_s

netsplit_packet_s

netsplit_s

flowstats_t

flow_t

fragbuf_s

fbufqueue_s

netchan_s

event_info_s

event_state_s

ref_state_s

cldll_func_s

netbandwithgraph_s

frame_s

runcmd_s

pred_viewangle_t

cl_local_data_t

downloadtime_t

incomingtransfer_t

client_t

cl_user_message_t

cl_user_event_t

cl_font_t

client_draw_t

cl_predicted_player_s

gameui_draw_t

cached_spritelist_t

center_print_t

screen_shake_t

net_request_t

clgame_static_t

gameui_static_t

client_static_t

channel_s

rawchan_s

IServerInterface

sv_baseline_t

server_log_t

server_s

client_frame_t

challenge_t

sv_user_message_t

sv_pushed_t

sv_interp_t

svgame_static_t

server_static_t

base_command_hashmap_s

cmdbuf_t

mz_internal_state

mz_stream_s

mz_dummy_time_t_tag

tdefl_compressor

tinfl_decompressor_tag

tinfl_huff_table

CScissorState

loadformat_s

saveformat_s

imglib_s

bmp_t

tga_s

png_ihdr_s

png_s

png_footer_s

dds_pf_s

dds_caps_s

dds_s

CBsp20Loader

CMenuEditable

CMenuSlider

HashFunctor

HashFunctor

HashFunctor

HashFunctorStringCaseless

HashFunctorUnpaddedStructure

CUtlString

CDefCaselessUtlStringEquals

CDefCaselessUtlStringLess

HashFunctor

HashFunctorUtlStringCaseless

lmp_s

CZoneAllocator

IBaseMemoryAllocator

memheader_s

mempool_s

dll_user_s

ScreenShake

ScreenFade

DLL_DECALLIST

CSquidSpit

CBullsquid

dsprite_t

dsprite_q1_t

dsprite_hl_t

dspriteframe_t

dspritegroup_t

dspriteinterval_t

dframetype_t

daliashdr_t

stvert_t

dtriangle_s

daliasframe_t

daliasgroup_t

daliasskingroup_t

daliasinterval_t

daliasskininterval_t

CPlane

daliasframetype_t

daliasskintype_t

CTalkMonster

CCineAI

CScientist

CDeadScientist

CSittingScientist

model_loader_t

map_loader_t

server_studio_api_s

sv_blending_interface_s

IClientStudio

IEngineStudio

player_model_t

sortedmesh_s

studio_draw_state_t

CEngineStudio

__CStaticWrapperForInterfaces_CEngineStudio

CMP5

CMP5AmmoClip

CMP5Chainammo

CMP5AmmoGrenade

delta_field_t

delta_info_t

tagBITMAPFILEHEADER

tagBITMAPINFOHEADER

tagRGBQUAD

CServerInterface

__CStaticWrapperForInterfaces_CServerInterface

CPython

CPythonAmmo

suffix_s

cubepack_s

CMenuBaseModel

CMenuTable

CMenuBaseArrayModel

CStringArrayModel

CMenuFileDialog

CGlock

CGlockAmmo

weapon_script_sound_t

CWeaponScript

CMenuCheckBox

CMenuField

CMenuSpinControl

CMenuPlayerModelView



CMenuPlayerSetup

CFuncTank

CFuncTankGun

CFuncTankLaser

CFuncTankRocket

CFuncTankMortar

CFuncTankControls

portable_samplepair_t

paintbuffer_t

sfx_s

soundfade_t

musicfade_t

snd_format_s

dma_t

voxword_s

sentence_t

mixer_t

listener_t

bg_track_t

CFlockingFlyerFlock

CFlockingFlyer

CWorldItem

CItemSuit

CItemBattery

CItemAntidote

CItemSecurity

CItemLongJump

OverrideAlphaFactor

alias_draw_state_t

packet_latency_t

cmdinfo_t

CCrowbar

CBaseSpectator

charinfo

qfont_s

notify_t

con_lineinfo_s

console_t

CLegacyCineMonster

CCineScientist

CCine2Scientist

CCinePanther

CCineBarney

CCine2HeavyWeapons

CCine2Slave

CCine3Scientist

CCine3Barney

CCineBlood

beamseg_t

inputstate_s

CMenuTouchEdit

CGMan

CMenuSwitch

CCycler

CGenericCycler

CCyclerProbe

CCyclerSprite

CWeaponCycler

CWreckage

CStaticInitWrapper

CLambdaStaticInitWrapper

CStaticDestructionWrapper

CStaticInitDestroyWrapper

BufferSizePolicyLinear

BufferSizePolicyFixed

BufferT

FixedBufferT

STypeInfo_t

SFieldInfo_t

SNetworkedField_t

SBasicInput

SBasicOutput

IMethodInfoWrapper

SStructInfo_t

SMethodParameterInfo_t

SMethodInfo_t

TestStruct

CNetworkMessage

CServerUserMessageHook

CClientUserMessageHook

Map

MultiMap

HashMap

HasMultiMap

cl_usermsg_callback

sv_usermsg_callback_t

CSatchel

CTripmine

CSatchelCharge

enginekey_t

keyname_s

CCrossbow

CCrossbowAmmo

CMainUIGui

__CStaticWrapperForInterfaces_CMainUIGui

LogData

CUtlCharConversion

CUtlBuffer

CNumStr

CUtlCStringConversion

CUtlNoEscConversion

lzss_header_t

lzss_node_s

lzss_list_t

lzss_state_t

CEngineDebug

__CStaticWrapperForInterfaces_CEngineDebug

CBaseDoor

CRotDoor

CMomentaryDoor

CShotgun

CShotgunAmmo

kbutton_s

appsys_t

mod_t

CMenuModListModel

CMenuCustomGame

CHudOverview

scrvarlistentry_s

scrvarlist_s

scrvarnumber_t

scrvardef_t

CMenuScriptConfigPage

CMenuScriptConfig

point_s

CEgon

CEgonAmmo

CRpgRocket

CRpg

CRpgAmmo

CAirtank

WeaponsResource

HistoryResource

decalinfo_t

CDefOps

CDefLess

CDefLessReverse

CDefLessPtr

CDefCaselessStringLess

CDefStringLess

CDefRBTreeBalanceListener

CRBTreeBalanceListener

CUtlRBTreeBase

CUtlRBTree

charRange_t

FT_MemoryRec_

FT_StreamRec_

FT_StreamDesc_

FT_Vector_

FT_BBox_

FT_Bitmap_

FT_Outline_

FT_Outline_Funcs_

FT_RasterRec_

FT_Span_

FT_Raster_Params_

FT_Raster_Funcs_

FT_UnitVector_

FT_Matrix_

FT_Data_

FT_Generic_

FT_ListNodeRec_

FT_ListRec_

FT_Glyph_Metrics_

FT_Bitmap_Size_

FT_LibraryRec_

FT_ModuleRec_

FT_DriverRec_

FT_RendererRec_

FT_FaceRec_

FT_SizeRec_

FT_GlyphSlotRec_

FT_CharMapRec_

FT_Face_InternalRec_

FT_Size_InternalRec_

FT_Size_Metrics_

FT_SubGlyphRec_

FT_Slot_InternalRec_

FT_Parameter_

FT_Open_Args_

FT_Size_RequestRec_

FT_LayerIterator_

abc_t

CFreeTypeFont

CBitmapFont

CMenuGameOptions

CHalfLifeTeamplay

CScriptedSentence

CFurniture

CMenuInputDevices

sx_preset_s

dly_s

CGauss

CGaussAmmo

CMenuScrollView

CPathTrack

CFuncTrackTrain

CPathCorner

CBarney

CDeadBarney

CThreadRAIILock

CThread

CThreadMutex

CThreadRWMutex

CThreadSpinlock

CThreadSemaphore

CThreadSpinSemaphore

CThreadLockedAccessor

CInterlockedAccessor

CXProf

CXProfNode

CXProfTest

xprof_node_desc_t

CXProfInit

CMenuVidOptions

CInfoBM

CBMortar

CBigMomma

CMenuConnectionWarning

CGLRenderBackend

__CStaticWrapperForInterfaces_CGLRenderBackend





CZombie

dirty_t

COptionsMenu

log_channel_t

CLoggingSystem

__CStaticWrapperForInterfaces_CLoggingSystem

CHAssassin

CMenuCredits

touch_button_s

touchdefaultbutton_s

touchbuttonlist_s

touch_s

mstudiocache_s

CTentacle

CTentacleMaw

CEnvGlobal

CRotButton

CMomentaryRotButton

CEnvSpark

CButtonTarget

moveclip_t

linetrace_t

CHandGrenade

CHgun

CBasePlatTrain

CFuncPlat

CPlatTrigger

CFuncPlatRot

CFuncTrain

CFuncTrainControls

CFuncTrackChange

CFuncTrackAuto

CGunTarget

CStudioModelRenderer

CGameStudioModelRenderer

CEngineEfxAPI

__CStaticWrapperForInterfaces_CEngineEfxAPI

CEngineEventAPI

__CStaticWrapperForInterfaces_CEngineEventAPI

CEngineDemoAPI

__CStaticWrapperForInterfaces_CEngineDemoAPI

CEngineNetAPI

__CStaticWrapperForInterfaces_CEngineNetAPI

CActAnimating

CXenPLight

CXenHair

CXenTreeTrigger

CXenTree

CXenSpore

CXenSporeSmall

CXenSporeMed

CXenSporeLarge

CXenHull

CMenuVidModesModel

CMenuRenderersModel

CMenuVidModes

AbstractInput

CInput

kblist_s

CInputSystem

__CStaticWrapperForInterfaces_CInputSystem

moveclip_s

CController

CControllerHeadBall

CControllerZapBall

CMenuGamePad

CMenuZoo

CMenuMessageBox

ipfilter_s

cidfilter_s

CRat

wavinfo_t

wadlist_s

leaflist_s

dbspmodel_t

mlumpstat_t

loadstat_t

mlumpinfo_t

CMenuPlayerIntroduceDialog

CFlyingMonster

CIchthyosaur

cgltf_memory_options

cgltf_file_options

cgltf_options

cgltf_extras

cgltf_buffer

cgltf_buffer_view

cgltf_accessor_sparse

cgltf_accessor

cgltf_attribute

cgltf_image

cgltf_sampler

cgltf_texture

cgltf_texture_transform

cgltf_texture_view

cgltf_pbr_metallic_roughness

cgltf_pbr_specular_glossiness

cgltf_clearcoat

cgltf_material

cgltf_morph_target

cgltf_draco_mesh_compression

cgltf_primitive

cgltf_mesh

cgltf_node

cgltf_skin

cgltf_camera_perspective

cgltf_camera_orthographic

cgltf_camera

cgltf_light

cgltf_scene

cgltf_animation_sampler

cgltf_animation_channel

cgltf_animation

cgltf_asset

cgltf_data

jsmntok_t

jsmn_parser

CGlTfLoader

parserstate_t

str64_s

CMenuTouchButtons

CBreakable

CPushable

CBaseTurret

CTurret

CMiniTurret

CSentry

CNullEntity

CBaseDMStart

CMenuProgressBar

CMenuConnectionProgress

CMenuSaveLoad

CBarnacle

ucmd_s

loadwavfmt_s

streamfmt_s

sndlib_s

wavehdr_t

chunkhdr_t

CBitStringT

CVariableBitStringBase

CValidator

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

BitCountToEndMask_t

CFixedBitStringBase

CBitString

CFixedBitString

GAME_HEADER

SAVE_HEADER

SAVE_CLIENT

SAVE_LIGHTSTYLE

master_s

masterlist_s

oldcmd_t

msg_debug_t

CMenuAudio

CMenuMultiplayer

CMenuBaseClientWindow

CRoach

autocomplete_list_s

con_autocomplete_t

CAdvancedControls

CISlave

CFrictionModifier

CAutoTrigger

CTriggerRelay

CMultiManager

CRenderFxManager

CBaseTrigger

CTriggerHurt

CTriggerMonsterJump

CTriggerCDAudio

CTargetCDAudio

CTriggerMultiple

CTriggerOnce

CTriggerCounter

CTriggerVolume

CFireAndDie

CChangeLevel

CLadder

CTriggerPush

CTriggerTeleport

CTriggerSave

CTriggerEndSection

CTriggerGravity

CTriggerChangeTarget

CTriggerCamera

CHGrunt

CHGruntRepel

CDeadHGrunt

CLight

CEnvLight

CSmoker

CSpiral

CStomp

CGargantua

net_loopmsg_t

net_loopback_t

packetlag_s

LONGPACKET

SPLITPACKET

net_state_t

nsthread_s

httpserver_s

httpfile_s

http_static_s

CRecharge

gllightmapstate_t

vbovertex_s

vbotexture_s

vboarray_s

vbosurfdata_s

vbodecal_s

vbodecaldata_s

vbo_static_s

multitexturestate_s

CMenuSavePreview

CMenuSavesListModel

CMenuLoadGame

CHornet

CAGrunt

CBloater

ITEM_INFO

CLeech

CCommandLine

CGraph_Retail

CLink_Retail

CTestHull

tagNodePair

CNodeViewer

mapcycle_item_s

mapcycle_s

joy_axis_s

CBubbling

CLightning

CTripBeam

CGlow

CGibShooter

CEnvShooter

CTestEffect

CBlood

CShake

CFade

CMessage

CEnvFunnel

CEnvBeverage

CItemSoda

CMonsterMaker

DeathNoticeItem

CHeadCrab

CBabyCrab

envmap_s

EqualityFunctor

EqualityFunctor

EqualityFunctor

CUtlHashMap

parserstate_s

scrvardef_s

main_menu_button_t

CMenuMain

CMenuMapListModel

CMenuCreateGame



CMenuTouchOptions

dynpitchvol

CAmbientGeneric

CEnvSound

sentenceg

CSpeaker

demoheader_t

demoentry_t

demodirectory_t

demoangle_t



sequenceCommandMapping_

sequenceCommandLine_

sentenceGroupEntry_

newhuff

gr_info_s

III_sideinfo

bandInfoStruct

CHL1Client

__CStaticWrapperForInterfaces_CHL1Client

CShower

CEnvExplosion

t_ospreygrunt

COsprey

CEngineNetsystem001

__CStaticWrapperForInterfaces_CEngineNetsystem001

CHealthKit

CWallHealth

server_t

CMenuGameListModel

CMenuServerBrowser

CFuncMortarField

CMortar

inflate_state

tdefl_sym_freq

tdefl_output_buffer

stringlist_s

wadtype_s

pack_s

zipfile_s

zip_s

searchpath_s

CEngineFilesystem

__CStaticWrapperForInterfaces_CEngineFilesystem

CEngineCvar

__CStaticWrapperForInterfaces_CEngineCvar

entity_field_alias_t

pitchdrift_s

viewinterp_t

CFuncWall

CFuncWallToggle

CFuncConveyor

CFuncIllusionary

CFuncMonsterClip

CFuncRotating

CPendulum

CDecal

CCorpse

CSprayCan

CBloodSplat

CDeadHEV

CStripWeapons

CRevertSaved

CInfoIntermission

CGenericMonster

CMenuKeysModel

CMenuControls

CMenuNewGame

sv_ents_t



## Functions

### VectorNormalize

*float VectorNormalize(vec3_t v)*

*Defined at line 701 of ./common/../mathlib/vector.h*

### Matrix3x4_VectorTransform

*void Matrix3x4_VectorTransform(const matrix3x4 in, const float [3] v, float [3] out)*

*Defined at line 32 of ./mathlib/matrix.cpp*

========================================================================

		Matrix3x4 operations

========================================================================

### Matrix3x4_VectorITransform

*void Matrix3x4_VectorITransform(const matrix3x4 in, const float [3] v, float [3] out)*

*Defined at line 39 of ./mathlib/matrix.cpp*

### Matrix3x4_VectorRotate

*void Matrix3x4_VectorRotate(const matrix3x4 in, const float [3] v, float [3] out)*

*Defined at line 52 of ./mathlib/matrix.cpp*

### Matrix3x4_VectorIRotate

*void Matrix3x4_VectorIRotate(const matrix3x4 in, const float [3] v, float [3] out)*

*Defined at line 59 of ./mathlib/matrix.cpp*

### Matrix3x4_ConcatTransforms

*void Matrix3x4_ConcatTransforms(matrix3x4 out, const matrix3x4 in1, const matrix3x4 in2)*

*Defined at line 66 of ./mathlib/matrix.cpp*

### Matrix3x4_FromOriginQuat

*void Matrix3x4_FromOriginQuat(matrix3x4 out, const vec4_t quaternion, const vec3_t origin)*

*Defined at line 116 of ./mathlib/matrix.cpp*

### Matrix3x4_CreateFromEntity

*void Matrix3x4_CreateFromEntity(matrix3x4 out, const vec3_t angles, const vec3_t origin, float scale)*

*Defined at line 135 of ./mathlib/matrix.cpp*

### Matrix3x4_TransformPositivePlane

*void Matrix3x4_TransformPositivePlane(const matrix3x4 in, const vec3_t normal, float d, vec3_t out, float * dist)*

*Defined at line 216 of ./mathlib/matrix.cpp*

### Matrix3x4_TransformAABB

*void Matrix3x4_TransformAABB(const matrix3x4 world, const vec3_t mins, const vec3_t maxs, vec3_t absmin, vec3_t absmax)*

*Defined at line 277 of ./mathlib/matrix.cpp*

==================Matrix3x4_TransformAABB==================

### Matrix3x4_SetOrigin

*void Matrix3x4_SetOrigin(matrix3x4 out, float x, float y, float z)*

*Defined at line 82 of ./mathlib/matrix.cpp*

### Matrix3x4_Invert_Simple

*void Matrix3x4_Invert_Simple(matrix3x4 out, const matrix3x4 in1)*

*Defined at line 227 of ./mathlib/matrix.cpp*

### Matrix3x4_OriginFromMatrix

*void Matrix3x4_OriginFromMatrix(const matrix3x4 in, float * out)*

*Defined at line 89 of ./mathlib/matrix.cpp*

### Matrix3x4_AnglesFromMatrix

*void Matrix3x4_AnglesFromMatrix(const matrix3x4 in, vec3_t out)*

*Defined at line 96 of ./mathlib/matrix.cpp*

### Matrix3x4_Transpose

*void Matrix3x4_Transpose(matrix3x4 out, const matrix3x4 in1)*

*Defined at line 253 of ./mathlib/matrix.cpp*

### Matrix4x4_VectorTransform

*void Matrix4x4_VectorTransform(const matrix4x4 in, const float [3] v, float [3] out)*

*Defined at line 309 of ./mathlib/matrix.cpp*

========================================================================

		Matrix4x4 operations

========================================================================

### Matrix4x4_VectorITransform

*void Matrix4x4_VectorITransform(const matrix4x4 in, const float [3] v, float [3] out)*

*Defined at line 316 of ./mathlib/matrix.cpp*

### Matrix4x4_VectorRotate

*void Matrix4x4_VectorRotate(const matrix4x4 in, const float [3] v, float [3] out)*

*Defined at line 329 of ./mathlib/matrix.cpp*

### Matrix4x4_VectorIRotate

*void Matrix4x4_VectorIRotate(const matrix4x4 in, const float [3] v, float [3] out)*

*Defined at line 336 of ./mathlib/matrix.cpp*

### Matrix4x4_ConcatTransforms

*void Matrix4x4_ConcatTransforms(matrix4x4 out, const matrix4x4 in1, const matrix4x4 in2)*

*Defined at line 343 of ./mathlib/matrix.cpp*

### Matrix4x4_FromOriginQuat

*void Matrix4x4_FromOriginQuat(matrix4x4 out, const vec4_t quaternion, const vec3_t origin)*

*Defined at line 373 of ./mathlib/matrix.cpp*

### Matrix4x4_CreateFromEntity

*void Matrix4x4_CreateFromEntity(matrix4x4 out, const vec3_t angles, const vec3_t origin, float scale)*

*Defined at line 393 of ./mathlib/matrix.cpp*

### Matrix4x4_TransformPositivePlane

*void Matrix4x4_TransformPositivePlane(const matrix4x4 in, const vec3_t normal, float d, vec3_t out, float * dist)*

*Defined at line 513 of ./mathlib/matrix.cpp*

### Matrix4x4_TransformStandardPlane

*void Matrix4x4_TransformStandardPlane(const matrix4x4 in, const vec3_t normal, float d, vec3_t out, float * dist)*

*Defined at line 524 of ./mathlib/matrix.cpp*

### Matrix4x4_ConvertToEntity

*void Matrix4x4_ConvertToEntity(const matrix4x4 in, vec3_t angles, vec3_t origin)*

*Defined at line 490 of ./mathlib/matrix.cpp*

### Matrix4x4_SetOrigin

*void Matrix4x4_SetOrigin(matrix4x4 out, float x, float y, float z)*

*Defined at line 359 of ./mathlib/matrix.cpp*

### Matrix4x4_Invert_Simple

*void Matrix4x4_Invert_Simple(matrix4x4 out, const matrix4x4 in1)*

*Defined at line 535 of ./mathlib/matrix.cpp*

### Matrix4x4_OriginFromMatrix

*void Matrix4x4_OriginFromMatrix(const matrix4x4 in, float * out)*

*Defined at line 366 of ./mathlib/matrix.cpp*

### Matrix4x4_Transpose

*void Matrix4x4_Transpose(matrix4x4 out, const matrix4x4 in1)*

*Defined at line 567 of ./mathlib/matrix.cpp*

### Matrix4x4_Invert_Full

*qboolean Matrix4x4_Invert_Full(matrix4x4 out, const matrix4x4 in1)*

*Defined at line 587 of ./mathlib/matrix.cpp*

### V_CalcFov

*float V_CalcFov(float * fov_x, float width, float height)*

*Defined at line 770 of ./mathlib/mathlib.cpp*

====================V_CalcFov====================

### V_AdjustFov

*void V_AdjustFov(float * fov_x, float * fov_y, float width, float height, qboolean lock_x)*

*Defined at line 788 of ./mathlib/mathlib.cpp*

====================V_AdjustFov====================

### BoxOnPlaneSide

*int BoxOnPlaneSide(const vec3_t emins, const vec3_t emaxs, const mplane_t * p)*

*Defined at line 819 of ./mathlib/mathlib.cpp*

==================BoxOnPlaneSide

Returns 1, 2, or 1 + 2==================

### SetBits

*void SetBits(T & iBitVector, U bits)*

*Defined at line 65 of ./common/common.h*

### ClearBits

*void ClearBits(T & iBitVector, U bits)*

*Defined at line 73 of ./common/common.h*

### FBitSet

*_Bool FBitSet(T iBitVec, U bit)*

*Defined at line 81 of ./common/common.h*

### IsColorString

*_Bool IsColorString(const char * p)*

*Defined at line 96 of ./common/common.h*

### ColorIndex

*_Bool ColorIndex(char c)*

*Defined at line 97 of ./common/common.h*

### ToLittleEndian

*T ToLittleEndian(T & x)*

*Defined at line 166 of ./common/common.h*

### ToBigEndian

*T ToBigEndian(T & x)*

*Defined at line 172 of ./common/common.h*

### ConnectTier1Libraries

*void ConnectTier1Libraries()*

*Defined at line 10 of ./tier1/tier1.cpp*

### DotProduct

*float DotProduct(const class Vector2D & a, const class Vector2D & b)*

*Defined at line 67 of ./common/../mathlib/vector.h*

========================================================================================================//

### operator*

*Vector2D operator*(float fl, const class Vector2D & v)*

*Defined at line 68 of ./common/../mathlib/vector.h*

### operator*

*Vector operator*(float fl, const class Vector & v)*

*Defined at line 140 of ./common/../mathlib/vector.h*

========================================================================================================//

### DotProduct

*float DotProduct(const class Vector & a, const class Vector & b)*

*Defined at line 141 of ./common/../mathlib/vector.h*

### CrossProduct

*Vector CrossProduct(const class Vector & a, const class Vector & b)*

*Defined at line 142 of ./common/../mathlib/vector.h*

### Matrix3x4_FromOriginQuat

*void Matrix3x4_FromOriginQuat(matrix3x4 out, const vec4_t quaternion, Vector origin)*

### Matrix3x4_CreateFromEntity

*void Matrix3x4_CreateFromEntity(matrix3x4 out, Vector angles, Vector origin, float scale)*

### Matrix3x4_TransformPositivePlane

*void Matrix3x4_TransformPositivePlane(const matrix3x4 in, Vector normal, float d, Vector out, float * dist)*

### Matrix3x4_TransformAABB

*void Matrix3x4_TransformAABB(const matrix3x4 world, Vector mins, Vector maxs, Vector absmin, Vector absmax)*

### Matrix3x4_AnglesFromMatrix

*void Matrix3x4_AnglesFromMatrix(const matrix3x4 in, Vector out)*

### Matrix4x4_FromOriginQuat

*void Matrix4x4_FromOriginQuat(matrix4x4 out, const vec4_t quaternion, Vector origin)*

### Matrix4x4_CreateFromEntity

*void Matrix4x4_CreateFromEntity(matrix4x4 out, Vector angles, Vector origin, float scale)*

### Matrix4x4_TransformPositivePlane

*void Matrix4x4_TransformPositivePlane(const matrix4x4 in, Vector normal, float d, Vector out, float * dist)*

### Matrix4x4_TransformStandardPlane

*void Matrix4x4_TransformStandardPlane(const matrix4x4 in, Vector normal, float d, Vector out, float * dist)*

### Matrix4x4_ConvertToEntity

*void Matrix4x4_ConvertToEntity(const matrix4x4 in, Vector angles, Vector origin)*

### BoxOnPlaneSide

*int BoxOnPlaneSide(Vector emins, Vector emaxs, const mplane_t * p)*

### rsqrt

*float rsqrt(float number)*

*Defined at line 288 of ./mathlib/mathlib.cpp*

=================rsqrt=================

### anglemod

*float anglemod(float a)*

*Defined at line 48 of ./mathlib/mathlib.cpp*

=================anglemod=================

### FloatToHalf

*uint16_t FloatToHalf(float v)*

*Defined at line 72 of ./mathlib/mathlib.cpp*

### HalfToFloat

*float HalfToFloat(uint16_t h)*

*Defined at line 88 of ./mathlib/mathlib.cpp*

### SimpleSpline

*float SimpleSpline(float value)*

*Defined at line 64 of ./mathlib/mathlib.cpp*

=================SimpleSpline

NOTE: ripped from hl2 sourcehermite basis function for smooth interpolationSimilar to Gain() above, but very cheap to callvalue should be between 0 & 1 inclusive=================

### RoundUpHullSize

*void RoundUpHullSize(float [3] size)*

*Defined at line 126 of ./mathlib/mathlib.cpp*

=================RoundUpHullSize

round the hullsize to nearest 'right' value=================

### SignbitsForPlane

*int SignbitsForPlane(const float [3] normal)*

*Defined at line 177 of ./mathlib/mathlib.cpp*

=================SignbitsForPlane

fast box on planeside test=================

### PlaneTypeForNormal

*int PlaneTypeForNormal(const float [3] normal)*

*Defined at line 191 of ./mathlib/mathlib.cpp*

=================PlaneTypeForNormal=================

### NearestPOW

*int NearestPOW(int value, qboolean roundDown)*

*Defined at line 250 of ./mathlib/mathlib.cpp*

=================NearestPOW=================

### SinCos

*void SinCos(float radians, float * sine, float * cosine)*

*Defined at line 310 of ./mathlib/mathlib.cpp*

=================SinCos=================

### VectorNormalizeLength2

*float VectorNormalizeLength2(const float [3] v, float [3] out)*

*Defined at line 349 of ./mathlib/mathlib.cpp*

### VectorCompareEpsilon

*qboolean VectorCompareEpsilon(const float [3] vec1, const float [3] vec2, vec_t epsilon)*

*Defined at line 336 of ./mathlib/mathlib.cpp*

==============VectorCompareEpsilon

==============

### VectorVectors

*void VectorVectors(const float [3] forward, float [3] right, float [3] up)*

*Defined at line 367 of ./mathlib/mathlib.cpp*

### VectorAngles

*void VectorAngles(const float * forward, float * angles)*

*Defined at line 424 of ./mathlib/mathlib.cpp*

=================VectorAngles

=================

### AngleVectors

*void AngleVectors(const float [3] angles, float [3] forward, float [3] right, float [3] up)*

*Defined at line 388 of ./mathlib/mathlib.cpp*

=================AngleVectors

=================

### VectorsAngles

*void VectorsAngles(const float [3] forward, const float [3] right, const float [3] up, float [3] angles)*

*Defined at line 461 of ./mathlib/mathlib.cpp*

=================VectorsAngles

=================

### PlanesGetIntersectionPoint

*qboolean PlanesGetIntersectionPoint(const struct mplane_s * plane1, const struct mplane_s * plane2, const struct mplane_s * plane3, float [3] out)*

*Defined at line 208 of ./mathlib/mathlib.cpp*

=================PlanesGetIntersectionPoint

=================

### PlaneIntersect

*void PlaneIntersect(const struct mplane_s * plane, const float [3] p0, const float [3] p1, float [3] out)*

*Defined at line 594 of ./mathlib/mathlib.cpp*

=================PlaneIntersect

find point where raywas intersect with plane=================

### AngleMatrix

*void AngleMatrix(const float * angles, float (*)[4] matrix)*

*Defined at line 908 of ./mathlib/mathlib.cpp*

=============================================================================================// Originally in pm_math.cpp

### VectorTransform

*void VectorTransform(const float * in1, float [3][4] in2, float * out)*

*Defined at line 968 of ./mathlib/mathlib.cpp*

### AngleIMatrix

*void AngleIMatrix(const float [3] angles, float [3][4] matrix)*

*Defined at line 938 of ./mathlib/mathlib.cpp*

### InterpolateAngles

*void InterpolateAngles(float * start, float * end, float * output, float frac)*

*Defined at line 1001 of ./mathlib/mathlib.cpp*

===================InterpolateAngles

Interpolate Euler angles.FIXME:  Use Quaternions to avoid discontinuitiesFrac is 0.0 to 1.0 ( i.e., should probably be clamped, but doesn't have to be )===================

### NormalizeAngles

*void NormalizeAngles(float * angles)*

*Defined at line 975 of ./mathlib/mathlib.cpp*

### ClearBounds

*void ClearBounds(float [3] mins, float [3] maxs)*

*Defined at line 495 of ./mathlib/mathlib.cpp*

 bounds operations

=================ClearBounds=================

=============================================================================================//

### AddPointToBounds

*void AddPointToBounds(const float [3] v, float [3] mins, float [3] maxs)*

*Defined at line 507 of ./mathlib/mathlib.cpp*

=================AddPointToBounds=================

### BoundsIntersect

*qboolean BoundsIntersect(const float [3] mins1, const float [3] maxs1, const float [3] mins2, const float [3] maxs2)*

*Defined at line 540 of ./mathlib/mathlib.cpp*

=================BoundsIntersect=================

### BoundsAndSphereIntersect

*qboolean BoundsAndSphereIntersect(const float [3] mins, const float [3] maxs, const float [3] origin, float radius)*

*Defined at line 554 of ./mathlib/mathlib.cpp*

=================BoundsAndSphereIntersect=================

### SphereIntersect

*qboolean SphereIntersect(const float [3] vSphereCenter, float fSphereRadiusSquared, const float [3] vLinePt, const float [3] vLineDir)*

*Defined at line 568 of ./mathlib/mathlib.cpp*

=================SphereIntersect=================

### RadiusFromBounds

*float RadiusFromBounds(const float [3] mins, const float [3] maxs)*

*Defined at line 608 of ./mathlib/mathlib.cpp*

=================RadiusFromBounds=================

### ExpandBounds

*void ExpandBounds(float [3] mins, float [3] maxs, float offset)*

*Defined at line 525 of ./mathlib/mathlib.cpp*

=================ExpandBounds=================

### AngleQuaternion

*void AngleQuaternion(const float [3] angles, vec4_t q, qboolean studio)*

*Defined at line 629 of ./mathlib/mathlib.cpp*

 studio utils

====================AngleQuaternion

====================

### QuaternionAngle

*void QuaternionAngle(const vec4_t q, float [3] angles)*

*Defined at line 658 of ./mathlib/mathlib.cpp*

====================QuaternionAngle

====================

### QuaternionSlerp

*void QuaternionSlerp(const vec4_t p, const vec4_t q, float t, vec4_t qt)*

*Defined at line 754 of ./mathlib/mathlib.cpp*

====================QuaternionSlerp

Quaternion sphereical linear interpolation====================

### RemapVal

*float RemapVal(float val, float A, float B, float C, float D)*

*Defined at line 265 of ./mathlib/mathlib.cpp*

 remap a value in the range [A,B] to [C,D].

### ApproachVal

*float ApproachVal(float target, float value, float speed)*

*Defined at line 270 of ./mathlib/mathlib.cpp*

### AngleVectorsTranspose

*void AngleVectorsTranspose(const float [3] angles, float [3] forward, float [3] right, float [3] up)*

*Defined at line 873 of ./mathlib/mathlib.cpp*

### GL_FrustumInitProj

*void GL_FrustumInitProj(gl_frustum_t * out, float flZNear, float flZFar, float flFovX, float flFovY)*

*Defined at line 70 of ./rendersystem/r_frustrum.cpp*

### GL_FrustumInitOrtho

*void GL_FrustumInitOrtho(gl_frustum_t * out, float xLeft, float xRight, float yTop, float yBottom, float flZNear, float flZFar)*

*Defined at line 111 of ./rendersystem/r_frustrum.cpp*

### GL_FrustumInitBox

*void GL_FrustumInitBox(gl_frustum_t * out, const vec3_t org, float radius)*

*Defined at line 138 of ./rendersystem/r_frustrum.cpp*

### GL_FrustumInitProjFromMatrix

*void GL_FrustumInitProjFromMatrix(gl_frustum_t * out, const matrix4x4 projection)*

*Defined at line 152 of ./rendersystem/r_frustrum.cpp*

### GL_FrustumSetPlane

*void GL_FrustumSetPlane(gl_frustum_t * out, int side, const vec3_t vecNormal, float flDist)*

*Defined at line 34 of ./rendersystem/r_frustrum.cpp*

### GL_FrustumNormalizePlane

*void GL_FrustumNormalizePlane(gl_frustum_t * out, int side)*

*Defined at line 46 of ./rendersystem/r_frustrum.cpp*

### GL_FrustumComputeBounds

*void GL_FrustumComputeBounds(gl_frustum_t * out, vec3_t mins, vec3_t maxs)*

*Defined at line 223 of ./rendersystem/r_frustrum.cpp*

### GL_FrustumComputeCorners

*void GL_FrustumComputeCorners(gl_frustum_t * out, vec3_t [8] bbox)*

*Defined at line 198 of ./rendersystem/r_frustrum.cpp*

### GL_FrustumDrawDebug

*void GL_FrustumDrawDebug(gl_frustum_t * out)*

*Defined at line 236 of ./rendersystem/r_frustrum.cpp*

### GL_FrustumCullBox

*qboolean GL_FrustumCullBox(gl_frustum_t * out, const vec3_t mins, const vec3_t maxs, int userClipFlags)*

*Defined at line 269 of ./rendersystem/r_frustrum.cpp*

 cull methods

### GL_FrustumCullSphere

*qboolean GL_FrustumCullSphere(gl_frustum_t * out, const vec3_t centre, float radius, int userClipFlags)*

*Defined at line 330 of ./rendersystem/r_frustrum.cpp*

### GL_FrustumEnablePlane

*void GL_FrustumEnablePlane(gl_frustum_t * out, int side)*

*Defined at line 19 of ./rendersystem/r_frustrum.cpp*

 plane manipulating

### GL_FrustumDisablePlane

*void GL_FrustumDisablePlane(gl_frustum_t * out, int side)*

*Defined at line 28 of ./rendersystem/r_frustrum.cpp*

### init_synth

*void init_synth(mpg123_handle_t * fr)*

*Defined at line 214 of ./engine/common/soundlib/libmpg/synth.cpp*

### set_synth_functions

*int set_synth_functions(mpg123_handle_t * fr)*

*Defined at line 268 of ./engine/common/soundlib/libmpg/synth.cpp*

 set synth functions for current frame

### fi_init

*void fi_init(frame_index_t * fi)*

*Defined at line 49 of ./engine/common/soundlib/libmpg/index.cpp*

 initialize stuff, set things to zero and NULL...

### fi_exit

*void fi_exit(frame_index_t * fi)*

*Defined at line 59 of ./engine/common/soundlib/libmpg/index.cpp*

 deallocate/zero things.

### fi_resize

*int fi_resize(frame_index_t * fi, size_t newsize)*

*Defined at line 67 of ./engine/common/soundlib/libmpg/index.cpp*

 prepare a given size, preserving current fill, if possible.

### fi_add

*void fi_add(frame_index_t * fi, mpg_off_t pos)*

*Defined at line 100 of ./engine/common/soundlib/libmpg/index.cpp*

 append a frame position, reducing index density if needed.

### fi_set

*int fi_set(frame_index_t * fi, mpg_off_t * offsets, mpg_off_t step, size_t fill)*

*Defined at line 127 of ./engine/common/soundlib/libmpg/index.cpp*

 replace the frame index

### fi_reset

*void fi_reset(frame_index_t * fi)*

*Defined at line 150 of ./engine/common/soundlib/libmpg/index.cpp*

 empty the index (setting fill=0 and step=1), but keep current size.

### bc_prepare

*void bc_prepare(bufferchain_t * , size_t pool_size, size_t bufblock)*

*Defined at line 180 of ./engine/common/soundlib/libmpg/reader.cpp*

 call this before any buffer chain use (even bc_init()).

### bc_cleanup

*void bc_cleanup(bufferchain_t * )*

*Defined at line 199 of ./engine/common/soundlib/libmpg/reader.cpp*

 free persistent data in the buffer chain, after bc_reset().

### bc_poolsize

*void bc_poolsize(bufferchain_t * , size_t pool_size, size_t bufblock)*

*Defined at line 193 of ./engine/common/soundlib/libmpg/reader.cpp*

 change pool size. This does not actually allocate/free anything on itself, just instructs later operations to free less / allocate more buffers.

### bc_fill

*size_t bc_fill(bufferchain_t * bc)*

*Defined at line 188 of ./engine/common/soundlib/libmpg/reader.cpp*

 return available byte count in the buffer.

### open_stream

*int open_stream(mpg123_handle_t * fr, const char * path, int fd)*

 open a file by path or use an opened file descriptor

### open_stream_handle

*int open_stream_handle(mpg123_handle_t * fr, void * iohandle)*

*Defined at line 834 of ./engine/common/soundlib/libmpg/reader.cpp*

 open an external handle.

### open_feed

*int open_feed(mpg123_handle_t * fr)*

*Defined at line 845 of ./engine/common/soundlib/libmpg/reader.cpp*

 feed based operation has some specials

### feed_more

*int feed_more(mpg123_handle_t * fr, const byte * in, long count)*

*Defined at line 338 of ./engine/common/soundlib/libmpg/reader.cpp*

 externally called function, returns 0 on success, -1 on error

### feed_forget

*void feed_forget(mpg123_handle_t * fr)*

 forget the data that has been read (free some buffers)

### feed_set_pos

*mpg_off_t feed_set_pos(mpg123_handle_t * fr, mpg_off_t pos)*

*Defined at line 385 of ./engine/common/soundlib/libmpg/reader.cpp*

 set position (inside available data if possible), return wanted byte offset of next feed.

### open_bad

*void open_bad(mpg123_handle_t * fr)*

*Defined at line 770 of ./engine/common/soundlib/libmpg/reader.cpp*

 error fallback

### frame_init

*void frame_init(mpg123_handle_t * fr)*

*Defined at line 279 of ./engine/common/soundlib/libmpg/frame.cpp*

 generic init, does not include dynamic buffers

### GL_BackendStartFrame

*void GL_BackendStartFrame()*

*Defined at line 69 of ./rendersystem/r_backend.cpp*

 gl_backend.c

==============GL_BackendStartFrame==============

### frame_init_par

*void frame_init_par(mpg123_handle_t * fr, mpg123_parm_t * mp)*

*Defined at line 128 of ./engine/common/soundlib/libmpg/frame.cpp*

### GL_BackendEndFrame

*void GL_BackendEndFrame()*

*Defined at line 79 of ./rendersystem/r_backend.cpp*

==============GL_BackendEndFrame==============

### frame_outbuffer

*int frame_outbuffer(mpg123_handle_t * fr)*

*Defined at line 284 of ./engine/common/soundlib/libmpg/frame.cpp*

### GL_CleanUpTextureUnits

*void GL_CleanUpTextureUnits(int last)*

*Defined at line 223 of ./rendersystem/r_backend.cpp*

==============GL_CleanUpTextureUnits==============

### frame_output_format

*int frame_output_format(mpg123_handle_t * fr)*

*Defined at line 147 of ./engine/common/soundlib/libmpg/format.cpp*

 match constraints against supported audio formats, store possible setup in frame return: -1: error; 0: no format change; 1: format change

### GL_Bind

*void GL_Bind(GLint tmu, GLenum texnum)*

*Defined at line 69 of ./rendersystem/r_image.cpp*

=================GL_Bind=================

### frame_buffers

*int frame_buffers(mpg123_handle_t * fr)*

*Defined at line 178 of ./engine/common/soundlib/libmpg/frame.cpp*

### GL_MultiTexCoord2f

*void GL_MultiTexCoord2f(GLenum texture, GLfloat s, GLfloat t)*

*Defined at line 262 of ./rendersystem/r_backend.cpp*

=================GL_MultiTexCoord2f=================

### frame_reset

*int frame_reset(mpg123_handle_t * fr)*

*Defined at line 349 of ./engine/common/soundlib/libmpg/frame.cpp*

 prepare the handle for a new track. reset variables, buffers...

### GL_SetTexCoordArrayMode

*void GL_SetTexCoordArrayMode(GLenum mode)*

*Defined at line 351 of ./rendersystem/r_backend.cpp*

=================GL_SetTexCoordArrayMode=================

### frame_buffers_reset

*int frame_buffers_reset(mpg123_handle_t * fr)*

*Defined at line 261 of ./engine/common/soundlib/libmpg/frame.cpp*

### GL_LoadTexMatrix

*void GL_LoadTexMatrix(const matrix4x4 m)*

*Defined at line 124 of ./rendersystem/r_backend.cpp*

=================GL_LoadTexMatrix=================

### frame_exit

*void frame_exit(mpg123_handle_t * fr)*

*Defined at line 375 of ./engine/common/soundlib/libmpg/frame.cpp*

### GL_LoadTexMatrixExt

*void GL_LoadTexMatrixExt(const float * glmatrix)*

*Defined at line 136 of ./rendersystem/r_backend.cpp*

=================GL_LoadTexMatrixExt=================

### frame_index_setup

*int frame_index_setup(mpg123_handle_t * fr)*

*Defined at line 105 of ./engine/common/soundlib/libmpg/frame.cpp*

### GL_LoadMatrix

*void GL_LoadMatrix(const matrix4x4 source)*

*Defined at line 149 of ./rendersystem/r_backend.cpp*

=================GL_LoadMatrix=================

### frame_expect_outsamples

*mpg_off_t frame_expect_outsamples(mpg123_handle_t * fr)*

*Defined at line 546 of ./engine/common/soundlib/libmpg/frame.cpp*

 compute the number of output samples we expect from this frame. this is either simple spf() or a tad more elaborate for ntom.

### GL_TexGen

*void GL_TexGen(GLenum coord, GLenum mode)*

*Defined at line 301 of ./rendersystem/r_backend.cpp*

=================GL_TexGen=================

### frame_offset

*mpg_off_t frame_offset(mpg123_handle_t * fr, mpg_off_t outs)*

*Defined at line 561 of ./engine/common/soundlib/libmpg/frame.cpp*

### GL_SelectTexture

*void GL_SelectTexture(GLint texture)*

*Defined at line 177 of ./rendersystem/r_backend.cpp*

=================GL_SelectTexture=================

### GL_CleanupAllTextureUnits

*void GL_CleanupAllTextureUnits()*

*Defined at line 249 of ./rendersystem/r_backend.cpp*

==============GL_CleanupAllTextureUnits==============

### frame_gapless_init

*void frame_gapless_init(mpg123_handle_t * fr, mpg_off_t framecount, mpg_off_t bskip, mpg_off_t eskip)*

*Defined at line 577 of ./engine/common/soundlib/libmpg/frame.cpp*

 input in _input_ samples

### GL_LoadIdentityTexMatrix

*void GL_LoadIdentityTexMatrix()*

*Defined at line 162 of ./rendersystem/r_backend.cpp*

=================GL_LoadIdentityTexMatrix=================

### frame_gapless_realinit

*void frame_gapless_realinit(mpg123_handle_t * fr)*

*Defined at line 594 of ./engine/common/soundlib/libmpg/frame.cpp*

### GL_DisableAllTexGens

*void GL_DisableAllTexGens()*

*Defined at line 210 of ./rendersystem/r_backend.cpp*

==============GL_DisableAllTexGens==============

### frame_gapless_update

*void frame_gapless_update(mpg123_handle_t * fr, mpg_off_t total_samples)*

*Defined at line 605 of ./engine/common/soundlib/libmpg/frame.cpp*

 at least note when there is trouble...

### GL_SetRenderMode

*void GL_SetRenderMode(int mode)*

*Defined at line 393 of ./rendersystem/r_backend.cpp*

### GL_TextureTarget

*void GL_TextureTarget(uint target)*

*Defined at line 278 of ./rendersystem/r_backend.cpp*

=================GL_TextureTarget=================

### frame_index_find

*mpg_off_t frame_index_find(mpg123_handle_t * fr, mpg_off_t want_frame, mpg_off_t * get_frame)*

*Defined at line 466 of ./engine/common/soundlib/libmpg/frame.cpp*

 find the best frame in index just before the wanted one, seek to there then step to just before wanted one with read_frame do not care tabout the stuff that was in buffer but not played back everything that left the decoder is counted as played decide if you want low latency reaction and accurate timing info or stable long-time playback with buffer!

### GL_Cull

*void GL_Cull(GLenum cull)*

*Defined at line 379 of ./rendersystem/r_backend.cpp*

=================GL_Cull=================

### frame_outs

*mpg_off_t frame_outs(mpg123_handle_t * fr, mpg_off_t num)*

*Defined at line 529 of ./engine/common/soundlib/libmpg/frame.cpp*

### R_ShowTextures

*void R_ShowTextures()*

*Defined at line 611 of ./rendersystem/r_backend.cpp*

===============R_ShowTextures

Draw all the images to the screen, on top of whateverwas there.  This is used to test for texture thrashing.===============

### frame_set_seek

*void frame_set_seek(mpg123_handle_t * fr, mpg_off_t sp)*

*Defined at line 690 of ./engine/common/soundlib/libmpg/frame.cpp*

 sample accurate seek prepare for decoder. this gets unadjusted output samples and takes resampling into account

### SCR_TimeRefresh_f

*void SCR_TimeRefresh_f()*

*Defined at line 723 of ./rendersystem/r_backend.cpp*

================SCR_TimeRefresh_f

timerefresh [noflip]================

### frame_set_frameseek

*void frame_set_frameseek(mpg123_handle_t * fr, mpg_off_t fe)*

*Defined at line 642 of ./engine/common/soundlib/libmpg/frame.cpp*

 the frame seek... this is not simply the seek to fe * fr->spf samples in output because we think of _input_ frames here. seek to frame offset 1 may be just seek to 200 samples offset in output since the beginning of first frame is delay/padding. hm, is that right? OK for the padding stuff, but actually, should the decoder delay be better totally hidden or not? with gapless, even the whole frame position could be advanced further than requested (since Homey don't play dat).

### CL_DrawBeams

*void CL_DrawBeams(int fTrans, BEAM * active_beams)*

*Defined at line 1260 of ./rendersystem/r_beams.cpp*

 gl_beams.c

==============CL_DrawBeams

draw beam loop==============

### frame_fill_toc

*int frame_fill_toc(mpg123_handle_t * fr, byte * in)*

*Defined at line 333 of ./engine/common/soundlib/libmpg/frame.cpp*

 Just copy the Xing TOC over...

### R_BeamCull

*qboolean R_BeamCull(const vec3_t start, const vec3_t end, qboolean pvsOnly)*

*Defined at line 119 of ./rendersystem/r_beams.cpp*

==============R_BeamCull

Cull the beam by bbox==============

### frame_skip

*void frame_skip(mpg123_handle_t * fr)*

*Defined at line 682 of ./engine/common/soundlib/libmpg/frame.cpp*

### do_rva

*void do_rva(mpg123_handle_t * fr)*

*Defined at line 726 of ./engine/common/soundlib/libmpg/frame.cpp*

 adjust the volume, taking both fr->outscale and rva values into account

### R_CullModel

*int R_CullModel(cl_entity_t * e, const vec3_t absmin, const vec3_t absmax)*

*Defined at line 55 of ./rendersystem/r_cull.cpp*

 gl_cull.c

=============R_CullModel=============

### R_CullBox

*qboolean R_CullBox(const vec3_t mins, const vec3_t maxs)*

*Defined at line 33 of ./rendersystem/r_cull.cpp*

=============================================================

FRUSTUM AND PVS CULLING

=============================================================

=================R_CullBox

Returns true if the box is completely outside the frustum=================

### R_CullSphere

*qboolean R_CullSphere(const vec3_t centre, const float radius)*

*Defined at line 45 of ./rendersystem/r_cull.cpp*

=================R_CullSphere

Returns true if the sphere is completely outside the frustum=================

### R_CullSurface

*int R_CullSurface(msurface_t * surf, gl_frustum_t * frustum, uint clipflags)*

*Defined at line 85 of ./rendersystem/r_cull.cpp*

=================R_CullSurface

cull invisible surfaces=================

### DrawSurfaceDecals

*void DrawSurfaceDecals(msurface_t * fa, qboolean single, qboolean reverse)*

*Defined at line 905 of ./ref_gl/gl_decals.cpp*

 gl_decals.c

### R_DecalSetupVerts

*float * R_DecalSetupVerts(decal_t * pDecal, msurface_t * surf, int texture, int * outCount)*

*Defined at line 847 of ./ref_gl/gl_decals.cpp*

 Build the vertex list for a decal on a surface and clip it to the surface. This is a template so it can work on world surfaces and dynamic displacement  triangles the same way.

### DrawSingleDecal

*void DrawSingleDecal(decal_t * pDecal, msurface_t * fa)*

*Defined at line 884 of ./ref_gl/gl_decals.cpp*

### R_EntityRemoveDecals

*void R_EntityRemoveDecals(model_t * mod)*

*Defined at line 1246 of ./ref_gl/gl_decals.cpp*

===============R_EntityRemoveDecals

remove all decals from specified entity===============

### DrawDecalsBatch

*void DrawDecalsBatch()*

*Defined at line 1042 of ./ref_gl/gl_decals.cpp*

### R_ClearDecals

*void R_ClearDecals()*

*Defined at line 58 of ./ref_gl/gl_decals.cpp*

### R_Set2DMode

*void R_Set2DMode(qboolean enable)*

*Defined at line 241 of ./rendersystem/r_draw.cpp*

 gl_draw.c

===============R_Set2DMode===============

### R_DrawTileClear

*void R_DrawTileClear(int texnum, int x, int y, int w, int h)*

*Defined at line 92 of ./rendersystem/r_draw.cpp*

=============Draw_TileClear

This repeats a 64*64 tile graphic to fill the screen around a sized downrefresh window.=============

### R_UploadStretchRaw

*void R_UploadStretchRaw(int texture, int cols, int rows, int width, int height, const byte * data)*

*Defined at line 194 of ./rendersystem/r_draw.cpp*

=============R_UploadStretchRaw=============

### R_DrawWorldHull

*void R_DrawWorldHull()*

*Defined at line 29 of ./rendersystem/r_dbghulls.cpp*

 REFTODO: rewrite in triapi

 gl_drawhulls.c

### R_DrawModelHull

*void R_DrawModelHull()*

*Defined at line 58 of ./rendersystem/r_dbghulls.cpp*

### R_SetTextureParameters

*void R_SetTextureParameters()*

*Defined at line 298 of ./rendersystem/r_image.cpp*

 gl_image.c

=================R_SetTextureParameters=================

### R_GetTexture

*gl_texture_t * R_GetTexture(GLenum texnum)*

*Defined at line 33 of ./rendersystem/r_image.cpp*

=================R_GetTexture

acess to array elem=================

### GL_LoadTexture

*int GL_LoadTexture(const char * name, const byte * buf, size_t size, int flags)*

*Defined at line 1458 of ./rendersystem/r_image.cpp*

================GL_LoadTexture================

### GL_LoadTextureArray

*int GL_LoadTextureArray(const char ** names, int flags)*

*Defined at line 1506 of ./rendersystem/r_image.cpp*

================GL_LoadTextureArray================

### GL_LoadTextureFromBuffer

*int GL_LoadTextureFromBuffer(const char * name, rgbdata_t * pic, texFlags_t flags, qboolean update)*

*Defined at line 1647 of ./rendersystem/r_image.cpp*

================GL_LoadTextureFromBuffer================

### GL_ResampleTexture

*byte * GL_ResampleTexture(const byte * source, int in_w, int in_h, int out_w, int out_h, qboolean isNormalMap)*

*Defined at line 754 of ./rendersystem/r_image.cpp*

=================GL_ResampleTexture

Assume input buffer is RGBA=================

### GL_CreateTexture

*int GL_CreateTexture(const char * name, int width, int height, const void * buffer, texFlags_t flags)*

*Defined at line 1692 of ./rendersystem/r_image.cpp*

================GL_CreateTexture

creates texture from buffer================

### GL_CreateTextureArray

*int GL_CreateTextureArray(const char * name, int width, int height, int depth, const void * buffer, texFlags_t flags)*

*Defined at line 1739 of ./rendersystem/r_image.cpp*

================GL_CreateTextureArray

creates texture array from buffer================

### GL_ProcessTexture

*void GL_ProcessTexture(int texnum, float gamma, int topColor, int bottomColor)*

*Defined at line 1813 of ./rendersystem/r_image.cpp*

================GL_ProcessTexture================

### GL_UpdateTexSize

*void GL_UpdateTexSize(int texnum, int width, int height, int depth)*

*Defined at line 1427 of ./rendersystem/r_image.cpp*

================GL_UpdateTexSize

recalc image room================

### GL_ApplyTextureParams

*void GL_ApplyTextureParams(gl_texture_t * tex)*

*Defined at line 111 of ./rendersystem/r_image.cpp*

=================GL_ApplyTextureParams=================

### GL_FindTexture

*int GL_FindTexture(const char * name)*

*Defined at line 1781 of ./rendersystem/r_image.cpp*

================GL_FindTexture================

### GL_FreeTexture

*void GL_FreeTexture(GLenum texnum)*

*Defined at line 1800 of ./rendersystem/r_image.cpp*

================GL_FreeTexture================

### GL_Target

*const char * GL_Target(GLenum target)*

### R_InitDlightTexture

*void R_InitDlightTexture()*

*Defined at line 1918 of ./rendersystem/r_image.cpp*

==================R_InitDlightTexture==================

### R_TextureList_f

*void R_TextureList_f()*

*Defined at line 2007 of ./rendersystem/r_image.cpp*

===============R_TextureList_f===============

### R_InitImages

*void R_InitImages()*

*Defined at line 2216 of ./rendersystem/r_image.cpp*

===============R_InitImages===============

### set_pointer

*void set_pointer(mpg123_handle_t * fr, long backstep)*

*Defined at line 61 of ./engine/common/soundlib/libmpg/parse.cpp*

 parse.c

### R_ShutdownImages

*void R_ShutdownImages()*

*Defined at line 2241 of ./rendersystem/r_image.cpp*

===============R_ShutdownImages===============

### GL_TexMemory

*int GL_TexMemory()*

*Defined at line 1867 of ./rendersystem/r_image.cpp*

================GL_TexMemory

return size of all uploaded textures================

### get_songlen

*int get_songlen(mpg123_handle_t * fr, int no)*

*Defined at line 127 of ./engine/common/soundlib/libmpg/parse.cpp*

### CL_RunLightStyles

*void CL_RunLightStyles()*

*Defined at line 35 of ./ref_gl/gl_rlight.cpp*

 gl_rlight.c

=============================================================================

DYNAMIC LIGHTS

=============================================================================

==================CL_RunLightStyles

==================

### compute_bpf

*double compute_bpf(mpg123_handle_t * fr)*

*Defined at line 81 of ./engine/common/soundlib/libmpg/parse.cpp*

### R_PushDlights

*void R_PushDlights()*

*Defined at line 148 of ./ref_gl/gl_rlight.cpp*

=============R_PushDlights=============

### frame_freq

*long frame_freq(mpg123_handle_t * fr)*

*Defined at line 76 of ./engine/common/soundlib/libmpg/parse.cpp*

### R_AnimateLight

*void R_AnimateLight()*

### mpg123_tpf

*double mpg123_tpf(mpg123_handle_t * fr)*

*Defined at line 113 of ./engine/common/soundlib/libmpg/parse.cpp*

### R_GetLightSpot

*void R_GetLightSpot(vec3_t lightspot)*

### mpg123_spf

*int mpg123_spf(mpg123_handle_t * mh)*

*Defined at line 105 of ./engine/common/soundlib/libmpg/parse.cpp*

### R_MarkLights

*void R_MarkLights(dlight_t * light, int bit, mnode_t * node)*

*Defined at line 101 of ./ref_gl/gl_rlight.cpp*

=============R_MarkLights=============

### read_frame

*int read_frame(mpg123_handle_t * fr)*

*Defined at line 852 of ./engine/common/soundlib/libmpg/parse.cpp*

 that's a big one: read the next frame. 1 is success, <= 0 is some error special error READER_MORE means: Please feed more data and try again.

### R_LightVec

* R_LightVec(const vec3_t start, const vec3_t end, vec3_t lightspot, vec3_t lightvec)*

*Defined at line 468 of ./ref_gl/gl_rlight.cpp*

=================R_LightVec

check bspmodels to get light from=================

### invalidate_format

*void invalidate_format(audioformat_t * af)*

*Defined at line 376 of ./engine/common/soundlib/libmpg/format.cpp*

 call this one to ensure that any valid format will be something different than this.

 format.c

### R_CountSurfaceDlights

*int R_CountSurfaceDlights(msurface_t * surf)*

*Defined at line 200 of ./ref_gl/gl_rlight.cpp*

=============R_CountSurfaceDlights=============

### postprocess_buffer

*void postprocess_buffer(mpg123_handle_t * fr)*

*Defined at line 422 of ./engine/common/soundlib/libmpg/format.cpp*

### R_LightPoint

* R_LightPoint(const vec3_t p0)*

*Defined at line 489 of ./ref_gl/gl_rlight.cpp*

=================R_LightPoint

light from floor=================

### R_CountDlights

*int R_CountDlights()*

*Defined at line 177 of ./ref_gl/gl_rlight.cpp*

=============R_CountDlights=============

### mpg123_fmt_all

*int mpg123_fmt_all(mpg123_parm_t * mp)*

*Defined at line 239 of ./engine/common/soundlib/libmpg/format.cpp*

### mpg123_format_none

*int mpg123_format_none(mpg123_handle_t * mh)*

*Defined at line 313 of ./engine/common/soundlib/libmpg/format.cpp*

### R_ClearScene

*void R_ClearScene()*

*Defined at line 217 of ./ref_gl/gl_rmain.cpp*

 gl_rmain.c

===============R_ClearScene===============

### mpg123_format_all

*int mpg123_format_all(mpg123_handle_t * mh)*

*Defined at line 331 of ./engine/common/soundlib/libmpg/format.cpp*

### R_LoadIdentity

*void R_LoadIdentity()*

*Defined at line 412 of ./ref_gl/gl_rmain.cpp*

=============R_LoadIdentity=============

### mpg123_format

*int mpg123_format(mpg123_handle_t * mh, long rate, int channels, int encodings)*

*Defined at line 349 of ./engine/common/soundlib/libmpg/format.cpp*

### R_RenderScene

*void R_RenderScene()*

*Defined at line 951 of ./ref_gl/gl_rmain.cpp*

================R_RenderScene

R_SetupRefParams must be called right before================

### decoder_synth_bytes

*mpg_off_t decoder_synth_bytes(mpg123_handle_t * fr, mpg_off_t s)*

*Defined at line 384 of ./engine/common/soundlib/libmpg/format.cpp*

 number of bytes the decoder produces.

### R_DrawCubemapView

*void R_DrawCubemapView(const vec3_t origin, const vec3_t angles, int size)*

*Defined at line 1139 of ./ref_gl/gl_rmain.cpp*

===============R_DrawCubemapView===============

### bytes_to_samples

*mpg_off_t bytes_to_samples(mpg123_handle_t * fr, mpg_off_t b)*

*Defined at line 396 of ./engine/common/soundlib/libmpg/format.cpp*

### R_SetupRefParams

*void R_SetupRefParams(const struct ref_viewpass_s * rvp)*

*Defined at line 1048 of ./ref_gl/gl_rmain.cpp*

===============R_SetupRefParams

set initial params for renderer===============

### samples_to_bytes

*mpg_off_t samples_to_bytes(mpg123_handle_t * fr, mpg_off_t s)*

*Defined at line 391 of ./engine/common/soundlib/libmpg/format.cpp*

 samples/bytes for output buffer after post-processing. take into account: channels, bytes per sample -- NOT resampling!

### R_TranslateForEntity

*void R_TranslateForEntity(cl_entity_t * e)*

*Defined at line 455 of ./ref_gl/gl_rmain.cpp*

=============R_TranslateForEntity=============

### outblock_bytes

*mpg_off_t outblock_bytes(mpg123_handle_t * fr, mpg_off_t s)*

*Defined at line 402 of ./engine/common/soundlib/libmpg/format.cpp*

 number of bytes needed for decoding _and_ post-processing.

### R_RotateForEntity

*void R_RotateForEntity(cl_entity_t * e)*

*Defined at line 429 of ./ref_gl/gl_rmain.cpp*

=============R_RotateForEntity=============

### init_layer3

*void init_layer3()*

*Defined at line 161 of ./engine/common/soundlib/libmpg/layer3.cpp*

 init tables for layer-3 ... specific with the downsampling...

### R_SetupGL

*void R_SetupGL(qboolean set_gl_state)*

*Defined at line 519 of ./ref_gl/gl_rmain.cpp*

=============R_SetupGL=============

### init_layer3_stuff

*void init_layer3_stuff(mpg123_handle_t * fr)*

*Defined at line 374 of ./engine/common/soundlib/libmpg/layer3.cpp*

### do_layer3

*int do_layer3(mpg123_handle_t * fr)*

*Defined at line 1431 of ./engine/common/soundlib/libmpg/layer3.cpp*

 and at the end... the main layer3 handler

### dct36

*void dct36(float * inbuf, float * o1, float * o2, float * wintab, float * tsbuf)*

*Defined at line 80 of ./engine/common/soundlib/libmpg/dct36.cpp*

 calculation of the inverse MDCT used to be static without 3dnow - does that floatly matter?

 dct36.c

### dct12

*void dct12(float * in, float * rawout1, float * rawout2, float * wi, float * ts)*

*Defined at line 217 of ./engine/common/soundlib/libmpg/dct36.cpp*

### dct64

*void dct64(float * out0, float * out1, float * samples)*

*Defined at line 19 of ./engine/common/soundlib/libmpg/dct64.cpp*

 dct64.c

### prepare_decode_tables

*void prepare_decode_tables()*

*Defined at line 55 of ./engine/common/soundlib/libmpg/tabinit.cpp*

### make_decode_tables

*void make_decode_tables(mpg123_handle_t * fr)*

*Defined at line 71 of ./engine/common/soundlib/libmpg/tabinit.cpp*

### mpg123_new

*mpg123_handle_t * mpg123_new(int * error)*

*Defined at line 50 of ./engine/common/soundlib/libmpg/mpg123.cpp*

 begin prototypes

 create a new handle with specified decoder, decoder can be "", "auto" or NULL for auto-detection

### mpg123_parnew

*mpg123_handle_t * mpg123_parnew(mpg123_parm_t * mp, int * error)*

*Defined at line 56 of ./engine/common/soundlib/libmpg/mpg123.cpp*

 ...the full routine with optional initial parameters to override defaults.

### mpg123_param

*int mpg123_param(mpg123_handle_t * mh, enum mpg123_parms key, long val)*

*Defined at line 160 of ./engine/common/soundlib/libmpg/mpg123.cpp*

### mpg123_open_handle

*int mpg123_open_handle(mpg123_handle_t * mh, void * iohandle)*

*Defined at line 223 of ./engine/common/soundlib/libmpg/mpg123.cpp*

### mpg123_replace_reader_handle

*int mpg123_replace_reader_handle(mpg123_handle_t * mh, mpg_ssize_t (*)(void *, void *, size_t) fread, mpg_off_t (*)(void *, mpg_off_t, int) lseek, void (*)(void *) fclose)*

*Defined at line 249 of ./engine/common/soundlib/libmpg/mpg123.cpp*

### mpg123_decode

*int mpg123_decode(mpg123_handle_t * mh, const byte * inmemory, size_t inmemsize, byte * outmemory, size_t outmemsize, size_t * done)*

*Defined at line 606 of ./engine/common/soundlib/libmpg/mpg123.cpp*

### mpg123_getformat

*int mpg123_getformat(mpg123_handle_t * mh, int * rate, int * channels, int * encoding)*

*Defined at line 683 of ./engine/common/soundlib/libmpg/mpg123.cpp*

### mpg123_read

*int mpg123_read(mpg123_handle_t * mh, byte * out, size_t size, size_t * done)*

*Defined at line 569 of ./engine/common/soundlib/libmpg/mpg123.cpp*

### mpg123_seek

*mpg_off_t mpg123_seek(mpg123_handle_t * mh, mpg_off_t sampleoff, int whence)*

*Defined at line 845 of ./engine/common/soundlib/libmpg/mpg123.cpp*

### mpg123_feed

*int mpg123_feed(mpg123_handle_t * mh, const byte * in, size_t size)*

*Defined at line 574 of ./engine/common/soundlib/libmpg/mpg123.cpp*

### mpg123_plain_strerror

*const char * mpg123_plain_strerror(int errcode)*

*Defined at line 946 of ./engine/common/soundlib/libmpg/mpg123.cpp*

### mpg123_open_feed

*int mpg123_open_feed(mpg123_handle_t * mh)*

*Defined at line 239 of ./engine/common/soundlib/libmpg/mpg123.cpp*

### mpg123_delete

*void mpg123_delete(mpg123_handle_t * mh)*

*Defined at line 213 of ./engine/common/soundlib/libmpg/mpg123.cpp*

### mpg123_tell

*mpg_off_t mpg123_tell(mpg123_handle_t * mh)*

*Defined at line 762 of ./engine/common/soundlib/libmpg/mpg123.cpp*

 now, where are we? We need to know the last decoded frame... and what's left of it in buffer. the current frame number can mean the last decoded frame or the to-be-decoded frame. if mh->to_decode, then mh->num frames have been decoded, the frame mh->num now coming next. if not, we have the possibility of mh->num+1 frames being decoded or nothing at all. then, there is firstframe...when we didn't reach it yet, then the next data will come from there. mh->num starts with -1

### mpg123_init

*int mpg123_init()*

*Defined at line 21 of ./engine/common/soundlib/libmpg/mpg123.cpp*

### mpg123_exit

*void mpg123_exit()*

*Defined at line 44 of ./engine/common/soundlib/libmpg/mpg123.cpp*

### default_init

*int default_init(mpg123_handle_t * fr)*

*Defined at line 856 of ./engine/common/soundlib/libmpg/reader.cpp*

### get_fileinfo

*mpg_off_t get_fileinfo(mpg123_handle_t * fr)*

*Defined at line 717 of ./engine/common/soundlib/libmpg/reader.cpp*

 returns length of a file (if filept points to a file) reads the last 128 bytes information into buffer ... that is not totally safe...

### buffy_new

*buffy_t * buffy_new(size_t size, size_t minsize)*

*Defined at line 31 of ./engine/common/soundlib/libmpg/reader.cpp*

 methods for the buffer chain, mainly used for feed reader, but not just that.

### buffy_del

*void buffy_del(buffy_t * buf)*

*Defined at line 53 of ./engine/common/soundlib/libmpg/reader.cpp*

### buffy_del_chain

*void buffy_del_chain(buffy_t * buf)*

*Defined at line 63 of ./engine/common/soundlib/libmpg/reader.cpp*

 delete this buffy and all following buffies.

### bc_alloc

*buffy_t * bc_alloc(bufferchain_t * bc, size_t size)*

*Defined at line 74 of ./engine/common/soundlib/libmpg/reader.cpp*

 fetch a buffer from the pool (if possible) or create one.

### bc_free

*void bc_free(bufferchain_t * bc, buffy_t * buf)*

*Defined at line 94 of ./engine/common/soundlib/libmpg/reader.cpp*

 either stuff the buffer back into the pool or free it for good.

### bc_fill_pool

*int bc_fill_pool(bufferchain_t * bc)*

*Defined at line 108 of ./engine/common/soundlib/libmpg/reader.cpp*

 make the buffer count in the pool match the pool size.

### R_AllowFog

*void R_AllowFog(qboolean allowed)*

*Defined at line 42 of ./ref_gl/gl_rmain.cpp*

### bc_init

*void bc_init(bufferchain_t * bc)*

*Defined at line 135 of ./engine/common/soundlib/libmpg/reader.cpp*

### R_SetupFrustum

*void R_SetupFrustum()*

*Defined at line 337 of ./ref_gl/gl_rmain.cpp*

===============R_SetupFrustum===============

### R_FindViewLeaf

*void R_FindViewLeaf()*

*Defined at line 481 of ./ref_gl/gl_rmain.cpp*

===============R_FindViewLeaf===============

### bc_reset

*void bc_reset(bufferchain_t * bc)*

*Defined at line 145 of ./engine/common/soundlib/libmpg/reader.cpp*

### R_CheckGamma

*void R_CheckGamma()*

*Defined at line 992 of ./ref_gl/gl_rmain.cpp*

===============R_CheckGamma===============

### R_PushScene

*void R_PushScene()*

*Defined at line 192 of ./ref_gl/gl_rmain.cpp*

===============R_PushScene===============

### R_PopScene

*void R_PopScene()*

*Defined at line 205 of ./ref_gl/gl_rmain.cpp*

===============R_PopScene===============

### bc_append

*int bc_append(bufferchain_t * bc, mpg_ssize_t size)*

*Defined at line 160 of ./engine/common/soundlib/libmpg/reader.cpp*

 create a new buffy at the end to be filled.

### R_DrawFog

*void R_DrawFog()*

*Defined at line 793 of ./ref_gl/gl_rmain.cpp*

=============R_DrawFog

=============

### CL_FxBlend

*int CL_FxBlend(cl_entity_t * e)*

*Defined at line 1166 of ./ref_gl/gl_rmain.cpp*

===============CL_FxBlend===============

### Matrix4x4_ToArrayFloatGL

*void Matrix4x4_ToArrayFloatGL(const matrix4x4 in, float [16] out)*

*Defined at line 102 of ./ref_gl/gl_rmath.cpp*

 gl_rmath.c

### Matrix4x4_FromArrayFloatGL

*void Matrix4x4_FromArrayFloatGL(matrix4x4 out, const float [16] in)*

*Defined at line 122 of ./ref_gl/gl_rmath.cpp*

### Matrix4x4_Concat

*void Matrix4x4_Concat(matrix4x4 out, const matrix4x4 in1, const matrix4x4 in2)*

*Defined at line 26 of ./ref_gl/gl_rmath.cpp*

========================================================================

	       Matrix4x4 operations (private to renderer)

========================================================================

### Matrix4x4_ConcatTranslate

*void Matrix4x4_ConcatTranslate(matrix4x4 out, float x, float y, float z)*

*Defined at line 233 of ./ref_gl/gl_rmath.cpp*

### Matrix4x4_ConcatRotate

*void Matrix4x4_ConcatRotate(matrix4x4 out, float angle, float x, float y, float z)*

*Defined at line 242 of ./ref_gl/gl_rmath.cpp*

### Matrix4x4_ConcatScale

*void Matrix4x4_ConcatScale(matrix4x4 out, float x)*

*Defined at line 251 of ./ref_gl/gl_rmath.cpp*

### Matrix4x4_ConcatScale3

*void Matrix4x4_ConcatScale3(matrix4x4 out, float x, float y, float z)*

*Defined at line 260 of ./ref_gl/gl_rmath.cpp*

### Matrix4x4_CreateTranslate

*void Matrix4x4_CreateTranslate(matrix4x4 out, float x, float y, float z)*

*Defined at line 142 of ./ref_gl/gl_rmath.cpp*

### Matrix4x4_CreateRotate

*void Matrix4x4_CreateRotate(matrix4x4 out, float angle, float x, float y, float z)*

*Defined at line 162 of ./ref_gl/gl_rmath.cpp*

### Matrix4x4_CreateScale

*void Matrix4x4_CreateScale(matrix4x4 out, float x)*

*Defined at line 193 of ./ref_gl/gl_rmath.cpp*

### Matrix4x4_CreateScale3

*void Matrix4x4_CreateScale3(matrix4x4 out, float x, float y, float z)*

*Defined at line 213 of ./ref_gl/gl_rmath.cpp*

### Matrix4x4_CreateProjection

*void Matrix4x4_CreateProjection(matrix4x4 out, float xMax, float xMin, float yMax, float yMin, float zNear, float zFar)*

*Defined at line 53 of ./ref_gl/gl_rmath.cpp*

================Matrix4x4_CreateProjection

NOTE: produce quake style world orientation================

### bc_add

*int bc_add(bufferchain_t * bc, const byte * data, mpg_ssize_t size)*

*Defined at line 207 of ./engine/common/soundlib/libmpg/reader.cpp*

 append a new buffer and copy content to it.

### Matrix4x4_CreateOrtho

*void Matrix4x4_CreateOrtho(matrix4x4 m, float xLeft, float xRight, float yBottom, float yTop, float zNear, float zFar)*

*Defined at line 68 of ./ref_gl/gl_rmath.cpp*

### Matrix4x4_CreateModelview

*void Matrix4x4_CreateModelview(matrix4x4 out)*

*Defined at line 90 of ./ref_gl/gl_rmath.cpp*

================Matrix4x4_CreateModelview

NOTE: produce quake style world orientation================

### bc_need_more

*mpg_ssize_t bc_need_more(bufferchain_t * bc)*

*Defined at line 236 of ./engine/common/soundlib/libmpg/reader.cpp*

 common handler for "You want more than I can give." situation.

### R_ClearStaticEntities

*void R_ClearStaticEntities()*

 gl_rmisc.c

### R_MarkLeaves

*void R_MarkLeaves()*

*Defined at line 3391 of ./ref_gl/gl_rsurf.cpp*

 gl_rsurf.c

===============R_MarkLeaves

Mark the leaves and nodes that are in the PVS for the current leaf===============

### bc_give

*mpg_ssize_t bc_give(bufferchain_t * bc, byte * out, mpg_ssize_t size)*

*Defined at line 245 of ./engine/common/soundlib/libmpg/reader.cpp*

 give some data, advancing position but not forgetting yet.

### R_DrawWorld

*void R_DrawWorld()*

*Defined at line 3324 of ./ref_gl/gl_rsurf.cpp*

=============R_DrawWorld=============

### R_DrawWaterSurfaces

*void R_DrawWaterSurfaces()*

*Defined at line 1379 of ./ref_gl/gl_rsurf.cpp*

================R_DrawWaterSurfaces================

### R_DrawBrushModel

*void R_DrawBrushModel(cl_entity_t * e)*

*Defined at line 1516 of ./ref_gl/gl_rsurf.cpp*

=================R_DrawBrushModel=================

### bc_skip

*mpg_ssize_t bc_skip(bufferchain_t * bc, mpg_ssize_t count)*

*Defined at line 282 of ./engine/common/soundlib/libmpg/reader.cpp*

 skip some bytes and return the new position. the buffers are still there, just the read pointer is moved!

### GL_SubdivideSurface

*void GL_SubdivideSurface(msurface_t * fa)*

*Defined at line 242 of ./ref_gl/gl_rsurf.cpp*

================GL_SubdivideSurface

Breaks a polygon up along axial 64 unitboundaries so that turbulent and sky warpscan be done reasonably.================

### GL_BuildPolygonFromSurface

*void GL_BuildPolygonFromSurface(model_t * mod, msurface_t * fa)*

*Defined at line 273 of ./ref_gl/gl_rsurf.cpp*

================GL_BuildPolygonFromSurface================

### bc_seekback

*mpg_ssize_t bc_seekback(bufferchain_t * bc, mpg_ssize_t count)*

*Defined at line 294 of ./engine/common/soundlib/libmpg/reader.cpp*

### DrawGLPoly

*void DrawGLPoly(glpoly_t * p, float xScale, float yScale)*

*Defined at line 779 of ./ref_gl/gl_rsurf.cpp*

================DrawGLPoly================

### R_TextureAnimation

*texture_t * R_TextureAnimation(msurface_t * s)*

*Defined at line 456 of ./ref_gl/gl_rsurf.cpp*

===============R_TextureAnimation

Returns the proper texture for a given time and surface===============

### bc_forget

*void bc_forget(bufferchain_t * bc)*

*Defined at line 302 of ./engine/common/soundlib/libmpg/reader.cpp*

 throw away buffies that we passed.

### GL_SetupFogColorForSurfaces

*void GL_SetupFogColorForSurfaces()*

*Defined at line 204 of ./ref_gl/gl_rsurf.cpp*

### R_DrawAlphaTextureChains

*void R_DrawAlphaTextureChains()*

*Defined at line 1325 of ./ref_gl/gl_rsurf.cpp*

================R_DrawAlphaTextureChains================

### GL_RebuildLightmaps

*void GL_RebuildLightmaps()*

*Defined at line 3510 of ./ref_gl/gl_rsurf.cpp*

==================GL_RebuildLightmaps

Rebuilds the lightmap texturewhen gamma is changed==================

### feed_init

*int feed_init(mpg123_handle_t * fr)*

*Defined at line 326 of ./engine/common/soundlib/libmpg/reader.cpp*

 reader for input via manually provided buffers

### GL_InitRandomTable

*void GL_InitRandomTable()*

*Defined at line 3642 of ./ref_gl/gl_rsurf.cpp*

### GL_BuildLightmaps

*void GL_BuildLightmaps()*

*Defined at line 3564 of ./ref_gl/gl_rsurf.cpp*

==================GL_BuildLightmaps

Builds the lightmap texturewith all the surfaces from all brush models==================

### GL_ResetFogColor

*void GL_ResetFogColor()*

*Defined at line 226 of ./ref_gl/gl_rsurf.cpp*

### R_GenerateVBO

*void R_GenerateVBO()*

*Defined at line 1786 of ./ref_gl/gl_rsurf.cpp*

===================R_GenerateVBO

Allocate memory for arrays, fill it with vertex attribs and upload to GPU===================

### feed_read

*mpg_ssize_t feed_read(mpg123_handle_t * fr, byte * out, mpg_ssize_t count)*

*Defined at line 346 of ./engine/common/soundlib/libmpg/reader.cpp*

### R_ClearVBO

*void R_ClearVBO()*

*Defined at line 2051 of ./ref_gl/gl_rsurf.cpp*

=============R_ClearVBO

free all vbo data=============

### R_AddDecalVBO

*void R_AddDecalVBO(decal_t * pdecal, msurface_t * surf)*

*Defined at line 2016 of ./ref_gl/gl_rsurf.cpp*

==============R_AddDecalVBO

generate decal mesh and put it to array==============

### feed_skip_bytes

*mpg_off_t feed_skip_bytes(mpg123_handle_t * fr, mpg_off_t len)*

*Defined at line 357 of ./engine/common/soundlib/libmpg/reader.cpp*

 returns reached position... negative ones are bad...

### CL_DrawParticlesExternal

*void CL_DrawParticlesExternal(const ref_viewpass_t * rvp, qboolean trans_pass, float frametime)*

*Defined at line 282 of ./ref_gl/gl_rpart.cpp*

 gl_rpart.c

===============CL_DrawParticlesExternal

allow to draw effects from custom renderer===============

### CL_DrawParticles

*void CL_DrawParticles(double frametime, particle_t * cl_active_particles, float partsize)*

*Defined at line 49 of ./ref_gl/gl_rpart.cpp*

================CL_DrawParticles

update particle color, position, free expired and draw it================

### feed_back_bytes

*int feed_back_bytes(mpg123_handle_t * fr, mpg_off_t bytes)*

*Defined at line 366 of ./engine/common/soundlib/libmpg/reader.cpp*

### CL_DrawTracers

*void CL_DrawTracers(double frametime, particle_t * cl_active_tracers)*

*Defined at line 161 of ./ref_gl/gl_rpart.cpp*

================CL_DrawTracers

update tracer color, position, free expired and draw it================

### R_SpriteInit

*void R_SpriteInit()*

*Defined at line 41 of ./ref_gl/gl_sprite.cpp*

 gl_sprite.c

====================R_SpriteInit

====================

### feed_seek_frame

*int feed_seek_frame(mpg123_handle_t * fr, mpg_off_t num)*

*Defined at line 373 of ./engine/common/soundlib/libmpg/reader.cpp*

### Mod_LoadSpriteModel

*void Mod_LoadSpriteModel(model_t * mod, const void * buffer, qboolean * loaded, uint texFlags)*

*Defined at line 32 of ./engine/common/mod_sprite.cpp*

 mod_sprite.c

====================Mod_LoadSpriteModel

load sprite model====================

### buffered_forget

*void buffered_forget(mpg123_handle_t * fr)*

*Defined at line 379 of ./engine/common/soundlib/libmpg/reader.cpp*

 not just for feed reader, also for self-feeding buffered reader.

### R_GetSpriteFrame

*mspriteframe_t * R_GetSpriteFrame(const model_t * pModel, int frame, float yaw)*

*Defined at line 403 of ./ref_gl/gl_sprite.cpp*

================R_GetSpriteFrame

assume pModel is valid================

### R_DrawSpriteModel

*void R_DrawSpriteModel(cl_entity_t * e)*

*Defined at line 812 of ./ref_gl/gl_sprite.cpp*

=================R_DrawSpriteModel=================

### R_StudioInit

*void R_StudioInit()*

*Defined at line 155 of ./rendersystem/r_studio.cpp*

 gl_studio.c

====================R_StudioInit

====================

### Mod_LoadStudioModel

*void Mod_LoadStudioModel(model_t * mod, const void * buffer, qboolean * loaded)*

*Defined at line 1038 of ./engine/common/mod_studio.cpp*

=================Mod_LoadStudioModel=================

### buffered_fullread

*mpg_ssize_t buffered_fullread(mpg123_handle_t * fr, byte * out, mpg_ssize_t count)*

*Defined at line 409 of ./engine/common/soundlib/libmpg/reader.cpp*

 the specific stuff for buffered stream reader.

### R_StudioLerpMovement

*void R_StudioLerpMovement(cl_entity_t * e, double time, vec3_t origin, vec3_t angles)*

*Defined at line 568 of ./rendersystem/r_studio.cpp*

====================R_StudioLerpMovement

====================

### CL_GetSequenceDuration

*float CL_GetSequenceDuration(cl_entity_t * ent, int sequence)*

*Defined at line 690 of ./rendersystem/r_studio.cpp*

====================CL_GetSequenceDuration

====================

### R_StudioGetTexture

*struct mstudiotex_s * R_StudioGetTexture(cl_entity_t * e)*

*Defined at line 1863 of ./rendersystem/r_studio.cpp*

===============R_StudioGetTexture

Doesn't changes studio global state at all===============

### plain_fullread

*mpg_ssize_t plain_fullread(mpg123_handle_t * fr, byte * buf, mpg_ssize_t count)*

*Defined at line 450 of ./engine/common/soundlib/libmpg/reader.cpp*

 stream based operation

### CL_GetStudioEstimatedFrame

*float CL_GetStudioEstimatedFrame(cl_entity_t * ent)*

*Defined at line 238 of ./engine/client/cl_frame.cpp*

====================CL_GetStudioEstimatedFrame

====================

### R_GetEntityRenderMode

*int R_GetEntityRenderMode(cl_entity_t * ent)*

*Defined at line 2737 of ./rendersystem/r_studio.cpp*

================R_GetEntityRenderMode

check for texture flags================

### io_seek

*mpg_off_t io_seek(reader_data_t * rdat, mpg_off_t offset, int whence)*

*Defined at line 475 of ./engine/common/soundlib/libmpg/reader.cpp*

 wrappers for actual reading/seeking... I'm full of wrappers here.

### R_DrawStudioModel

*void R_DrawStudioModel(cl_entity_t * e)*

*Defined at line 3605 of ./rendersystem/r_studio.cpp*

=================R_DrawStudioModel=================

### pfnPlayerInfo

*player_info_t * pfnPlayerInfo(int index)*

*Defined at line 382 of ./rendersystem/r_studio.cpp*

===============pfnPlayerInfo

===============

### R_GatherPlayerLight

*void R_GatherPlayerLight()*

*Defined at line 3676 of ./rendersystem/r_studio.cpp*

=================R_GatherPlayerLight=================

### io_read

*mpg_ssize_t io_read(reader_data_t * rdat, void * buf, size_t count)*

*Defined at line 487 of ./engine/common/soundlib/libmpg/reader.cpp*

### R_StudioEstimateFrame

*float R_StudioEstimateFrame(cl_entity_t * e, mstudioseqdesc_t * pseqdesc)*

*Defined at line 634 of ./rendersystem/r_studio.cpp*

====================StudioEstimateFrame

====================

### plain_read

*mpg_ssize_t plain_read(mpg123_handle_t * fr, void * buf, size_t count)*

*Defined at line 500 of ./engine/common/soundlib/libmpg/reader.cpp*

 A normal read and a read with timeout.

### R_StudioResetPlayerModels

*void R_StudioResetPlayerModels()*

*Defined at line 2684 of ./rendersystem/r_studio.cpp*

### CL_InitStudioAPI

*void CL_InitStudioAPI()*

*Defined at line 3985 of ./rendersystem/r_studio.cpp*

===============CL_InitStudioAPI

Initialize client studio===============

### stream_lseek

*mpg_off_t stream_lseek(mpg123_handle_t * fr, mpg_off_t pos, int whence)*

*Defined at line 505 of ./engine/common/soundlib/libmpg/reader.cpp*

### Mod_StudioLoadTextures

*void Mod_StudioLoadTextures(model_t * mod, void * data)*

*Defined at line 3849 of ./rendersystem/r_studio.cpp*

=================Mod_StudioLoadTextures=================

### Mod_StudioUnloadTextures

*void Mod_StudioUnloadTextures(void * data)*

*Defined at line 3871 of ./rendersystem/r_studio.cpp*

=================Mod_StudioUnloadTextures=================

### stream_close

*void stream_close(mpg123_handle_t * fr)*

*Defined at line 524 of ./engine/common/soundlib/libmpg/reader.cpp*

### Mod_LoadAliasModel

*void Mod_LoadAliasModel(model_t * mod, const void * buffer, qboolean * loaded)*

*Defined at line 624 of ./rendersystem/r_alias.cpp*

 gl_alias.c

=================Mod_LoadAliasModel=================

### R_DrawAliasModel

*void R_DrawAliasModel(cl_entity_t * e)*

*Defined at line 1360 of ./rendersystem/r_alias.cpp*

=================R_DrawAliasModel

=================

### stream_seek_frame

*int stream_seek_frame(mpg123_handle_t * fr, mpg_off_t newframe)*

*Defined at line 542 of ./engine/common/soundlib/libmpg/reader.cpp*

### R_AliasInit

*void R_AliasInit()*

*Defined at line 84 of ./rendersystem/r_alias.cpp*

====================R_StudioInit

====================

### R_InitSkyClouds

*void R_InitSkyClouds(mip_t * mt, struct texture_s * tx, qboolean custom_palette)*

*Defined at line 650 of ./rendersystem/r_warp.cpp*

=============R_InitSkyClouds

A sky texture is 256*128, with the right side being a masked overlay==============

### generic_head_read

*int generic_head_read(mpg123_handle_t * fr, ulong * newhead)*

*Defined at line 586 of ./engine/common/soundlib/libmpg/reader.cpp*

 return FALSE on error, TRUE on success, READER_MORE on occasion

### R_AddSkyBoxSurface

*void R_AddSkyBoxSurface(msurface_t * fa)*

*Defined at line 305 of ./rendersystem/r_warp.cpp*

=================R_AddSkyBoxSurface=================

### R_ClearSkyBox

*void R_ClearSkyBox()*

*Defined at line 289 of ./rendersystem/r_warp.cpp*

==============R_ClearSkyBox==============

### R_DrawSkyBox

*void R_DrawSkyBox()*

*Defined at line 364 of ./rendersystem/r_warp.cpp*

==============R_DrawSkybox==============

### generic_head_shift

*int generic_head_shift(mpg123_handle_t * fr, ulong * head)*

*Defined at line 602 of ./engine/common/soundlib/libmpg/reader.cpp*

 return FALSE on error, TRUE on success, READER_MORE on occasion

### R_DrawClouds

*void R_DrawClouds()*

*Defined at line 618 of ./rendersystem/r_warp.cpp*

==============R_DrawClouds

Quake-style clouds==============

### EmitWaterPolys

*void EmitWaterPolys(msurface_t * warp, qboolean reverse)*

*Defined at line 756 of ./rendersystem/r_warp.cpp*

=============EmitWaterPolys

Does a water warp on the pre-fragmented glpoly_t chain=============

### VGUI_DrawInit

*void VGUI_DrawInit()*

*Defined at line 32 of ./rendersystem/r_vgui.cpp*

 gl_vgui.c

================VGUI_DrawInit

Startup VGUI backend================

### stream_skip_bytes

*mpg_off_t stream_skip_bytes(mpg123_handle_t * fr, mpg_off_t len)*

*Defined at line 620 of ./engine/common/soundlib/libmpg/reader.cpp*

 returns reached position... negative ones are bad...

### VGUI_DrawShutdown

*void VGUI_DrawShutdown()*

*Defined at line 45 of ./rendersystem/r_vgui.cpp*

================VGUI_DrawShutdown

Release all textures================

### VGUI_SetupDrawingText

*void VGUI_SetupDrawingText(int * pColor)*

*Defined at line 152 of ./rendersystem/r_vgui.cpp*

### stream_back_bytes

*int stream_back_bytes(mpg123_handle_t * fr, mpg_off_t bytes)*

*Defined at line 665 of ./engine/common/soundlib/libmpg/reader.cpp*

 return 0 on success...

### VGUI_SetupDrawingRect

*void VGUI_SetupDrawingRect(int * pColor)*

*Defined at line 144 of ./rendersystem/r_vgui.cpp*

### VGUI_SetupDrawingImage

*void VGUI_SetupDrawingImage(int * pColor)*

*Defined at line 162 of ./rendersystem/r_vgui.cpp*

### VGUI_BindTexture

*void VGUI_BindTexture(int id)*

*Defined at line 172 of ./rendersystem/r_vgui.cpp*

### generic_read_frame_body

*int generic_read_frame_body(mpg123_handle_t * fr, byte * buf, int size)*

*Defined at line 679 of ./engine/common/soundlib/libmpg/reader.cpp*

 returns size on success...

### VGUI_EnableTexture

*void VGUI_EnableTexture(qboolean enable)*

*Defined at line 215 of ./rendersystem/r_vgui.cpp*

================VGUI_EnableTexture

disable texturemode for fill rectangle================

### VGUI_CreateTexture

*void VGUI_CreateTexture(int id, int width, int height)*

*Defined at line 107 of ./rendersystem/r_vgui.cpp*

================VGUI_CreateTexture

Create empty rgba texture and upload them into video memory================

### generic_tell

*mpg_off_t generic_tell(mpg123_handle_t * fr)*

*Defined at line 689 of ./engine/common/soundlib/libmpg/reader.cpp*

### VGUI_UploadTexture

*void VGUI_UploadTexture(int id, const char * buffer, int width, int height)*

*Defined at line 76 of ./rendersystem/r_vgui.cpp*

================VGUI_UploadTexture

Upload texture into video memory================

### VGUI_UploadTextureBlock

*void VGUI_UploadTextureBlock(int id, int drawX, int drawY, const byte * rgba, int blockWidth, int blockHeight)*

*Defined at line 132 of ./rendersystem/r_vgui.cpp*

### stream_rewind

*void stream_rewind(mpg123_handle_t * fr)*

*Defined at line 698 of ./engine/common/soundlib/libmpg/reader.cpp*

 this does not (fully) work for non-seekable streams... You have to check for that flag, pal!

### VGUI_DrawQuad

*void VGUI_DrawQuad(const vpoint_t * ul, const vpoint_t * lr)*

*Defined at line 228 of ./rendersystem/r_vgui.cpp*

================VGUI_DrawQuad

generic method to fill rectangle================

### VGUI_GetTextureSizes

*void VGUI_GetTextureSizes(int * width, int * height)*

*Defined at line 194 of ./rendersystem/r_vgui.cpp*

================VGUI_GetTextureSizes

returns wide and tall for currently binded texture================

### VGUI_GenerateTexture

*int VGUI_GenerateTexture()*

*Defined at line 62 of ./rendersystem/r_vgui.cpp*

================VGUI_GenerateTexture

generate unique texture number================

### R_Init

*qboolean R_Init()*

*Defined at line 617 of ./engine/client/ref_common.cpp*

 renderer exports

===============R_Init===============

### bad_init

*int bad_init(mpg123_handle_t * mh)*

*Defined at line 742 of ./engine/common/soundlib/libmpg/reader.cpp*

### R_Shutdown

*void R_Shutdown()*

*Defined at line 481 of ./engine/client/ref_common.cpp*

===============R_Shutdown===============

### GL_SetupAttributes

*void GL_SetupAttributes(int safegl)*

*Defined at line 990 of ./ref_gl/gl_opengl.cpp*

### GL_OnContextCreated

*void GL_OnContextCreated()*

*Defined at line 1115 of ./ref_gl/gl_opengl.cpp*

### bad_fullread

*mpg_ssize_t bad_fullread(mpg123_handle_t * mh, byte * data, mpg_ssize_t count)*

*Defined at line 743 of ./engine/common/soundlib/libmpg/reader.cpp*

### GL_InitExtensions

*void GL_InitExtensions()*

*Defined at line 699 of ./ref_gl/gl_opengl.cpp*

### GL_ClearExtensions

*void GL_ClearExtensions()*

*Defined at line 759 of ./ref_gl/gl_opengl.cpp*

### bad_head_read

*int bad_head_read(mpg123_handle_t * mh, ulong * newhead)*

*Defined at line 744 of ./engine/common/soundlib/libmpg/reader.cpp*

### VID_CheckChanges

*void VID_CheckChanges()*

*Defined at line 106 of ./engine/client/vid_common.cpp*

==================VID_CheckChanges

check vid modes and fullscreen==================

### bad_head_shift

*int bad_head_shift(mpg123_handle_t * mh, ulong * head)*

*Defined at line 745 of ./engine/common/soundlib/libmpg/reader.cpp*

### GL_FreeImage

*void GL_FreeImage(const char * name)*

*Defined at line 33 of ./engine/client/ref_common.cpp*

================GL_FreeImage

Frees image by name================

### VID_ScreenShot

*qboolean VID_ScreenShot(const char * filename, int shot_type)*

*Defined at line 457 of ./rendersystem/r_backend.cpp*

### bad_skip_bytes

*mpg_off_t bad_skip_bytes(mpg123_handle_t * mh, mpg_off_t len)*

*Defined at line 746 of ./engine/common/soundlib/libmpg/reader.cpp*

### VID_CubemapShot

*qboolean VID_CubemapShot(const char * base, uint size, const float * vieworg, qboolean skyshot)*

*Defined at line 523 of ./rendersystem/r_backend.cpp*

=================VID_CubemapShot=================

### R_BeginFrame

*void R_BeginFrame(qboolean clearScene)*

*Defined at line 1017 of ./ref_gl/gl_rmain.cpp*

===============R_BeginFrame===============

### R_RenderFrame

*void R_RenderFrame(const struct ref_viewpass_s * vp)*

*Defined at line 1079 of ./ref_gl/gl_rmain.cpp*

===============R_RenderFrame===============

### bad_read_frame_body

*int bad_read_frame_body(mpg123_handle_t * mh, byte * data, int size)*

*Defined at line 747 of ./engine/common/soundlib/libmpg/reader.cpp*

### R_EndFrame

*void R_EndFrame()*

*Defined at line 1127 of ./ref_gl/gl_rmain.cpp*

===============R_EndFrame===============

### bad_back_bytes

*int bad_back_bytes(mpg123_handle_t * mh, mpg_off_t bytes)*

*Defined at line 748 of ./engine/common/soundlib/libmpg/reader.cpp*

### R_GetTextureParms

*void R_GetTextureParms(int * w, int * h, int texnum)*

*Defined at line 23 of ./rendersystem/r_draw.cpp*

 handy API wrappers

=============R_GetImageParms=============

### bad_seek_frame

*int bad_seek_frame(mpg123_handle_t * mh, mpg_off_t num)*

*Defined at line 749 of ./engine/common/soundlib/libmpg/reader.cpp*

### R_GetSpriteParms

*void R_GetSpriteParms(int * frameWidth, int * frameHeight, int * numFrames, int curFrame, const struct model_s * pSprite)*

*Defined at line 40 of ./rendersystem/r_draw.cpp*

=============R_GetSpriteParms

same as GetImageParms but usedfor sprite models=============

### R_DrawStretchRaw

*void R_DrawStretchRaw(float x, float y, float w, float h, int cols, int rows, const byte * data, qboolean dirty)*

*Defined at line 122 of ./rendersystem/r_draw.cpp*

=============R_DrawStretchRaw=============

### bad_tell

*mpg_off_t bad_tell(mpg123_handle_t * mh)*

*Defined at line 750 of ./engine/common/soundlib/libmpg/reader.cpp*

### R_DrawStretchPic

*void R_DrawStretchPic(float x, float y, float w, float h, float s1, float t1, float s2, float t2, int texnum)*

*Defined at line 65 of ./rendersystem/r_draw.cpp*

=============R_DrawStretchPic=============

### bad_rewind

*void bad_rewind(mpg123_handle_t * mh)*

*Defined at line 751 of ./engine/common/soundlib/libmpg/reader.cpp*

### R_SpeedsMessage

*qboolean R_SpeedsMessage(char * out, size_t size)*

*Defined at line 28 of ./rendersystem/r_backend.cpp*

===============R_SpeedsMessage===============

### R_SetupSky

*void R_SetupSky(const char * skyboxname)*

*Defined at line 411 of ./rendersystem/r_warp.cpp*

===============R_SetupSky===============

### bad_close

*void bad_close(mpg123_handle_t * mh)*

*Defined at line 752 of ./engine/common/soundlib/libmpg/reader.cpp*

### R_WorldToScreen

*int R_WorldToScreen(const vec3_t point, vec3_t screen)*

*Defined at line 131 of ./ref_gl/gl_rmain.cpp*

===============R_WorldToScreen

Convert a given point from world into screen spaceReturns true if we behind to screen===============

### R_ScreenToWorld

*void R_ScreenToWorld(const vec3_t screen, vec3_t point)*

*Defined at line 170 of ./ref_gl/gl_rmain.cpp*

===============R_ScreenToWorld

Convert a given point from screen into world space===============

### open_finish

*int open_finish(mpg123_handle_t * fr)*

*Defined at line 825 of ./engine/common/soundlib/libmpg/reader.cpp*

 final code common to open_stream and open_stream_handle.

### R_AddEntity

*qboolean R_AddEntity(struct cl_entity_s * pRefEntity, int entityType)*

*Defined at line 234 of ./ref_gl/gl_rmain.cpp*

===============R_AddEntity===============

### Mod_LoadMapSprite

*void Mod_LoadMapSprite(struct model_s * mod, const void * buffer, size_t size, qboolean * loaded)*

*Defined at line 241 of ./ref_gl/gl_sprite.cpp*

====================Mod_LoadMapSprite

Loading a bitmap image as sprite with multiple framesas pieces of input image====================

### Mod_SpriteUnloadTextures

*void Mod_SpriteUnloadTextures(void * data)*

*Defined at line 363 of ./ref_gl/gl_sprite.cpp*

====================Mod_UnloadSpriteModel

release sprite model and frames====================

### Mod_UnloadAliasModel

*void Mod_UnloadAliasModel(struct model_s * mod)*

### Mod_AliasUnloadTextures

*void Mod_AliasUnloadTextures(void * data)*

*Defined at line 733 of ./rendersystem/r_alias.cpp*

### R_RunViewmodelEvents

*void R_RunViewmodelEvents()*

*Defined at line 3641 of ./rendersystem/r_studio.cpp*

=================R_RunViewmodelEvents=================

### R_DrawViewModel

*void R_DrawViewModel()*

*Defined at line 3692 of ./rendersystem/r_studio.cpp*

=================R_DrawViewModel=================

### R_GetSpriteTexture

*int R_GetSpriteTexture(const struct model_s * m_pSpriteModel, int frame)*

*Defined at line 52 of ./rendersystem/r_draw.cpp*

### R_DecalShoot

*void R_DecalShoot(int textureIndex, int entityIndex, int modelIndex, vec3_t pos, int flags, float scale)*

*Defined at line 754 of ./ref_gl/gl_decals.cpp*

 Shoots a decal onto the surface of the BSP.  position is the center of the decal in world coords

### R_RemoveEfrags

*void R_RemoveEfrags(struct cl_entity_s * ent)*

*Defined at line 43 of ./engine/client/cl_efrag.cpp*

================R_RemoveEfrags

Call when removing an object from the world or moving it to another position================

### R_AddEfrags

*void R_AddEfrags(struct cl_entity_s * ent)*

*Defined at line 141 of ./engine/client/cl_efrag.cpp*

===========R_AddEfrags===========

### R_DecalRemoveAll

*void R_DecalRemoveAll(int texture)*

*Defined at line 1218 of ./ref_gl/gl_decals.cpp*

===============R_DecalRemoveAll

remove all decals with specified texture===============

### R_CreateDecalList

*int R_CreateDecalList(decallist_t * pList)*

*Defined at line 1162 of ./ref_gl/gl_decals.cpp*

----------------------------------------------------------------------------- Purpose: Called by CSaveRestore::SaveClientState Input  : *pList -  Output : int-----------------------------------------------------------------------------

### R_ClearAllDecals

*void R_ClearAllDecals()*

*Defined at line 1271 of ./ref_gl/gl_decals.cpp*

===============R_ClearAllDecals

remove all decals from anythingused for full decals restart ===============

### Mod_GetCurrentVis

*byte * Mod_GetCurrentVis()*

*Defined at line 46 of ./ref_gl/gl_rsurf.cpp*

### Mod_SetOrthoBounds

*void Mod_SetOrthoBounds(const float * mins, const float * maxs)*

*Defined at line 53 of ./ref_gl/gl_rsurf.cpp*

### R_NewMap

*void R_NewMap()*

*Defined at line 107 of ./rendersystem/r_misc.cpp*

### CL_AddCustomBeam

*void CL_AddCustomBeam(cl_entity_t * pEnvBeam)*

*Defined at line 163 of ./rendersystem/r_beams.cpp*

================CL_AddCustomBeam

Add the beam that encoded as custom entity================

### GL_CheckForErrors_

*void GL_CheckForErrors_(const char * filename, const int fileline)*

*Defined at line 977 of ./ref_gl/gl_opengl.cpp*

=================GL_CheckForErrorsobsolete=================

### GL_ErrorString

*const char * GL_ErrorString(int err)*

*Defined at line 950 of ./ref_gl/gl_opengl.cpp*

=================GL_ErrorStringconvert errorcode to string=================

### GL_Support

*qboolean GL_Support(int r_ext)*

*Defined at line 300 of ./ref_gl/gl_opengl.cpp*

=================GL_Support=================

### GL_MaxTextureUnits

*int GL_MaxTextureUnits()*

*Defined at line 314 of ./ref_gl/gl_opengl.cpp*

=================GL_MaxTextureUnits=================

### GL_CheckExtension

*qboolean GL_CheckExtension(const char * name, const dllfunc_t * funcs, const char * cvarname, int r_ext)*

*Defined at line 326 of ./ref_gl/gl_opengl.cpp*

=================GL_CheckExtension=================

### GL_SetExtension

*void GL_SetExtension(int r_ext, int enable)*

*Defined at line 288 of ./ref_gl/gl_opengl.cpp*

=================GL_SetExtension=================

### TriRenderMode

*void TriRenderMode(int mode)*

*Defined at line 40 of ./rendersystem/r_triapi.cpp*

 TriAPI

 gl_triapi.c

=================TriAPI implementation

=================

=================TriRenderMode=================

===============================================================

  TRIAPI IMPLEMENTATION

===============================================================

=============TriRenderMode

set rendermode=============

### TriBegin

*void TriBegin(int mode)*

*Defined at line 77 of ./rendersystem/r_triapi.cpp*

=============TriBegin

begin triangle sequence=============

### TriEnd

*void TriEnd()*

*Defined at line 118 of ./rendersystem/r_triapi.cpp*

=============TriEnd

draw triangle sequence=============

### TriTexCoord2f

*void TriTexCoord2f(float u, float v)*

*Defined at line 185 of ./rendersystem/r_triapi.cpp*

=============TriTexCoord2f

=============

### TriVertex3fv

*void TriVertex3fv(const float * v)*

*Defined at line 196 of ./rendersystem/r_triapi.cpp*

=============TriVertex3fv

=============

### TriVertex3f

*void TriVertex3f(float x, float y, float z)*

*Defined at line 207 of ./rendersystem/r_triapi.cpp*

=============TriVertex3f

=============

### _TriColor4f

*void _TriColor4f(float r, float g, float b, float a)*

*Defined at line 129 of ./rendersystem/r_triapi.cpp*

=============_TriColor4f

=============

### _TriColor4ub

*void _TriColor4ub(byte r, byte g, byte b, byte a)*

*Defined at line 140 of ./rendersystem/r_triapi.cpp*

=============_TriColor4f

=============

### TriColor4f

*void TriColor4f(float r, float g, float b, float a)*

*Defined at line 167 of ./rendersystem/r_triapi.cpp*

=================TriColor4f=================

### TriColor4ub

*void TriColor4ub(byte r, byte g, byte b, byte a)*

*Defined at line 152 of ./rendersystem/r_triapi.cpp*

=============TriColor4ub

=============

=============TriColor4ub=============

### TriBrightness

*void TriBrightness(float brightness)*

*Defined at line 349 of ./rendersystem/r_triapi.cpp*

=============TriBrightness=============

### TriWorldToScreen

*int TriWorldToScreen(const float * world, float * screen)*

*Defined at line 219 of ./rendersystem/r_triapi.cpp*

=============TriWorldToScreen

convert world coordinates (x,y,z) into screen (x, y)=============

=============TriWorldToScreenconvert world coordinates (x,y,z) into screen (x, y)=============

### TriSpriteTexture

*int TriSpriteTexture(model_t * pSpriteModel, int frame)*

*Defined at line 240 of ./rendersystem/r_triapi.cpp*

=============TriSpriteTexture

bind current texture=============

### TriFog

*void TriFog(float [3] flFogColor, float flStart, float flEnd, int bOn)*

*Defined at line 262 of ./rendersystem/r_triapi.cpp*

=============TriFog

enables global fog on the level=============

### TriGetMatrix

*void TriGetMatrix(const int pname, float * matrix)*

*Defined at line 304 of ./rendersystem/r_triapi.cpp*

=============TriGetMatrix

very strange export=============

### TriFogParams

*void TriFogParams(float flDensity, int iFogSkybox)*

*Defined at line 315 of ./rendersystem/r_triapi.cpp*

=============TriForParams

=============

### TriCullFace

*void TriCullFace(TRICULLSTYLE mode)*

*Defined at line 327 of ./rendersystem/r_triapi.cpp*

=============TriCullFace

=============

=============TriCullFace=============

### Q_strcasecmp

*int Q_strcasecmp(const char * a, const char * b)*

*Defined at line 583 of ./public/crtlib.cpp*

 crtlib.c

### Q_strnupr

*void Q_strnupr(const char * in, char * out, size_t size_out)*

*Defined at line 81 of ./public/crtlib.cpp*

### Q_strnlwr

*void Q_strnlwr(const char * in, char * out, size_t size_out)*

*Defined at line 95 of ./public/crtlib.cpp*

### Q_strlen

*int Q_strlen(const char * string)*

*Defined at line 119 of ./public/crtlib.cpp*

### Q_colorstr

*int Q_colorstr(const char * string)*

*Defined at line 125 of ./public/crtlib.cpp*

### Q_toupper

*char Q_toupper(const char in)*

*Defined at line 274 of ./public/crtlib.cpp*

### Q_tolower

*char Q_tolower(const char in)*

*Defined at line 285 of ./public/crtlib.cpp*

### Q_strncat

*size_t Q_strncat(char * dst, const char * src, size_t siz)*

*Defined at line 296 of ./public/crtlib.cpp*

### Q_strncpy

*size_t Q_strncpy(char * dst, const char * src, size_t siz)*

*Defined at line 174 of ./mainui/Utils.h*

### Q_hashkey

*uint Q_hashkey(const char * string, uint hashSize, qboolean caseinsensitive)*

*Defined at line 804 of ./public/crtlib.cpp*

### Q_isdigit

*qboolean Q_isdigit(const char * str)*

*Defined at line 109 of ./public/crtlib.cpp*

### Q_atoi

*int Q_atoi(const char * str)*

*Defined at line 356 of ./public/crtlib.cpp*

### Q_atof

*float Q_atof(const char * str)*

*Defined at line 404 of ./public/crtlib.cpp*

### Q_atov

*void Q_atov(float * vec, const char * str, size_t siz)*

*Defined at line 471 of ./public/crtlib.cpp*

### Q_strchr

*char * Q_strchr(const char * s, char c)*

*Defined at line 495 of ./public/crtlib.cpp*

### Q_strrchr

*char * Q_strrchr(const char * s, char c)*

*Defined at line 507 of ./public/crtlib.cpp*

### Q_strnicmp

*int Q_strnicmp(const char * s1, const char * s2, int n)*

*Defined at line 521 of ./public/crtlib.cpp*

### Q_strncmp

*int Q_strncmp(const char * s1, const char * s2, int n)*

*Defined at line 554 of ./public/crtlib.cpp*

### Q_stricmpext

*qboolean Q_stricmpext(const char * s1, const char * s2)*

*Defined at line 634 of ./public/crtlib.cpp*

### Q_timestamp

*const char * Q_timestamp(int format)*

*Defined at line 660 of ./public/crtlib.cpp*

### Q_stristr

*char * Q_stristr(const char * string, const char * string2)*

*Defined at line 728 of ./public/crtlib.cpp*

### Q_strstr

*char * Q_strstr(const char * string, const char * string2)*

*Defined at line 705 of ./public/crtlib.cpp*

### Q_vsnprintf

*int Q_vsnprintf(char * buffer, size_t buffersize, const char * format, va_list args)*

*Defined at line 751 of ./public/crtlib.cpp*

### Q_snprintf

*int Q_snprintf(char * buffer, size_t buffersize, const char * format)*

*Defined at line 780 of ./public/crtlib.cpp*

### Q_sprintf

*int Q_sprintf(char * buffer, const char * format)*

*Defined at line 792 of ./public/crtlib.cpp*

### Q_pretifymem

*char * Q_pretifymem(float value, int digitsafterdecimal)*

*Defined at line 823 of ./public/crtlib.cpp*

### va

*char * va(const char * format)*

*Defined at line 901 of ./public/crtlib.cpp*

============va

does a varargs printf into a temp buffer,so I don't need to have varargs versionsof all text functions.============

### COM_FileBase

*void COM_FileBase(const char * in, char * out)*

*Defined at line 923 of ./public/crtlib.cpp*

============COM_FileBase

Extracts the base name of a file (no path, no extension, assumes '/' as path separator)============

============COM_FileBase============

 Extracts the base name of a file (no path, no extension, assumes '/' as path separator)

### COM_FileExtension

*const char * COM_FileExtension(const char * in)*

*Defined at line 963 of ./public/crtlib.cpp*

============COM_FileExtension============

### COM_DefaultExtension

*void COM_DefaultExtension(char * path, const char * extension)*

*Defined at line 1055 of ./public/crtlib.cpp*

==================COM_DefaultExtension==================

### COM_ReplaceExtension

*void COM_ReplaceExtension(char * path, const char * extension)*

*Defined at line 1078 of ./public/crtlib.cpp*

==================COM_ReplaceExtension==================

### COM_ExtractFilePath

*void COM_ExtractFilePath(const char * path, char * dest)*

*Defined at line 1014 of ./public/crtlib.cpp*

============COM_ExtractFilePath============

### COM_FileWithoutPath

*const char * COM_FileWithoutPath(const char * in)*

*Defined at line 991 of ./public/crtlib.cpp*

============COM_FileWithoutPath============

### COM_StripExtension

*void COM_StripExtension(char * path)*

*Defined at line 1035 of ./public/crtlib.cpp*

============COM_StripExtension============

### matchpattern

*int matchpattern(const char * in, const char * pattern, qboolean caseinsensitive)*

*Defined at line 1084 of ./public/crtlib.cpp*

### matchpattern_with_separator

*int matchpattern_with_separator(const char * in, const char * pattern, qboolean caseinsensitive, const char * separators, qboolean wildcard_least_one)*

*Defined at line 1091 of ./public/crtlib.cpp*

 wildcard_least_one: if true * matches 1 or more characters                     if false * matches 0 or more characters

### Q_strdup

*char * Q_strdup(const char * s)*

*Defined at line 1152 of ./public/crtlib.cpp*

### Q_malloc

*void * Q_malloc(size_t sz)*

*Defined at line 1164 of ./public/crtlib.cpp*

### Q_free

*void Q_free(void * blk)*

*Defined at line 1170 of ./public/crtlib.cpp*

### Q_fmtcolorstr

*char * Q_fmtcolorstr(const char * s, char * out, size_t n)*

*Defined at line 175 of ./public/crtlib.cpp*

### Q_fmtcolorstr

*char * Q_fmtcolorstr(const char * s, char * out, size_t n, const unsigned char [10][3] color_table)*

*Defined at line 180 of ./public/crtlib.cpp*

### Q_fmtcolorstr

*char * Q_fmtcolorstr(const char * s, char * out, size_t n, const unsigned char [10][3] color_table, const unsigned char [10] modifier_table)*

*Defined at line 185 of ./public/crtlib.cpp*

### Q_strint

*_Bool Q_strint(const char * str, int & out, int base)*

*Defined at line 1176 of ./public/crtlib.cpp*

 Safe string conversions 

### Q_strfloat

*_Bool Q_strfloat(const char * str, float & out)*

*Defined at line 1185 of ./public/crtlib.cpp*

### Q_strdouble

*_Bool Q_strdouble(const char * str, double & out)*

*Defined at line 1203 of ./public/crtlib.cpp*

### Q_strlong

*_Bool Q_strlong(const char * str, long long & out, int base)*

*Defined at line 1194 of ./public/crtlib.cpp*

### Q_strbool

*_Bool Q_strbool(const char * str, _Bool & out)*

*Defined at line 1212 of ./public/crtlib.cpp*

### Q_FileExtension

*char * Q_FileExtension(const char * s, char * out, size_t len)*

*Defined at line 1219 of ./public/crtlib.cpp*

 Path operations 

### Q_FileName

*char * Q_FileName(const char * s, char * out, size_t len)*

*Defined at line 1233 of ./public/crtlib.cpp*

### Q_BaseDirectory

*char * Q_BaseDirectory(const char * s, char * out, size_t len)*

*Defined at line 1247 of ./public/crtlib.cpp*

### Q_StripExtension

*char * Q_StripExtension(const char * s, char * out, size_t len)*

*Defined at line 1266 of ./public/crtlib.cpp*

### Q_StripDirectory

*char * Q_StripDirectory(const char * s, char * out, size_t len)*

*Defined at line 1276 of ./public/crtlib.cpp*

### Q_FixSlashes

*char * Q_FixSlashes(const char * s, char * out, size_t len)*

*Defined at line 1290 of ./public/crtlib.cpp*

### Q_FixSlashesInPlace

*char * Q_FixSlashesInPlace(char * s)*

*Defined at line 1308 of ./public/crtlib.cpp*

### Q_FixSlashesInPlace

*class String & Q_FixSlashesInPlace(class String & s)*

*Defined at line 1320 of ./public/crtlib.cpp*

### Q_MakeAbsolute

*char * Q_MakeAbsolute(const char * s, char * out, size_t len)*

*Defined at line 1332 of ./public/crtlib.cpp*

### Q_startswith

*_Bool Q_startswith(const char * string, const char * startingString)*

*Defined at line 67 of ./public/crtlib.cpp*

### Q_endswith

*_Bool Q_endswith(const char * str, const char * subst)*

*Defined at line 72 of ./public/crtlib.cpp*

### Q_getcwd

*char * Q_getcwd(char * buf, size_t sz)*

*Defined at line 1343 of ./public/crtlib.cpp*

 Other C std functions which might not be portable 

### Q_getpid

*int Q_getpid()*

*Defined at line 1352 of ./public/crtlib.cpp*

### Q_mkstemp

*int Q_mkstemp(char * tmpl)*

*Defined at line 1361 of ./public/crtlib.cpp*

### Q_unlink

*int Q_unlink(const char * path)*

*Defined at line 1370 of ./public/crtlib.cpp*

### Q_mkdir

*int Q_mkdir(const char * path)*

*Defined at line 1379 of ./public/crtlib.cpp*

### Q_fileno

*int Q_fileno(FILE * f)*

*Defined at line 1388 of ./public/crtlib.cpp*

### Mem_Malloc

*void * Mem_Malloc(byte * pool, size_t size)*

*Defined at line 781 of ./rendersystem/gl_local.h*

### Mem_Calloc

*void * Mem_Calloc(byte * pool, size_t size)*

*Defined at line 782 of ./rendersystem/gl_local.h*

### Mem_Realloc

*void * Mem_Realloc(byte * pool, void * ptr, size_t size)*

*Defined at line 783 of ./rendersystem/gl_local.h*

### Mem_Free

*void Mem_Free(void * mem)*

*Defined at line 784 of ./rendersystem/gl_local.h*

### Mem_AllocPool

*void * Mem_AllocPool(const char * name)*

*Defined at line 785 of ./rendersystem/gl_local.h*

### Mem_FreePool

*void Mem_FreePool(byte ** pool)*

*Defined at line 786 of ./rendersystem/gl_local.h*

### MESSAGE_BEGIN

*void MESSAGE_BEGIN(int msg_dest, int msg_type, const float * pOrigin, edict_t * ed)*

*Defined at line 76 of ./game/shared/../server/enginecallback.h*

### GET_PRIVATE

*void * GET_PRIVATE(edict_t * pent)*

*Defined at line 99 of ./game/shared/../server/enginecallback.h*

### MESSAGE_BEGIN

*void MESSAGE_BEGIN(int msg_dest, int msg_type, const float * pOrigin, entvars_t * ent)*

*Defined at line 164 of ./game/shared/util.h*

### MAKE_STRING

*int MAKE_STRING(const char * szValue)*

*Defined at line 48 of ./game/shared/util.h*

### FIND_ENTITY_BY_CLASSNAME

*edict_t * FIND_ENTITY_BY_CLASSNAME(edict_t * entStart, const char * pszName)*

*Defined at line 58 of ./game/shared/util.h*

### FIND_ENTITY_BY_TARGETNAME

*edict_t * FIND_ENTITY_BY_TARGETNAME(edict_t * entStart, const char * pszName)*

*Defined at line 63 of ./game/shared/util.h*

### FIND_ENTITY_BY_TARGET

*edict_t * FIND_ENTITY_BY_TARGET(edict_t * entStart, const char * pszName)*

*Defined at line 69 of ./game/shared/util.h*

 for doing a reverse lookup. Say you have a door, and want to find its button.

### DBG_EntOfVars

*edict_t * DBG_EntOfVars(const entvars_t * pev)*

*Defined at line 314 of ./game/server/util.cpp*

 DEBUG Stubs

### ENT

*edict_t * ENT(const entvars_t * pev)*

*Defined at line 125 of ./game/shared/util.h*

### ENT

*edict_t * ENT(edict_t * pent)*

*Defined at line 129 of ./game/shared/util.h*

### ENT

*edict_t * ENT(EOFFSET eoffset)*

*Defined at line 130 of ./game/shared/util.h*

### OFFSET

*EOFFSET OFFSET(EOFFSET eoffset)*

*Defined at line 131 of ./game/shared/util.h*

### OFFSET

*EOFFSET OFFSET(const edict_t * pent)*

*Defined at line 132 of ./game/shared/util.h*

### OFFSET

*EOFFSET OFFSET(entvars_t * pev)*

*Defined at line 140 of ./game/shared/util.h*

### VARS

*entvars_t * VARS(entvars_t * pev)*

*Defined at line 148 of ./game/shared/util.h*

### VARS

*entvars_t * VARS(edict_t * pent)*

*Defined at line 153 of ./game/shared/util.h*

### VARS

*entvars_t * VARS(EOFFSET eoffset)*

*Defined at line 161 of ./game/shared/util.h*

### ENTINDEX

*int ENTINDEX(edict_t * pEdict)*

*Defined at line 162 of ./game/shared/util.h*

### INDEXENT

*edict_t * INDEXENT(int iEdictNum)*

*Defined at line 163 of ./game/shared/util.h*

### FNullEnt

*BOOL FNullEnt(EOFFSET eoffset)*

*Defined at line 170 of ./game/shared/util.h*

### FNullEnt

*BOOL FNullEnt(const edict_t * pent)*

*Defined at line 171 of ./game/shared/util.h*

### FNullEnt

*BOOL FNullEnt(entvars_t * pev)*

*Defined at line 172 of ./game/shared/util.h*

### FStringNull

*BOOL FStringNull(int iString)*

*Defined at line 176 of ./game/shared/util.h*

### FStrEq

*BOOL FStrEq(const char * sz1, const char * sz2)*

*Defined at line 217 of ./game/shared/util.h*

 Misc useful

### FClassnameIs

*BOOL FClassnameIs(edict_t * pent, const char * szClassname)*

*Defined at line 222 of ./game/shared/util.h*

### FClassnameIs

*BOOL FClassnameIs(entvars_t * pev, const char * szClassname)*

*Defined at line 227 of ./game/shared/util.h*

### UTIL_SetSize

*void UTIL_SetSize(entvars_t * pev, const class Vector & vecMin, const class Vector & vecMax)*

*Defined at line 954 of ./game/server/util.cpp*

 Misc. Prototypes

### UTIL_VecToYaw

*float UTIL_VecToYaw(const class Vector & vec)*

*Defined at line 959 of ./game/server/util.cpp*

### UTIL_VecToAngles

*Vector UTIL_VecToAngles(const class Vector & vec)*

*Defined at line 382 of ./game/server/util.cpp*

### UTIL_AngleMod

*float UTIL_AngleMod(float a)*

*Defined at line 347 of ./game/server/util.cpp*

 ripped this out of the engine

### UTIL_AngleDiff

*float UTIL_AngleDiff(float destAngle, float srcAngle)*

*Defined at line 364 of ./game/server/util.cpp*

### UTIL_FindEntityInSphere

*class CBaseEntity * UTIL_FindEntityInSphere(class CBaseEntity * pStartEntity, const class Vector & vecCenter, float flRadius)*

*Defined at line 499 of ./game/server/util.cpp*

### UTIL_FindEntityByString

*class CBaseEntity * UTIL_FindEntityByString(class CBaseEntity * pStartEntity, const char * szKeyword, const char * szValue)*

*Defined at line 515 of ./game/server/util.cpp*

### UTIL_FindEntityByClassname

*class CBaseEntity * UTIL_FindEntityByClassname(class CBaseEntity * pStartEntity, const char * szName)*

*Defined at line 531 of ./game/server/util.cpp*

### UTIL_FindEntityByTargetname

*class CBaseEntity * UTIL_FindEntityByTargetname(class CBaseEntity * pStartEntity, const char * szName)*

*Defined at line 536 of ./game/server/util.cpp*

### UTIL_FindEntityGeneric

*class CBaseEntity * UTIL_FindEntityGeneric(const char * szName, class Vector & vecSrc, float flRadius)*

*Defined at line 541 of ./game/server/util.cpp*

### UTIL_PlayerByIndex

*class CBaseEntity * UTIL_PlayerByIndex(int playerIndex)*

*Defined at line 567 of ./game/server/util.cpp*

 returns a CBaseEntity pointer to a player by index.  Only returns if the player is spawned and connected otherwise returns NULL Index is 1 based

### UTIL_MakeVectors

*void UTIL_MakeVectors(const class Vector & vecAngles)*

*Defined at line 583 of ./game/server/util.cpp*

### UTIL_MonstersInSphere

*int UTIL_MonstersInSphere(class CBaseEntity ** pList, int listMax, const class Vector & center, float radius)*

*Defined at line 439 of ./game/server/util.cpp*

 Pass in an array of pointers and an array size, it fills the array and returns the number inserted

### UTIL_EntitiesInBox

*int UTIL_EntitiesInBox(class CBaseEntity ** pList, int listMax, const class Vector & mins, const class Vector & maxs, int flagMask)*

*Defined at line 398 of ./game/server/util.cpp*

### UTIL_MakeVectorsPrivate

*void UTIL_MakeVectorsPrivate(const class Vector & vecAngles, float * p_vForward, float * p_vRight, float * p_vUp)*

*Defined at line 257 of ./game/shared/util.h*

### UTIL_MakeAimVectors

*void UTIL_MakeAimVectors(const class Vector & vecAngles)*

*Defined at line 588 of ./game/server/util.cpp*

### UTIL_MakeInvVectors

*void UTIL_MakeInvVectors(const class Vector & vec, globalvars_t * pgv)*

*Defined at line 598 of ./game/server/util.cpp*

### UTIL_SetOrigin

*void UTIL_SetOrigin(entvars_t * pev, const class Vector & vecOrigin)*

*Defined at line 964 of ./game/server/util.cpp*

### UTIL_EmitAmbientSound

*void UTIL_EmitAmbientSound(edict_t * entity, const class Vector & vecOrigin, const char * samp, float vol, float attenuation, int fFlags, int pitch)*

*Defined at line 610 of ./game/server/util.cpp*

### UTIL_ParticleEffect

*void UTIL_ParticleEffect(const class Vector & vecOrigin, const class Vector & vecDirection, ULONG ulColor, ULONG ulCount)*

*Defined at line 971 of ./game/server/util.cpp*

### UTIL_ScreenShake

*void UTIL_ScreenShake(const class Vector & center, float amplitude, float frequency, float duration, float radius)*

*Defined at line 658 of ./game/server/util.cpp*

 Shake the screen of all clients within radius radius == 0, shake all clients UNDONE: Allow caller to shake clients not ONGROUND? UNDONE: Fix falloff model (disabled)? UNDONE: Affect user controls?

### UTIL_ScreenShakeAll

*void UTIL_ScreenShakeAll(const class Vector & center, float amplitude, float frequency, float duration)*

*Defined at line 700 of ./game/server/util.cpp*

### UTIL_ShowMessage

*void UTIL_ShowMessage(const char * pString, class CBaseEntity * pPlayer)*

*Defined at line 893 of ./game/server/util.cpp*

### UTIL_ShowMessageAll

*void UTIL_ShowMessageAll(const char * pString)*

*Defined at line 903 of ./game/server/util.cpp*

### UTIL_ScreenFadeAll

*void UTIL_ScreenFadeAll(const class Vector & color, float fadeTime, float holdTime, int alpha, int flags)*

*Defined at line 732 of ./game/server/util.cpp*

### UTIL_ScreenFade

*void UTIL_ScreenFade(class CBaseEntity * pEntity, const class Vector & color, float fadeTime, float fadeHold, int alpha, int flags)*

*Defined at line 747 of ./game/server/util.cpp*

### UTIL_TraceLine

*void UTIL_TraceLine(const class Vector & vecStart, const class Vector & vecEnd, IGNORE_MONSTERS igmon, edict_t * pentIgnore, TraceResult * ptr)*

*Defined at line 922 of ./game/server/util.cpp*

=====================UTIL_TraceLine

Don't actually trace, but act like the trace didn't hit anything.=====================

### UTIL_TraceLine

*void UTIL_TraceLine(const class Vector & vecStart, const class Vector & vecEnd, IGNORE_MONSTERS igmon, IGNORE_GLASS ignoreGlass, edict_t * pentIgnore, TraceResult * ptr)*

*Defined at line 917 of ./game/server/util.cpp*

 Overloaded to add IGNORE_GLASS

### UTIL_TraceHull

*void UTIL_TraceHull(const class Vector & vecStart, const class Vector & vecEnd, IGNORE_MONSTERS igmon, int hullNumber, edict_t * pentIgnore, TraceResult * ptr)*

*Defined at line 927 of ./game/server/util.cpp*

### UTIL_GetGlobalTrace

* UTIL_GetGlobalTrace()*

*Defined at line 937 of ./game/server/util.cpp*

### UTIL_TraceModel

*void UTIL_TraceModel(const class Vector & vecStart, const class Vector & vecEnd, int hullNumber, edict_t * pentModel, TraceResult * ptr)*

*Defined at line 932 of ./game/server/util.cpp*

### UTIL_GetAimVector

*Vector UTIL_GetAimVector(edict_t * pent, float flSpeed)*

*Defined at line 1049 of ./game/server/util.cpp*

### UTIL_PointContents

*int UTIL_PointContents(const class Vector & vec)*

*Defined at line 1094 of ./game/server/util.cpp*

### UTIL_IsMasterTriggered

*int UTIL_IsMasterTriggered(string_t sMaster, class CBaseEntity * pActivator)*

*Defined at line 1056 of ./game/server/util.cpp*

### UTIL_BloodStream

*void UTIL_BloodStream(const class Vector & origin, const class Vector & direction, int color, int amount)*

*Defined at line 1099 of ./game/server/util.cpp*

### UTIL_BloodDrips

*void UTIL_BloodDrips(const class Vector & origin, const class Vector & direction, int color, int amount)*

*Defined at line 1120 of ./game/server/util.cpp*

### UTIL_RandomBloodVector

*Vector UTIL_RandomBloodVector()*

*Defined at line 1152 of ./game/server/util.cpp*

### UTIL_ShouldShowBlood

*BOOL UTIL_ShouldShowBlood(int bloodColor)*

*Defined at line 1076 of ./game/server/util.cpp*

### UTIL_BloodDecalTrace

*void UTIL_BloodDecalTrace(TraceResult * pTrace, int bloodColor)*

*Defined at line 1163 of ./game/server/util.cpp*

### UTIL_DecalTrace

*void UTIL_DecalTrace(TraceResult * pTrace, int decalNumber)*

*Defined at line 1174 of ./game/server/util.cpp*

### UTIL_PlayerDecalTrace

*void UTIL_PlayerDecalTrace(TraceResult * pTrace, int playernum, int decalNumber, BOOL bIsCustom)*

*Defined at line 1241 of ./game/server/util.cpp*

==============UTIL_PlayerDecalTrace

A player is trying to apply his custom decal for the spray can.Tell connected clients to display it, or use the default spray can decalif the custom can't be loaded.==============

### UTIL_GunshotDecalTrace

*void UTIL_GunshotDecalTrace(TraceResult * pTrace, int decalNumber)*

*Defined at line 1271 of ./game/server/util.cpp*

### UTIL_Sparks

*void UTIL_Sparks(const class Vector & position)*

*Defined at line 1293 of ./game/server/util.cpp*

### UTIL_Ricochet

*void UTIL_Ricochet(const class Vector & position, float scale)*

*Defined at line 1303 of ./game/server/util.cpp*

### UTIL_StringToVector

*void UTIL_StringToVector(float * pVector, const char * pString)*

*Defined at line 151 of ./game/client/hud_spectator.cpp*

----------------------------------------------------------------------------- UTIL_StringToVector originally from ..**<not a builtin command>** **<not a builtin command>** .cpp, slightly changed-----------------------------------------------------------------------------

### UTIL_StringToIntArray

*void UTIL_StringToIntArray(int * pVector, int count, const char * pString)*

*Defined at line 1360 of ./game/server/util.cpp*

### UTIL_ClampVectorToBox

*Vector UTIL_ClampVectorToBox(const class Vector & input, const class Vector & clampSize)*

*Defined at line 1386 of ./game/server/util.cpp*

### UTIL_Approach

*float UTIL_Approach(float target, float value, float speed)*

*Defined at line 976 of ./game/server/util.cpp*

### UTIL_ApproachAngle

*float UTIL_ApproachAngle(float target, float value, float speed)*

*Defined at line 990 of ./game/server/util.cpp*

### UTIL_AngleDistance

*float UTIL_AngleDistance(float next, float cur)*

*Defined at line 1016 of ./game/server/util.cpp*

### UTIL_VarArgs

*char * UTIL_VarArgs(const char * format)*

*Defined at line 1037 of ./game/server/util.cpp*

### UTIL_Remove

*void UTIL_Remove(class CBaseEntity * pEntity)*

*Defined at line 1502 of ./game/server/util.cpp*

### UTIL_IsValidEntity

*BOOL UTIL_IsValidEntity(edict_t * pent)*

*Defined at line 1512 of ./game/server/util.cpp*

### UTIL_TeamsMatch

*BOOL UTIL_TeamsMatch(const char * pTeamName1, const char * pTeamName2)*

*Defined at line 1314 of ./game/server/util.cpp*

### CVAR_GET_FLOAT

*float CVAR_GET_FLOAT(const char * x)*

*Defined at line 46 of ./game/client/cl_util.h*

### UTIL_SplineFraction

*float UTIL_SplineFraction(float value, float scale)*

*Defined at line 1028 of ./game/server/util.cpp*

 Use for ease-in, ease-out style interpolation (accel/decel)

### CVAR_GET_STRING

*char * CVAR_GET_STRING(const char * x)*

*Defined at line 47 of ./game/client/cl_util.h*

### UTIL_WaterLevel

*float UTIL_WaterLevel(const class Vector & position, float minz, float maxz)*

*Defined at line 1414 of ./game/server/util.cpp*

 Search for water transition along a vertical line

### CVAR_CREATE

*struct cvar_s * CVAR_CREATE(const char * cv, const char * val, const int flags)*

*Defined at line 49 of ./game/client/cl_util.h*

### UTIL_Bubbles

*void UTIL_Bubbles(Vector mins, Vector maxs, int count)*

*Defined at line 1446 of ./game/server/util.cpp*

### UTIL_BubbleTrail

*void UTIL_BubbleTrail(Vector from, Vector to, int count)*

*Defined at line 1468 of ./game/server/util.cpp*

### DrawSetTextColor

*void DrawSetTextColor(float r, float g, float b)*

*Defined at line 91 of ./game/client/cl_util.h*

### UTIL_PrecacheOther

*void UTIL_PrecacheOther(const char * szClassname)*

*Defined at line 1519 of ./game/server/util.cpp*

 UTIL_* Stubs

 allows precacheing of other entities

### UTIL_ClientPrintAll

*void UTIL_ClientPrintAll(int msg_dest, const char * msg_name, const char * param1, const char * param2, const char * param3, const char * param4)*

*Defined at line 812 of ./game/server/util.cpp*

 prints a message to each client

### SPR_Height

*int SPR_Height(HSPRITE x, int f)*

*Defined at line 100 of ./game/client/cl_util.h*

 Gets the height & width of a sprite,  at the specified frame

### UTIL_CenterPrintAll

*void UTIL_CenterPrintAll(const char * msg_name, const char * param1, const char * param2, const char * param3, const char * param4)*

*Defined at line 342 of ./game/shared/util.h*

### SPR_Width

*int SPR_Width(HSPRITE x, int f)*

*Defined at line 101 of ./game/client/cl_util.h*

### TextMessageGet

*client_textmessage_t * TextMessageGet(const char * pName)*

*Defined at line 103 of ./game/client/cl_util.h*

### TextMessageDrawChar

*int TextMessageDrawChar(int x, int y, int number, int r, int g, int b)*

*Defined at line 108 of ./game/client/cl_util.h*

### UTIL_GetNextBestWeapon

*BOOL UTIL_GetNextBestWeapon(class CBasePlayer * pPlayer, class CBasePlayerItem * pCurrentWeapon)*

*Defined at line 341 of ./game/server/util.cpp*

### ClientPrint

*void ClientPrint(entvars_t * client, int msg_dest, const char * msg_name, const char * param1, const char * param2, const char * param3, const char * param4)*

*Defined at line 829 of ./game/server/util.cpp*

 prints messages through the HUD

### DrawConsoleString

*int DrawConsoleString(int x, int y, const char * string)*

*Defined at line 113 of ./game/client/cl_util.h*

### UTIL_SayText

*void UTIL_SayText(const char * pText, class CBaseEntity * pEntity)*

*Defined at line 846 of ./game/server/util.cpp*

 prints a message to the HUD say (chat)

### UTIL_SayTextAll

*void UTIL_SayTextAll(const char * pText, class CBaseEntity * pEntity)*

*Defined at line 857 of ./game/server/util.cpp*

### GetConsoleStringSize

*void GetConsoleStringSize(const char * string, int * width, int * height)*

*Defined at line 120 of ./game/client/cl_util.h*

### DrawUtfString

*int DrawUtfString(int xpos, int ypos, int iMaxX, const char * szIt, int r, int g, int b)*

*Defined at line 236 of ./game/client/hud_redraw.cpp*

### UTIL_HudMessageAll

*void UTIL_HudMessageAll(const hudtextparms_t & textparms, const char * pMessage)*

*Defined at line 799 of ./game/server/util.cpp*

 prints as transparent 'title' to the HUD

### ConsoleStringLen

*int ConsoleStringLen(const char * string)*

*Defined at line 130 of ./game/client/cl_util.h*

### UTIL_HudMessage

*void UTIL_HudMessage(class CBaseEntity * pEntity, const hudtextparms_t & textparms, const char * pMessage)*

*Defined at line 755 of ./game/server/util.cpp*

### ConsolePrint

*void ConsolePrint(const char * string)*

*Defined at line 139 of ./game/client/cl_util.h*

### UTIL_dtos1

*char * UTIL_dtos1(int d)*

*Defined at line 865 of ./game/server/util.cpp*

 for handy use with ClientPrint params

### UTIL_dtos2

*char * UTIL_dtos2(int d)*

*Defined at line 872 of ./game/server/util.cpp*

### CenterPrint

*void CenterPrint(const char * string)*

*Defined at line 144 of ./game/client/cl_util.h*

### UTIL_dtos3

*char * UTIL_dtos3(int d)*

*Defined at line 879 of ./game/server/util.cpp*

### UTIL_dtos4

*char * UTIL_dtos4(int d)*

*Defined at line 886 of ./game/server/util.cpp*

### UTIL_LogPrintf

*void UTIL_LogPrintf(const char * fmt)*

*Defined at line 1540 of ./game/server/util.cpp*

 Writes message to console with timestamp and FragLog header.

========================================================= UTIL_LogPrintf - Prints a logged message to console. Preceded by LOG: ( timestamp ) < message >=========================================================

### PlaySound

*void PlaySound(const char * szSound, float vol)*

*Defined at line 153 of ./game/client/cl_util.h*

 sound functions

### UTIL_DotPoints

*float UTIL_DotPoints(const class Vector & vecSrc, const class Vector & vecCheck, const class Vector & vecDir)*

*Defined at line 1557 of ./game/server/util.cpp*

 Sorta like FInViewCone, but for nonmonsters. 

========================================================= UTIL_DotPoints - returns the dot product of a line from src to check and vecdir.=========================================================

### PlaySound

*void PlaySound(int iSound, float vol)*

*Defined at line 154 of ./game/client/cl_util.h*

### UTIL_StripToken

*void UTIL_StripToken(const char * pKey, char * pDest)*

*Defined at line 1570 of ./game/server/util.cpp*

========================================================= UTIL_StripToken - for redundant keynames=========================================================

### SetMovedir

*void SetMovedir(entvars_t * pev)*

*Defined at line 215 of ./game/server/subs.cpp*

 Misc functions

QuakeEd only writes a single float for angles (bad idea), so up and down arejust constant angles.

### ScaleColors

*void ScaleColors(int & r, int & g, int & b, int a)*

*Defined at line 182 of ./game/client/hud_redraw.cpp*

### VecBModelOrigin

*Vector VecBModelOrigin(entvars_t * pevBModel)*

*Defined at line 43 of ./game/server/bmodels.cpp*

 BModelOrigin - calculates origin of a bmodel from absmin/size because all bmodel origins are 0 0 0

### BuildChangeList

*int BuildChangeList(LEVELLIST * pLevelList, int maxList)*

*Defined at line 1530 of ./game/server/triggers.cpp*

### VectorClear

*void VectorClear(float * a)*

*Defined at line 174 of ./game/client/cl_util.h*

### DBG_AssertFunction

*void DBG_AssertFunction(BOOL fExpr, const char * szExpr, const char * szFile, int szLine, const char * szMessage)*

*Defined at line 326 of ./game/server/util.cpp*

### VectorMA

*void VectorMA(const float * veca, float scale, const float * vecb, float * vecc)*

*Defined at line 47 of ./game/client/util.cpp*

### USENTENCEG_Pick

*int USENTENCEG_Pick(int isentenceg, char * szfound)*

*Defined at line 1085 of ./game/server/sound.cpp*

 pick a random sentence from rootname0 to rootnameX. picks from the rgsentenceg[isentenceg] least recently used, modifies lru array. returns the sentencename. note, lru must be seeded with 0-n randomized sentence numbers, with the rest of the lru filled with -1. The first integer in the lru is actually the size of the list.  Returns ipick, the ordinal of the picked sentence within the group.

### USENTENCEG_PickSequential

*int USENTENCEG_PickSequential(int isentenceg, char * szfound, int ipick, int freset)*

*Defined at line 1039 of ./game/server/sound.cpp*

 ignore lru. pick next sentence from sentence group. Go in order until we hit the last sentence,  then repeat list if freset is true.  If freset is false, then repeat last sentence. ipick is passed in as the requested sentence ordinal. ipick 'next' is returned.   return of -1 indicates an error.

### VectorScale

*void VectorScale(const float * in, float scale, float * out)*

*Defined at line 40 of ./game/client/util.cpp*

### USENTENCEG_InitLRU

*void USENTENCEG_InitLRU(unsigned char * plru, int count)*

*Defined at line 1008 of ./game/server/sound.cpp*

 randomize list of sentence name indices

### SENTENCEG_Init

*void SENTENCEG_Init()*

*Defined at line 1251 of ./game/server/sound.cpp*

 open sentences.txt, scan for groups, build rgsentenceg Should be called from world spawn, only works on the first call and is ignored subsequently.

### UnpackRGB

*void UnpackRGB(int & r, int & g, int & b, unsigned long ulRGB)*

*Defined at line 183 of ./game/client/cl_util.h*

### SENTENCEG_Stop

*void SENTENCEG_Stop(edict_t * entity, int isentenceg, int ipick)*

*Defined at line 1228 of ./game/server/sound.cpp*

 for this entity, for the given sentence within the sentence group, stop the sentence.

### SENTENCEG_PlayRndI

*int SENTENCEG_PlayRndI(edict_t * entity, int isentenceg, float volume, float attenuation, int flags, int pitch)*

*Defined at line 1159 of ./game/server/sound.cpp*

 given sentence group index, play random sentence for given entity. returns ipick - which sentence was picked to  play from the group. Ipick is only needed if you plan on stopping the sound before playback is done (see SENTENCEG_Stop).

### LoadSprite

*HSPRITE LoadSprite(const char * pszName)*

*Defined at line 54 of ./game/client/util.cpp*

### SENTENCEG_PlayRndSz

*int SENTENCEG_PlayRndSz(edict_t * entity, const char * szrootname, float volume, float attenuation, int flags, int pitch)*

*Defined at line 1177 of ./game/server/sound.cpp*

 same as above, but takes sentence group name instead of index

### SENTENCEG_PlaySequentialSz

*int SENTENCEG_PlaySequentialSz(edict_t * entity, const char * szrootname, float volume, float attenuation, int flags, int pitch, int ipick, int freset)*

*Defined at line 1204 of ./game/server/sound.cpp*

 play sentences in sequential order from sentence group.  Reset after last sentence.

### HUD_MessageBox

*_Bool HUD_MessageBox(const char * msg)*

*Defined at line 603 of ./game/client/client_int.cpp*

### SENTENCEG_GetIndex

*int SENTENCEG_GetIndex(const char * szrootname)*

*Defined at line 1135 of ./game/server/sound.cpp*

 Given sentence group rootname (name without number suffix), get sentence group index (isentenceg). Returns -1 if no such name.

### SENTENCEG_Lookup

*int SENTENCEG_Lookup(const char * sample, char * sentencenum)*

*Defined at line 1371 of ./game/server/sound.cpp*

 convert sentence (sample) name to !sentencenum, return !sentencenum

### IsXashFWGS

*_Bool IsXashFWGS()*

*Defined at line 618 of ./game/client/client_int.cpp*

### TEXTURETYPE_Init

*void TEXTURETYPE_Init()*

### TEXTURETYPE_Find

*char TEXTURETYPE_Find(char * name)*

*Defined at line 1517 of ./game/server/sound.cpp*

### GameSharedInit

*void GameSharedInit()*

*Defined at line 15 of ./game/shared/game_shared.cpp*

 Called to initialize the shared stuff 

### TEXTURETYPE_PlaySound

*float TEXTURETYPE_PlaySound(TraceResult * ptr, Vector vecSrc, Vector vecEnd, int iBulletType)*

*Defined at line 1526 of ./game/server/sound.cpp*

 play a strike sound based on the texture that was hit by the attack traceline.  VecSrc/VecEnd are the original traceline endpoints used by the attacker, iBulletType is the type of bullet that hit the texture. returns volume of strike instrument (crowbar) to play

### EMIT_SOUND_DYN

*void EMIT_SOUND_DYN(edict_t * entity, int channel, const char * sample, float volume, float attenuation, int flags, int pitch)*

*Defined at line 43 of ./game/client/hl/hl_baseentity.cpp*

 NOTE: use EMIT_SOUND_DYN to set the pitch of a sound. Pitch of 100 is no pitch shift.  Pitch > 100 up to 255 is a higher pitch, pitch < 100 down to 1 is a lower pitch.   150 to 70 is the realistic range. EMIT_SOUND_DYN with pitch != 100 should be used sparingly, as it's not quite as fast as EMIT_SOUND (the pitchshift mixer is not native coded).

### EMIT_SOUND

*void EMIT_SOUND(edict_t * entity, int channel, const char * sample, float volume, float attenuation)*

*Defined at line 538 of ./game/shared/util.h*

### STOP_SOUND

*void STOP_SOUND(edict_t * entity, int channel, const char * sample)*

*Defined at line 543 of ./game/shared/util.h*

### EMIT_SOUND_SUIT

*void EMIT_SOUND_SUIT(edict_t * entity, const char * sample)*

*Defined at line 1409 of ./game/server/sound.cpp*

 play a specific sentence over the HEV suit speaker - just pass player entity, and !sentencename

### EMIT_GROUPID_SUIT

*void EMIT_GROUPID_SUIT(edict_t * entity, int isentenceg)*

*Defined at line 1424 of ./game/server/sound.cpp*

 play a sentence, randomly selected from the passed in group id, over the HEV suit speaker

### EMIT_GROUPNAME_SUIT

*void EMIT_GROUPNAME_SUIT(edict_t * entity, const char * groupname)*

*Defined at line 1439 of ./game/server/sound.cpp*

 play a sentence, randomly selected from the passed in groupname

### UTIL_SetGroupTrace

*void UTIL_SetGroupTrace(int groupmask, int op)*

*Defined at line 164 of ./game/server/util.cpp*

 Normal overrides

### UTIL_UnsetGroupTrace

*void UTIL_UnsetGroupTrace()*

*Defined at line 172 of ./game/server/util.cpp*

### UTIL_SharedRandomLong

*int UTIL_SharedRandomLong(unsigned int seed, int low, int high)*

*Defined at line 84 of ./game/server/util.cpp*

=====================UTIL_SharedRandomLong=====================

### UTIL_SharedRandomFloat

*float UTIL_SharedRandomFloat(unsigned int seed, float low, float high)*

*Defined at line 113 of ./game/server/util.cpp*

=====================UTIL_SharedRandomFloat=====================

### UTIL_WeaponTimeBase

*float UTIL_WeaponTimeBase()*

*Defined at line 35 of ./game/server/util.cpp*

=====================UTIL_WeaponTimeBase

Always 0.0 on client, even if not predicting weapons ( won't get called in that case )=====================

### GetClassPtr

*T * GetClassPtr(T * a)*

*Defined at line 591 of ./game/shared/util.h*

 Converts a entvars_t * to a class pointer It will allocate the class and entity if necessary

### PM_ParticleLine

*void PM_ParticleLine(const vec3_t start, const vec3_t end, int pcolor, float life, float zvel)*

*Defined at line 33 of ./engine/common/pm_debug.cpp*

 pm_debug.c

===============PM_ParticleLine

draw line from particles================

### PM_DrawBBox

*void PM_DrawBBox(const vec3_t mins, const vec3_t maxs, const vec3_t origin, int pcolor, float life)*

*Defined at line 73 of ./engine/common/pm_debug.cpp*

================PM_DrawBBox

================

### Pmove_Init

*void Pmove_Init()*

*Defined at line 49 of ./engine/common/pm_trace.cpp*

 pm_trace.c

### PM_InitBoxHull

*void PM_InitBoxHull()*

*Defined at line 66 of ./engine/common/pm_trace.cpp*

===================PM_InitBoxHull

Set up the planes and clipnodes so that the six floats of a bounding boxcan just be stored out and get a proper hull_t structure.===================

### PM_HullForBsp

*hull_t * PM_HullForBsp(physent_t * pe, playermove_t * pmove, float * offset)*

*Defined at line 147 of ./engine/common/pm_trace.cpp*

==================PM_HullForBsp

assume physent is valid==================

### PM_RecursiveHullCheck

*qboolean PM_RecursiveHullCheck(hull_t * hull, int num, float p1f, float p2f, vec3_t p1, vec3_t p2, pmtrace_t * trace)*

*Defined at line 201 of ./engine/common/pm_trace.cpp*

==================PM_RecursiveHullCheck==================

### PM_PlayerTraceExt

*pmtrace_s PM_PlayerTraceExt(playermove_t * pm, vec3_t p1, vec3_t p2, int flags, int numents, physent_t * ents, int ignore_pe, pfnIgnore pmFilter)*

*Defined at line 316 of ./engine/common/pm_trace.cpp*

### PM_TestPlayerPosition

*int PM_TestPlayerPosition(playermove_t * pmove, vec3_t pos, pmtrace_t * ptrace, pfnIgnore pmFilter)*

*Defined at line 532 of ./engine/common/pm_trace.cpp*

### PM_HullPointContents

*int PM_HullPointContents(hull_t * hull, int num, const vec3_t p)*

*Defined at line 125 of ./engine/common/pm_trace.cpp*

==================PM_HullPointContents

==================

### PM_TruePointContents

*int PM_TruePointContents(playermove_t * pmove, const vec3_t p)*

*Defined at line 665 of ./engine/common/pm_trace.cpp*

=============PM_TruePointContents

=============

### PM_PointContents

*int PM_PointContents(playermove_t * pmove, const vec3_t p)*

*Defined at line 685 of ./engine/common/pm_trace.cpp*

=============PM_PointContents

=============

### PM_ConvertTrace

*void PM_ConvertTrace(trace_t * out, pmtrace_t * in, edict_t * ent)*

*Defined at line 112 of ./engine/common/pm_trace.cpp*

### PM_TraceTexture

*const char * PM_TraceTexture(physent_t * pe, vec3_t vstart, vec3_t vend)*

*Defined at line 223 of ./engine/common/pm_surface.cpp*

 pm_surface.c

==================PM_TraceTexture

find the face where the traceline hitassume physentity is valid==================

### PM_RecursiveSurfCheck

*msurface_t * PM_RecursiveSurfCheck(model_t * model, mnode_t * node, vec3_t p1, vec3_t p2)*

*Defined at line 107 of ./engine/common/pm_surface.cpp*

==================PM_RecursiveSurfCheck

==================

### PM_TraceSurface

*msurface_t * PM_TraceSurface(physent_t * pe, vec3_t start, vec3_t end)*

*Defined at line 184 of ./engine/common/pm_surface.cpp*

==================PM_TraceTexture

find the face where the traceline hitassume physentity is valid==================

### PM_TestLineExt

*int PM_TestLineExt(playermove_t * pmove, physent_t * ents, int numents, const vec3_t start, const vec3_t end, int flags)*

*Defined at line 330 of ./engine/common/pm_surface.cpp*

### R_RecursiveLightPoint

*qboolean R_RecursiveLightPoint(model_t * model, mnode_t * node, float p1f, float p2f, colorVec * cv, const vec3_t start, const vec3_t end)*

*Defined at line 231 of ./ref_gl/gl_rlight.cpp*

=================R_RecursiveLightPoint=================

### R_LightVecInternal

* R_LightVecInternal(const vec3_t start, const vec3_t end, vec3_t lspot, vec3_t lvec)*

*Defined at line 385 of ./ref_gl/gl_rlight.cpp*

=================R_LightVec

check bspmodels to get light from=================

### _vpaste

*const char * _vpaste(const char * fmt)*

*Defined at line 9 of ./tier1/dbg.cpp*

### Msg

*void Msg(const char * fmt)*

*Defined at line 21 of ./tier1/dbg.cpp*

### Warn

*void Warn(const char * fmt)*

*Defined at line 33 of ./tier1/dbg.cpp*

### Error

*void Error(const char * fmt)*

*Defined at line 45 of ./tier1/dbg.cpp*

### FatalError

*void FatalError(const char * fmt)*

*Defined at line 57 of ./tier1/dbg.cpp*

### MsgC

*void MsgC(const char [3] color, const char * fmt)*

*Defined at line 67 of ./tier1/dbg.cpp*

### GetEntityAPI

*int GetEntityAPI(DLL_FUNCTIONS * pFunctionTable, int interfaceVersion)*

### GetEntityAPI2

*int GetEntityAPI2(DLL_FUNCTIONS * pFunctionTable, int * interfaceVersion)*

### Server_GetPhysicsInterface

*int Server_GetPhysicsInterface(int iVersion, server_physics_api_t * pfuncsFromEngine, physics_interface_t * pFunctionTable)*

*Defined at line 827 of ./game/server/world.cpp*

### DispatchSpawn

*int DispatchSpawn(edict_t * pent)*

*Defined at line 310 of ./game/server/cbase.cpp*

### DispatchKeyValue

*void DispatchKeyValue(edict_t * pentKeyvalue, KeyValueData * pkvd)*

*Defined at line 361 of ./game/server/cbase.cpp*

### DispatchTouch

*void DispatchTouch(edict_t * pentTouched, edict_t * pentOther)*

*Defined at line 386 of ./game/server/cbase.cpp*

### DispatchUse

*void DispatchUse(edict_t * pentUsed, edict_t * pentOther)*

*Defined at line 398 of ./game/server/cbase.cpp*

### DispatchThink

*void DispatchThink(edict_t * pent)*

*Defined at line 407 of ./game/server/cbase.cpp*

### DispatchBlocked

*void DispatchBlocked(edict_t * pentBlocked, edict_t * pentOther)*

*Defined at line 419 of ./game/server/cbase.cpp*

### DispatchSave

*void DispatchSave(edict_t * pent, SAVERESTOREDATA * pSaveData)*

*Defined at line 428 of ./game/server/cbase.cpp*

### DispatchRestore

*int DispatchRestore(edict_t * pent, SAVERESTOREDATA * pSaveData, int globalEntity)*

*Defined at line 478 of ./game/server/cbase.cpp*

### DispatchObjectCollsionBox

*void DispatchObjectCollsionBox(edict_t * pent)*

*Defined at line 585 of ./game/server/cbase.cpp*

### SaveWriteFields

*void SaveWriteFields(SAVERESTOREDATA * pSaveData, const char * pname, void * pBaseData, TYPEDESCRIPTION * pFields, int fieldCount)*

*Defined at line 596 of ./game/server/cbase.cpp*

### SaveReadFields

*void SaveReadFields(SAVERESTOREDATA * pSaveData, const char * pname, void * pBaseData, TYPEDESCRIPTION * pFields, int fieldCount)*

*Defined at line 602 of ./game/server/cbase.cpp*

### SaveGlobalState

*void SaveGlobalState(SAVERESTOREDATA * pSaveData)*

*Defined at line 421 of ./game/server/world.cpp*

### RestoreGlobalState

*void RestoreGlobalState(SAVERESTOREDATA * pSaveData)*

*Defined at line 427 of ./game/server/world.cpp*

### ResetGlobalState

*void ResetGlobalState()*

*Defined at line 433 of ./game/server/world.cpp*

### FireTargets

*void FireTargets(const char * targetName, class CBaseEntity * pActivator, class CBaseEntity * pCaller, USE_TYPE useType, float value)*

*Defined at line 109 of ./game/server/subs.cpp*

### PlayLockSounds

*void PlayLockSounds(entvars_t * pev, locksound_t * pls, int flocked, int fbutton)*

*Defined at line 117 of ./game/server/func_door.cpp*

 play door or button locked or unlocked sounds.  pass in pointer to valid locksound struct.  if flocked is true, play 'door is locked' sound, otherwise play 'door is unlocked' sound NOTE: this routine is shared by doors and buttons

### ButtonSound

*const char * ButtonSound(int sound)*

*Defined at line 385 of ./game/server/func_button.cpp*

 Button sound table.  Also used by CBaseDoor to get 'touched' door lock/unlock sounds

### GetSkillCvar

*float GetSkillCvar(const char * pName)*

*Defined at line 28 of ./game/server/skill.cpp*

========================================================= take the name of a cvar, tack a digit for the skill level on, and return the value.of that Cvar =========================================================

### UTIL_MoveToOrigin

*void UTIL_MoveToOrigin(edict_t * pent, const class Vector & vecGoal, float flDist, int iMoveType)*

*Defined at line 390 of ./game/server/util.cpp*

 float UTIL_MoveToOrigin( edict_t *pent, const Vector vecGoal, float flDist, int iMoveType )

 spawn flags 256 and above are already taken by the engine

### VecCheckToss

*Vector VecCheckToss(entvars_t * pev, const class Vector & vecSpot1, Vector vecSpot2, float flGravityAdj)*

*Defined at line 78 of ./game/server/ai/ai.cpp*

 VecCheckToss - returns the velocity at which an object should be lobbed from vecspot1 to land near vecspot2. returns g_vecZero if toss is not feasible.

### VecCheckThrow

*Vector VecCheckThrow(entvars_t * pev, const class Vector & vecSpot1, Vector vecSpot2, float flSpeed, float flGravityAdj)*

*Defined at line 163 of ./game/server/ai/ai.cpp*

 VecCheckThrow - returns the velocity vector at which an object should be thrown from vecspot1 to hit vecspot2. returns g_vecZero if throw is not feasible.

### EjectBrass

*void EjectBrass(const class Vector & vecOrigin, const class Vector & vecVelocity, float rotation, int model, int soundtype)*

*Defined at line 291 of ./game/client/hl/hl_baseentity.cpp*

 EjectBrass - tosses a brass shell from passed origin at passed velocity

### ExplodeModel

*void ExplodeModel(const class Vector & vecOrigin, float speed, int model, int count)*

### FBoxVisible

*BOOL FBoxVisible(entvars_t * pevLooker, entvars_t * pevTarget)*

### FBoxVisible

*BOOL FBoxVisible(entvars_t * pevLooker, entvars_t * pevTarget, class Vector & vecTargetOrigin, float flSize)*

*Defined at line 47 of ./game/server/ai/ai.cpp*

========================================================= FBoxVisible - a more accurate ( and slower ) version of FVisible. 

 !!!UNDONE - make this CBaseMonster?=========================================================

### IsSoundEvent

*int IsSoundEvent(int eventNumber)*

*Defined at line 173 of ./game/server/animation.cpp*

### LookupActivity

*int LookupActivity(void * pmodel, entvars_t * pev, int activity)*

*Defined at line 81 of ./game/server/animation.cpp*

### LookupActivityHeaviest

*int LookupActivityHeaviest(void * pmodel, entvars_t * pev, int activity)*

*Defined at line 108 of ./game/server/animation.cpp*

### LookupSequence

*int LookupSequence(void * pmodel, const char * label)*

*Defined at line 152 of ./game/server/animation.cpp*

### GetSequenceInfo

*void GetSequenceInfo(void * pmodel, entvars_t * pev, float * pflFrameRate, float * pflGroundSpeed)*

*Defined at line 218 of ./game/server/animation.cpp*

### GetSequenceFlags

*int GetSequenceFlags(void * pmodel, entvars_t * pev)*

*Defined at line 250 of ./game/server/animation.cpp*

### LookupAnimationEvents

*int LookupAnimationEvents(void * pmodel, entvars_t * pev, float flStart, float flEnd)*

### SetController

*float SetController(void * pmodel, entvars_t * pev, int iController, float flValue)*

*Defined at line 309 of ./game/server/animation.cpp*

### SetBlending

*float SetBlending(void * pmodel, entvars_t * pev, int iBlender, float flValue)*

*Defined at line 364 of ./game/server/animation.cpp*

### GetEyePosition

*void GetEyePosition(void * pmodel, float * vecEyePosition)*

*Defined at line 137 of ./game/server/animation.cpp*

### SequencePrecache

*void SequencePrecache(void * pmodel, const char * pSequenceName)*

*Defined at line 180 of ./game/server/animation.cpp*

### FindTransition

*int FindTransition(void * pmodel, int iEndingAnim, int iGoalAnim, int * piDir)*

*Defined at line 407 of ./game/server/animation.cpp*

### SetBodygroup

*void SetBodygroup(void * pmodel, entvars_t * pev, int iGroup, int iValue)*

*Defined at line 474 of ./game/server/animation.cpp*

### GetBodygroup

*int GetBodygroup(void * pmodel, entvars_t * pev, int iGroup)*

*Defined at line 495 of ./game/server/animation.cpp*

### GetAnimationEvent

*int GetAnimationEvent(void * pmodel, entvars_t * pev, MonsterEvent_t * pMonsterEvent, float flStart, float flEnd, int index)*

*Defined at line 264 of ./game/server/animation.cpp*

### ExtractBbox

*int ExtractBbox(void * pmodel, int sequence, float * mins, float * maxs)*

*Defined at line 58 of ./game/server/animation.cpp*

### GameDLLInit

*void GameDLLInit()*

*Defined at line 454 of ./game/server/game.cpp*

 Register your console variables here This gets called one time when the game is initialied

### monster_houndeye

*void monster_houndeye(entvars_t * pev)*

*Defined at line 114 of ./game/server/npc/npc_houndeye.cpp*

### DeactivateSatchels

*void DeactivateSatchels(class CBasePlayer * pOwner)*

*Defined at line 459 of ./game/shared/hl1/weapon_satchel.cpp*

========================================================= DeactivateSatchels - removes all satchels owned by the provided player. Should only be used upon death.

 Made this global on purpose.=========================================================

### ClearMultiDamage

*void ClearMultiDamage()*

*Defined at line 285 of ./game/client/hl/hl_baseentity.cpp*

 ClearMultiDamage - resets the global multi damage accumulator

### ApplyMultiDamage

*void ApplyMultiDamage(entvars_t * pevInflictor, entvars_t * pevAttacker)*

*Defined at line 286 of ./game/client/hl/hl_baseentity.cpp*

 ApplyMultiDamage - inflicts contents of global multi damage register on gMultiDamage.pEntity

 GLOBALS USED:		gMultiDamage

### AddMultiDamage

*void AddMultiDamage(entvars_t * pevInflictor, class CBaseEntity * pEntity, float flDamage, int bitsDamageType)*

*Defined at line 287 of ./game/client/hl/hl_baseentity.cpp*

 GLOBALS USED:		gMultiDamage

### DecalGunshot

*void DecalGunshot(TraceResult * pTrace, int iBulletType)*

*Defined at line 290 of ./game/client/hl/hl_baseentity.cpp*

### SpawnBlood

*void SpawnBlood(Vector vecSpot, int bloodColor, float flDamage)*

*Defined at line 288 of ./game/client/hl/hl_baseentity.cpp*

================SpawnBlood================

### DamageDecal

*int DamageDecal(class CBaseEntity * pEntity, int bitsDamageType)*

*Defined at line 289 of ./game/client/hl/hl_baseentity.cpp*

### RadiusDamage

*void RadiusDamage(Vector vecSrc, entvars_t * pevInflictor, entvars_t * pevAttacker, float flDamage, float flRadius, int iClassIgnore, int bitsDamageType)*

*Defined at line 298 of ./game/client/hl/hl_baseentity.cpp*

 RadiusDamage - this entity is exploding, or otherwise needs to inflict damage upon entities within a certain range.

 only damage ents that can clearly be seen by the explosion!

### monster_apache

*void monster_apache(entvars_t * pev)*

*Defined at line 93 of ./game/server/npc/npc_apache.cpp*

### hvr_rocket

*void hvr_rocket(entvars_t * pev)*

*Defined at line 939 of ./game/server/npc/npc_apache.cpp*

### monster_nihilanth

*void monster_nihilanth(entvars_t * pev)*

*Defined at line 135 of ./game/server/npc/npc_nihilanth.cpp*

### nihilanth_energy_ball

*void nihilanth_energy_ball(entvars_t * pev)*

*Defined at line 218 of ./game/server/npc/npc_nihilanth.cpp*

### PM_Init

*void PM_Init(struct playermove_s * ppmove)*

*Defined at line 3341 of ./pm_shared/pm_shared.cpp*

### PM_Move

*void PM_Move(struct playermove_s * ppmove, int server)*

*Defined at line 3297 of ./pm_shared/pm_shared.cpp*

This modume implements the shared player physics code between any particular game and the engine.  The same PM_Move routine is built into the game .dll and the client .dll and isinvoked by each side as appropriate.  There should be no distinction, internally, between serverand client.  This will ensure that prediction behaves appropriately.

### PM_FindTextureType

*char PM_FindTextureType(char * name)*

*Defined at line 237 of ./pm_shared/pm_shared.cpp*

 NOTE: this routine should ONLY be called if the  current texture under the player changes!

### BEGIN_READ

*void BEGIN_READ(void * buf, int size)*

*Defined at line 27 of ./game/client/parsemsg.cpp*

### READ_CHAR

*int READ_CHAR()*

*Defined at line 35 of ./game/client/parsemsg.cpp*

### READ_BYTE

*int READ_BYTE()*

*Defined at line 51 of ./game/client/parsemsg.cpp*

### READ_SHORT

*int READ_SHORT()*

*Defined at line 67 of ./game/client/parsemsg.cpp*

### READ_WORD

*int READ_WORD()*

*Defined at line 84 of ./game/client/parsemsg.cpp*

### READ_LONG

*int READ_LONG()*

*Defined at line 89 of ./game/client/parsemsg.cpp*

### READ_FLOAT

*float READ_FLOAT()*

*Defined at line 106 of ./game/client/parsemsg.cpp*

### READ_STRING

*char * READ_STRING()*

*Defined at line 126 of ./game/client/parsemsg.cpp*

### READ_COORD

*float READ_COORD()*

*Defined at line 151 of ./game/client/parsemsg.cpp*

### READ_ANGLE

*float READ_ANGLE()*

*Defined at line 156 of ./game/client/parsemsg.cpp*

### READ_HIRESANGLE

*float READ_HIRESANGLE()*

*Defined at line 161 of ./game/client/parsemsg.cpp*

### VectorCompare

*int VectorCompare(const float * v1, const float * v2)*

*Defined at line 21 of ./game/client/studio_util.cpp*

====================VectorCompare

====================

### CrossProduct

*void CrossProduct(const float * v1, const float * v2, float * cross)*

*Defined at line 38 of ./game/client/studio_util.cpp*

====================CrossProduct

====================

### ConcatTransforms

*void ConcatTransforms(float [3][4] in1, float [3][4] in2, float [3][4] out)*

*Defined at line 51 of ./game/client/studio_util.cpp*

================ConcatTransforms

================

### MatrixCopy

*void MatrixCopy(float [3][4] in, float [3][4] out)*

*Defined at line 200 of ./game/client/studio_util.cpp*

====================MatrixCopy

====================

### QuaternionMatrix

*void QuaternionMatrix(vec4_t quaternion, float (*)[4] matrix)*

*Defined at line 179 of ./game/client/studio_util.cpp*

====================QuaternionMatrix

====================

### QuaternionSlerp

*void QuaternionSlerp(vec4_t p, vec4_t q, float t, vec4_t qt)*

*Defined at line 115 of ./game/client/studio_util.cpp*

====================QuaternionSlerp

====================

### AngleQuaternion

*void AngleQuaternion(float * angles, vec4_t quaternion)*

*Defined at line 87 of ./game/client/studio_util.cpp*

====================AngleQuaternion

====================

### V_GetInEyePos

*void V_GetInEyePos(int entity, float * origin, float * angles)*

*Defined at line 1209 of ./game/client/view.cpp*

### V_ResetChaseCam

*void V_ResetChaseCam()*

*Defined at line 1204 of ./game/client/view.cpp*

### V_GetChasePos

*void V_GetChasePos(int target, float * cl_angles, float * origin, float * angles)*

*Defined at line 1158 of ./game/client/view.cpp*

### GetClientColor

*float * GetClientColor(int clientIndex)*

*Defined at line 53 of ./game/client/death.cpp*

### SpectatorMode

*void SpectatorMode()*

*Defined at line 45 of ./game/client/hud_spectator.cpp*

### SpectatorSpray

*void SpectatorSpray()*

*Defined at line 60 of ./game/client/hud_spectator.cpp*

### SpectatorHelp

*void SpectatorHelp()*

*Defined at line 79 of ./game/client/hud_spectator.cpp*

### SpectatorMenu

*void SpectatorMenu()*

*Defined at line 96 of ./game/client/hud_spectator.cpp*

### ToggleScores

*void ToggleScores()*

*Defined at line 105 of ./game/client/hud_spectator.cpp*

### UTIL_FindEntityInMap

*int UTIL_FindEntityInMap(const char * name, float * origin, float * angle)*

*Defined at line 178 of ./game/client/hud_spectator.cpp*

### SDL_GetPlatform

*const char * SDL_GetPlatform()*



**brief** Gets the name of the platform.

### SDL_malloc

*void * SDL_malloc(size_t size)*

### SDL_calloc

*void * SDL_calloc(size_t nmemb, size_t size)*

### SDL_realloc

*void * SDL_realloc(void * mem, size_t size)*

### SDL_free

*void SDL_free(void * mem)*

### SDL_GetMemoryFunctions

*void SDL_GetMemoryFunctions(SDL_malloc_func * malloc_func, SDL_calloc_func * calloc_func, SDL_realloc_func * realloc_func, SDL_free_func * free_func)*



**brief** Get the current set of SDL memory functions

### SDL_SetMemoryFunctions

*int SDL_SetMemoryFunctions(SDL_malloc_func malloc_func, SDL_calloc_func calloc_func, SDL_realloc_func realloc_func, SDL_free_func free_func)*



**brief** Replace SDL's memory allocation functions with a custom set



**note** If you are replacing SDL's memory functions, you should call        SDL_GetNumAllocations() and be very careful if it returns non-zero.        That means that your free function will be called with memory        allocated by the previous memory allocation functions.

### SDL_GetNumAllocations

*int SDL_GetNumAllocations()*



**brief** Get the number of outstanding (unfreed) allocations

### SDL_getenv

*char * SDL_getenv(const char * name)*

### SDL_setenv

*int SDL_setenv(const char * name, const char * value, int overwrite)*

### SDL_qsort

*void SDL_qsort(void * base, size_t nmemb, size_t size, int (*)(const void *, const void *) compare)*

### SDL_abs

*int SDL_abs(int x)*

### SDL_isdigit

*int SDL_isdigit(int x)*

### SDL_isspace

*int SDL_isspace(int x)*

### SDL_isupper

*int SDL_isupper(int x)*

### SDL_islower

*int SDL_islower(int x)*

### SDL_toupper

*int SDL_toupper(int x)*

### SDL_tolower

*int SDL_tolower(int x)*

### SDL_memset

*void * SDL_memset(void * dst, int c, size_t len)*

### SDL_memset4

*void SDL_memset4(void * dst, Uint32 val, size_t dwords)*

*Defined at line 423 of /usr/include/SDL2/SDL_stdinc.h*

 Note that memset() is a byte assignment and this is a 32-bit assignment, so they're not directly equivalent. 

### SDL_memcpy

*void * SDL_memcpy(void * dst, const void * src, size_t len)*

### SDL_memmove

*void * SDL_memmove(void * dst, const void * src, size_t len)*

### SDL_memcmp

*int SDL_memcmp(const void * s1, const void * s2, size_t len)*

### SDL_wcslen

*size_t SDL_wcslen(const wchar_t * wstr)*

### SDL_wcslcpy

*size_t SDL_wcslcpy(wchar_t * dst, const wchar_t * src, size_t maxlen)*

### SDL_wcslcat

*size_t SDL_wcslcat(wchar_t * dst, const wchar_t * src, size_t maxlen)*

### SDL_wcsdup

*wchar_t * SDL_wcsdup(const wchar_t * wstr)*

### SDL_wcsstr

*wchar_t * SDL_wcsstr(const wchar_t * haystack, const wchar_t * needle)*

### SDL_wcscmp

*int SDL_wcscmp(const wchar_t * str1, const wchar_t * str2)*

### SDL_wcsncmp

*int SDL_wcsncmp(const wchar_t * str1, const wchar_t * str2, size_t maxlen)*

### SDL_strlen

*size_t SDL_strlen(const char * str)*

### SDL_strlcpy

*size_t SDL_strlcpy(char * dst, const char * src, size_t maxlen)*

### SDL_utf8strlcpy

*size_t SDL_utf8strlcpy(char * dst, const char * src, size_t dst_bytes)*

### SDL_strlcat

*size_t SDL_strlcat(char * dst, const char * src, size_t maxlen)*

### SDL_strdup

*char * SDL_strdup(const char * str)*

### SDL_strrev

*char * SDL_strrev(char * str)*

### SDL_strupr

*char * SDL_strupr(char * str)*

### SDL_strlwr

*char * SDL_strlwr(char * str)*

### SDL_strchr

*char * SDL_strchr(const char * str, int c)*

### SDL_strrchr

*char * SDL_strrchr(const char * str, int c)*

### SDL_strstr

*char * SDL_strstr(const char * haystack, const char * needle)*

### SDL_strtokr

*char * SDL_strtokr(char * s1, const char * s2, char ** saveptr)*

### SDL_utf8strlen

*size_t SDL_utf8strlen(const char * str)*

### SDL_itoa

*char * SDL_itoa(int value, char * str, int radix)*

### SDL_uitoa

*char * SDL_uitoa(unsigned int value, char * str, int radix)*

### SDL_ltoa

*char * SDL_ltoa(long value, char * str, int radix)*

### SDL_ultoa

*char * SDL_ultoa(unsigned long value, char * str, int radix)*

### SDL_lltoa

*char * SDL_lltoa(Sint64 value, char * str, int radix)*

### SDL_ulltoa

*char * SDL_ulltoa(Uint64 value, char * str, int radix)*

### SDL_atoi

*int SDL_atoi(const char * str)*

### SDL_atof

*double SDL_atof(const char * str)*

### SDL_strtol

*long SDL_strtol(const char * str, char ** endp, int base)*

### SDL_strtoul

*unsigned long SDL_strtoul(const char * str, char ** endp, int base)*

### SDL_strtoll

*Sint64 SDL_strtoll(const char * str, char ** endp, int base)*

### SDL_strtoull

*Uint64 SDL_strtoull(const char * str, char ** endp, int base)*

### SDL_strtod

*double SDL_strtod(const char * str, char ** endp)*

### SDL_strcmp

*int SDL_strcmp(const char * str1, const char * str2)*

### SDL_strncmp

*int SDL_strncmp(const char * str1, const char * str2, size_t maxlen)*

### SDL_strcasecmp

*int SDL_strcasecmp(const char * str1, const char * str2)*

### SDL_strncasecmp

*int SDL_strncasecmp(const char * str1, const char * str2, size_t len)*

### SDL_sscanf

*int SDL_sscanf(const char * text, const char * fmt)*

### SDL_vsscanf

*int SDL_vsscanf(const char * text, const char * fmt, va_list ap)*

### SDL_snprintf

*int SDL_snprintf(char * text, size_t maxlen, const char * fmt)*

### SDL_vsnprintf

*int SDL_vsnprintf(char * text, size_t maxlen, const char * fmt, va_list ap)*

### SDL_acos

*double SDL_acos(double x)*

### SDL_acosf

*float SDL_acosf(float x)*

### SDL_asin

*double SDL_asin(double x)*

### SDL_asinf

*float SDL_asinf(float x)*

### SDL_atan

*double SDL_atan(double x)*

### SDL_atanf

*float SDL_atanf(float x)*

### SDL_atan2

*double SDL_atan2(double x, double y)*

### SDL_atan2f

*float SDL_atan2f(float x, float y)*

### SDL_ceil

*double SDL_ceil(double x)*

### SDL_ceilf

*float SDL_ceilf(float x)*

### SDL_copysign

*double SDL_copysign(double x, double y)*

### SDL_copysignf

*float SDL_copysignf(float x, float y)*

### SDL_cos

*double SDL_cos(double x)*

### SDL_cosf

*float SDL_cosf(float x)*

### SDL_exp

*double SDL_exp(double x)*

### SDL_expf

*float SDL_expf(float x)*

### SDL_fabs

*double SDL_fabs(double x)*

### SDL_fabsf

*float SDL_fabsf(float x)*

### SDL_floor

*double SDL_floor(double x)*

### SDL_floorf

*float SDL_floorf(float x)*

### SDL_fmod

*double SDL_fmod(double x, double y)*

### SDL_fmodf

*float SDL_fmodf(float x, float y)*

### SDL_log

*double SDL_log(double x)*

### SDL_logf

*float SDL_logf(float x)*

### SDL_log10

*double SDL_log10(double x)*

### SDL_log10f

*float SDL_log10f(float x)*

### SDL_pow

*double SDL_pow(double x, double y)*

### SDL_powf

*float SDL_powf(float x, float y)*

### SDL_scalbn

*double SDL_scalbn(double x, int n)*

### SDL_scalbnf

*float SDL_scalbnf(float x, int n)*

### SDL_sin

*double SDL_sin(double x)*

### SDL_sinf

*float SDL_sinf(float x)*

### SDL_sqrt

*double SDL_sqrt(double x)*

### SDL_sqrtf

*float SDL_sqrtf(float x)*

### SDL_tan

*double SDL_tan(double x)*

### SDL_tanf

*float SDL_tanf(float x)*

### SDL_iconv_open

*SDL_iconv_t SDL_iconv_open(const char * tocode, const char * fromcode)*

### SDL_iconv_close

*int SDL_iconv_close(SDL_iconv_t cd)*

### SDL_iconv

*size_t SDL_iconv(SDL_iconv_t cd, const char ** inbuf, size_t * inbytesleft, char ** outbuf, size_t * outbytesleft)*

### SDL_iconv_string

*char * SDL_iconv_string(const char * tocode, const char * fromcode, const char * inbuf, size_t inbytesleft)*

  This function converts a string between encodings in one pass, returning a  string that must be freed with SDL_free() or NULL on error.

### SDL_memcpy4

*void * SDL_memcpy4(void * dst, const void * src, size_t dwords)*

*Defined at line 604 of /usr/include/SDL2/SDL_stdinc.h*

### SDL_main

*int SDL_main(int argc, char *[] argv)*

### SDL_SetMainReady

*void SDL_SetMainReady()*

  This is called by the real SDL main function to let the rest of the  library know that initialization was done properly.

  Calling this yourself without knowing what you're doing can cause  crashes and hard to diagnose problems with your application.

### SDL_ReportAssertion

*SDL_AssertState SDL_ReportAssertion(SDL_AssertData * , const char * , const char * , int )*

 Never call this directly. Use the SDL_assert* macros. 

### SDL_SetAssertionHandler

*void SDL_SetAssertionHandler(SDL_AssertionHandler handler, void * userdata)*



**brief** Set an application-defined assertion handler.

  This allows an app to show its own assertion UI and/or force the  response to an assertion failure. If the app doesn't provide this, SDL  will try to do the right thing, popping up a system-specific GUI dialog,  and probably minimizing any fullscreen windows.

  This callback may fire from any thread, but it runs wrapped in a mutex, so  it will only fire from one thread at a time.

  Setting the callback to NULL restores SDL's original internal handler.

  This callback is NOT reset to SDL's internal handler upon SDL_Quit()!

  Return SDL_AssertState value of how to handle the assertion failure.



**handler**

**userdata**

### SDL_GetDefaultAssertionHandler

*SDL_AssertionHandler SDL_GetDefaultAssertionHandler()*



**brief** Get the default assertion handler.

  This returns the function pointer that is called by default when an   assertion is triggered. This is an internal function provided by SDL,   that is used for assertions when SDL_SetAssertionHandler() hasn't been   used to provide a different function.



**return** The default SDL_AssertionHandler that is called when an assert triggers.

### SDL_GetAssertionHandler

*SDL_AssertionHandler SDL_GetAssertionHandler(void ** puserdata)*



**brief** Get the current assertion handler.

  This returns the function pointer that is called when an assertion is   triggered. This is either the value last passed to   SDL_SetAssertionHandler(), or if no application-specified function is   set, is equivalent to calling SDL_GetDefaultAssertionHandler().



**puserdata**

**return** The SDL_AssertionHandler that is called when an assert triggers.

### SDL_GetAssertionReport

*const SDL_AssertData * SDL_GetAssertionReport()*



**brief** Get a list of all assertion failures.

  Get all assertions triggered since last call to SDL_ResetAssertionReport(),  or the start of the program.

  The proper way to examine this data looks something like this:

<code>

  const SDL_AssertData *item = SDL_GetAssertionReport();  while (item) {      printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\n",             item->condition, item->function, item->filename,             item->linenum, item->trigger_count,             item->always_ignore ? "yes" : "no");      item = item->next;  }</code>





**return** List of all assertions.

**sa** SDL_ResetAssertionReport

### SDL_ResetAssertionReport

*void SDL_ResetAssertionReport()*



**brief** Reset the list of all assertion failures.

  Reset list of all assertions triggered.



**sa** SDL_GetAssertionReport

### SDL_AtomicTryLock

*SDL_bool SDL_AtomicTryLock(SDL_SpinLock * lock)*



**brief** Try to lock a spin lock by setting it to a non-zero value.



**lock**



**return** SDL_TRUE if the lock succeeded, SDL_FALSE if the lock is already held.

### SDL_AtomicLock

*void SDL_AtomicLock(SDL_SpinLock * lock)*



**brief** Lock a spin lock by setting it to a non-zero value.



**lock**

### SDL_AtomicUnlock

*void SDL_AtomicUnlock(SDL_SpinLock * lock)*



**brief** Unlock a spin lock by setting it to 0. Always returns immediately



**lock**

### SDL_MemoryBarrierReleaseFunction

*void SDL_MemoryBarrierReleaseFunction()*

 Memory barriers are designed to prevent reads and writes from being reordered by the compiler and being seen out of order on multi-core CPUs.

 A typical pattern would be for thread A to write some data and a flag, and for thread B to read the flag and get the data. In this case you would insert a release barrier between writing the data and the flag, guaranteeing that the data write completes no later than the flag is written, and you would insert an acquire barrier between reading the flag and reading the data, to ensure that all the reads associated with the flag have completed.

 In this pattern you should always see a release barrier paired with an acquire barrier and you should gate the data reads/writes with a single flag variable.

 For more information on these semantics, take a look at the blog post: http://preshing.com/20120913/acquire-and-release-semantics

### SDL_MemoryBarrierAcquireFunction

*void SDL_MemoryBarrierAcquireFunction()*

### SDL_AtomicCAS

*SDL_bool SDL_AtomicCAS(SDL_atomic_t * a, int oldval, int newval)*



**brief** Set an atomic variable to a new value if it is currently an old value.



**return** SDL_TRUE if the atomic variable was set, SDL_FALSE otherwise.



**note** If you don't know what this function is for, you shouldn't use it!

### SDL_AtomicSet

*int SDL_AtomicSet(SDL_atomic_t * a, int v)*



**brief** Set an atomic variable to a value.



**return** The previous value of the atomic variable.

### SDL_AtomicGet

*int SDL_AtomicGet(SDL_atomic_t * a)*



**brief** Get the value of an atomic variable

### SDL_AtomicAdd

*int SDL_AtomicAdd(SDL_atomic_t * a, int v)*



**brief** Add to an atomic variable.



**return** The previous value of the atomic variable.



**note** This same style can be used for any number operation

### SDL_AtomicCASPtr

*SDL_bool SDL_AtomicCASPtr(void ** a, void * oldval, void * newval)*



**brief** Set a pointer to a new value if it is currently an old value.



**return** SDL_TRUE if the pointer was set, SDL_FALSE otherwise.



**note** If you don't know what this function is for, you shouldn't use it!

### SDL_AtomicSetPtr

*void * SDL_AtomicSetPtr(void ** a, void * v)*



**brief** Set a pointer to a value atomically.



**return** The previous value of the pointer.

### SDL_AtomicGetPtr

*void * SDL_AtomicGetPtr(void ** a)*



**brief** Get the value of a pointer atomically.

### SDL_SetError

*int SDL_SetError(const char * fmt)*

 Public functions 

 SDL_SetError() unconditionally returns -1. 

### SDL_GetError

*const char * SDL_GetError()*

### SDL_ClearError

*void SDL_ClearError()*

### SDL_Error

*int SDL_Error(SDL_errorcode code)*

 SDL_Error() unconditionally returns -1. 

### SDL_Swap16

*Uint16 SDL_Swap16(Uint16 x)*

*Defined at line 80 of /usr/include/SDL2/SDL_endian.h*

### SDL_Swap32

*Uint32 SDL_Swap32(Uint32 x)*

*Defined at line 124 of /usr/include/SDL2/SDL_endian.h*

### SDL_Swap64

*Uint64 SDL_Swap64(Uint64 x)*

*Defined at line 191 of /usr/include/SDL2/SDL_endian.h*

### SDL_SwapFloat

*float SDL_SwapFloat(float x)*

*Defined at line 215 of /usr/include/SDL2/SDL_endian.h*

### SDL_CreateMutex

*SDL_mutex * SDL_CreateMutex()*

  Create a mutex, initialized unlocked.

### SDL_LockMutex

*int SDL_LockMutex(SDL_mutex * mutex)*

### SDL_TryLockMutex

*int SDL_TryLockMutex(SDL_mutex * mutex)*

  Try to lock the mutex



**return** 0, SDL_MUTEX_TIMEDOUT, or -1 on error

### SDL_UnlockMutex

*int SDL_UnlockMutex(SDL_mutex * mutex)*

### SDL_DestroyMutex

*void SDL_DestroyMutex(SDL_mutex * mutex)*

  Destroy a mutex.

### SDL_CreateSemaphore

*SDL_sem * SDL_CreateSemaphore(Uint32 initial_value)*

  Create a semaphore, initialized with value, returns NULL on failure.

### SDL_DestroySemaphore

*void SDL_DestroySemaphore(SDL_sem * sem)*

  Destroy a semaphore.

### SDL_SemWait

*int SDL_SemWait(SDL_sem * sem)*

  This function suspends the calling thread until the semaphore pointed  to by **c**  has a positive count. It then atomically decreases the  semaphore count.

### SDL_SemTryWait

*int SDL_SemTryWait(SDL_sem * sem)*

  Non-blocking variant of SDL_SemWait().



**return** 0 if the wait succeeds, ::SDL_MUTEX_TIMEDOUT if the wait would          block, and -1 on error.

### SDL_SemWaitTimeout

*int SDL_SemWaitTimeout(SDL_sem * sem, Uint32 ms)*

  Variant of SDL_SemWait() with a timeout in milliseconds.



**return** 0 if the wait succeeds, ::SDL_MUTEX_TIMEDOUT if the wait does not          succeed in the allotted time, and -1 on error.



**warning** On some platforms this function is implemented by looping with a           delay of 1 ms, and so should be avoided if possible.

### SDL_SemPost

*int SDL_SemPost(SDL_sem * sem)*

  Atomically increases the semaphore's count (not blocking).



**return** 0, or -1 on error.

### SDL_SemValue

*Uint32 SDL_SemValue(SDL_sem * sem)*

  Returns the current count of the semaphore.

### SDL_CreateCond

*SDL_cond * SDL_CreateCond()*

  Create a condition variable.

  Typical use of condition variables:

  Thread A:    SDL_LockMutex(lock);    while ( ! condition ) {        SDL_CondWait(cond, lock);    }    SDL_UnlockMutex(lock);

  Thread B:    SDL_LockMutex(lock);    ...    condition = true;    ...    SDL_CondSignal(cond);    SDL_UnlockMutex(lock);

  There is some discussion whether to signal the condition variable  with the mutex locked or not.  There is some potential performance  benefit to unlocking first on some platforms, but there are some  potential race conditions depending on how your code is structured.

  In general it's safer to signal the condition variable while the  mutex is locked.

### SDL_DestroyCond

*void SDL_DestroyCond(SDL_cond * cond)*

  Destroy a condition variable.

### SDL_CondSignal

*int SDL_CondSignal(SDL_cond * cond)*

  Restart one of the threads that are waiting on the condition variable.



**return** 0 or -1 on error.

### SDL_CondBroadcast

*int SDL_CondBroadcast(SDL_cond * cond)*

  Restart all threads that are waiting on the condition variable.



**return** 0 or -1 on error.

### SDL_CondWait

*int SDL_CondWait(SDL_cond * cond, SDL_mutex * mutex)*

  Wait on the condition variable, unlocking the provided mutex.



**warning** The mutex must be locked before entering this function!

  The mutex is re-locked once the condition variable is signaled.



**return** 0 when it is signaled, or -1 on error.

### SDL_CondWaitTimeout

*int SDL_CondWaitTimeout(SDL_cond * cond, SDL_mutex * mutex, Uint32 ms)*

  Waits for at most **c**  milliseconds, and returns 0 if the condition  variable is signaled, ::SDL_MUTEX_TIMEDOUT if the condition is not  signaled in the allotted time, and -1 on error.



**warning** On some platforms this function is implemented by looping with a           delay of 1 ms, and so should be avoided if possible.

### SDL_CreateThread

*SDL_Thread * SDL_CreateThread(SDL_ThreadFunction fn, const char * name, void * data)*

  Create a thread with a default stack size.

  This is equivalent to calling:  SDL_CreateThreadWithStackSize(fn, name, 0, data);

### SDL_CreateThreadWithStackSize

*SDL_Thread * SDL_CreateThreadWithStackSize(SDL_ThreadFunction fn, const char * name, const size_t stacksize, void * data)*

  Create a thread.

   Thread naming is a little complicated: Most systems have very small    limits for the string length (Haiku has 32 bytes, Linux currently has 16,    Visual C++ 6.0 has nine!), and possibly other arbitrary rules. You'll    have to see what happens with your system's debugger. The name should be    UTF-8 (but using the naming limits of C identifiers is a better bet).   There are no requirements for thread naming conventions, so long as the    string is null-terminated UTF-8, but these guidelines are helpful in    choosing a name:

    http://stackoverflow.com/questions/149932/naming-conventions-for-threads

   If a system imposes requirements, SDL will try to munge the string for    it (truncate, etc), but the original string contents will be available    from SDL_GetThreadName().

   The size (in bytes) of the new stack can be specified. Zero means "use    the system default" which might be wildly different between platforms    (x86 Linux generally defaults to eight megabytes, an embedded device    might be a few kilobytes instead).

   In SDL 2.1, stacksize will be folded into the original SDL_CreateThread    function.

### SDL_GetThreadName

*const char * SDL_GetThreadName(SDL_Thread * thread)*

 Get the thread name, as it was specified in SDL_CreateThread().  This function returns a pointer to a UTF-8 string that names the  specified thread, or NULL if it doesn't have a name. This is internal  memory, not to be free()'d by the caller, and remains valid until the  specified thread is cleaned up by SDL_WaitThread().

### SDL_ThreadID

*SDL_threadID SDL_ThreadID()*

  Get the thread identifier for the current thread.

### SDL_GetThreadID

*SDL_threadID SDL_GetThreadID(SDL_Thread * thread)*

  Get the thread identifier for the specified thread.

  Equivalent to SDL_ThreadID() if the specified thread is NULL.

### SDL_SetThreadPriority

*int SDL_SetThreadPriority(SDL_ThreadPriority priority)*

  Set the priority for the current thread

### SDL_WaitThread

*void SDL_WaitThread(SDL_Thread * thread, int * status)*

  Wait for a thread to finish. Threads that haven't been detached will  remain (as a "zombie") until this function cleans them up. Not doing so  is a resource leak.

  Once a thread has been cleaned up through this function, the SDL_Thread  that references it becomes invalid and should not be referenced again.  As such, only one thread may call SDL_WaitThread() on another.

  The return code for the thread function is placed in the area  pointed to by **c**  if **c**  is not NULL.

  You may not wait on a thread that has been used in a call to  SDL_DetachThread(). Use either that function or this one, but not  both, or behavior is undefined.

  It is safe to pass NULL to this function; it is a no-op.

### SDL_DetachThread

*void SDL_DetachThread(SDL_Thread * thread)*

  A thread may be "detached" to signify that it should not remain until  another thread has called SDL_WaitThread() on it. Detaching a thread  is useful for long-running threads that nothing needs to synchronize  with or further manage. When a detached thread is done, it simply  goes away.

  There is no way to recover the return code of a detached thread. If you  need this, don't detach the thread and instead use SDL_WaitThread().

  Once a thread is detached, you should usually assume the SDL_Thread isn't  safe to reference again, as it will become invalid immediately upon  the detached thread's exit, instead of remaining until someone has called  SDL_WaitThread() to finally clean it up. As such, don't detach the same  thread more than once.

  If a thread has already exited when passed to SDL_DetachThread(), it will  stop waiting for a call to SDL_WaitThread() and clean up immediately.  It is not safe to detach a thread that might be used with SDL_WaitThread().

  You may not call SDL_WaitThread() on a thread that has been detached.  Use either that function or this one, but not both, or behavior is  undefined.

  It is safe to pass NULL to this function; it is a no-op.

### SDL_TLSCreate

*SDL_TLSID SDL_TLSCreate()*



**brief** Create an identifier that is globally visible to all threads but refers to data that is thread-specific.



**return** The newly created thread local storage identifier, or 0 on error



  static SDL_SpinLock tls_lock;

  static SDL_TLSID thread_local_storage;



  void SetMyThreadData(void *value)

  {

      if (!thread_local_storage) {

          SDL_AtomicLock(&tls_lock);

          if (!thread_local_storage) {

              thread_local_storage = SDL_TLSCreate();

          }

          SDL_AtomicUnlock(&tls_lock);

      }

      SDL_TLSSet(thread_local_storage, value, 0);

  }



  void *GetMyThreadData(void)

  {

      return SDL_TLSGet(thread_local_storage);

  }



**sa** SDL_TLSGet()

**sa** SDL_TLSSet()

### SDL_TLSGet

*void * SDL_TLSGet(SDL_TLSID id)*



**brief** Get the value associated with a thread local storage ID for the current thread.



**id**



**return** The value associated with the ID for the current thread, or NULL if no value has been set.



**sa** SDL_TLSCreate()

**sa** SDL_TLSSet()

### SDL_TLSSet

*int SDL_TLSSet(SDL_TLSID id, const void * value, void (*)(void *) destructor)*



**brief** Set the value associated with a thread local storage ID for the current thread.



**id**

**value**

**destructor**



**return** 0 on success, -1 on error



**sa** SDL_TLSCreate()

**sa** SDL_TLSGet()

### SDL_RWFromFile

*SDL_RWops * SDL_RWFromFile(const char * file, const char * mode)*



 RWFrom functions

  Functions to create SDL_RWops structures from various data streams.

@{ 

### SDL_RWFromFP

*SDL_RWops * SDL_RWFromFP(FILE * fp, SDL_bool autoclose)*

### SDL_RWFromMem

*SDL_RWops * SDL_RWFromMem(void * mem, int size)*

### SDL_RWFromConstMem

*SDL_RWops * SDL_RWFromConstMem(const void * mem, int size)*

### SDL_AllocRW

*SDL_RWops * SDL_AllocRW()*

### SDL_FreeRW

*void SDL_FreeRW(SDL_RWops * area)*

### SDL_RWsize

*Sint64 SDL_RWsize(SDL_RWops * context)*

  Return the size of the file in this rwops, or -1 if unknown

### SDL_RWseek

*Sint64 SDL_RWseek(SDL_RWops * context, Sint64 offset, int whence)*

  Seek to **c**  relative to **c**  one of stdio's whence values:  RW_SEEK_SET, RW_SEEK_CUR, RW_SEEK_END



**return** the final offset in the data stream, or -1 on error.

### SDL_RWtell

*Sint64 SDL_RWtell(SDL_RWops * context)*

  Return the current offset in the data stream, or -1 on error.

### SDL_RWread

*size_t SDL_RWread(SDL_RWops * context, void * ptr, size_t size, size_t maxnum)*

  Read up to **c**  objects each of size **c**  from the data  stream to the area pointed at by **c** 



**return** the number of objects read, or 0 at error or end of file.

### SDL_RWwrite

*size_t SDL_RWwrite(SDL_RWops * context, const void * ptr, size_t size, size_t num)*

  Write exactly **c**  objects each of size **c**  from the area  pointed at by **c**  to data stream.



**return** the number of objects written, or 0 at error or end of file.

### SDL_RWclose

*int SDL_RWclose(SDL_RWops * context)*

  Close and free an allocated SDL_RWops structure.



**return** 0 if successful or -1 on write error when flushing data.

### SDL_LoadFile_RW

*void * SDL_LoadFile_RW(SDL_RWops * src, size_t * datasize, int freesrc)*

  Load all the data from an SDL data stream.

  The data is allocated with a zero byte at the end (null terminated)

  If **c**  is not NULL, it is filled with the size of the data read.

  If **c**  is non-zero, the stream will be closed after being read.

  The data should be freed with SDL_free().



**return** the data, or NULL if there was an error.

### SDL_LoadFile

*void * SDL_LoadFile(const char * file, size_t * datasize)*

  Load an entire file.

  The data is allocated with a zero byte at the end (null terminated)

  If **c**  is not NULL, it is filled with the size of the data read.

  If **c**  is non-zero, the stream will be closed after being read.

  The data should be freed with SDL_free().



**return** the data, or NULL if there was an error.

### SDL_ReadU8

*Uint8 SDL_ReadU8(SDL_RWops * src)*



 Read endian functions

  Read an item of the specified endianness and return in native format.

@{ 

### SDL_ReadLE16

*Uint16 SDL_ReadLE16(SDL_RWops * src)*

### SDL_ReadBE16

*Uint16 SDL_ReadBE16(SDL_RWops * src)*

### SDL_ReadLE32

*Uint32 SDL_ReadLE32(SDL_RWops * src)*

### SDL_ReadBE32

*Uint32 SDL_ReadBE32(SDL_RWops * src)*

### SDL_ReadLE64

*Uint64 SDL_ReadLE64(SDL_RWops * src)*

### SDL_ReadBE64

*Uint64 SDL_ReadBE64(SDL_RWops * src)*

### SDL_WriteU8

*size_t SDL_WriteU8(SDL_RWops * dst, Uint8 value)*



 Write endian functions

  Write an item of native format to the specified endianness.

@{ 

### SDL_WriteLE16

*size_t SDL_WriteLE16(SDL_RWops * dst, Uint16 value)*

### SDL_WriteBE16

*size_t SDL_WriteBE16(SDL_RWops * dst, Uint16 value)*

### SDL_WriteLE32

*size_t SDL_WriteLE32(SDL_RWops * dst, Uint32 value)*

### SDL_WriteBE32

*size_t SDL_WriteBE32(SDL_RWops * dst, Uint32 value)*

### SDL_WriteLE64

*size_t SDL_WriteLE64(SDL_RWops * dst, Uint64 value)*

### SDL_WriteBE64

*size_t SDL_WriteBE64(SDL_RWops * dst, Uint64 value)*

### SDL_GetNumAudioDrivers

*int SDL_GetNumAudioDrivers()*



 Driver discovery functions

  These functions return the list of built in audio drivers, in the  order that they are normally initialized by default.

@{ 

### SDL_GetAudioDriver

*const char * SDL_GetAudioDriver(int index)*

### SDL_AudioInit

*int SDL_AudioInit(const char * driver_name)*



 Initialization and cleanup

**<not a builtin command>**  These functions are used internally, and should not be used unless            you have a specific need to specify the audio driver you want to            use.  You should normally use SDL_Init() or SDL_InitSubSystem().

@{ 

### SDL_AudioQuit

*void SDL_AudioQuit()*

### SDL_GetCurrentAudioDriver

*const char * SDL_GetCurrentAudioDriver()*

  This function returns the name of the current audio driver, or NULL  if no driver has been initialized.

### SDL_OpenAudio

*int SDL_OpenAudio(SDL_AudioSpec * desired, SDL_AudioSpec * obtained)*

  This function opens the audio device with the desired parameters, and  returns 0 if successful, placing the actual hardware parameters in the  structure pointed to by **c**   If **c**  is NULL, the audio  data passed to the callback function will be guaranteed to be in the  requested format, and will be automatically converted to the hardware  audio format if necessary.  This function returns -1 if it failed  to open the audio device, or couldn't set up the audio thread.

  When filling in the desired audio spec structure,    - **c**  should be the desired audio frequency in samples-per-      second.    - **c**  should be the desired audio format.    - **c**  is the desired size of the audio buffer, in      samples.  This number should be a power of two, and may be adjusted by      the audio driver to a value more suitable for the hardware.  Good values      seem to range between 512 and 8096 inclusive, depending on the      application and CPU speed.  Smaller values yield faster response time,      but can lead to underflow if the application is doing heavy processing      and cannot fill the audio buffer in time.  A stereo sample consists of      both right and left channels in LR ordering.      Note that the number of samples is directly related to time by the      following formula:  

 ms = (samples*1000)/freq 

    - **c**  is the size in bytes of the audio buffer, and is      calculated by SDL_OpenAudio().    - **c**  is the value used to set the buffer to silence,      and is calculated by SDL_OpenAudio().    - **c**  should be set to a function that will be called      when the audio device is ready for more data.  It is passed a pointer      to the audio buffer, and the length in bytes of the audio buffer.      This function usually runs in a separate thread, and so you should      protect data structures that it accesses by calling SDL_LockAudio()      and SDL_UnlockAudio() in your code. Alternately, you may pass a NULL      pointer here, and call SDL_QueueAudio() with some frequency, to queue      more audio samples to be played (or for capture devices, call      SDL_DequeueAudio() with some frequency, to obtain audio samples).    - **c**  is passed as the first parameter to your callback      function. If you passed a NULL callback, this value is ignored.

  The audio device starts out playing silence when it's opened, and should  be enabled for playing by calling **c**  when you are ready  for your audio callback function to be called.  Since the audio driver  may modify the requested size of the audio buffer, you should allocate  any local mixing buffers after you open the audio device.

### SDL_GetNumAudioDevices

*int SDL_GetNumAudioDevices(int iscapture)*

  Get the number of available devices exposed by the current driver.  Only valid after a successfully initializing the audio subsystem.  Returns -1 if an explicit list of devices can't be determined; this is  not an error. For example, if SDL is set up to talk to a remote audio  server, it can't list every one available on the Internet, but it will  still allow a specific host to be specified to SDL_OpenAudioDevice().

  In many common cases, when this function returns a value <= 0, it can still  successfully open the default device (NULL for first argument of  SDL_OpenAudioDevice()).

### SDL_GetAudioDeviceName

*const char * SDL_GetAudioDeviceName(int index, int iscapture)*

  Get the human-readable name of a specific audio device.  Must be a value between 0 and (number of audio devices-1).  Only valid after a successfully initializing the audio subsystem.  The values returned by this function reflect the latest call to  SDL_GetNumAudioDevices(); recall that function to redetect available  hardware.

  The string returned by this function is UTF-8 encoded, read-only, and  managed internally. You are not to free it. If you need to keep the  string for any length of time, you should make your own copy of it, as it  will be invalid next time any of several other SDL functions is called.

### SDL_OpenAudioDevice

*SDL_AudioDeviceID SDL_OpenAudioDevice(const char * device, int iscapture, const SDL_AudioSpec * desired, SDL_AudioSpec * obtained, int allowed_changes)*

  Open a specific audio device. Passing in a device name of NULL requests  the most reasonable default (and is equivalent to calling SDL_OpenAudio()).

  The device name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but  some drivers allow arbitrary and driver-specific strings, such as a  hostname/IP address for a remote audio server, or a filename in the  diskaudio driver.



**return** 0 on error, a valid device ID that is >= 2 on success.

  SDL_OpenAudio(), unlike this function, always acts on device ID 1.

### SDL_GetAudioStatus

*SDL_AudioStatus SDL_GetAudioStatus()*

### SDL_GetAudioDeviceStatus

*SDL_AudioStatus SDL_GetAudioDeviceStatus(SDL_AudioDeviceID dev)*

### SDL_PauseAudio

*void SDL_PauseAudio(int pause_on)*



 Pause audio functions

  These functions pause and unpause the audio callback processing.  They should be called with a parameter of 0 after opening the audio  device to start playing sound.  This is so you can safely initialize  data for your callback function after opening the audio device.  Silence will be written to the audio device during the pause.

@{ 

### SDL_PauseAudioDevice

*void SDL_PauseAudioDevice(SDL_AudioDeviceID dev, int pause_on)*

### SDL_LoadWAV_RW

*SDL_AudioSpec * SDL_LoadWAV_RW(SDL_RWops * src, int freesrc, SDL_AudioSpec * spec, Uint8 ** audio_buf, Uint32 * audio_len)*



**brief** Load the audio data of a WAVE file into memory

  Loading a WAVE file requires **c** **c** **c**  and **c**   to be valid pointers. The entire data portion of the file is then loaded  into memory and decoded if necessary.

  If **c**  is non-zero, the data source gets automatically closed and  freed before the function returns.

  Supported are RIFF WAVE files with the formats PCM (8, 16, 24, and 32 bits),  IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and A-law and  µ-law (8 bits). Other formats are currently unsupported and cause an error.

  If this function succeeds, the pointer returned by it is equal to **c**   and the pointer to the audio data allocated by the function is written to**c**  and its length in bytes to **c**  The 

 SDL_AudioSpec

  members **c** **c**  and **c**  are set to the values of the  audio data in the buffer. The **c**  member is set to a sane default and  all others are set to zero.

  It's necessary to use SDL_FreeWAV() to free the audio data returned in**c**  when it is no longer used.

  Because of the underspecification of the Waveform format, there are many  problematic files in the wild that cause issues with strict decoders. To  provide compatibility with these files, this decoder is lenient in regards  to the truncation of the file, the fact chunk, and the size of the RIFF  chunk. The hints SDL_HINT_WAVE_RIFF_CHUNK_SIZE, SDL_HINT_WAVE_TRUNCATION,  and SDL_HINT_WAVE_FACT_CHUNK can be used to tune the behavior of the  loading process.

  Any file that is invalid (due to truncation, corruption, or wrong values in  the headers), too big, or unsupported causes an error. Additionally, any  critical I/O error from the data source will terminate the loading process  with an error. The function returns NULL on error and in all cases (with the  exception of **c**  being NULL), an appropriate error message will be set.

  It is required that the data source supports seeking.

  Example:

      SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, ...);



**src**

**freesrc**

**spec**

**audio_buf**

**audio_len**

**return** NULL on error, or non-NULL on success.

### SDL_FreeWAV

*void SDL_FreeWAV(Uint8 * audio_buf)*

  This function frees data previously allocated with SDL_LoadWAV_RW()

### SDL_BuildAudioCVT

*int SDL_BuildAudioCVT(SDL_AudioCVT * cvt, SDL_AudioFormat src_format, Uint8 src_channels, int src_rate, SDL_AudioFormat dst_format, Uint8 dst_channels, int dst_rate)*

  This function takes a source format and rate and a destination format  and rate, and initializes the **c**  structure with information needed  by SDL_ConvertAudio() to convert a buffer of audio data from one format  to the other. An unsupported format causes an error and -1 will be returned.



**return** 0 if no conversion is needed, 1 if the audio filter is set up,  or -1 on error.

### SDL_ConvertAudio

*int SDL_ConvertAudio(SDL_AudioCVT * cvt)*

  Once you have initialized the **c**  structure using SDL_BuildAudioCVT(),  created an audio buffer **c**  and filled it with **c**  bytes of  audio data in the source format, this function will convert it in-place  to the desired format.

  The data conversion may expand the size of the audio data, so the buffer**c**  should be allocated after the **c**  structure is initialized by  SDL_BuildAudioCVT(), and should be **c**  bytes long.



**return** 0 on success or -1 if **c**  is NULL.

### SDL_NewAudioStream

*SDL_AudioStream * SDL_NewAudioStream(const SDL_AudioFormat src_format, const Uint8 src_channels, const int src_rate, const SDL_AudioFormat dst_format, const Uint8 dst_channels, const int dst_rate)*

  Create a new audio stream



**src_format**

**src_channels**

**src_rate**

**dst_format**

**dst_channels**

**dst_rate**

**return** 0 on success, or -1 on error.



**sa** SDL_AudioStreamPut

**sa** SDL_AudioStreamGet

**sa** SDL_AudioStreamAvailable

**sa** SDL_AudioStreamFlush

**sa** SDL_AudioStreamClear

**sa** SDL_FreeAudioStream

### SDL_AudioStreamPut

*int SDL_AudioStreamPut(SDL_AudioStream * stream, const void * buf, int len)*

  Add data to be converted/resampled to the stream



**stream**

**buf**

**len**

**return** 0 on success, or -1 on error.



**sa** SDL_NewAudioStream

**sa** SDL_AudioStreamGet

**sa** SDL_AudioStreamAvailable

**sa** SDL_AudioStreamFlush

**sa** SDL_AudioStreamClear

**sa** SDL_FreeAudioStream

### SDL_AudioStreamGet

*int SDL_AudioStreamGet(SDL_AudioStream * stream, void * buf, int len)*

  Get converted/resampled data from the stream



**stream**

**buf**

**len**

**return** The number of bytes read from the stream, or -1 on error



**sa** SDL_NewAudioStream

**sa** SDL_AudioStreamPut

**sa** SDL_AudioStreamAvailable

**sa** SDL_AudioStreamFlush

**sa** SDL_AudioStreamClear

**sa** SDL_FreeAudioStream

### SDL_AudioStreamAvailable

*int SDL_AudioStreamAvailable(SDL_AudioStream * stream)*

 Get the number of converted/resampled bytes available. The stream may be  buffering data behind the scenes until it has enough to resample  correctly, so this number might be lower than what you expect, or even  be zero. Add more data or flush the stream if you need the data now.



**sa** SDL_NewAudioStream

**sa** SDL_AudioStreamPut

**sa** SDL_AudioStreamGet

**sa** SDL_AudioStreamFlush

**sa** SDL_AudioStreamClear

**sa** SDL_FreeAudioStream

### SDL_AudioStreamFlush

*int SDL_AudioStreamFlush(SDL_AudioStream * stream)*

 Tell the stream that you're done sending data, and anything being buffered  should be converted/resampled and made available immediately.

 It is legal to add more data to a stream after flushing, but there will  be audio gaps in the output. Generally this is intended to signal the  end of input, so the complete output becomes available.



**sa** SDL_NewAudioStream

**sa** SDL_AudioStreamPut

**sa** SDL_AudioStreamGet

**sa** SDL_AudioStreamAvailable

**sa** SDL_AudioStreamClear

**sa** SDL_FreeAudioStream

### SDL_AudioStreamClear

*void SDL_AudioStreamClear(SDL_AudioStream * stream)*

  Clear any pending data in the stream without converting it



**sa** SDL_NewAudioStream

**sa** SDL_AudioStreamPut

**sa** SDL_AudioStreamGet

**sa** SDL_AudioStreamAvailable

**sa** SDL_AudioStreamFlush

**sa** SDL_FreeAudioStream

### SDL_FreeAudioStream

*void SDL_FreeAudioStream(SDL_AudioStream * stream)*

 Free an audio stream



**sa** SDL_NewAudioStream

**sa** SDL_AudioStreamPut

**sa** SDL_AudioStreamGet

**sa** SDL_AudioStreamAvailable

**sa** SDL_AudioStreamFlush

**sa** SDL_AudioStreamClear

### SDL_MixAudio

*void SDL_MixAudio(Uint8 * dst, const Uint8 * src, Uint32 len, int volume)*

  This takes two audio buffers of the playing audio format and mixes  them, performing addition, volume adjustment, and overflow clipping.  The volume ranges from 0 - 128, and should be set to ::SDL_MIX_MAXVOLUME  for full audio volume.  Note this does not change hardware volume.  This is provided for convenience -- you can mix your own audio data.

### SDL_MixAudioFormat

*void SDL_MixAudioFormat(Uint8 * dst, const Uint8 * src, SDL_AudioFormat format, Uint32 len, int volume)*

  This works like SDL_MixAudio(), but you specify the audio format instead of  using the format of audio device 1. Thus it can be used when no audio  device is open at all.

### SDL_QueueAudio

*int SDL_QueueAudio(SDL_AudioDeviceID dev, const void * data, Uint32 len)*

  Queue more audio on non-callback devices.

  (If you are looking to retrieve queued audio from a non-callback capture  device, you want SDL_DequeueAudio() instead. This will return -1 to  signify an error if you use it with capture devices.)

  SDL offers two ways to feed audio to the device: you can either supply a  callback that SDL triggers with some frequency to obtain more audio  (pull method), or you can supply no callback, and then SDL will expect  you to supply data at regular intervals (push method) with this function.

  There are no limits on the amount of data you can queue, short of  exhaustion of address space. Queued data will drain to the device as  necessary without further intervention from you. If the device needs  audio but there is not enough queued, it will play silence to make up  the difference. This means you will have skips in your audio playback  if you aren't routinely queueing sufficient data.

  This function copies the supplied data, so you are safe to free it when  the function returns. This function is thread-safe, but queueing to the  same device from two threads at once does not promise which buffer will  be queued first.

  You may not queue audio on a device that is using an application-supplied  callback; doing so returns an error. You have to use the audio callback  or queue audio with this function, but not both.

  You should not call SDL_LockAudio() on the device before queueing; SDL  handles locking internally for this function.



**dev**

**data**

**len**

**return** 0 on success, or -1 on error.



**sa** SDL_GetQueuedAudioSize

**sa** SDL_ClearQueuedAudio

### SDL_DequeueAudio

*Uint32 SDL_DequeueAudio(SDL_AudioDeviceID dev, void * data, Uint32 len)*

  Dequeue more audio on non-callback devices.

  (If you are looking to queue audio for output on a non-callback playback  device, you want SDL_QueueAudio() instead. This will always return 0  if you use it with playback devices.)

  SDL offers two ways to retrieve audio from a capture device: you can  either supply a callback that SDL triggers with some frequency as the  device records more audio data, (push method), or you can supply no  callback, and then SDL will expect you to retrieve data at regular  intervals (pull method) with this function.

  There are no limits on the amount of data you can queue, short of  exhaustion of address space. Data from the device will keep queuing as  necessary without further intervention from you. This means you will  eventually run out of memory if you aren't routinely dequeueing data.

  Capture devices will not queue data when paused; if you are expecting  to not need captured audio for some length of time, use  SDL_PauseAudioDevice() to stop the capture device from queueing more  data. This can be useful during, say, level loading times. When  unpaused, capture devices will start queueing data from that point,  having flushed any capturable data available while paused.

  This function is thread-safe, but dequeueing from the same device from  two threads at once does not promise which thread will dequeued data  first.

  You may not dequeue audio from a device that is using an  application-supplied callback; doing so returns an error. You have to use  the audio callback, or dequeue audio with this function, but not both.

  You should not call SDL_LockAudio() on the device before queueing; SDL  handles locking internally for this function.



**dev**

**data**

**len**

**return** number of bytes dequeued, which could be less than requested.



**sa** SDL_GetQueuedAudioSize

**sa** SDL_ClearQueuedAudio

### SDL_GetQueuedAudioSize

*Uint32 SDL_GetQueuedAudioSize(SDL_AudioDeviceID dev)*

  Get the number of bytes of still-queued audio.

  For playback device:

    This is the number of bytes that have been queued for playback with    SDL_QueueAudio(), but have not yet been sent to the hardware. This    number may shrink at any time, so this only informs of pending data.

    Once we've sent it to the hardware, this function can not decide the    exact byte boundary of what has been played. It's possible that we just    gave the hardware several kilobytes right before you called this    function, but it hasn't played any of it yet, or maybe half of it, etc.

  For capture devices:

    This is the number of bytes that have been captured by the device and    are waiting for you to dequeue. This number may grow at any time, so    this only informs of the lower-bound of available data.

  You may not queue audio on a device that is using an application-supplied  callback; calling this function on such a device always returns 0.  You have to queue audio with SDL_QueueAudio()/SDL_DequeueAudio(), or use  the audio callback, but not both.

  You should not call SDL_LockAudio() on the device before querying; SDL  handles locking internally for this function.



**dev**

**return** Number of bytes (not samples!) of queued audio.



**sa** SDL_QueueAudio

**sa** SDL_ClearQueuedAudio

### SDL_ClearQueuedAudio

*void SDL_ClearQueuedAudio(SDL_AudioDeviceID dev)*

  Drop any queued audio data. For playback devices, this is any queued data  still waiting to be submitted to the hardware. For capture devices, this  is any data that was queued by the device that hasn't yet been dequeued by  the application.

  Immediately after this call, SDL_GetQueuedAudioSize() will return 0. For  playback devices, the hardware will start playing silence if more audio  isn't queued. Unpaused capture devices will start filling the queue again  as soon as they have more data available (which, depending on the state  of the hardware and the thread, could be before this function call  returns!).

  This will not prevent playback of queued audio that's already been sent  to the hardware, as we can not undo that, so expect there to be some  fraction of a second of audio that might still be heard. This can be  useful if you want to, say, drop any pending music during a level change  in your game.

  You may not queue audio on a device that is using an application-supplied  callback; calling this function on such a device is always a no-op.  You have to queue audio with SDL_QueueAudio()/SDL_DequeueAudio(), or use  the audio callback, but not both.

  You should not call SDL_LockAudio() on the device before clearing the  queue; SDL handles locking internally for this function.

  This function always succeeds and thus returns void.



**dev**



**sa** SDL_QueueAudio

**sa** SDL_GetQueuedAudioSize

### SDL_LockAudio

*void SDL_LockAudio()*



 Audio lock functions

  The lock manipulated by these functions protects the callback function.  During a SDL_LockAudio()/SDL_UnlockAudio() pair, you can be guaranteed that  the callback function is not running.  Do not call these from the callback  function or you will cause deadlock.

@{ 

### SDL_LockAudioDevice

*void SDL_LockAudioDevice(SDL_AudioDeviceID dev)*

### SDL_UnlockAudio

*void SDL_UnlockAudio()*

### SDL_UnlockAudioDevice

*void SDL_UnlockAudioDevice(SDL_AudioDeviceID dev)*

### SDL_CloseAudio

*void SDL_CloseAudio()*

  This function shuts down audio processing and closes the audio device.

### SDL_CloseAudioDevice

*void SDL_CloseAudioDevice(SDL_AudioDeviceID dev)*

### SDL_SetClipboardText

*int SDL_SetClipboardText(const char * text)*



**brief** Put UTF-8 text into the clipboard



**sa** SDL_GetClipboardText()

### SDL_GetClipboardText

*char * SDL_GetClipboardText()*



**brief** Get UTF-8 text from the clipboard, which must be freed with SDL_free()



**sa** SDL_SetClipboardText()

### SDL_HasClipboardText

*SDL_bool SDL_HasClipboardText()*



**brief** Returns a flag indicating whether the clipboard exists and contains a text string that is non-empty



**sa** SDL_GetClipboardText()

### SDL_GetCPUCount

*int SDL_GetCPUCount()*

  This function returns the number of CPU cores available.

### SDL_GetCPUCacheLineSize

*int SDL_GetCPUCacheLineSize()*

  This function returns the L1 cache line size of the CPU

  This is useful for determining multi-threaded structure padding  or SIMD prefetch sizes.

### SDL_HasRDTSC

*SDL_bool SDL_HasRDTSC()*

  This function returns true if the CPU has the RDTSC instruction.

### SDL_HasAltiVec

*SDL_bool SDL_HasAltiVec()*

  This function returns true if the CPU has AltiVec features.

### SDL_HasMMX

*SDL_bool SDL_HasMMX()*

  This function returns true if the CPU has MMX features.

### SDL_Has3DNow

*SDL_bool SDL_Has3DNow()*

  This function returns true if the CPU has 3DNow! features.

### SDL_HasSSE

*SDL_bool SDL_HasSSE()*

  This function returns true if the CPU has SSE features.

### SDL_HasSSE2

*SDL_bool SDL_HasSSE2()*

  This function returns true if the CPU has SSE2 features.

### SDL_HasSSE3

*SDL_bool SDL_HasSSE3()*

  This function returns true if the CPU has SSE3 features.

### SDL_HasSSE41

*SDL_bool SDL_HasSSE41()*

  This function returns true if the CPU has SSE4.1 features.

### SDL_HasSSE42

*SDL_bool SDL_HasSSE42()*

  This function returns true if the CPU has SSE4.2 features.

### SDL_HasAVX

*SDL_bool SDL_HasAVX()*

  This function returns true if the CPU has AVX features.

### SDL_HasAVX2

*SDL_bool SDL_HasAVX2()*

  This function returns true if the CPU has AVX2 features.

### SDL_HasAVX512F

*SDL_bool SDL_HasAVX512F()*

  This function returns true if the CPU has AVX-512F (foundation) features.

### SDL_HasARMSIMD

*SDL_bool SDL_HasARMSIMD()*

  This function returns true if the CPU has ARM SIMD (ARMv6) features.

### SDL_HasNEON

*SDL_bool SDL_HasNEON()*

  This function returns true if the CPU has NEON (ARM SIMD) features.

### SDL_GetSystemRAM

*int SDL_GetSystemRAM()*

  This function returns the amount of RAM configured in the system, in MB.

### SDL_SIMDGetAlignment

*size_t SDL_SIMDGetAlignment()*



**brief** Report the alignment this system needs for SIMD allocations.

 This will return the minimum number of bytes to which a pointer must be  aligned to be compatible with SIMD instructions on the current machine.  For example, if the machine supports SSE only, it will return 16, but if  it supports AVX-512F, it'll return 64 (etc). This only reports values for  instruction sets SDL knows about, so if your SDL build doesn't have  SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and  not 64 for the AVX-512 instructions that exist but SDL doesn't know about.  Plan accordingly.

### SDL_SIMDAlloc

*void * SDL_SIMDAlloc(const size_t len)*



**brief** Allocate memory in a SIMD-friendly way.

 This will allocate a block of memory that is suitable for use with SIMD  instructions. Specifically, it will be properly aligned and padded for  the system's supported vector instructions.

 The memory returned will be padded such that it is safe to read or write  an incomplete vector at the end of the memory block. This can be useful  so you don't have to drop back to a scalar fallback at the end of your  SIMD processing loop to deal with the final elements without overflowing  the allocated buffer.

 You must free this memory with SDL_FreeSIMD(), not free() or SDL_free()  or delete[], etc.

 Note that SDL will only deal with SIMD instruction sets it is aware of;  for example, SDL 2.0.8 knows that SSE wants 16-byte vectors  (SDL_HasSSE()), and AVX2 wants 32 bytes (SDL_HasAVX2()), but doesn't  know that AVX-512 wants 64. To be clear: if you can't decide to use an  instruction set with an SDL_Has*() function, don't use that instruction  set with memory allocated through here.

 SDL_AllocSIMD(0) will return a non-NULL pointer, assuming the system isn't  out of memory.



**len**

**return** Pointer to newly-allocated block, NULL if out of memory.



**sa** SDL_SIMDAlignment

**sa** SDL_SIMDFree

### SDL_SIMDFree

*void SDL_SIMDFree(void * ptr)*



**brief** Deallocate memory obtained from SDL_SIMDAlloc

 It is not valid to use this function on a pointer from anything but  SDL_SIMDAlloc(). It can't be used on pointers from malloc, realloc,  SDL_malloc, memalign, new[], etc.

 However, SDL_SIMDFree(NULL) is a legal no-op.



**sa** SDL_SIMDAlloc

### SDL_GetPixelFormatName

*const char * SDL_GetPixelFormatName(Uint32 format)*



**brief** Get the human readable name of a pixel format

### SDL_PixelFormatEnumToMasks

*SDL_bool SDL_PixelFormatEnumToMasks(Uint32 format, int * bpp, Uint32 * Rmask, Uint32 * Gmask, Uint32 * Bmask, Uint32 * Amask)*



**brief** Convert one of the enumerated pixel formats to a bpp and RGBA masks.



**return** SDL_TRUE, or SDL_FALSE if the conversion wasn't possible.



**sa** SDL_MasksToPixelFormatEnum()

### SDL_MasksToPixelFormatEnum

*Uint32 SDL_MasksToPixelFormatEnum(int bpp, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)*



**brief** Convert a bpp and RGBA masks to an enumerated pixel format.



**return** The pixel format, or ::SDL_PIXELFORMAT_UNKNOWN if the conversion          wasn't possible.



**sa** SDL_PixelFormatEnumToMasks()

### SDL_AllocFormat

*SDL_PixelFormat * SDL_AllocFormat(Uint32 pixel_format)*



**brief** Create an SDL_PixelFormat structure from a pixel format enum.

### SDL_FreeFormat

*void SDL_FreeFormat(SDL_PixelFormat * format)*



**brief** Free an SDL_PixelFormat structure.

### SDL_AllocPalette

*SDL_Palette * SDL_AllocPalette(int ncolors)*



**brief** Create a palette structure with the specified number of color         entries.



**return** A new palette, or NULL if there wasn't enough memory.



**note** The palette entries are initialized to white.



**sa** SDL_FreePalette()

### SDL_SetPixelFormatPalette

*int SDL_SetPixelFormatPalette(SDL_PixelFormat * format, SDL_Palette * palette)*



**brief** Set the palette for a pixel format structure.

### SDL_SetPaletteColors

*int SDL_SetPaletteColors(SDL_Palette * palette, const SDL_Color * colors, int firstcolor, int ncolors)*



**brief** Set a range of colors in a palette.



**palette**

**colors**

**firstcolor**

**ncolors**



**return** 0 on success, or -1 if not all of the colors could be set.

### SDL_FreePalette

*void SDL_FreePalette(SDL_Palette * palette)*



**brief** Free a palette created with SDL_AllocPalette().



**sa** SDL_AllocPalette()

### SDL_MapRGB

*Uint32 SDL_MapRGB(const SDL_PixelFormat * format, Uint8 r, Uint8 g, Uint8 b)*



**brief** Maps an RGB triple to an opaque pixel value for a given pixel format.



**sa** SDL_MapRGBA

### SDL_MapRGBA

*Uint32 SDL_MapRGBA(const SDL_PixelFormat * format, Uint8 r, Uint8 g, Uint8 b, Uint8 a)*



**brief** Maps an RGBA quadruple to a pixel value for a given pixel format.



**sa** SDL_MapRGB

### SDL_GetRGB

*void SDL_GetRGB(Uint32 pixel, const SDL_PixelFormat * format, Uint8 * r, Uint8 * g, Uint8 * b)*



**brief** Get the RGB components from a pixel of the specified format.



**sa** SDL_GetRGBA

### SDL_GetRGBA

*void SDL_GetRGBA(Uint32 pixel, const SDL_PixelFormat * format, Uint8 * r, Uint8 * g, Uint8 * b, Uint8 * a)*



**brief** Get the RGBA components from a pixel of the specified format.



**sa** SDL_GetRGB

### SDL_CalculateGammaRamp

*void SDL_CalculateGammaRamp(float gamma, Uint16 * ramp)*



**brief** Calculate a 256 entry gamma ramp for a gamma value.

### SDL_PointInRect

*SDL_bool SDL_PointInRect(const SDL_Point * p, const SDL_Rect * r)*

*Defined at line 99 of /usr/include/SDL2/SDL_rect.h*



**brief** Returns true if point resides inside a rectangle.

### SDL_RectEmpty

*SDL_bool SDL_RectEmpty(const SDL_Rect * r)*

*Defined at line 108 of /usr/include/SDL2/SDL_rect.h*



**brief** Returns true if the rectangle has no area.

### SDL_RectEquals

*SDL_bool SDL_RectEquals(const SDL_Rect * a, const SDL_Rect * b)*

*Defined at line 116 of /usr/include/SDL2/SDL_rect.h*



**brief** Returns true if the two rectangles are equal.

### SDL_HasIntersection

*SDL_bool SDL_HasIntersection(const SDL_Rect * A, const SDL_Rect * B)*



**brief** Determine whether two rectangles intersect.



**return** SDL_TRUE if there is an intersection, SDL_FALSE otherwise.

### SDL_IntersectRect

*SDL_bool SDL_IntersectRect(const SDL_Rect * A, const SDL_Rect * B, SDL_Rect * result)*



**brief** Calculate the intersection of two rectangles.



**return** SDL_TRUE if there is an intersection, SDL_FALSE otherwise.

### SDL_UnionRect

*void SDL_UnionRect(const SDL_Rect * A, const SDL_Rect * B, SDL_Rect * result)*



**brief** Calculate the union of two rectangles.

### SDL_EnclosePoints

*SDL_bool SDL_EnclosePoints(const SDL_Point * points, int count, const SDL_Rect * clip, SDL_Rect * result)*



**brief** Calculate a minimal rectangle enclosing a set of points



**return** SDL_TRUE if any points were within the clipping rect

### SDL_IntersectRectAndLine

*SDL_bool SDL_IntersectRectAndLine(const SDL_Rect * rect, int * X1, int * Y1, int * X2, int * Y2)*



**brief** Calculate the intersection of a rectangle and line segment.



**return** SDL_TRUE if there is an intersection, SDL_FALSE otherwise.

### SDL_ComposeCustomBlendMode

*SDL_BlendMode SDL_ComposeCustomBlendMode(SDL_BlendFactor srcColorFactor, SDL_BlendFactor dstColorFactor, SDL_BlendOperation colorOperation, SDL_BlendFactor srcAlphaFactor, SDL_BlendFactor dstAlphaFactor, SDL_BlendOperation alphaOperation)*



**brief** Create a custom blend mode, which may or may not be supported by a given renderer



**srcColorFactor**

**dstColorFactor**

**colorOperation**

**srcAlphaFactor**

**dstAlphaFactor**

**alphaOperation**

  The result of the blend mode operation will be:      dstRGB = dstRGB * dstColorFactor colorOperation srcRGB * srcColorFactor  and      dstA = dstA * dstAlphaFactor alphaOperation srcA * srcAlphaFactor

### SDL_CreateRGBSurface

*SDL_Surface * SDL_CreateRGBSurface(Uint32 flags, int width, int height, int depth, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)*

  Allocate and free an RGB surface.

  If the depth is 4 or 8 bits, an empty palette is allocated for the surface.  If the depth is greater than 8 bits, the pixel format is set using the  flags '[RGB]mask'.

  If the function runs out of memory, it will return NULL.



**flags**

**width**

**height**

**depth**

**Rmask**

**Gmask**

**Bmask**

**Amask**

### SDL_CreateRGBSurfaceWithFormat

*SDL_Surface * SDL_CreateRGBSurfaceWithFormat(Uint32 flags, int width, int height, int depth, Uint32 format)*

 !!! FIXME for 2.1: why does this ask for depth? Format provides that. 

### SDL_CreateRGBSurfaceFrom

*SDL_Surface * SDL_CreateRGBSurfaceFrom(void * pixels, int width, int height, int depth, int pitch, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)*

### SDL_CreateRGBSurfaceWithFormatFrom

*SDL_Surface * SDL_CreateRGBSurfaceWithFormatFrom(void * pixels, int width, int height, int depth, int pitch, Uint32 format)*

### SDL_FreeSurface

*void SDL_FreeSurface(SDL_Surface * surface)*

### SDL_SetSurfacePalette

*int SDL_SetSurfacePalette(SDL_Surface * surface, SDL_Palette * palette)*



**brief** Set the palette used by a surface.



**return** 0, or -1 if the surface format doesn't use a palette.



**note** A single palette can be shared with many surfaces.

### SDL_LockSurface

*int SDL_LockSurface(SDL_Surface * surface)*



**brief** Sets up a surface for directly accessing the pixels.

  Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write  to and read from **c**  using the pixel format stored in**c**   Once you are done accessing the surface, you should  use SDL_UnlockSurface() to release it.

  Not all surfaces require locking.  If SDL_MUSTLOCK(surface) evaluates  to 0, then you can read and write to the surface at any time, and the  pixel format of the surface will not change.

  No operating system or library calls should be made between lock/unlock  pairs, as critical system locks may be held during this time.

  SDL_LockSurface() returns 0, or -1 if the surface couldn't be locked.



**sa** SDL_UnlockSurface()

### SDL_UnlockSurface

*void SDL_UnlockSurface(SDL_Surface * surface)*



**sa** SDL_LockSurface() 

### SDL_LoadBMP_RW

*SDL_Surface * SDL_LoadBMP_RW(SDL_RWops * src, int freesrc)*

  Load a surface from a seekable SDL data stream (memory or file).

  If **c**  is non-zero, the stream will be closed after being read.

  The new surface should be freed with SDL_FreeSurface().



**return** the new surface, or NULL if there was an error.

### SDL_SaveBMP_RW

*int SDL_SaveBMP_RW(SDL_Surface * surface, SDL_RWops * dst, int freedst)*

  Save a surface to a seekable SDL data stream (memory or file).

  Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the  BMP directly. Other RGB formats with 8-bit or higher get converted to a  24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit  surface before they are saved. YUV and paletted 1-bit and 4-bit formats are  not supported.

  If **c**  is non-zero, the stream will be closed after being written.



**return** 0 if successful or -1 if there was an error.

### SDL_SetSurfaceRLE

*int SDL_SetSurfaceRLE(SDL_Surface * surface, int flag)*



**brief** Sets the RLE acceleration hint for a surface.



**return** 0 on success, or -1 if the surface is not valid



**note** If RLE is enabled, colorkey and alpha blending blits are much faster,        but the surface must be locked before directly accessing the pixels.

### SDL_SetColorKey

*int SDL_SetColorKey(SDL_Surface * surface, int flag, Uint32 key)*



**brief** Sets the color key (transparent pixel) in a blittable surface.



**surface**

**flag**

**key**



**return** 0 on success, or -1 if the surface is not valid

  You can pass SDL_RLEACCEL to enable RLE accelerated blits.

### SDL_HasColorKey

*SDL_bool SDL_HasColorKey(SDL_Surface * surface)*



**brief** Returns whether the surface has a color key



**return** SDL_TRUE if the surface has a color key, or SDL_FALSE if the surface is NULL or has no color key

### SDL_GetColorKey

*int SDL_GetColorKey(SDL_Surface * surface, Uint32 * key)*



**brief** Gets the color key (transparent pixel) in a blittable surface.



**surface**

**key**



**return** 0 on success, or -1 if the surface is not valid or colorkey is not          enabled.

### SDL_SetSurfaceColorMod

*int SDL_SetSurfaceColorMod(SDL_Surface * surface, Uint8 r, Uint8 g, Uint8 b)*



**brief** Set an additional color value used in blit operations.



**surface**

**r**

**g**

**b**



**return** 0 on success, or -1 if the surface is not valid.



**sa** SDL_GetSurfaceColorMod()

### SDL_GetSurfaceColorMod

*int SDL_GetSurfaceColorMod(SDL_Surface * surface, Uint8 * r, Uint8 * g, Uint8 * b)*



**brief** Get the additional color value used in blit operations.



**surface**

**r**

**g**

**b**



**return** 0 on success, or -1 if the surface is not valid.



**sa** SDL_SetSurfaceColorMod()

### SDL_SetSurfaceAlphaMod

*int SDL_SetSurfaceAlphaMod(SDL_Surface * surface, Uint8 alpha)*



**brief** Set an additional alpha value used in blit operations.



**surface**

**alpha**



**return** 0 on success, or -1 if the surface is not valid.



**sa** SDL_GetSurfaceAlphaMod()

### SDL_GetSurfaceAlphaMod

*int SDL_GetSurfaceAlphaMod(SDL_Surface * surface, Uint8 * alpha)*



**brief** Get the additional alpha value used in blit operations.



**surface**

**alpha**



**return** 0 on success, or -1 if the surface is not valid.



**sa** SDL_SetSurfaceAlphaMod()

### SDL_SetSurfaceBlendMode

*int SDL_SetSurfaceBlendMode(SDL_Surface * surface, SDL_BlendMode blendMode)*



**brief** Set the blend mode used for blit operations.



**surface**

**blendMode**



**return** 0 on success, or -1 if the parameters are not valid.



**sa** SDL_GetSurfaceBlendMode()

### SDL_GetSurfaceBlendMode

*int SDL_GetSurfaceBlendMode(SDL_Surface * surface, SDL_BlendMode * blendMode)*



**brief** Get the blend mode used for blit operations.



**surface**

**blendMode**



**return** 0 on success, or -1 if the surface is not valid.



**sa** SDL_SetSurfaceBlendMode()

### SDL_SetClipRect

*SDL_bool SDL_SetClipRect(SDL_Surface * surface, const SDL_Rect * rect)*

  Sets the clipping rectangle for the destination surface in a blit.

  If the clip rectangle is NULL, clipping will be disabled.

  If the clip rectangle doesn't intersect the surface, the function will  return SDL_FALSE and blits will be completely clipped.  Otherwise the  function returns SDL_TRUE and blits to the surface will be clipped to  the intersection of the surface area and the clipping rectangle.

  Note that blits are automatically clipped to the edges of the source  and destination surfaces.

### SDL_GetClipRect

*void SDL_GetClipRect(SDL_Surface * surface, SDL_Rect * rect)*

  Gets the clipping rectangle for the destination surface in a blit.

**c**  must be a pointer to a valid rectangle which will be filled  with the correct values.

### SDL_DuplicateSurface

*SDL_Surface * SDL_DuplicateSurface(SDL_Surface * surface)*

 Creates a new surface identical to the existing surface

### SDL_ConvertSurface

*SDL_Surface * SDL_ConvertSurface(SDL_Surface * src, const SDL_PixelFormat * fmt, Uint32 flags)*

  Creates a new surface of the specified format, and then copies and maps  the given surface to it so the blit of the converted surface will be as  fast as possible.  If this function fails, it returns NULL.

  The **c**  parameter is passed to SDL_CreateRGBSurface() and has those  semantics.  You can also pass ::SDL_RLEACCEL in the flags parameter and  SDL will try to RLE accelerate colorkey and alpha blits in the resulting  surface.

### SDL_ConvertSurfaceFormat

*SDL_Surface * SDL_ConvertSurfaceFormat(SDL_Surface * src, Uint32 pixel_format, Uint32 flags)*

### SDL_ConvertPixels

*int SDL_ConvertPixels(int width, int height, Uint32 src_format, const void * src, int src_pitch, Uint32 dst_format, void * dst, int dst_pitch)*



**brief** Copy a block of pixels of one format to another format



**return** 0 on success, or -1 if there was an error

### SDL_FillRect

*int SDL_FillRect(SDL_Surface * dst, const SDL_Rect * rect, Uint32 color)*

  Performs a fast fill of the given rectangle with **c** 

  If **c**  is NULL, the whole surface will be filled with **c** 

  The color should be a pixel of the format used by the surface, and  can be generated by the SDL_MapRGB() function.



**return** 0 on success, or -1 on error.

### SDL_FillRects

*int SDL_FillRects(SDL_Surface * dst, const SDL_Rect * rects, int count, Uint32 color)*

### SDL_UpperBlit

*int SDL_UpperBlit(SDL_Surface * src, const SDL_Rect * srcrect, SDL_Surface * dst, SDL_Rect * dstrect)*

  This is the public blit function, SDL_BlitSurface(), and it performs  rectangle validation and clipping before passing it to SDL_LowerBlit()

### SDL_LowerBlit

*int SDL_LowerBlit(SDL_Surface * src, SDL_Rect * srcrect, SDL_Surface * dst, SDL_Rect * dstrect)*

  This is a semi-private blit function and it performs low-level surface  blitting only.

### SDL_SoftStretch

*int SDL_SoftStretch(SDL_Surface * src, const SDL_Rect * srcrect, SDL_Surface * dst, const SDL_Rect * dstrect)*



**brief** Perform a fast, low quality, stretch blit between two surfaces of the         same pixel format.



**note** This function uses a static buffer, and is not thread-safe.

### SDL_UpperBlitScaled

*int SDL_UpperBlitScaled(SDL_Surface * src, const SDL_Rect * srcrect, SDL_Surface * dst, SDL_Rect * dstrect)*

  This is the public scaled blit function, SDL_BlitScaled(), and it performs  rectangle validation and clipping before passing it to SDL_LowerBlitScaled()

### SDL_LowerBlitScaled

*int SDL_LowerBlitScaled(SDL_Surface * src, SDL_Rect * srcrect, SDL_Surface * dst, SDL_Rect * dstrect)*

  This is a semi-private blit function and it performs low-level surface  scaled blitting only.

### SDL_SetYUVConversionMode

*void SDL_SetYUVConversionMode(SDL_YUV_CONVERSION_MODE mode)*



**brief** Set the YUV conversion mode

### SDL_GetYUVConversionMode

*SDL_YUV_CONVERSION_MODE SDL_GetYUVConversionMode()*



**brief** Get the YUV conversion mode

### SDL_GetYUVConversionModeForResolution

*SDL_YUV_CONVERSION_MODE SDL_GetYUVConversionModeForResolution(int width, int height)*



**brief** Get the YUV conversion mode, returning the correct mode for the resolution when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC

### SDL_GetNumVideoDrivers

*int SDL_GetNumVideoDrivers()*



**brief** Get the number of video drivers compiled into SDL



**sa** SDL_GetVideoDriver()

### SDL_GetVideoDriver

*const char * SDL_GetVideoDriver(int index)*



**brief** Get the name of a built in video driver.



**note** The video drivers are presented in the order in which they are        normally checked during initialization.



**sa** SDL_GetNumVideoDrivers()

### SDL_VideoInit

*int SDL_VideoInit(const char * driver_name)*



**brief** Initialize the video subsystem, optionally specifying a video driver.



**driver_name**



**return** 0 on success, -1 on error

  This function initializes the video subsystem; setting up a connection  to the window manager, etc, and determines the available display modes  and pixel formats, but does not initialize a window or graphics mode.



**sa** SDL_VideoQuit()

### SDL_VideoQuit

*void SDL_VideoQuit()*



**brief** Shuts down the video subsystem.

  This function closes all windows, and restores the original video mode.



**sa** SDL_VideoInit()

### SDL_GetCurrentVideoDriver

*const char * SDL_GetCurrentVideoDriver()*



**brief** Returns the name of the currently initialized video driver.



**return** The name of the current video driver or NULL if no driver          has been initialized



**sa** SDL_GetNumVideoDrivers()

**sa** SDL_GetVideoDriver()

### SDL_GetNumVideoDisplays

*int SDL_GetNumVideoDisplays()*



**brief** Returns the number of available video displays.



**sa** SDL_GetDisplayBounds()

### SDL_GetDisplayName

*const char * SDL_GetDisplayName(int displayIndex)*



**brief** Get the name of a display in UTF-8 encoding



**return** The name of a display, or NULL for an invalid display index.



**sa** SDL_GetNumVideoDisplays()

### SDL_GetDisplayBounds

*int SDL_GetDisplayBounds(int displayIndex, SDL_Rect * rect)*



**brief** Get the desktop area represented by a display, with the primary         display located at 0,0



**return** 0 on success, or -1 if the index is out of range.



**sa** SDL_GetNumVideoDisplays()

### SDL_GetDisplayUsableBounds

*int SDL_GetDisplayUsableBounds(int displayIndex, SDL_Rect * rect)*



**brief** Get the usable desktop area represented by a display, with the         primary display located at 0,0

  This is the same area as SDL_GetDisplayBounds() reports, but with portions  reserved by the system removed. For example, on Mac OS X, this subtracts  the area occupied by the menu bar and dock.

  Setting a window to be fullscreen generally bypasses these unusable areas,  so these are good guidelines for the maximum space available to a  non-fullscreen window.



**return** 0 on success, or -1 if the index is out of range.



**sa** SDL_GetDisplayBounds()

**sa** SDL_GetNumVideoDisplays()

### SDL_GetDisplayDPI

*int SDL_GetDisplayDPI(int displayIndex, float * ddpi, float * hdpi, float * vdpi)*



**brief** Get the dots/pixels-per-inch for a display



**note** Diagonal, horizontal and vertical DPI can all be optionally        returned if the parameter is non-NULL.



**return** 0 on success, or -1 if no DPI information is available or the index is out of range.



**sa** SDL_GetNumVideoDisplays()

### SDL_GetDisplayOrientation

*SDL_DisplayOrientation SDL_GetDisplayOrientation(int displayIndex)*



**brief** Get the orientation of a display



**return** The orientation of the display, or SDL_ORIENTATION_UNKNOWN if it isn't available.



**sa** SDL_GetNumVideoDisplays()

### SDL_GetNumDisplayModes

*int SDL_GetNumDisplayModes(int displayIndex)*



**brief** Returns the number of available display modes.



**sa** SDL_GetDisplayMode()

### SDL_GetDisplayMode

*int SDL_GetDisplayMode(int displayIndex, int modeIndex, SDL_DisplayMode * mode)*



**brief** Fill in information about a specific display mode.



**note** The display modes are sorted in this priority:

**li** bits per pixel -> more colors to fewer colors

**li** width -> largest to smallest

**li** height -> largest to smallest

**li** refresh rate -> highest to lowest



**sa** SDL_GetNumDisplayModes()

### SDL_GetDesktopDisplayMode

*int SDL_GetDesktopDisplayMode(int displayIndex, SDL_DisplayMode * mode)*



**brief** Fill in information about the desktop display mode.

### SDL_GetCurrentDisplayMode

*int SDL_GetCurrentDisplayMode(int displayIndex, SDL_DisplayMode * mode)*



**brief** Fill in information about the current display mode.

### SDL_GetClosestDisplayMode

*SDL_DisplayMode * SDL_GetClosestDisplayMode(int displayIndex, const SDL_DisplayMode * mode, SDL_DisplayMode * closest)*



**brief** Get the closest match to the requested display mode.



**displayIndex**

**mode**

**closest**



**return** The passed in value **c**  or NULL if no matching video mode          was available.

  The available display modes are scanned, and **c**  is filled in with the  closest mode matching the requested mode and returned.  The mode format and  refresh_rate default to the desktop mode if they are 0.  The modes are  scanned with size being first priority, format being second priority, and  finally checking the refresh_rate.  If all the available modes are too  small, then NULL is returned.



**sa** SDL_GetNumDisplayModes()

**sa** SDL_GetDisplayMode()

### SDL_GetWindowDisplayIndex

*int SDL_GetWindowDisplayIndex(SDL_Window * window)*



**brief** Get the display index associated with a window.



**return** the display index of the display containing the center of the          window, or -1 on error.

### SDL_SetWindowDisplayMode

*int SDL_SetWindowDisplayMode(SDL_Window * window, const SDL_DisplayMode * mode)*



**brief** Set the display mode used when a fullscreen window is visible.

  By default the window's dimensions and the desktop format and refresh rate  are used.



**window**

**mode**



**return** 0 on success, or -1 if setting the display mode failed.



**sa** SDL_GetWindowDisplayMode()

**sa** SDL_SetWindowFullscreen()

### SDL_GetWindowDisplayMode

*int SDL_GetWindowDisplayMode(SDL_Window * window, SDL_DisplayMode * mode)*



**brief** Fill in information about the display mode used when a fullscreen         window is visible.



**sa** SDL_SetWindowDisplayMode()

**sa** SDL_SetWindowFullscreen()

### SDL_GetWindowPixelFormat

*Uint32 SDL_GetWindowPixelFormat(SDL_Window * window)*



**brief** Get the pixel format associated with the window.

### SDL_CreateWindow

*SDL_Window * SDL_CreateWindow(const char * title, int x, int y, int w, int h, Uint32 flags)*



**brief** Create a window with the specified position, dimensions, and flags.



**title**

**x**

**y**

**w**

**h**

**flags**



**return** The created window, or NULL if window creation failed.

  If the window is created with the SDL_WINDOW_ALLOW_HIGHDPI flag, its size  in pixels may differ from its size in screen coordinates on platforms with  high-DPI support (e.g. iOS and Mac OS X). Use SDL_GetWindowSize() to query  the client area's size in screen coordinates, and SDL_GL_GetDrawableSize(),  SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to query the  drawable size in pixels.

  If the window is created with any of the SDL_WINDOW_OPENGL or  SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function  (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the  corresponding UnloadLibrary function is called by SDL_DestroyWindow().

  If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,  SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.



**note** On non-Apple devices, SDL requires you to either not link to the        Vulkan loader or link to a dynamic library version. This limitation        may be removed in a future version of SDL.



**sa** SDL_DestroyWindow()

**sa** SDL_GL_LoadLibrary()

**sa** SDL_Vulkan_LoadLibrary()

### SDL_CreateWindowFrom

*SDL_Window * SDL_CreateWindowFrom(const void * data)*



**brief** Create an SDL window from an existing native window.



**data**



**return** The created window, or NULL if window creation failed.



**sa** SDL_DestroyWindow()

### SDL_GetWindowID

*Uint32 SDL_GetWindowID(SDL_Window * window)*



**brief** Get the numeric ID of a window, for logging purposes.

### SDL_GetWindowFromID

*SDL_Window * SDL_GetWindowFromID(Uint32 id)*



**brief** Get a window from a stored ID, or NULL if it doesn't exist.

### SDL_GetWindowFlags

*Uint32 SDL_GetWindowFlags(SDL_Window * window)*



**brief** Get the window flags.

### SDL_SetWindowTitle

*void SDL_SetWindowTitle(SDL_Window * window, const char * title)*



**brief** Set the title of a window, in UTF-8 format.



**sa** SDL_GetWindowTitle()

### SDL_GetWindowTitle

*const char * SDL_GetWindowTitle(SDL_Window * window)*



**brief** Get the title of a window, in UTF-8 format.



**sa** SDL_SetWindowTitle()

### SDL_SetWindowIcon

*void SDL_SetWindowIcon(SDL_Window * window, SDL_Surface * icon)*



**brief** Set the icon for a window.



**window**

**icon**

### SDL_SetWindowData

*void * SDL_SetWindowData(SDL_Window * window, const char * name, void * userdata)*



**brief** Associate an arbitrary named pointer with a window.



**window**

**name**

**userdata**



**return** The previous value associated with 'name'



**note** The name is case-sensitive.



**sa** SDL_GetWindowData()

### SDL_GetWindowData

*void * SDL_GetWindowData(SDL_Window * window, const char * name)*



**brief** Retrieve the data pointer associated with a window.



**window**

**name**



**return** The value associated with 'name'



**sa** SDL_SetWindowData()

### SDL_SetWindowPosition

*void SDL_SetWindowPosition(SDL_Window * window, int x, int y)*



**brief** Set the position of a window.



**window**

**x**

**y**



**note** The window coordinate origin is the upper left of the display.



**sa** SDL_GetWindowPosition()

### SDL_GetWindowPosition

*void SDL_GetWindowPosition(SDL_Window * window, int * x, int * y)*



**brief** Get the position of a window.



**window**

**x**

**y**



**sa** SDL_SetWindowPosition()

### SDL_SetWindowSize

*void SDL_SetWindowSize(SDL_Window * window, int w, int h)*



**brief** Set the size of a window's client area.



**window**

**w**

**h**



**note** Fullscreen windows automatically match the size of the display mode,        and you should use SDL_SetWindowDisplayMode() to change their size.

  The window size in screen coordinates may differ from the size in pixels, if  the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with  high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or  SDL_GetRendererOutputSize() to get the real client area size in pixels.



**sa** SDL_GetWindowSize()

**sa** SDL_SetWindowDisplayMode()

### SDL_GetWindowSize

*void SDL_GetWindowSize(SDL_Window * window, int * w, int * h)*



**brief** Get the size of a window's client area.



**window**

**w**

**h**

  The window size in screen coordinates may differ from the size in pixels, if  the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with  high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or  SDL_GetRendererOutputSize() to get the real client area size in pixels.



**sa** SDL_SetWindowSize()

### SDL_GetWindowBordersSize

*int SDL_GetWindowBordersSize(SDL_Window * window, int * top, int * left, int * bottom, int * right)*



**brief** Get the size of a window's borders (decorations) around the client area.



**window**

**top**

**left**

**bottom**

**right**



**return** 0 on success, or -1 if getting this information is not supported.



**note** if this function fails (returns -1), the size values will be        initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as        if the window in question was borderless.

### SDL_SetWindowMinimumSize

*void SDL_SetWindowMinimumSize(SDL_Window * window, int min_w, int min_h)*



**brief** Set the minimum size of a window's client area.



**window**

**min_w**

**min_h**



**note** You can't change the minimum size of a fullscreen window, it        automatically matches the size of the display mode.



**sa** SDL_GetWindowMinimumSize()

**sa** SDL_SetWindowMaximumSize()

### SDL_GetWindowMinimumSize

*void SDL_GetWindowMinimumSize(SDL_Window * window, int * w, int * h)*



**brief** Get the minimum size of a window's client area.



**window**

**w**

**h**



**sa** SDL_GetWindowMaximumSize()

**sa** SDL_SetWindowMinimumSize()

### SDL_SetWindowMaximumSize

*void SDL_SetWindowMaximumSize(SDL_Window * window, int max_w, int max_h)*



**brief** Set the maximum size of a window's client area.



**window**

**max_w**

**max_h**



**note** You can't change the maximum size of a fullscreen window, it        automatically matches the size of the display mode.



**sa** SDL_GetWindowMaximumSize()

**sa** SDL_SetWindowMinimumSize()

### SDL_GetWindowMaximumSize

*void SDL_GetWindowMaximumSize(SDL_Window * window, int * w, int * h)*



**brief** Get the maximum size of a window's client area.



**window**

**w**

**h**



**sa** SDL_GetWindowMinimumSize()

**sa** SDL_SetWindowMaximumSize()

### SDL_SetWindowBordered

*void SDL_SetWindowBordered(SDL_Window * window, SDL_bool bordered)*



**brief** Set the border state of a window.

  This will add or remove the window's SDL_WINDOW_BORDERLESS flag and  add or remove the border from the actual window. This is a no-op if the  window's border already matches the requested state.



**window**

**bordered**



**note** You can't change the border state of a fullscreen window.



**sa** SDL_GetWindowFlags()

### SDL_SetWindowResizable

*void SDL_SetWindowResizable(SDL_Window * window, SDL_bool resizable)*



**brief** Set the user-resizable state of a window.

  This will add or remove the window's SDL_WINDOW_RESIZABLE flag and  allow/disallow user resizing of the window. This is a no-op if the  window's resizable state already matches the requested state.



**window**

**resizable**



**note** You can't change the resizable state of a fullscreen window.



**sa** SDL_GetWindowFlags()

### SDL_ShowWindow

*void SDL_ShowWindow(SDL_Window * window)*



**brief** Show a window.



**sa** SDL_HideWindow()

### SDL_HideWindow

*void SDL_HideWindow(SDL_Window * window)*



**brief** Hide a window.



**sa** SDL_ShowWindow()

### SDL_RaiseWindow

*void SDL_RaiseWindow(SDL_Window * window)*



**brief** Raise a window above other windows and set the input focus.

### SDL_MaximizeWindow

*void SDL_MaximizeWindow(SDL_Window * window)*



**brief** Make a window as large as possible.



**sa** SDL_RestoreWindow()

### SDL_MinimizeWindow

*void SDL_MinimizeWindow(SDL_Window * window)*



**brief** Minimize a window to an iconic representation.



**sa** SDL_RestoreWindow()

### SDL_RestoreWindow

*void SDL_RestoreWindow(SDL_Window * window)*



**brief** Restore the size and position of a minimized or maximized window.



**sa** SDL_MaximizeWindow()

**sa** SDL_MinimizeWindow()

### SDL_SetWindowFullscreen

*int SDL_SetWindowFullscreen(SDL_Window * window, Uint32 flags)*



**brief** Set a window's fullscreen state.



**return** 0 on success, or -1 if setting the display mode failed.



**sa** SDL_SetWindowDisplayMode()

**sa** SDL_GetWindowDisplayMode()

### SDL_GetWindowSurface

*SDL_Surface * SDL_GetWindowSurface(SDL_Window * window)*



**brief** Get the SDL surface associated with the window.



**return** The window's framebuffer surface, or NULL on error.

  A new surface will be created with the optimal format for the window,  if necessary. This surface will be freed when the window is destroyed.



**note** You may not combine this with 3D or the rendering API on this window.



**sa** SDL_UpdateWindowSurface()

**sa** SDL_UpdateWindowSurfaceRects()

### SDL_UpdateWindowSurface

*int SDL_UpdateWindowSurface(SDL_Window * window)*



**brief** Copy the window surface to the screen.



**return** 0 on success, or -1 on error.



**sa** SDL_GetWindowSurface()

**sa** SDL_UpdateWindowSurfaceRects()

### SDL_UpdateWindowSurfaceRects

*int SDL_UpdateWindowSurfaceRects(SDL_Window * window, const SDL_Rect * rects, int numrects)*



**brief** Copy a number of rectangles on the window surface to the screen.



**return** 0 on success, or -1 on error.



**sa** SDL_GetWindowSurface()

**sa** SDL_UpdateWindowSurface()

### SDL_SetWindowGrab

*void SDL_SetWindowGrab(SDL_Window * window, SDL_bool grabbed)*



**brief** Set a window's input grab mode.



**window**

**grabbed**

  If the caller enables a grab while another window is currently grabbed,  the other window loses its grab in favor of the caller's window.



**sa** SDL_GetWindowGrab()

### SDL_GetWindowGrab

*SDL_bool SDL_GetWindowGrab(SDL_Window * window)*



**brief** Get a window's input grab mode.



**return** This returns SDL_TRUE if input is grabbed, and SDL_FALSE otherwise.



**sa** SDL_SetWindowGrab()

### SDL_GetGrabbedWindow

*SDL_Window * SDL_GetGrabbedWindow()*



**brief** Get the window that currently has an input grab enabled.



**return** This returns the window if input is grabbed, and NULL otherwise.



**sa** SDL_SetWindowGrab()

### SDL_SetWindowBrightness

*int SDL_SetWindowBrightness(SDL_Window * window, float brightness)*



**brief** Set the brightness (gamma correction) for a window.



**return** 0 on success, or -1 if setting the brightness isn't supported.



**sa** SDL_GetWindowBrightness()

**sa** SDL_SetWindowGammaRamp()

### SDL_GetWindowBrightness

*float SDL_GetWindowBrightness(SDL_Window * window)*



**brief** Get the brightness (gamma correction) for a window.



**return** The last brightness value passed to SDL_SetWindowBrightness()



**sa** SDL_SetWindowBrightness()

### SDL_SetWindowOpacity

*int SDL_SetWindowOpacity(SDL_Window * window, float opacity)*



**brief** Set the opacity for a window



**window**

**opacity**



**return** 0 on success, or -1 if setting the opacity isn't supported.



**sa** SDL_GetWindowOpacity()

### SDL_GetWindowOpacity

*int SDL_GetWindowOpacity(SDL_Window * window, float * out_opacity)*



**brief** Get the opacity of a window.

  If transparency isn't supported on this platform, opacity will be reported  as 1.0f without error.



**window**

**out_opacity**



**return** 0 on success, or -1 on error (invalid window, etc).



**sa** SDL_SetWindowOpacity()

### SDL_SetWindowModalFor

*int SDL_SetWindowModalFor(SDL_Window * modal_window, SDL_Window * parent_window)*



**brief** Sets the window as a modal for another window (TODO: reconsider this function and/or its name)



**modal_window**

**parent_window**



**return** 0 on success, or -1 otherwise.

### SDL_SetWindowInputFocus

*int SDL_SetWindowInputFocus(SDL_Window * window)*



**brief** Explicitly sets input focus to the window.

  You almost certainly want SDL_RaiseWindow() instead of this function. Use  this with caution, as you might give focus to a window that's completely  obscured by other windows.



**window**



**return** 0 on success, or -1 otherwise.

**sa** SDL_RaiseWindow()

### SDL_SetWindowGammaRamp

*int SDL_SetWindowGammaRamp(SDL_Window * window, const Uint16 * red, const Uint16 * green, const Uint16 * blue)*



**brief** Set the gamma ramp for a window.



**window**

**red**

**green**

**blue**



**return** 0 on success, or -1 if gamma ramps are unsupported.

  Set the gamma translation table for the red, green, and blue channels  of the video hardware.  Each table is an array of 256 16-bit quantities,  representing a mapping between the input and output for that channel.  The input is the index into the array, and the output is the 16-bit  gamma value at that index, scaled to the output color precision.



**sa** SDL_GetWindowGammaRamp()

### SDL_GetWindowGammaRamp

*int SDL_GetWindowGammaRamp(SDL_Window * window, Uint16 * red, Uint16 * green, Uint16 * blue)*



**brief** Get the gamma ramp for a window.



**window**

**red**

**green**

**blue**



**return** 0 on success, or -1 if gamma ramps are unsupported.



**sa** SDL_SetWindowGammaRamp()

### SDL_SetWindowHitTest

*int SDL_SetWindowHitTest(SDL_Window * window, SDL_HitTest callback, void * callback_data)*



**brief** Provide a callback that decides if a window region has special properties.

  Normally windows are dragged and resized by decorations provided by the  system window manager (a title bar, borders, etc), but for some apps, it  makes sense to drag them from somewhere else inside the window itself; for  example, one might have a borderless window that wants to be draggable  from any part, or simulate its own title bar, etc.

  This function lets the app provide a callback that designates pieces of  a given window as special. This callback is run during event processing  if we need to tell the OS to treat a region of the window specially; the  use of this callback is known as "hit testing."

  Mouse input may not be delivered to your application if it is within  a special area; the OS will often apply that input to moving the window or  resizing the window and not deliver it to the application.

  Specifying NULL for a callback disables hit-testing. Hit-testing is  disabled by default.

  Platforms that don't support this functionality will return -1  unconditionally, even if you're attempting to disable hit-testing.

  Your callback may fire at any time, and its firing does not indicate any  specific behavior (for example, on Windows, this certainly might fire  when the OS is deciding whether to drag your window, but it fires for lots  of other reasons, too, some unrelated to anything you probably care about  _and when the mouse isn't actually at the location it is testing_).  Since this can fire at any time, you should try to keep your callback  efficient, devoid of allocations, etc.



**window**

**callback**

**callback_data**

**return** 0 on success, -1 on error (including unsupported).

### SDL_DestroyWindow

*void SDL_DestroyWindow(SDL_Window * window)*



**brief** Destroy a window.

### SDL_IsScreenSaverEnabled

*SDL_bool SDL_IsScreenSaverEnabled()*



**brief** Returns whether the screensaver is currently enabled (default off).



**sa** SDL_EnableScreenSaver()

**sa** SDL_DisableScreenSaver()

### SDL_EnableScreenSaver

*void SDL_EnableScreenSaver()*



**brief** Allow the screen to be blanked by a screensaver



**sa** SDL_IsScreenSaverEnabled()

**sa** SDL_DisableScreenSaver()

### SDL_DisableScreenSaver

*void SDL_DisableScreenSaver()*



**brief** Prevent the screen from being blanked by a screensaver



**sa** SDL_IsScreenSaverEnabled()

**sa** SDL_EnableScreenSaver()

### SDL_GL_LoadLibrary

*int SDL_GL_LoadLibrary(const char * path)*



**brief** Dynamically load an OpenGL library.



**path**



**return** 0 on success, or -1 if the library couldn't be loaded.

  This should be done after initializing the video driver, but before  creating any OpenGL windows.  If no OpenGL library is loaded, the default  library will be loaded upon creation of the first OpenGL window.



**note** If you do this, you need to retrieve all of the GL functions used in        your program from the dynamic library using SDL_GL_GetProcAddress().



**sa** SDL_GL_GetProcAddress()

**sa** SDL_GL_UnloadLibrary()

### SDL_GL_GetProcAddress

*void * SDL_GL_GetProcAddress(const char * proc)*



**brief** Get the address of an OpenGL function.

### SDL_GL_UnloadLibrary

*void SDL_GL_UnloadLibrary()*



**brief** Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().



**sa** SDL_GL_LoadLibrary()

### SDL_GL_ExtensionSupported

*SDL_bool SDL_GL_ExtensionSupported(const char * extension)*



**brief** Return true if an OpenGL extension is supported for the current         context.

### SDL_GL_ResetAttributes

*void SDL_GL_ResetAttributes()*



**brief** Reset all previously set OpenGL context attributes to their default values

### SDL_GL_SetAttribute

*int SDL_GL_SetAttribute(SDL_GLattr attr, int value)*



**brief** Set an OpenGL window attribute before window creation.



**return** 0 on success, or -1 if the attribute could not be set.

### SDL_GL_GetAttribute

*int SDL_GL_GetAttribute(SDL_GLattr attr, int * value)*



**brief** Get the actual value for an attribute from the current context.



**return** 0 on success, or -1 if the attribute could not be retrieved.          The integer at **c**  will be modified in either case.

### SDL_GL_CreateContext

*SDL_GLContext SDL_GL_CreateContext(SDL_Window * window)*



**brief** Create an OpenGL context for use with an OpenGL window, and make it         current.



**sa** SDL_GL_DeleteContext()

### SDL_GL_MakeCurrent

*int SDL_GL_MakeCurrent(SDL_Window * window, SDL_GLContext context)*



**brief** Set up an OpenGL context for rendering into an OpenGL window.



**note** The context must have been created with a compatible window.

### SDL_GL_GetCurrentWindow

*SDL_Window * SDL_GL_GetCurrentWindow()*



**brief** Get the currently active OpenGL window.

### SDL_GL_GetCurrentContext

*SDL_GLContext SDL_GL_GetCurrentContext()*



**brief** Get the currently active OpenGL context.

### SDL_GL_GetDrawableSize

*void SDL_GL_GetDrawableSize(SDL_Window * window, int * w, int * h)*



**brief** Get the size of a window's underlying drawable in pixels (for use         with glViewport).



**window**

**w**

**h**

 This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI drawable, i.e. the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with high-DPI support (Apple calls this "Retina"), and not disabled by the SDL_HINT_VIDEO_HIGHDPI_DISABLED hint.



**sa** SDL_GetWindowSize()

**sa** SDL_CreateWindow()

### SDL_GL_SetSwapInterval

*int SDL_GL_SetSwapInterval(int interval)*



**brief** Set the swap interval for the current OpenGL context.



**interval**



**return** 0 on success, or -1 if setting the swap interval is not supported.



**sa** SDL_GL_GetSwapInterval()

### SDL_GL_GetSwapInterval

*int SDL_GL_GetSwapInterval()*



**brief** Get the swap interval for the current OpenGL context.



**return** 0 if there is no vertical retrace synchronization, 1 if the buffer          swap is synchronized with the vertical retrace, and -1 if late          swaps happen immediately instead of waiting for the next retrace.          If the system can't determine the swap interval, or there isn't a          valid current context, this will return 0 as a safe default.



**sa** SDL_GL_SetSwapInterval()

### SDL_GL_SwapWindow

*void SDL_GL_SwapWindow(SDL_Window * window)*



**brief** Swap the OpenGL buffers for a window, if double-buffering is        supported.

### SDL_GL_DeleteContext

*void SDL_GL_DeleteContext(SDL_GLContext context)*



**brief** Delete an OpenGL context.



**sa** SDL_GL_CreateContext()

### SDL_GetKeyboardFocus

*SDL_Window * SDL_GetKeyboardFocus()*



**brief** Get the window which currently has keyboard focus.

### SDL_GetKeyboardState

*const Uint8 * SDL_GetKeyboardState(int * numkeys)*



**brief** Get a snapshot of the current state of the keyboard.



**numkeys**



**return** An array of key states. Indexes into this array are obtained by using ::SDL_Scancode values.

**b** 

  const Uint8 *state = SDL_GetKeyboardState(NULL);

  if ( state[SDL_SCANCODE_RETURN] )   {

      printf("<RETURN> is pressed.\n");

  }



### SDL_GetModState

*SDL_Keymod SDL_GetModState()*



**brief** Get the current key modifier state for the keyboard.

### SDL_SetModState

*void SDL_SetModState(SDL_Keymod modstate)*



**brief** Set the current key modifier state for the keyboard.



**note** This does not change the keyboard state, only the key modifier flags.

### SDL_GetKeyFromScancode

*SDL_Keycode SDL_GetKeyFromScancode(SDL_Scancode scancode)*



**brief** Get the key code corresponding to the given scancode according         to the current keyboard layout.

  See ::SDL_Keycode for details.



**sa** SDL_GetKeyName()

### SDL_GetScancodeFromKey

*SDL_Scancode SDL_GetScancodeFromKey(SDL_Keycode key)*



**brief** Get the scancode corresponding to the given key code according to the         current keyboard layout.

  See ::SDL_Scancode for details.



**sa** SDL_GetScancodeName()

### SDL_GetScancodeName

*const char * SDL_GetScancodeName(SDL_Scancode scancode)*



**brief** Get a human-readable name for a scancode.



**return** A pointer to the name for the scancode.          If the scancode doesn't have a name, this function returns          an empty string ("").



**sa** SDL_Scancode

### SDL_GetScancodeFromName

*SDL_Scancode SDL_GetScancodeFromName(const char * name)*



**brief** Get a scancode from a human-readable name



**return** scancode, or SDL_SCANCODE_UNKNOWN if the name wasn't recognized



**sa** SDL_Scancode

### SDL_GetKeyName

*const char * SDL_GetKeyName(SDL_Keycode key)*



**brief** Get a human-readable name for a key.



**return** A pointer to a UTF-8 string that stays valid at least until the next          call to this function. If you need it around any longer, you must          copy it.  If the key doesn't have a name, this function returns an          empty string ("").



**sa** SDL_Keycode

### SDL_GetKeyFromName

*SDL_Keycode SDL_GetKeyFromName(const char * name)*



**brief** Get a key code from a human-readable name



**return** key code, or SDLK_UNKNOWN if the name wasn't recognized



**sa** SDL_Keycode

### SDL_StartTextInput

*void SDL_StartTextInput()*



**brief** Start accepting Unicode text input events.         This function will show the on-screen keyboard if supported.



**sa** SDL_StopTextInput()

**sa** SDL_SetTextInputRect()

**sa** SDL_HasScreenKeyboardSupport()

### SDL_IsTextInputActive

*SDL_bool SDL_IsTextInputActive()*



**brief** Return whether or not Unicode text input events are enabled.



**sa** SDL_StartTextInput()

**sa** SDL_StopTextInput()

### SDL_StopTextInput

*void SDL_StopTextInput()*



**brief** Stop receiving any text input events.         This function will hide the on-screen keyboard if supported.



**sa** SDL_StartTextInput()

**sa** SDL_HasScreenKeyboardSupport()

### SDL_SetTextInputRect

*void SDL_SetTextInputRect(SDL_Rect * rect)*



**brief** Set the rectangle used to type Unicode text inputs.         This is used as a hint for IME and on-screen keyboard placement.



**sa** SDL_StartTextInput()

### SDL_HasScreenKeyboardSupport

*SDL_bool SDL_HasScreenKeyboardSupport()*



**brief** Returns whether the platform has some screen keyboard support.



**return** SDL_TRUE if some keyboard support is available else SDL_FALSE.



**note** Not all screen keyboard functions are supported on all platforms.



**sa** SDL_IsScreenKeyboardShown()

### SDL_IsScreenKeyboardShown

*SDL_bool SDL_IsScreenKeyboardShown(SDL_Window * window)*



**brief** Returns whether the screen keyboard is shown for given window.



**window**



**return** SDL_TRUE if screen keyboard is shown else SDL_FALSE.



**sa** SDL_HasScreenKeyboardSupport()

### SDL_GetMouseFocus

*SDL_Window * SDL_GetMouseFocus()*



**brief** Get the window which currently has mouse focus.

### SDL_GetMouseState

*Uint32 SDL_GetMouseState(int * x, int * y)*



**brief** Retrieve the current state of the mouse.

  The current button state is returned as a button bitmask, which can  be tested using the SDL_BUTTON(X) macros, and x and y are set to the  mouse cursor position relative to the focus window for the currently  selected mouse.  You can pass NULL for either x or y.

### SDL_GetGlobalMouseState

*Uint32 SDL_GetGlobalMouseState(int * x, int * y)*



**brief** Get the current state of the mouse, in relation to the desktop

  This works just like SDL_GetMouseState(), but the coordinates will be  reported relative to the top-left of the desktop. This can be useful if  you need to track the mouse outside of a specific window and  SDL_CaptureMouse() doesn't fit your needs. For example, it could be  useful if you need to track the mouse while dragging a window, where  coordinates relative to a window might not be in sync at all times.



**note** SDL_GetMouseState() returns the mouse position as SDL understands        it from the last pump of the event queue. This function, however,        queries the OS for the current mouse position, and as such, might        be a slightly less efficient function. Unless you know what you're        doing and have a good reason to use this function, you probably want        SDL_GetMouseState() instead.



**x**

**y**

**return** The current button state as a bitmask, which can be tested using the SDL_BUTTON(X) macros.



**sa** SDL_GetMouseState

### SDL_GetRelativeMouseState

*Uint32 SDL_GetRelativeMouseState(int * x, int * y)*



**brief** Retrieve the relative state of the mouse.

  The current button state is returned as a button bitmask, which can  be tested using the SDL_BUTTON(X) macros, and x and y are set to the  mouse deltas since the last call to SDL_GetRelativeMouseState().

### SDL_WarpMouseInWindow

*void SDL_WarpMouseInWindow(SDL_Window * window, int x, int y)*



**brief** Moves the mouse to the given position within the window.



**window**

**x**

**y**



**note** This function generates a mouse motion event

### SDL_WarpMouseGlobal

*int SDL_WarpMouseGlobal(int x, int y)*



**brief** Moves the mouse to the given position in global screen space.



**x**

**y**

**return** 0 on success, -1 on error (usually: unsupported by a platform).



**note** This function generates a mouse motion event

### SDL_SetRelativeMouseMode

*int SDL_SetRelativeMouseMode(SDL_bool enabled)*



**brief** Set relative mouse mode.



**enabled**



**return** 0 on success, or -1 if relative mode is not supported.

  While the mouse is in relative mode, the cursor is hidden, and the  driver will try to report continuous motion in the current window.  Only relative motion events will be delivered, the mouse position  will not change.



**note** This function will flush any pending mouse motion.



**sa** SDL_GetRelativeMouseMode()

### SDL_CaptureMouse

*int SDL_CaptureMouse(SDL_bool enabled)*



**brief** Capture the mouse, to track input outside an SDL window.



**enabled**

  Capturing enables your app to obtain mouse events globally, instead of  just within your window. Not all video targets support this function.  When capturing is enabled, the current window will get all mouse events,  but unlike relative mode, no change is made to the cursor and it is  not restrained to your window.

  This function may also deny mouse input to other windows--both those in  your application and others on the system--so you should use this  function sparingly, and in small bursts. For example, you might want to  track the mouse while the user is dragging something, until the user  releases a mouse button. It is not recommended that you capture the mouse  for long periods of time, such as the entire time your app is running.

  While captured, mouse events still report coordinates relative to the  current (foreground) window, but those coordinates may be outside the  bounds of the window (including negative values). Capturing is only  allowed for the foreground window. If the window loses focus while  capturing, the capture will be disabled automatically.

  While capturing is enabled, the current window will have the  SDL_WINDOW_MOUSE_CAPTURE flag set.



**return** 0 on success, or -1 if not supported.

### SDL_GetRelativeMouseMode

*SDL_bool SDL_GetRelativeMouseMode()*



**brief** Query whether relative mouse mode is enabled.



**sa** SDL_SetRelativeMouseMode()

### SDL_CreateCursor

*SDL_Cursor * SDL_CreateCursor(const Uint8 * data, const Uint8 * mask, int w, int h, int hot_x, int hot_y)*



**brief** Create a cursor, using the specified bitmap data and         mask (in MSB format).

  The cursor width must be a multiple of 8 bits.

  The cursor is created in black and white according to the following:<table>

<tr>

<td>

 data </td>

<td>

 mask </td>

<td>

 resulting pixel on screen </td>

</tr>

<tr>

<td>

  0   </td>

<td>

  1   </td>

<td>

 White </td>

</tr>

<tr>

<td>

  1   </td>

<td>

  1   </td>

<td>

 Black </td>

</tr>

<tr>

<td>

  0   </td>

<td>

  0   </td>

<td>

 Transparent </td>

</tr>

<tr>

<td>

  1   </td>

<td>

  0   </td>

<td>

 Inverted color if possible, black                                         if not. </td>

</tr>

</table>





**sa** SDL_FreeCursor()

### SDL_CreateColorCursor

*SDL_Cursor * SDL_CreateColorCursor(SDL_Surface * surface, int hot_x, int hot_y)*



**brief** Create a color cursor.



**sa** SDL_FreeCursor()

### SDL_CreateSystemCursor

*SDL_Cursor * SDL_CreateSystemCursor(SDL_SystemCursor id)*



**brief** Create a system cursor.



**sa** SDL_FreeCursor()

### SDL_SetCursor

*void SDL_SetCursor(SDL_Cursor * cursor)*



**brief** Set the active cursor.

### SDL_GetCursor

*SDL_Cursor * SDL_GetCursor()*



**brief** Return the active cursor.

### SDL_GetDefaultCursor

*SDL_Cursor * SDL_GetDefaultCursor()*



**brief** Return the default cursor.

### SDL_FreeCursor

*void SDL_FreeCursor(SDL_Cursor * cursor)*



**brief** Frees a cursor created with SDL_CreateCursor() or similar functions.



**sa** SDL_CreateCursor()

**sa** SDL_CreateColorCursor()

**sa** SDL_CreateSystemCursor()

### SDL_ShowCursor

*int SDL_ShowCursor(int toggle)*



**brief** Toggle whether or not the cursor is shown.



**toggle**



**return** 1 if the cursor is shown, or 0 if the cursor is hidden.

### SDL_LockJoysticks

*void SDL_LockJoysticks()*

 Locking for multi-threaded access to the joystick API

 If you are using the joystick API or handling events from multiple threads you should use these locking functions to protect access to the joysticks.

 In particular, you are guaranteed that the joystick list won't change, so the API functions that take a joystick index will be valid, and joystick and game controller events will not be delivered.

### SDL_UnlockJoysticks

*void SDL_UnlockJoysticks()*

### SDL_NumJoysticks

*int SDL_NumJoysticks()*

  Count the number of joysticks attached to the system right now

### SDL_JoystickNameForIndex

*const char * SDL_JoystickNameForIndex(int device_index)*

  Get the implementation dependent name of a joystick.  This can be called before any joysticks are opened.  If no name can be found, this function returns NULL.

### SDL_JoystickGetDevicePlayerIndex

*int SDL_JoystickGetDevicePlayerIndex(int device_index)*

  Get the player index of a joystick, or -1 if it's not available  This can be called before any joysticks are opened.

### SDL_JoystickGetDeviceGUID

* SDL_JoystickGetDeviceGUID(int device_index)*

  Return the GUID for the joystick at this index  This can be called before any joysticks are opened.

### SDL_JoystickGetDeviceVendor

*Uint16 SDL_JoystickGetDeviceVendor(int device_index)*

  Get the USB vendor ID of a joystick, if available.  This can be called before any joysticks are opened.  If the vendor ID isn't available this function returns 0.

### SDL_JoystickGetDeviceProduct

*Uint16 SDL_JoystickGetDeviceProduct(int device_index)*

  Get the USB product ID of a joystick, if available.  This can be called before any joysticks are opened.  If the product ID isn't available this function returns 0.

### SDL_JoystickGetDeviceProductVersion

*Uint16 SDL_JoystickGetDeviceProductVersion(int device_index)*

  Get the product version of a joystick, if available.  This can be called before any joysticks are opened.  If the product version isn't available this function returns 0.

### SDL_JoystickGetDeviceType

*SDL_JoystickType SDL_JoystickGetDeviceType(int device_index)*

  Get the type of a joystick, if available.  This can be called before any joysticks are opened.

### SDL_JoystickGetDeviceInstanceID

*SDL_JoystickID SDL_JoystickGetDeviceInstanceID(int device_index)*

  Get the instance ID of a joystick.  This can be called before any joysticks are opened.  If the index is out of range, this function will return -1.

### SDL_JoystickOpen

*SDL_Joystick * SDL_JoystickOpen(int device_index)*

  Open a joystick for use.  The index passed as an argument refers to the N'th joystick on the system.  This index is not the value which will identify this joystick in future  joystick events.  The joystick's instance id (::SDL_JoystickID) will be used  there instead.



**return** A joystick identifier, or NULL if an error occurred.

### SDL_JoystickFromInstanceID

*SDL_Joystick * SDL_JoystickFromInstanceID(SDL_JoystickID instance_id)*

 Return the SDL_Joystick associated with an instance id.

### SDL_JoystickFromPlayerIndex

*SDL_Joystick * SDL_JoystickFromPlayerIndex(int player_index)*

 Return the SDL_Joystick associated with a player index.

### SDL_JoystickName

*const char * SDL_JoystickName(SDL_Joystick * joystick)*

  Return the name for this currently opened joystick.  If no name can be found, this function returns NULL.

### SDL_JoystickGetPlayerIndex

*int SDL_JoystickGetPlayerIndex(SDL_Joystick * joystick)*

  Get the player index of an opened joystick, or -1 if it's not available

  For XInput controllers this returns the XInput user index.

### SDL_JoystickSetPlayerIndex

*void SDL_JoystickSetPlayerIndex(SDL_Joystick * joystick, int player_index)*

  Set the player index of an opened joystick

### SDL_JoystickGetGUID

* SDL_JoystickGetGUID(SDL_Joystick * joystick)*

  Return the GUID for this opened joystick

### SDL_JoystickGetVendor

*Uint16 SDL_JoystickGetVendor(SDL_Joystick * joystick)*

  Get the USB vendor ID of an opened joystick, if available.  If the vendor ID isn't available this function returns 0.

### SDL_JoystickGetProduct

*Uint16 SDL_JoystickGetProduct(SDL_Joystick * joystick)*

  Get the USB product ID of an opened joystick, if available.  If the product ID isn't available this function returns 0.

### SDL_JoystickGetProductVersion

*Uint16 SDL_JoystickGetProductVersion(SDL_Joystick * joystick)*

  Get the product version of an opened joystick, if available.  If the product version isn't available this function returns 0.

### SDL_JoystickGetType

*SDL_JoystickType SDL_JoystickGetType(SDL_Joystick * joystick)*

  Get the type of an opened joystick.

### SDL_JoystickGetGUIDString

*void SDL_JoystickGetGUIDString( guid, char * pszGUID, int cbGUID)*

  Return a string representation for this guid. pszGUID must point to at least 33 bytes  (32 for the string plus a NULL terminator).

### SDL_JoystickGetGUIDFromString

* SDL_JoystickGetGUIDFromString(const char * pchGUID)*

  Convert a string into a joystick guid

### SDL_JoystickGetAttached

*SDL_bool SDL_JoystickGetAttached(SDL_Joystick * joystick)*

  Returns SDL_TRUE if the joystick has been opened and currently connected, or SDL_FALSE if it has not.

### SDL_JoystickInstanceID

*SDL_JoystickID SDL_JoystickInstanceID(SDL_Joystick * joystick)*

  Get the instance ID of an opened joystick or -1 if the joystick is invalid.

### SDL_JoystickNumAxes

*int SDL_JoystickNumAxes(SDL_Joystick * joystick)*

  Get the number of general axis controls on a joystick.

### SDL_JoystickNumBalls

*int SDL_JoystickNumBalls(SDL_Joystick * joystick)*

  Get the number of trackballs on a joystick.

  Joystick trackballs have only relative motion events associated  with them and their state cannot be polled.

### SDL_JoystickNumHats

*int SDL_JoystickNumHats(SDL_Joystick * joystick)*

  Get the number of POV hats on a joystick.

### SDL_JoystickNumButtons

*int SDL_JoystickNumButtons(SDL_Joystick * joystick)*

  Get the number of buttons on a joystick.

### SDL_JoystickUpdate

*void SDL_JoystickUpdate()*

  Update the current state of the open joysticks.

  This is called automatically by the event loop if any joystick  events are enabled.

### SDL_JoystickEventState

*int SDL_JoystickEventState(int state)*

  Enable/disable joystick event polling.

  If joystick events are disabled, you must call SDL_JoystickUpdate()  yourself and check the state of the joystick when you want joystick  information.

  The state can be one of ::SDL_QUERY, ::SDL_ENABLE or ::SDL_IGNORE.

### SDL_JoystickGetAxis

*Sint16 SDL_JoystickGetAxis(SDL_Joystick * joystick, int axis)*

  Get the current state of an axis control on a joystick.

  The state is a value ranging from -32768 to 32767.

  The axis indices start at index 0.

### SDL_JoystickGetAxisInitialState

*SDL_bool SDL_JoystickGetAxisInitialState(SDL_Joystick * joystick, int axis, Sint16 * state)*

  Get the initial state of an axis control on a joystick.

  The state is a value ranging from -32768 to 32767.

  The axis indices start at index 0.



**return** SDL_TRUE if this axis has any initial value, or SDL_FALSE if not.

### SDL_JoystickGetHat

*Uint8 SDL_JoystickGetHat(SDL_Joystick * joystick, int hat)*

  Get the current state of a POV hat on a joystick.

  The hat indices start at index 0.



**return** The return value is one of the following positions:           - ::SDL_HAT_CENTERED           - ::SDL_HAT_UP           - ::SDL_HAT_RIGHT           - ::SDL_HAT_DOWN           - ::SDL_HAT_LEFT           - ::SDL_HAT_RIGHTUP           - ::SDL_HAT_RIGHTDOWN           - ::SDL_HAT_LEFTUP           - ::SDL_HAT_LEFTDOWN

### SDL_JoystickGetBall

*int SDL_JoystickGetBall(SDL_Joystick * joystick, int ball, int * dx, int * dy)*

  Get the ball axis change since the last poll.



**return** 0, or -1 if you passed it invalid parameters.

  The ball indices start at index 0.

### SDL_JoystickGetButton

*Uint8 SDL_JoystickGetButton(SDL_Joystick * joystick, int button)*

  Get the current state of a button on a joystick.

  The button indices start at index 0.

### SDL_JoystickRumble

*int SDL_JoystickRumble(SDL_Joystick * joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 duration_ms)*

  Trigger a rumble effect  Each call to this function cancels any previous rumble effect, and calling it with 0 intensity stops any rumbling.



**joystick**

**low_frequency_rumble**

**high_frequency_rumble**

**duration_ms**



**return** 0, or -1 if rumble isn't supported on this joystick

### SDL_JoystickClose

*void SDL_JoystickClose(SDL_Joystick * joystick)*

  Close a joystick previously opened with SDL_JoystickOpen().

### SDL_JoystickCurrentPowerLevel

*SDL_JoystickPowerLevel SDL_JoystickCurrentPowerLevel(SDL_Joystick * joystick)*

  Return the battery level of this joystick

### SDL_GameControllerAddMappingsFromRW

*int SDL_GameControllerAddMappingsFromRW(SDL_RWops * rw, int freerw)*

  Load a set of mappings from a seekable SDL data stream (memory or file), filtered by the current SDL_GetPlatform()  A community sourced database of controllers is available at https://raw.github.com/gabomdq/SDL_GameControllerDB/master/gamecontrollerdb.txt

  If **c**  is non-zero, the stream will be closed after being read.



**return** number of mappings added, -1 on error

### SDL_GameControllerAddMapping

*int SDL_GameControllerAddMapping(const char * mappingString)*

  Add or update an existing mapping configuration



**return** 1 if mapping is added, 0 if updated, -1 on error

### SDL_GameControllerNumMappings

*int SDL_GameControllerNumMappings()*

  Get the number of mappings installed



**return** the number of mappings

### SDL_GameControllerMappingForIndex

*char * SDL_GameControllerMappingForIndex(int mapping_index)*

  Get the mapping at a particular index.



**return** the mapping string.  Must be freed with SDL_free().  Returns NULL if the index is out of range.

### SDL_GameControllerMappingForGUID

*char * SDL_GameControllerMappingForGUID( guid)*

  Get a mapping string for a GUID



**return** the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available

### SDL_GameControllerMapping

*char * SDL_GameControllerMapping(SDL_GameController * gamecontroller)*

  Get a mapping string for an open GameController



**return** the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available

### SDL_IsGameController

*SDL_bool SDL_IsGameController(int joystick_index)*

  Is the joystick on this index supported by the game controller interface?

### SDL_GameControllerNameForIndex

*const char * SDL_GameControllerNameForIndex(int joystick_index)*

  Get the implementation dependent name of a game controller.  This can be called before any controllers are opened.  If no name can be found, this function returns NULL.

### SDL_GameControllerTypeForIndex

*SDL_GameControllerType SDL_GameControllerTypeForIndex(int joystick_index)*

  Get the type of a game controller.  This can be called before any controllers are opened.

### SDL_GameControllerMappingForDeviceIndex

*char * SDL_GameControllerMappingForDeviceIndex(int joystick_index)*

  Get the mapping of a game controller.  This can be called before any controllers are opened.



**return** the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available

### SDL_GameControllerOpen

*SDL_GameController * SDL_GameControllerOpen(int joystick_index)*

  Open a game controller for use.  The index passed as an argument refers to the N'th game controller on the system.  This index is not the value which will identify this controller in future  controller events.  The joystick's instance id (::SDL_JoystickID) will be  used there instead.



**return** A controller identifier, or NULL if an error occurred.

### SDL_GameControllerFromInstanceID

*SDL_GameController * SDL_GameControllerFromInstanceID(SDL_JoystickID joyid)*

 Return the SDL_GameController associated with an instance id.

### SDL_GameControllerFromPlayerIndex

*SDL_GameController * SDL_GameControllerFromPlayerIndex(int player_index)*

 Return the SDL_GameController associated with a player index.

### SDL_GameControllerName

*const char * SDL_GameControllerName(SDL_GameController * gamecontroller)*

  Return the name for this currently opened controller

### SDL_GameControllerGetType

*SDL_GameControllerType SDL_GameControllerGetType(SDL_GameController * gamecontroller)*

  Return the type of this currently opened controller

### SDL_GameControllerGetPlayerIndex

*int SDL_GameControllerGetPlayerIndex(SDL_GameController * gamecontroller)*

  Get the player index of an opened game controller, or -1 if it's not available

  For XInput controllers this returns the XInput user index.

### SDL_GameControllerSetPlayerIndex

*void SDL_GameControllerSetPlayerIndex(SDL_GameController * gamecontroller, int player_index)*

  Set the player index of an opened game controller

### SDL_GameControllerGetVendor

*Uint16 SDL_GameControllerGetVendor(SDL_GameController * gamecontroller)*

  Get the USB vendor ID of an opened controller, if available.  If the vendor ID isn't available this function returns 0.

### SDL_GameControllerGetProduct

*Uint16 SDL_GameControllerGetProduct(SDL_GameController * gamecontroller)*

  Get the USB product ID of an opened controller, if available.  If the product ID isn't available this function returns 0.

### SDL_GameControllerGetProductVersion

*Uint16 SDL_GameControllerGetProductVersion(SDL_GameController * gamecontroller)*

  Get the product version of an opened controller, if available.  If the product version isn't available this function returns 0.

### SDL_GameControllerGetAttached

*SDL_bool SDL_GameControllerGetAttached(SDL_GameController * gamecontroller)*

  Returns SDL_TRUE if the controller has been opened and currently connected,  or SDL_FALSE if it has not.

### SDL_GameControllerGetJoystick

*SDL_Joystick * SDL_GameControllerGetJoystick(SDL_GameController * gamecontroller)*

  Get the underlying joystick object used by a controller

### SDL_GameControllerEventState

*int SDL_GameControllerEventState(int state)*

  Enable/disable controller event polling.

  If controller events are disabled, you must call SDL_GameControllerUpdate()  yourself and check the state of the controller when you want controller  information.

  The state can be one of ::SDL_QUERY, ::SDL_ENABLE or ::SDL_IGNORE.

### SDL_GameControllerUpdate

*void SDL_GameControllerUpdate()*

  Update the current state of the open game controllers.

  This is called automatically by the event loop if any game controller  events are enabled.

### SDL_GameControllerGetAxisFromString

*SDL_GameControllerAxis SDL_GameControllerGetAxisFromString(const char * pchString)*

  turn this string into a axis mapping

### SDL_GameControllerGetStringForAxis

*const char * SDL_GameControllerGetStringForAxis(SDL_GameControllerAxis axis)*

  turn this axis enum into a string mapping

### SDL_GameControllerGetBindForAxis

*SDL_GameControllerButtonBind SDL_GameControllerGetBindForAxis(SDL_GameController * gamecontroller, SDL_GameControllerAxis axis)*

  Get the SDL joystick layer binding for this controller button mapping

### SDL_GameControllerGetAxis

*Sint16 SDL_GameControllerGetAxis(SDL_GameController * gamecontroller, SDL_GameControllerAxis axis)*

  Get the current state of an axis control on a game controller.

  The state is a value ranging from -32768 to 32767 (except for the triggers,  which range from 0 to 32767).

  The axis indices start at index 0.

### SDL_GameControllerGetButtonFromString

*SDL_GameControllerButton SDL_GameControllerGetButtonFromString(const char * pchString)*

  turn this string into a button mapping

### SDL_GameControllerGetStringForButton

*const char * SDL_GameControllerGetStringForButton(SDL_GameControllerButton button)*

  turn this button enum into a string mapping

### SDL_GameControllerGetBindForButton

*SDL_GameControllerButtonBind SDL_GameControllerGetBindForButton(SDL_GameController * gamecontroller, SDL_GameControllerButton button)*

  Get the SDL joystick layer binding for this controller button mapping

### SDL_GameControllerGetButton

*Uint8 SDL_GameControllerGetButton(SDL_GameController * gamecontroller, SDL_GameControllerButton button)*

  Get the current state of a button on a game controller.

  The button indices start at index 0.

### SDL_GameControllerRumble

*int SDL_GameControllerRumble(SDL_GameController * gamecontroller, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 duration_ms)*

  Trigger a rumble effect  Each call to this function cancels any previous rumble effect, and calling it with 0 intensity stops any rumbling.



**gamecontroller**

**low_frequency_rumble**

**high_frequency_rumble**

**duration_ms**



**return** 0, or -1 if rumble isn't supported on this joystick

### SDL_GameControllerClose

*void SDL_GameControllerClose(SDL_GameController * gamecontroller)*

  Close a controller previously opened with SDL_GameControllerOpen().

### SDL_GetNumTouchDevices

*int SDL_GetNumTouchDevices()*



**brief** Get the number of registered touch devices.

### SDL_GetTouchDevice

*SDL_TouchID SDL_GetTouchDevice(int index)*



**brief** Get the touch ID with the given index, or 0 if the index is invalid.

### SDL_GetTouchDeviceType

*SDL_TouchDeviceType SDL_GetTouchDeviceType(SDL_TouchID touchID)*



**brief** Get the type of the given touch device.

### SDL_GetNumTouchFingers

*int SDL_GetNumTouchFingers(SDL_TouchID touchID)*



**brief** Get the number of active fingers for a given touch device.

### SDL_GetTouchFinger

*SDL_Finger * SDL_GetTouchFinger(SDL_TouchID touchID, int index)*



**brief** Get the finger object of the given touch, with the given index.

### SDL_RecordGesture

*int SDL_RecordGesture(SDL_TouchID touchId)*



**brief** Begin Recording a gesture on the specified touch, or all touches (-1)



### SDL_SaveAllDollarTemplates

*int SDL_SaveAllDollarTemplates(SDL_RWops * dst)*



**brief** Save all currently loaded Dollar Gesture templates



### SDL_SaveDollarTemplate

*int SDL_SaveDollarTemplate(SDL_GestureID gestureId, SDL_RWops * dst)*



**brief** Save a currently loaded Dollar Gesture template



### SDL_LoadDollarTemplates

*int SDL_LoadDollarTemplates(SDL_TouchID touchId, SDL_RWops * src)*



**brief** Load Dollar Gesture templates from a file



### SDL_PumpEvents

*void SDL_PumpEvents()*

  Pumps the event loop, gathering events from the input devices.

  This function updates the event queue and internal input device state.

  This should only be run in the thread that sets the video mode.

### SDL_PeepEvents

*int SDL_PeepEvents(SDL_Event * events, int numevents, SDL_eventaction action, Uint32 minType, Uint32 maxType)*

  Checks the event queue for messages and optionally returns them.

  If **c**  is ::SDL_ADDEVENT, up to **c**  events will be added to  the back of the event queue.

  If **c**  is ::SDL_PEEKEVENT, up to **c**  events at the front  of the event queue, within the specified minimum and maximum type,  will be returned and will not be removed from the queue.

  If **c**  is ::SDL_GETEVENT, up to **c**  events at the front  of the event queue, within the specified minimum and maximum type,  will be returned and will be removed from the queue.



**return** The number of events actually stored, or -1 if there was an error.

  This function is thread-safe.

### SDL_HasEvent

*SDL_bool SDL_HasEvent(Uint32 type)*

  Checks to see if certain event types are in the event queue.

### SDL_HasEvents

*SDL_bool SDL_HasEvents(Uint32 minType, Uint32 maxType)*

### SDL_FlushEvent

*void SDL_FlushEvent(Uint32 type)*

  This function clears events from the event queue  This function only affects currently queued events. If you want to make  sure that all pending OS events are flushed, you can call SDL_PumpEvents()  on the main thread immediately before the flush call.

### SDL_FlushEvents

*void SDL_FlushEvents(Uint32 minType, Uint32 maxType)*

### SDL_PollEvent

*int SDL_PollEvent(SDL_Event * event)*



**brief** Polls for currently pending events.



**return** 1 if there are any pending events, or 0 if there are none available.



**event**

### SDL_WaitEvent

*int SDL_WaitEvent(SDL_Event * event)*



**brief** Waits indefinitely for the next available event.



**return** 1, or 0 if there was an error while waiting for events.



**event**

### SDL_WaitEventTimeout

*int SDL_WaitEventTimeout(SDL_Event * event, int timeout)*



**brief** Waits until the specified timeout (in milliseconds) for the next         available event.



**return** 1, or 0 if there was an error while waiting for events.



**event**

**timeout**

### SDL_PushEvent

*int SDL_PushEvent(SDL_Event * event)*



**brief** Add an event to the event queue.



**return** 1 on success, 0 if the event was filtered, or -1 if the event queue          was full or there was some other error.

### SDL_SetEventFilter

*void SDL_SetEventFilter(SDL_EventFilter filter, void * userdata)*

  Sets up a filter to process all events before they change internal state and  are posted to the internal event queue.

  The filter is prototyped as:

      int SDL_EventFilter(void *userdata, SDL_Event * event);

  If the filter returns 1, then the event will be added to the internal queue.  If it returns 0, then the event will be dropped from the queue, but the  internal state will still be updated.  This allows selective filtering of  dynamically arriving events.



**warning**  Be very careful of what you do in the event filter function, as            it may run in a different thread!

  There is one caveat when dealing with the ::SDL_QuitEvent event type.  The  event filter is only called when the window manager desires to close the  application window.  If the event filter returns 1, then the window will  be closed, otherwise the window will remain open if possible.

  If the quit event is generated by an interrupt signal, it will bypass the  internal queue and be delivered to the application at the next event poll.

### SDL_GetEventFilter

*SDL_bool SDL_GetEventFilter(SDL_EventFilter * filter, void ** userdata)*

  Return the current event filter - can be used to "chain" filters.  If there is no event filter set, this function returns SDL_FALSE.

### SDL_AddEventWatch

*void SDL_AddEventWatch(SDL_EventFilter filter, void * userdata)*

  Add a function which is called when an event is added to the queue.

### SDL_DelEventWatch

*void SDL_DelEventWatch(SDL_EventFilter filter, void * userdata)*

  Remove an event watch function added with SDL_AddEventWatch()

### SDL_FilterEvents

*void SDL_FilterEvents(SDL_EventFilter filter, void * userdata)*

  Run the filter function on the current event queue, removing any  events for which the filter returns 0.

### SDL_EventState

*Uint8 SDL_EventState(Uint32 type, int state)*

  This function allows you to set the state of processing certain events.   - If **c**  is set to ::SDL_IGNORE, that event will be automatically     dropped from the event queue and will not be filtered.   - If **c**  is set to ::SDL_ENABLE, that event will be processed     normally.   - If **c**  is set to ::SDL_QUERY, SDL_EventState() will return the     current processing state of the specified event.

### SDL_RegisterEvents

*Uint32 SDL_RegisterEvents(int numevents)*

  This function allocates a set of user-defined events, and returns  the beginning event number for that set of events.

  If there aren't enough user-defined events left, this function  returns (Uint32)-1

### SDL_GetBasePath

*char * SDL_GetBasePath()*



**brief** Get the path where the application resides.

 Get the "base path". This is the directory where the application was run  from, which is probably the installation directory, and may or may not  be the process's current working directory.

 This returns an absolute path in UTF-8 encoding, and is guaranteed to  end with a path separator ('\' on Windows, '/' most other places).

 The pointer returned by this function is owned by you. Please call  SDL_free() on the pointer when you are done with it, or it will be a  memory leak. This is not necessarily a fast call, though, so you should  call this once near startup and save the string if you need it.

 Some platforms can't determine the application's path, and on other  platforms, this might be meaningless. In such cases, this function will  return NULL.



**return** String of base dir in UTF-8 encoding, or NULL on error.



**sa** SDL_GetPrefPath

### SDL_GetPrefPath

*char * SDL_GetPrefPath(const char * org, const char * app)*



**brief** Get the user-and-app-specific path where files can be written.

 Get the "pref dir". This is meant to be where users can write personal  files (preferences and save games, etc) that are specific to your  application. This directory is unique per user, per application.

 This function will decide the appropriate location in the native filesystem,  create the directory if necessary, and return a string of the absolute  path to the directory in UTF-8 encoding.

 On Windows, the string might look like:  "C:\Users\bob\AppData\Roaming\My Company\My Program Name\"

 On Linux, the string might look like:  "/home/bob/.local/share/My Program Name/"

 On Mac OS X, the string might look like:  "/Users/bob/Library/Application Support/My Program Name/"

 (etc.)

 You specify the name of your organization (if it's not a real organization,  your name or an Internet domain you own might do) and the name of your  application. These should be untranslated proper names.

 Both the org and app strings may become part of a directory name, so  please follow these rules:

    - Try to use the same org string (including case-sensitivity) for      all your applications that use this function.    - Always use a unique app string for each one, and make sure it never      changes for an app once you've decided on it.    - Unicode characters are legal, as long as it's UTF-8 encoded, but...    - ...only use letters, numbers, and spaces. Avoid punctuation like      "Game Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.

 This returns an absolute path in UTF-8 encoding, and is guaranteed to  end with a path separator ('\' on Windows, '/' most other places).

 The pointer returned by this function is owned by you. Please call  SDL_free() on the pointer when you are done with it, or it will be a  memory leak. This is not necessarily a fast call, though, so you should  call this once near startup and save the string if you need it.

 You should assume the path returned by this function is the only safe  place to write files (and that SDL_GetBasePath(), while it might be  writable, or even the parent of the returned path, aren't where you  should be writing things).

 Some platforms can't determine the pref path, and on other  platforms, this might be meaningless. In such cases, this function will  return NULL.



**org**

**app**

**return** UTF-8 string of user dir in platform-dependent notation. NULL          if there's a problem (creating directory failed, etc).



**sa** SDL_GetBasePath

### SDL_NumHaptics

*int SDL_NumHaptics()*

 Function prototypes 



**brief** Count the number of haptic devices attached to the system.



**return** Number of haptic devices detected on the system.

### SDL_HapticName

*const char * SDL_HapticName(int device_index)*



**brief** Get the implementation dependent name of a haptic device.

  This can be called before any joysticks are opened.  If no name can be found, this function returns NULL.



**device_index**

**return** Name of the device or NULL on error.



**sa** SDL_NumHaptics

### SDL_HapticOpen

*SDL_Haptic * SDL_HapticOpen(int device_index)*



**brief** Opens a haptic device for use.

  The index passed as an argument refers to the N'th haptic device on this  system.

  When opening a haptic device, its gain will be set to maximum and  autocenter will be disabled.  To modify these values use  SDL_HapticSetGain() and SDL_HapticSetAutocenter().



**device_index**

**return** Device identifier or NULL on error.



**sa** SDL_HapticIndex

**sa** SDL_HapticOpenFromMouse

**sa** SDL_HapticOpenFromJoystick

**sa** SDL_HapticClose

**sa** SDL_HapticSetGain

**sa** SDL_HapticSetAutocenter

**sa** SDL_HapticPause

**sa** SDL_HapticStopAll

### SDL_HapticOpened

*int SDL_HapticOpened(int device_index)*



**brief** Checks if the haptic device at index has been opened.



**device_index**

**return** 1 if it has been opened or 0 if it hasn't.



**sa** SDL_HapticOpen

**sa** SDL_HapticIndex

### SDL_HapticIndex

*int SDL_HapticIndex(SDL_Haptic * haptic)*



**brief** Gets the index of a haptic device.



**haptic**

**return** The index of the haptic device or -1 on error.



**sa** SDL_HapticOpen

**sa** SDL_HapticOpened

### SDL_MouseIsHaptic

*int SDL_MouseIsHaptic()*



**brief** Gets whether or not the current mouse has haptic capabilities.



**return** SDL_TRUE if the mouse is haptic, SDL_FALSE if it isn't.



**sa** SDL_HapticOpenFromMouse

### SDL_HapticOpenFromMouse

*SDL_Haptic * SDL_HapticOpenFromMouse()*



**brief** Tries to open a haptic device from the current mouse.



**return** The haptic device identifier or NULL on error.



**sa** SDL_MouseIsHaptic

**sa** SDL_HapticOpen

### SDL_JoystickIsHaptic

*int SDL_JoystickIsHaptic(SDL_Joystick * joystick)*



**brief** Checks to see if a joystick has haptic features.



**joystick**

**return** SDL_TRUE if the joystick is haptic, SDL_FALSE if it isn't          or -1 if an error occurred.



**sa** SDL_HapticOpenFromJoystick

### SDL_HapticOpenFromJoystick

*SDL_Haptic * SDL_HapticOpenFromJoystick(SDL_Joystick * joystick)*



**brief** Opens a haptic device for use from a joystick device.

  You must still close the haptic device separately.  It will not be closed  with the joystick.

  When opening from a joystick you should first close the haptic device before  closing the joystick device.  If not, on some implementations the haptic  device will also get unallocated and you'll be unable to use force feedback  on that device.



**joystick**

**return** A valid haptic device identifier on success or NULL on error.



**sa** SDL_HapticOpen

**sa** SDL_HapticClose

### SDL_HapticClose

*void SDL_HapticClose(SDL_Haptic * haptic)*



**brief** Closes a haptic device previously opened with SDL_HapticOpen().



**haptic**

### SDL_HapticNumEffects

*int SDL_HapticNumEffects(SDL_Haptic * haptic)*



**brief** Returns the number of effects a haptic device can store.

  On some platforms this isn't fully supported, and therefore is an  approximation.  Always check to see if your created effect was actually  created and do not rely solely on SDL_HapticNumEffects().



**haptic**

**return** The number of effects the haptic device can store or          -1 on error.



**sa** SDL_HapticNumEffectsPlaying

**sa** SDL_HapticQuery

### SDL_HapticNumEffectsPlaying

*int SDL_HapticNumEffectsPlaying(SDL_Haptic * haptic)*



**brief** Returns the number of effects a haptic device can play at the same         time.

  This is not supported on all platforms, but will always return a value.  Added here for the sake of completeness.



**haptic**

**return** The number of effects the haptic device can play at the same time          or -1 on error.



**sa** SDL_HapticNumEffects

**sa** SDL_HapticQuery

### SDL_HapticQuery

*unsigned int SDL_HapticQuery(SDL_Haptic * haptic)*



**brief** Gets the haptic device's supported features in bitwise manner.

  Example:

  if (SDL_HapticQuery(haptic) & SDL_HAPTIC_CONSTANT) {

      printf("We have constant haptic effect!\n");

  }



**haptic**

**return** Haptic features in bitwise manner (OR'd).



**sa** SDL_HapticNumEffects

**sa** SDL_HapticEffectSupported

### SDL_HapticNumAxes

*int SDL_HapticNumAxes(SDL_Haptic * haptic)*



**brief** Gets the number of haptic axes the device has.



**sa** SDL_HapticDirection

### SDL_HapticEffectSupported

*int SDL_HapticEffectSupported(SDL_Haptic * haptic, SDL_HapticEffect * effect)*



**brief** Checks to see if effect is supported by haptic.



**haptic**

**effect**

**return** SDL_TRUE if effect is supported, SDL_FALSE if it isn't or -1 on error.



**sa** SDL_HapticQuery

**sa** SDL_HapticNewEffect

### SDL_HapticNewEffect

*int SDL_HapticNewEffect(SDL_Haptic * haptic, SDL_HapticEffect * effect)*



**brief** Creates a new haptic effect on the device.



**haptic**

**effect**

**return** The identifier of the effect on success or -1 on error.



**sa** SDL_HapticUpdateEffect

**sa** SDL_HapticRunEffect

**sa** SDL_HapticDestroyEffect

### SDL_HapticUpdateEffect

*int SDL_HapticUpdateEffect(SDL_Haptic * haptic, int effect, SDL_HapticEffect * data)*



**brief** Updates the properties of an effect.

  Can be used dynamically, although behavior when dynamically changing  direction may be strange.  Specifically the effect may reupload itself  and start playing from the start.  You cannot change the type either when  running SDL_HapticUpdateEffect().



**haptic**

**effect**

**data**

**return** 0 on success or -1 on error.



**sa** SDL_HapticNewEffect

**sa** SDL_HapticRunEffect

**sa** SDL_HapticDestroyEffect

### SDL_HapticRunEffect

*int SDL_HapticRunEffect(SDL_Haptic * haptic, int effect, Uint32 iterations)*



**brief** Runs the haptic effect on its associated haptic device.

  If iterations are ::SDL_HAPTIC_INFINITY, it'll run the effect over and over  repeating the envelope (attack and fade) every time.  If you only want the  effect to last forever, set ::SDL_HAPTIC_INFINITY in the effect's length  parameter.



**haptic**

**effect**

**iterations**

**return** 0 on success or -1 on error.



**sa** SDL_HapticStopEffect

**sa** SDL_HapticDestroyEffect

**sa** SDL_HapticGetEffectStatus

### SDL_HapticStopEffect

*int SDL_HapticStopEffect(SDL_Haptic * haptic, int effect)*



**brief** Stops the haptic effect on its associated haptic device.



**haptic**

**effect**

**return** 0 on success or -1 on error.



**sa** SDL_HapticRunEffect

**sa** SDL_HapticDestroyEffect

### SDL_HapticDestroyEffect

*void SDL_HapticDestroyEffect(SDL_Haptic * haptic, int effect)*



**brief** Destroys a haptic effect on the device.

  This will stop the effect if it's running.  Effects are automatically  destroyed when the device is closed.



**haptic**

**effect**



**sa** SDL_HapticNewEffect

### SDL_HapticGetEffectStatus

*int SDL_HapticGetEffectStatus(SDL_Haptic * haptic, int effect)*



**brief** Gets the status of the current effect on the haptic device.

  Device must support the ::SDL_HAPTIC_STATUS feature.



**haptic**

**effect**

**return** 0 if it isn't playing, 1 if it is playing or -1 on error.



**sa** SDL_HapticRunEffect

**sa** SDL_HapticStopEffect

### SDL_HapticSetGain

*int SDL_HapticSetGain(SDL_Haptic * haptic, int gain)*



**brief** Sets the global gain of the device.

  Device must support the ::SDL_HAPTIC_GAIN feature.

  The user may specify the maximum gain by setting the environment variable  SDL_HAPTIC_GAIN_MAX which should be between 0 and 100.  All calls to  SDL_HapticSetGain() will scale linearly using SDL_HAPTIC_GAIN_MAX as the  maximum.



**haptic**

**gain**

**return** 0 on success or -1 on error.



**sa** SDL_HapticQuery

### SDL_HapticSetAutocenter

*int SDL_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter)*



**brief** Sets the global autocenter of the device.

  Autocenter should be between 0 and 100.  Setting it to 0 will disable  autocentering.

  Device must support the ::SDL_HAPTIC_AUTOCENTER feature.



**haptic**

**autocenter**

**return** 0 on success or -1 on error.



**sa** SDL_HapticQuery

### SDL_HapticPause

*int SDL_HapticPause(SDL_Haptic * haptic)*



**brief** Pauses a haptic device.

  Device must support the ::SDL_HAPTIC_PAUSE feature.  Call  SDL_HapticUnpause() to resume playback.

  Do not modify the effects nor add new ones while the device is paused.  That can cause all sorts of weird errors.



**haptic**

**return** 0 on success or -1 on error.



**sa** SDL_HapticUnpause

### SDL_HapticUnpause

*int SDL_HapticUnpause(SDL_Haptic * haptic)*



**brief** Unpauses a haptic device.

  Call to unpause after SDL_HapticPause().



**haptic**

**return** 0 on success or -1 on error.



**sa** SDL_HapticPause

### SDL_HapticStopAll

*int SDL_HapticStopAll(SDL_Haptic * haptic)*



**brief** Stops all the currently playing effects on a haptic device.



**haptic**

**return** 0 on success or -1 on error.

### SDL_HapticRumbleSupported

*int SDL_HapticRumbleSupported(SDL_Haptic * haptic)*



**brief** Checks to see if rumble is supported on a haptic device.



**haptic**

**return** SDL_TRUE if effect is supported, SDL_FALSE if it isn't or -1 on error.



**sa** SDL_HapticRumbleInit

**sa** SDL_HapticRumblePlay

**sa** SDL_HapticRumbleStop

### SDL_HapticRumbleInit

*int SDL_HapticRumbleInit(SDL_Haptic * haptic)*



**brief** Initializes the haptic device for simple rumble playback.



**haptic**

**return** 0 on success or -1 on error.



**sa** SDL_HapticOpen

**sa** SDL_HapticRumbleSupported

**sa** SDL_HapticRumblePlay

**sa** SDL_HapticRumbleStop

### SDL_HapticRumblePlay

*int SDL_HapticRumblePlay(SDL_Haptic * haptic, float strength, Uint32 length)*



**brief** Runs simple rumble on a haptic device



**haptic**

**strength**

**length**

**return** 0 on success or -1 on error.



**sa** SDL_HapticRumbleSupported

**sa** SDL_HapticRumbleInit

**sa** SDL_HapticRumbleStop

### SDL_HapticRumbleStop

*int SDL_HapticRumbleStop(SDL_Haptic * haptic)*



**brief** Stops the simple rumble on a haptic device.



**haptic**

**return** 0 on success or -1 on error.



**sa** SDL_HapticRumbleSupported

**sa** SDL_HapticRumbleInit

**sa** SDL_HapticRumblePlay

### SDL_SetHintWithPriority

*SDL_bool SDL_SetHintWithPriority(const char * name, const char * value, SDL_HintPriority priority)*



**brief** Set a hint with a specific priority

  The priority controls the behavior when setting a hint that already  has a value.  Hints will replace existing hints of their priority and  lower.  Environment variables are considered to have override priority.



**return** SDL_TRUE if the hint was set, SDL_FALSE otherwise

### SDL_SetHint

*SDL_bool SDL_SetHint(const char * name, const char * value)*



**brief** Set a hint with normal priority



**return** SDL_TRUE if the hint was set, SDL_FALSE otherwise

### SDL_GetHint

*const char * SDL_GetHint(const char * name)*



**brief** Get a hint



**return** The string value of a hint variable.

### SDL_GetHintBoolean

*SDL_bool SDL_GetHintBoolean(const char * name, SDL_bool default_value)*



**brief** Get a hint



**return** The boolean value of a hint variable.

### SDL_AddHintCallback

*void SDL_AddHintCallback(const char * name, SDL_HintCallback callback, void * userdata)*



**brief** Add a function to watch a particular hint



**name**

**callback**

**userdata**

### SDL_DelHintCallback

*void SDL_DelHintCallback(const char * name, SDL_HintCallback callback, void * userdata)*



**brief** Remove a function watching a particular hint



**name**

**callback**

**userdata**

### SDL_ClearHints

*void SDL_ClearHints()*



**brief**  Clear all hints

  This function is called during SDL_Quit() to free stored hints.

### SDL_LoadObject

*void * SDL_LoadObject(const char * sofile)*

  This function dynamically loads a shared object and returns a pointer  to the object handle (or NULL if there was an error).  The 'sofile' parameter is a system dependent name of the object file.

### SDL_LoadFunction

*void * SDL_LoadFunction(void * handle, const char * name)*

  Given an object handle, this function looks up the address of the  named function in the shared object and returns it.  This address  is no longer valid after calling SDL_UnloadObject().

### SDL_UnloadObject

*void SDL_UnloadObject(void * handle)*

  Unload a shared object from memory.

### SDL_LogSetAllPriority

*void SDL_LogSetAllPriority(SDL_LogPriority priority)*



**brief** Set the priority of all log categories

### SDL_LogSetPriority

*void SDL_LogSetPriority(int category, SDL_LogPriority priority)*



**brief** Set the priority of a particular log category

### SDL_LogGetPriority

*SDL_LogPriority SDL_LogGetPriority(int category)*



**brief** Get the priority of a particular log category

### SDL_LogResetPriorities

*void SDL_LogResetPriorities()*



**brief** Reset all priorities to default.



**note** This is called in SDL_Quit().

### SDL_Log

*void SDL_Log(const char * fmt)*



**brief** Log a message with SDL_LOG_CATEGORY_APPLICATION and SDL_LOG_PRIORITY_INFO

### SDL_LogVerbose

*void SDL_LogVerbose(int category, const char * fmt)*



**brief** Log a message with SDL_LOG_PRIORITY_VERBOSE

### SDL_LogDebug

*void SDL_LogDebug(int category, const char * fmt)*



**brief** Log a message with SDL_LOG_PRIORITY_DEBUG

### SDL_LogInfo

*void SDL_LogInfo(int category, const char * fmt)*



**brief** Log a message with SDL_LOG_PRIORITY_INFO

### SDL_LogWarn

*void SDL_LogWarn(int category, const char * fmt)*



**brief** Log a message with SDL_LOG_PRIORITY_WARN

### SDL_LogError

*void SDL_LogError(int category, const char * fmt)*



**brief** Log a message with SDL_LOG_PRIORITY_ERROR

### SDL_LogCritical

*void SDL_LogCritical(int category, const char * fmt)*



**brief** Log a message with SDL_LOG_PRIORITY_CRITICAL

### SDL_LogMessage

*void SDL_LogMessage(int category, SDL_LogPriority priority, const char * fmt)*



**brief** Log a message with the specified category and priority.

### SDL_LogMessageV

*void SDL_LogMessageV(int category, SDL_LogPriority priority, const char * fmt, va_list ap)*



**brief** Log a message with the specified category and priority.

### SDL_LogGetOutputFunction

*void SDL_LogGetOutputFunction(SDL_LogOutputFunction * callback, void ** userdata)*



**brief** Get the current log output function.

### SDL_LogSetOutputFunction

*void SDL_LogSetOutputFunction(SDL_LogOutputFunction callback, void * userdata)*



**brief** This function allows you to replace the default log output         function with one of your own.

### SDL_ShowMessageBox

*int SDL_ShowMessageBox(const SDL_MessageBoxData * messageboxdata, int * buttonid)*



**brief** Create a modal message box.



**messageboxdata**

**buttonid**



**return** -1 on error, otherwise 0 and buttonid contains user id of button          hit or -1 if dialog was closed.



**note** This function should be called on the thread that created the parent        window, or on the main thread if the messagebox has no parent.  It will        block execution of that thread until the user clicks a button or        closes the messagebox.

### SDL_ShowSimpleMessageBox

*int SDL_ShowSimpleMessageBox(Uint32 flags, const char * title, const char * message, SDL_Window * window)*



**brief** Create a simple modal message box



**flags**

**title**

**message**

**window**



**return** 0 on success, -1 on error



**sa** SDL_ShowMessageBox

### SDL_Metal_CreateView

*SDL_MetalView SDL_Metal_CreateView(SDL_Window * window)*



**brief** Create a CAMetalLayer-backed NSView/UIView and attach it to the        specified window.

  On macOS, this does *not* associate a MTLDevice with the CAMetalLayer on its  own. It is up to user code to do that.

  The returned handle can be casted directly to a NSView or UIView, and the  CAMetalLayer can be accessed from the view's 'layer' property.



  SDL_MetalView metalview = SDL_Metal_CreateView(window);

  UIView *uiview = (__bridge UIView *)metalview;

  CAMetalLayer *metallayer = (CAMetalLayer *)uiview.layer;

  // [...]

  SDL_Metal_DestroyView(metalview);



**sa** SDL_Metal_DestroyView

### SDL_Metal_DestroyView

*void SDL_Metal_DestroyView(SDL_MetalView view)*



**brief** Destroy an existing SDL_MetalView object.

  This should be called before SDL_DestroyWindow, if SDL_Metal_CreateView was  called after SDL_CreateWindow.



**sa** SDL_Metal_CreateView

### SDL_GetPowerInfo

*SDL_PowerState SDL_GetPowerInfo(int * secs, int * pct)*



**brief** Get the current power supply details.



**secs**



**pct**



**return** The state of the battery (if any).

### SDL_GetNumRenderDrivers

*int SDL_GetNumRenderDrivers()*



**brief** Get the number of 2D rendering drivers available for the current         display.

  A render driver is a set of code that handles rendering and texture  management on a particular display.  Normally there is only one, but  some drivers may have several available with different capabilities.



**sa** SDL_GetRenderDriverInfo()

**sa** SDL_CreateRenderer()

### SDL_GetRenderDriverInfo

*int SDL_GetRenderDriverInfo(int index, SDL_RendererInfo * info)*



**brief** Get information about a specific 2D rendering driver for the current         display.



**index**

**info**



**return** 0 on success, -1 if the index was out of range.



**sa** SDL_CreateRenderer()

### SDL_CreateWindowAndRenderer

*int SDL_CreateWindowAndRenderer(int width, int height, Uint32 window_flags, SDL_Window ** window, SDL_Renderer ** renderer)*



**brief** Create a window and default renderer



**width**

**height**

**window_flags**

**window**

**renderer**



**return** 0 on success, or -1 on error

### SDL_CreateRenderer

*SDL_Renderer * SDL_CreateRenderer(SDL_Window * window, int index, Uint32 flags)*



**brief** Create a 2D rendering context for a window.



**window**

**index**

**flags**



**return** A valid rendering context or NULL if there was an error.



**sa** SDL_CreateSoftwareRenderer()

**sa** SDL_GetRendererInfo()

**sa** SDL_DestroyRenderer()

### SDL_CreateSoftwareRenderer

*SDL_Renderer * SDL_CreateSoftwareRenderer(SDL_Surface * surface)*



**brief** Create a 2D software rendering context for a surface.



**surface**



**return** A valid rendering context or NULL if there was an error.



**sa** SDL_CreateRenderer()

**sa** SDL_DestroyRenderer()

### SDL_GetRenderer

*SDL_Renderer * SDL_GetRenderer(SDL_Window * window)*



**brief** Get the renderer associated with a window.

### SDL_GetRendererInfo

*int SDL_GetRendererInfo(SDL_Renderer * renderer, SDL_RendererInfo * info)*



**brief** Get information about a rendering context.

### SDL_GetRendererOutputSize

*int SDL_GetRendererOutputSize(SDL_Renderer * renderer, int * w, int * h)*



**brief** Get the output size in pixels of a rendering context.

### SDL_CreateTexture

*SDL_Texture * SDL_CreateTexture(SDL_Renderer * renderer, Uint32 format, int access, int w, int h)*



**brief** Create a texture for a rendering context.



**renderer**

**format**

**access**

**w**

**h**



**return** The created texture is returned, or NULL if no rendering context was          active,  the format was unsupported, or the width or height were out          of range.



**note** The contents of the texture are not defined at creation.



**sa** SDL_QueryTexture()

**sa** SDL_UpdateTexture()

**sa** SDL_DestroyTexture()

### SDL_CreateTextureFromSurface

*SDL_Texture * SDL_CreateTextureFromSurface(SDL_Renderer * renderer, SDL_Surface * surface)*



**brief** Create a texture from an existing surface.



**renderer**

**surface**



**return** The created texture is returned, or NULL on error.



**note** The surface is not modified or freed by this function.



**sa** SDL_QueryTexture()

**sa** SDL_DestroyTexture()

### SDL_QueryTexture

*int SDL_QueryTexture(SDL_Texture * texture, Uint32 * format, int * access, int * w, int * h)*



**brief** Query the attributes of a texture



**texture**

**format**

**access**

**w**

**h**



**return** 0 on success, or -1 if the texture is not valid.

### SDL_SetTextureColorMod

*int SDL_SetTextureColorMod(SDL_Texture * texture, Uint8 r, Uint8 g, Uint8 b)*



**brief** Set an additional color value used in render copy operations.



**texture**

**r**

**g**

**b**



**return** 0 on success, or -1 if the texture is not valid or color modulation          is not supported.



**sa** SDL_GetTextureColorMod()

### SDL_GetTextureColorMod

*int SDL_GetTextureColorMod(SDL_Texture * texture, Uint8 * r, Uint8 * g, Uint8 * b)*



**brief** Get the additional color value used in render copy operations.



**texture**

**r**

**g**

**b**



**return** 0 on success, or -1 if the texture is not valid.



**sa** SDL_SetTextureColorMod()

### SDL_SetTextureAlphaMod

*int SDL_SetTextureAlphaMod(SDL_Texture * texture, Uint8 alpha)*



**brief** Set an additional alpha value used in render copy operations.



**texture**

**alpha**



**return** 0 on success, or -1 if the texture is not valid or alpha modulation          is not supported.



**sa** SDL_GetTextureAlphaMod()

### SDL_GetTextureAlphaMod

*int SDL_GetTextureAlphaMod(SDL_Texture * texture, Uint8 * alpha)*



**brief** Get the additional alpha value used in render copy operations.



**texture**

**alpha**



**return** 0 on success, or -1 if the texture is not valid.



**sa** SDL_SetTextureAlphaMod()

### SDL_SetTextureBlendMode

*int SDL_SetTextureBlendMode(SDL_Texture * texture, SDL_BlendMode blendMode)*



**brief** Set the blend mode used for texture copy operations.



**texture**

**blendMode**



**return** 0 on success, or -1 if the texture is not valid or the blend mode is          not supported.



**note** If the blend mode is not supported, the closest supported mode is        chosen.



**sa** SDL_GetTextureBlendMode()

### SDL_GetTextureBlendMode

*int SDL_GetTextureBlendMode(SDL_Texture * texture, SDL_BlendMode * blendMode)*



**brief** Get the blend mode used for texture copy operations.



**texture**

**blendMode**



**return** 0 on success, or -1 if the texture is not valid.



**sa** SDL_SetTextureBlendMode()

### SDL_SetTextureScaleMode

*int SDL_SetTextureScaleMode(SDL_Texture * texture, SDL_ScaleMode scaleMode)*



**brief** Set the scale mode used for texture scale operations.



**texture**

**scaleMode**



**return** 0 on success, or -1 if the texture is not valid.



**note** If the scale mode is not supported, the closest supported mode is        chosen.



**sa** SDL_GetTextureScaleMode()

### SDL_GetTextureScaleMode

*int SDL_GetTextureScaleMode(SDL_Texture * texture, SDL_ScaleMode * scaleMode)*



**brief** Get the scale mode used for texture scale operations.



**texture**

**scaleMode**



**return** 0 on success, or -1 if the texture is not valid.



**sa** SDL_SetTextureScaleMode()

### SDL_UpdateTexture

*int SDL_UpdateTexture(SDL_Texture * texture, const SDL_Rect * rect, const void * pixels, int pitch)*



**brief** Update the given texture rectangle with new pixel data.



**texture**

**rect**

**pixels**

**pitch**

  The pixel data must be in the format of the texture. The pixel format can be  queried with SDL_QueryTexture.



**return** 0 on success, or -1 if the texture is not valid.



**note** This is a fairly slow function.

### SDL_UpdateYUVTexture

*int SDL_UpdateYUVTexture(SDL_Texture * texture, const SDL_Rect * rect, const Uint8 * Yplane, int Ypitch, const Uint8 * Uplane, int Upitch, const Uint8 * Vplane, int Vpitch)*



**brief** Update a rectangle within a planar YV12 or IYUV texture with new pixel data.



**texture**

**rect**

**Yplane**

**Ypitch**

**Uplane**

**Upitch**

**Vplane**

**Vpitch**



**return** 0 on success, or -1 if the texture is not valid.



**note** You can use SDL_UpdateTexture() as long as your pixel data is        a contiguous block of Y and U/V planes in the proper order, but        this function is available if your pixel data is not contiguous.

### SDL_LockTexture

*int SDL_LockTexture(SDL_Texture * texture, const SDL_Rect * rect, void ** pixels, int * pitch)*



**brief** Lock a portion of the texture for write-only pixel access.



**texture**

**rect**

**pixels**

**pitch**



**return** 0 on success, or -1 if the texture is not valid or was not created with ::SDL_TEXTUREACCESS_STREAMING.



**sa** SDL_UnlockTexture()

### SDL_LockTextureToSurface

*int SDL_LockTextureToSurface(SDL_Texture * texture, const SDL_Rect * rect, SDL_Surface ** surface)*



**brief** Lock a portion of the texture for write-only pixel access.         Expose it as a SDL surface.



**texture**

**rect**

**surface**



**return** 0 on success, or -1 if the texture is not valid or was not created with ::SDL_TEXTUREACCESS_STREAMING.



**sa** SDL_UnlockTexture()

### SDL_UnlockTexture

*void SDL_UnlockTexture(SDL_Texture * texture)*



**brief** Unlock a texture, uploading the changes to video memory, if needed.         If SDL_LockTextureToSurface() was called for locking, the SDL surface is freed.



**sa** SDL_LockTexture()

**sa** SDL_LockTextureToSurface()

### SDL_RenderTargetSupported

*SDL_bool SDL_RenderTargetSupported(SDL_Renderer * renderer)*



**brief** Determines whether a window supports the use of render targets



**renderer**



**return** SDL_TRUE if supported, SDL_FALSE if not.

### SDL_SetRenderTarget

*int SDL_SetRenderTarget(SDL_Renderer * renderer, SDL_Texture * texture)*



**brief** Set a texture as the current rendering target.



**renderer**

**texture**



**return** 0 on success, or -1 on error



**sa** SDL_GetRenderTarget()

### SDL_GetRenderTarget

*SDL_Texture * SDL_GetRenderTarget(SDL_Renderer * renderer)*



**brief** Get the current render target or NULL for the default render target.



**return** The current render target



**sa** SDL_SetRenderTarget()

### SDL_RenderSetLogicalSize

*int SDL_RenderSetLogicalSize(SDL_Renderer * renderer, int w, int h)*



**brief** Set device independent resolution for rendering



**renderer**

**w**

**h**

  This function uses the viewport and scaling functionality to allow a fixed logical  resolution for rendering, regardless of the actual output resolution.  If the actual  output resolution doesn't have the same aspect ratio the output rendering will be  centered within the output display.

  If the output display is a window, mouse events in the window will be filtered  and scaled so they seem to arrive within the logical resolution.



**note** If this function results in scaling or subpixel drawing by the        rendering backend, it will be handled using the appropriate        quality hints.



**sa** SDL_RenderGetLogicalSize()

**sa** SDL_RenderSetScale()

**sa** SDL_RenderSetViewport()

### SDL_RenderGetLogicalSize

*void SDL_RenderGetLogicalSize(SDL_Renderer * renderer, int * w, int * h)*



**brief** Get device independent resolution for rendering



**renderer**

**w**

**h**



**sa** SDL_RenderSetLogicalSize()

### SDL_RenderSetIntegerScale

*int SDL_RenderSetIntegerScale(SDL_Renderer * renderer, SDL_bool enable)*



**brief** Set whether to force integer scales for resolution-independent rendering



**renderer**

**enable**

  This function restricts the logical viewport to integer values - that is, when  a resolution is between two multiples of a logical size, the viewport size is  rounded down to the lower multiple.



**sa** SDL_RenderSetLogicalSize()

### SDL_RenderGetIntegerScale

*SDL_bool SDL_RenderGetIntegerScale(SDL_Renderer * renderer)*



**brief** Get whether integer scales are forced for resolution-independent rendering



**renderer**



**sa** SDL_RenderSetIntegerScale()

### SDL_RenderSetViewport

*int SDL_RenderSetViewport(SDL_Renderer * renderer, const SDL_Rect * rect)*



**brief** Set the drawing area for rendering on the current target.



**renderer**

**rect**

  The x,y of the viewport rect represents the origin for rendering.



**return** 0 on success, or -1 on error



**note** If the window associated with the renderer is resized, the viewport is automatically reset.



**sa** SDL_RenderGetViewport()

**sa** SDL_RenderSetLogicalSize()

### SDL_RenderGetViewport

*void SDL_RenderGetViewport(SDL_Renderer * renderer, SDL_Rect * rect)*



**brief** Get the drawing area for the current target.



**sa** SDL_RenderSetViewport()

### SDL_RenderSetClipRect

*int SDL_RenderSetClipRect(SDL_Renderer * renderer, const SDL_Rect * rect)*



**brief** Set the clip rectangle for the current target.



**renderer**

**rect**



**return** 0 on success, or -1 on error



**sa** SDL_RenderGetClipRect()

### SDL_RenderGetClipRect

*void SDL_RenderGetClipRect(SDL_Renderer * renderer, SDL_Rect * rect)*



**brief** Get the clip rectangle for the current target.



**renderer**

**rect**



**sa** SDL_RenderSetClipRect()

### SDL_RenderIsClipEnabled

*SDL_bool SDL_RenderIsClipEnabled(SDL_Renderer * renderer)*



**brief** Get whether clipping is enabled on the given renderer.



**renderer**



**sa** SDL_RenderGetClipRect()

### SDL_RenderSetScale

*int SDL_RenderSetScale(SDL_Renderer * renderer, float scaleX, float scaleY)*



**brief** Set the drawing scale for rendering on the current target.



**renderer**

**scaleX**

**scaleY**

  The drawing coordinates are scaled by the x/y scaling factors  before they are used by the renderer.  This allows resolution  independent drawing with a single coordinate system.



**note** If this results in scaling or subpixel drawing by the        rendering backend, it will be handled using the appropriate        quality hints.  For best results use integer scaling factors.



**sa** SDL_RenderGetScale()

**sa** SDL_RenderSetLogicalSize()

### SDL_RenderGetScale

*void SDL_RenderGetScale(SDL_Renderer * renderer, float * scaleX, float * scaleY)*



**brief** Get the drawing scale for the current target.



**renderer**

**scaleX**

**scaleY**



**sa** SDL_RenderSetScale()

### SDL_SetRenderDrawColor

*int SDL_SetRenderDrawColor(SDL_Renderer * renderer, Uint8 r, Uint8 g, Uint8 b, Uint8 a)*



**brief** Set the color used for drawing operations (Rect, Line and Clear).



**renderer**

**r**

**g**

**b**

**a**



**return** 0 on success, or -1 on error

### SDL_GetRenderDrawColor

*int SDL_GetRenderDrawColor(SDL_Renderer * renderer, Uint8 * r, Uint8 * g, Uint8 * b, Uint8 * a)*



**brief** Get the color used for drawing operations (Rect, Line and Clear).



**renderer**

**r**

**g**

**b**

**a**



**return** 0 on success, or -1 on error

### SDL_SetRenderDrawBlendMode

*int SDL_SetRenderDrawBlendMode(SDL_Renderer * renderer, SDL_BlendMode blendMode)*



**brief** Set the blend mode used for drawing operations (Fill and Line).



**renderer**

**blendMode**



**return** 0 on success, or -1 on error



**note** If the blend mode is not supported, the closest supported mode is        chosen.



**sa** SDL_GetRenderDrawBlendMode()

### SDL_GetRenderDrawBlendMode

*int SDL_GetRenderDrawBlendMode(SDL_Renderer * renderer, SDL_BlendMode * blendMode)*



**brief** Get the blend mode used for drawing operations.



**renderer**

**blendMode**



**return** 0 on success, or -1 on error



**sa** SDL_SetRenderDrawBlendMode()

### SDL_RenderClear

*int SDL_RenderClear(SDL_Renderer * renderer)*



**brief** Clear the current rendering target with the drawing color

  This function clears the entire rendering target, ignoring the viewport and  the clip rectangle.



**return** 0 on success, or -1 on error

### SDL_RenderDrawPoint

*int SDL_RenderDrawPoint(SDL_Renderer * renderer, int x, int y)*



**brief** Draw a point on the current rendering target.



**renderer**

**x**

**y**



**return** 0 on success, or -1 on error

### SDL_RenderDrawPoints

*int SDL_RenderDrawPoints(SDL_Renderer * renderer, const SDL_Point * points, int count)*



**brief** Draw multiple points on the current rendering target.



**renderer**

**points**

**count**



**return** 0 on success, or -1 on error

### SDL_RenderDrawLine

*int SDL_RenderDrawLine(SDL_Renderer * renderer, int x1, int y1, int x2, int y2)*



**brief** Draw a line on the current rendering target.



**renderer**

**x1**

**y1**

**x2**

**y2**



**return** 0 on success, or -1 on error

### SDL_RenderDrawLines

*int SDL_RenderDrawLines(SDL_Renderer * renderer, const SDL_Point * points, int count)*



**brief** Draw a series of connected lines on the current rendering target.



**renderer**

**points**

**count**



**return** 0 on success, or -1 on error

### SDL_RenderDrawRect

*int SDL_RenderDrawRect(SDL_Renderer * renderer, const SDL_Rect * rect)*



**brief** Draw a rectangle on the current rendering target.



**renderer**

**rect**



**return** 0 on success, or -1 on error

### SDL_RenderDrawRects

*int SDL_RenderDrawRects(SDL_Renderer * renderer, const SDL_Rect * rects, int count)*



**brief** Draw some number of rectangles on the current rendering target.



**renderer**

**rects**

**count**



**return** 0 on success, or -1 on error

### SDL_RenderFillRect

*int SDL_RenderFillRect(SDL_Renderer * renderer, const SDL_Rect * rect)*



**brief** Fill a rectangle on the current rendering target with the drawing color.



**renderer**

**rect**



**return** 0 on success, or -1 on error

### SDL_RenderFillRects

*int SDL_RenderFillRects(SDL_Renderer * renderer, const SDL_Rect * rects, int count)*



**brief** Fill some number of rectangles on the current rendering target with the drawing color.



**renderer**

**rects**

**count**



**return** 0 on success, or -1 on error

### SDL_RenderCopy

*int SDL_RenderCopy(SDL_Renderer * renderer, SDL_Texture * texture, const SDL_Rect * srcrect, const SDL_Rect * dstrect)*



**brief** Copy a portion of the texture to the current rendering target.



**renderer**

**texture**

**srcrect**

**dstrect**



**return** 0 on success, or -1 on error

### SDL_RenderCopyEx

*int SDL_RenderCopyEx(SDL_Renderer * renderer, SDL_Texture * texture, const SDL_Rect * srcrect, const SDL_Rect * dstrect, const double angle, const SDL_Point * center, const SDL_RendererFlip flip)*



**brief** Copy a portion of the source texture to the current rendering target, rotating it by angle around the given center



**renderer**

**texture**

**srcrect**

**dstrect**

**angle**

**center**

**flip**



**return** 0 on success, or -1 on error

### SDL_RenderDrawPointF

*int SDL_RenderDrawPointF(SDL_Renderer * renderer, float x, float y)*



**brief** Draw a point on the current rendering target.



**renderer**

**x**

**y**



**return** 0 on success, or -1 on error

### SDL_RenderDrawPointsF

*int SDL_RenderDrawPointsF(SDL_Renderer * renderer, const SDL_FPoint * points, int count)*



**brief** Draw multiple points on the current rendering target.



**renderer**

**points**

**count**



**return** 0 on success, or -1 on error

### SDL_RenderDrawLineF

*int SDL_RenderDrawLineF(SDL_Renderer * renderer, float x1, float y1, float x2, float y2)*



**brief** Draw a line on the current rendering target.



**renderer**

**x1**

**y1**

**x2**

**y2**



**return** 0 on success, or -1 on error

### SDL_RenderDrawLinesF

*int SDL_RenderDrawLinesF(SDL_Renderer * renderer, const SDL_FPoint * points, int count)*



**brief** Draw a series of connected lines on the current rendering target.



**renderer**

**points**

**count**



**return** 0 on success, or -1 on error

### SDL_RenderDrawRectF

*int SDL_RenderDrawRectF(SDL_Renderer * renderer, const SDL_FRect * rect)*



**brief** Draw a rectangle on the current rendering target.



**renderer**

**rect**



**return** 0 on success, or -1 on error

### SDL_RenderDrawRectsF

*int SDL_RenderDrawRectsF(SDL_Renderer * renderer, const SDL_FRect * rects, int count)*



**brief** Draw some number of rectangles on the current rendering target.



**renderer**

**rects**

**count**



**return** 0 on success, or -1 on error

### SDL_RenderFillRectF

*int SDL_RenderFillRectF(SDL_Renderer * renderer, const SDL_FRect * rect)*



**brief** Fill a rectangle on the current rendering target with the drawing color.



**renderer**

**rect**



**return** 0 on success, or -1 on error

### SDL_RenderFillRectsF

*int SDL_RenderFillRectsF(SDL_Renderer * renderer, const SDL_FRect * rects, int count)*



**brief** Fill some number of rectangles on the current rendering target with the drawing color.



**renderer**

**rects**

**count**



**return** 0 on success, or -1 on error

### SDL_RenderCopyF

*int SDL_RenderCopyF(SDL_Renderer * renderer, SDL_Texture * texture, const SDL_Rect * srcrect, const SDL_FRect * dstrect)*



**brief** Copy a portion of the texture to the current rendering target.



**renderer**

**texture**

**srcrect**

**dstrect**



**return** 0 on success, or -1 on error

### SDL_RenderCopyExF

*int SDL_RenderCopyExF(SDL_Renderer * renderer, SDL_Texture * texture, const SDL_Rect * srcrect, const SDL_FRect * dstrect, const double angle, const SDL_FPoint * center, const SDL_RendererFlip flip)*



**brief** Copy a portion of the source texture to the current rendering target, rotating it by angle around the given center



**renderer**

**texture**

**srcrect**

**dstrect**

**angle**

**center**

**flip**



**return** 0 on success, or -1 on error

### SDL_RenderReadPixels

*int SDL_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect, Uint32 format, void * pixels, int pitch)*



**brief** Read pixels from the current rendering target.



**renderer**

**rect**

**format**

**pixels**

**pitch**



**return** 0 on success, or -1 if pixel reading is not supported.



**warning** This is a very slow operation, and should not be used frequently.

### SDL_RenderPresent

*void SDL_RenderPresent(SDL_Renderer * renderer)*



**brief** Update the screen with rendering performed.

### SDL_DestroyTexture

*void SDL_DestroyTexture(SDL_Texture * texture)*



**brief** Destroy the specified texture.



**sa** SDL_CreateTexture()

**sa** SDL_CreateTextureFromSurface()

### SDL_DestroyRenderer

*void SDL_DestroyRenderer(SDL_Renderer * renderer)*



**brief** Destroy the rendering context for a window and free associated         textures.



**sa** SDL_CreateRenderer()

### SDL_RenderFlush

*int SDL_RenderFlush(SDL_Renderer * renderer)*



**brief** Force the rendering context to flush any pending commands to the         underlying rendering API.

  You do not need to (and in fact, shouldn't) call this function unless  you are planning to call into OpenGL/Direct3D/Metal/whatever directly  in addition to using an SDL_Renderer.

  This is for a very-specific case: if you are using SDL's render API,  you asked for a specific renderer backend (OpenGL, Direct3D, etc),  you set SDL_HINT_RENDER_BATCHING to "1", and you plan to make  OpenGL/D3D/whatever calls in addition to SDL render API calls. If all of  this applies, you should call SDL_RenderFlush() between calls to SDL's  render API and the low-level API you're using in cooperation.

  In all other cases, you can ignore this function. This is only here to  get maximum performance out of a specific situation. In all other cases,  SDL will do the right thing, perhaps at a performance loss.

  This function is first available in SDL 2.0.10, and is not needed in  2.0.9 and earlier, as earlier versions did not queue rendering commands  at all, instead flushing them to the OS immediately.

### SDL_GL_BindTexture

*int SDL_GL_BindTexture(SDL_Texture * texture, float * texw, float * texh)*



**brief** Bind the texture to the current OpenGL/ES/ES2 context for use with         OpenGL instructions.



**texture**

**texw**

**texh**



**return** 0 on success, or -1 if the operation is not supported

### SDL_GL_UnbindTexture

*int SDL_GL_UnbindTexture(SDL_Texture * texture)*



**brief** Unbind a texture from the current OpenGL/ES/ES2 context.



**texture**



**return** 0 on success, or -1 if the operation is not supported

### SDL_RenderGetMetalLayer

*void * SDL_RenderGetMetalLayer(SDL_Renderer * renderer)*



**brief** Get the CAMetalLayer associated with the given Metal renderer



**renderer**



**return** CAMetalLayer* on success, or NULL if the renderer isn't a Metal renderer



**sa** SDL_RenderGetMetalCommandEncoder()

### SDL_RenderGetMetalCommandEncoder

*void * SDL_RenderGetMetalCommandEncoder(SDL_Renderer * renderer)*



**brief** Get the Metal command encoder for the current frame



**renderer**



**return** id<MTLRenderCommandEncoder> on success, or NULL if the renderer isn't a Metal renderer



**sa** SDL_RenderGetMetalLayer()

### SDL_NumSensors

*int SDL_NumSensors()*



**brief** Count the number of sensors attached to the system right now

### SDL_SensorGetDeviceName

*const char * SDL_SensorGetDeviceName(int device_index)*



**brief** Get the implementation dependent name of a sensor.

  This can be called before any sensors are opened.



**return** The sensor name, or NULL if device_index is out of range.

### SDL_SensorGetDeviceType

*SDL_SensorType SDL_SensorGetDeviceType(int device_index)*



**brief** Get the type of a sensor.

  This can be called before any sensors are opened.



**return** The sensor type, or SDL_SENSOR_INVALID if device_index is out of range.

### SDL_SensorGetDeviceNonPortableType

*int SDL_SensorGetDeviceNonPortableType(int device_index)*



**brief** Get the platform dependent type of a sensor.

  This can be called before any sensors are opened.



**return** The sensor platform dependent type, or -1 if device_index is out of range.

### SDL_SensorGetDeviceInstanceID

*SDL_SensorID SDL_SensorGetDeviceInstanceID(int device_index)*



**brief** Get the instance ID of a sensor.

  This can be called before any sensors are opened.



**return** The sensor instance ID, or -1 if device_index is out of range.

### SDL_SensorOpen

*SDL_Sensor * SDL_SensorOpen(int device_index)*



**brief** Open a sensor for use.

  The index passed as an argument refers to the N'th sensor on the system.



**return** A sensor identifier, or NULL if an error occurred.

### SDL_SensorFromInstanceID

*SDL_Sensor * SDL_SensorFromInstanceID(SDL_SensorID instance_id)*

 Return the SDL_Sensor associated with an instance id.

### SDL_SensorGetName

*const char * SDL_SensorGetName(SDL_Sensor * sensor)*



**brief** Get the implementation dependent name of a sensor.



**return** The sensor name, or NULL if the sensor is NULL.

### SDL_SensorGetType

*SDL_SensorType SDL_SensorGetType(SDL_Sensor * sensor)*



**brief** Get the type of a sensor.

  This can be called before any sensors are opened.



**return** The sensor type, or SDL_SENSOR_INVALID if the sensor is NULL.

### SDL_SensorGetNonPortableType

*int SDL_SensorGetNonPortableType(SDL_Sensor * sensor)*



**brief** Get the platform dependent type of a sensor.

  This can be called before any sensors are opened.



**return** The sensor platform dependent type, or -1 if the sensor is NULL.

### SDL_SensorGetInstanceID

*SDL_SensorID SDL_SensorGetInstanceID(SDL_Sensor * sensor)*



**brief** Get the instance ID of a sensor.

  This can be called before any sensors are opened.



**return** The sensor instance ID, or -1 if the sensor is NULL.

### SDL_SensorGetData

*int SDL_SensorGetData(SDL_Sensor * sensor, float * data, int num_values)*

  Get the current state of an opened sensor.

  The number of values and interpretation of the data is sensor dependent.



**sensor**

**data**

**num_values**



**return** 0 or -1 if an error occurred.

### SDL_SensorClose

*void SDL_SensorClose(SDL_Sensor * sensor)*

  Close a sensor previously opened with SDL_SensorOpen()

### SDL_SensorUpdate

*void SDL_SensorUpdate()*

  Update the current state of the open sensors.

  This is called automatically by the event loop if sensor events are enabled.

  This needs to be called from the thread that initialized the sensor subsystem.

### SDL_CreateShapedWindow

*SDL_Window * SDL_CreateShapedWindow(const char * title, unsigned int x, unsigned int y, unsigned int w, unsigned int h, Uint32 flags)*



**brief** Create a window that can be shaped with the specified position, dimensions, and flags.



**title**

**x**

**y**

**w**

**h**

**flags**



**return** The window created, or NULL if window creation failed.



**sa** SDL_DestroyWindow()

### SDL_IsShapedWindow

*SDL_bool SDL_IsShapedWindow(const SDL_Window * window)*



**brief** Return whether the given window is a shaped window.



**window**



**return** SDL_TRUE if the window is a window that can be shaped, SDL_FALSE if the window is unshaped or NULL.



**sa** SDL_CreateShapedWindow

### SDL_SetWindowShape

*int SDL_SetWindowShape(SDL_Window * window, SDL_Surface * shape, SDL_WindowShapeMode * shape_mode)*



**brief** Set the shape and parameters of a shaped window.



**window**

**shape**

**shape_mode**



**return** 0 on success, SDL_INVALID_SHAPE_ARGUMENT on an invalid shape argument, or SDL_NONSHAPEABLE_WINDOW           if the SDL_Window given does not reference a valid shaped window.



**sa** SDL_WindowShapeMode

**sa** SDL_GetShapedWindowMode.

### SDL_GetShapedWindowMode

*int SDL_GetShapedWindowMode(SDL_Window * window, SDL_WindowShapeMode * shape_mode)*



**brief** Get the shape parameters of a shaped window.



**window**

**shape_mode**



**return** 0 if the window has a shape and, provided shape_mode was not NULL, shape_mode has been filled with the mode           data, SDL_NONSHAPEABLE_WINDOW if the SDL_Window given is not a shaped window, or SDL_WINDOW_LACKS_SHAPE if           the SDL_Window given is a shapeable window currently lacking a shape.



**sa** SDL_WindowShapeMode

**sa** SDL_SetWindowShape

### SDL_LinuxSetThreadPriority

*int SDL_LinuxSetThreadPriority(Sint64 threadID, int priority)*



**brief** Sets the UNIX nice value for a thread, using setpriority() if possible, and RealtimeKit if available.



**return** 0 on success, or -1 on error.

### SDL_IsTablet

*SDL_bool SDL_IsTablet()*



**brief** Return true if the current device is a tablet.

### SDL_OnApplicationWillTerminate

*void SDL_OnApplicationWillTerminate()*

 Functions used by iOS application delegates to notify SDL about state changes 

### SDL_OnApplicationDidReceiveMemoryWarning

*void SDL_OnApplicationDidReceiveMemoryWarning()*

### SDL_OnApplicationWillResignActive

*void SDL_OnApplicationWillResignActive()*

### SDL_OnApplicationDidEnterBackground

*void SDL_OnApplicationDidEnterBackground()*

### SDL_OnApplicationWillEnterForeground

*void SDL_OnApplicationWillEnterForeground()*

### SDL_OnApplicationDidBecomeActive

*void SDL_OnApplicationDidBecomeActive()*

### SDL_GetTicks

*Uint32 SDL_GetTicks()*



**brief** Get the number of milliseconds since the SDL library initialization.



**note** This value wraps if the program runs for more than ~49 days.

### SDL_GetPerformanceCounter

*Uint64 SDL_GetPerformanceCounter()*



**brief** Get the current value of the high resolution counter

### SDL_GetPerformanceFrequency

*Uint64 SDL_GetPerformanceFrequency()*



**brief** Get the count per second of the high resolution counter

### SDL_Delay

*void SDL_Delay(Uint32 ms)*



**brief** Wait a specified number of milliseconds before returning.

### SDL_AddTimer

*SDL_TimerID SDL_AddTimer(Uint32 interval, SDL_TimerCallback callback, void * param)*



**brief** Add a new timer to the pool of timers already running.



**return** A timer ID, or 0 when an error occurs.

### SDL_RemoveTimer

*SDL_bool SDL_RemoveTimer(SDL_TimerID id)*



**brief** Remove a timer knowing its ID.



**return** A boolean value indicating success or failure.



**warning** It is not safe to remove a timer multiple times.

### SDL_GetVersion

*void SDL_GetVersion(SDL_version * ver)*



**brief** Get the version of SDL that is linked against your program.

  If you are linking to SDL dynamically, then it is possible that the  current version will be different than the version you compiled against.  This function returns the current version, while SDL_VERSION() is a  macro that tells you what version you compiled with.



  SDL_version compiled;

  SDL_version linked;



  SDL_VERSION(&compiled);

  SDL_GetVersion(&linked);

  printf("We compiled against SDL version %d.%d.%d ...\n",

         compiled.major, compiled.minor, compiled.patch);

  printf("But we linked against SDL version %d.%d.%d.\n",

         linked.major, linked.minor, linked.patch);

  This function may be called safely at any time, even before SDL_Init().



**sa** SDL_VERSION

### SDL_GetRevision

*const char * SDL_GetRevision()*



**brief** Get the code revision of SDL that is linked against your program.

  Returns an arbitrary string (a hash value) uniquely identifying the  exact revision of the SDL library in use, and is only useful in comparing  against other revisions. It is NOT an incrementing number.

### SDL_GetRevisionNumber

*int SDL_GetRevisionNumber()*



**brief** Get the revision number of SDL that is linked against your program.

  Returns a number uniquely identifying the exact revision of the SDL  library in use. It is an incrementing number based on commits to  hg.libsdl.org.

### SDL_Init

*int SDL_Init(Uint32 flags)*

  This function initializes  the subsystems specified by **c** 

### SDL_InitSubSystem

*int SDL_InitSubSystem(Uint32 flags)*

  This function initializes specific SDL subsystems

  Subsystem initialization is ref-counted, you must call  SDL_QuitSubSystem() for each SDL_InitSubSystem() to correctly  shutdown a subsystem manually (or call SDL_Quit() to force shutdown).  If a subsystem is already loaded then this call will  increase the ref-count and return.

### SDL_QuitSubSystem

*void SDL_QuitSubSystem(Uint32 flags)*

  This function cleans up specific SDL subsystems

### SDL_WasInit

*Uint32 SDL_WasInit(Uint32 flags)*

  This function returns a mask of the specified subsystems which have  previously been initialized.

  If **c**  is 0, it returns a mask of all initialized subsystems.

### SDL_Quit

*void SDL_Quit()*

  This function cleans up all initialized subsystems. You should  call it upon all exit conditions.

### Platform_DoubleTime

*double Platform_DoubleTime()*

*Defined at line 20 of ./engine/platform/sdl/sys_sdl.cpp*

==============================================================================

                       SYSTEM UTILS

==============================================================================

### Platform_Sleep

*void Platform_Sleep(int msec)*

*Defined at line 35 of ./engine/platform/sdl/sys_sdl.cpp*

### Platform_ShellExecute

*void Platform_ShellExecute(const char * path, const char * parms)*

*Defined at line 70 of ./engine/platform/posix/sys_posix.cpp*

### Platform_MessageBox

*void Platform_MessageBox(const char * title, const char * message, qboolean parentMainWindow)*

*Defined at line 41 of ./engine/platform/sdl/sys_sdl.cpp*

### Platform_Vibrate

*void Platform_Vibrate(float life, char flags)*

*Defined at line 86 of ./engine/platform/sdl/in_sdl.cpp*

============================================================================== 

			MOBILE API 

============================================================================== 

=============Platform_Vibrate

=============

### Platform_GetNativeObject

*void * Platform_GetNativeObject(const char * name)*

*Defined at line 458 of ./engine/platform/sdl/events.cpp*

### Platform_JoyInit

*int Platform_JoyInit(int numjoy)*

*Defined at line 241 of ./engine/platform/sdl/in_sdl.cpp*

============================================================================== 

			INPUT 

============================================================================== 

 Gamepad support

=============Platform_JoyInit

=============

### Platform_EnableTextInput

*void Platform_EnableTextInput(qboolean enable)*

*Defined at line 97 of ./engine/platform/sdl/in_sdl.cpp*

 Text input

=============SDLash_EnableTextInput

=============

### Platform_RunEvents

*void Platform_RunEvents()*

*Defined at line 450 of ./engine/platform/sdl/events.cpp*

 System events

=============SDLash_RunEvents

=============

### Platform_GetMousePos

*void Platform_GetMousePos(int * x, int * y)*

*Defined at line 36 of ./engine/platform/sdl/in_sdl.cpp*

 Mouse

=============Platform_GetMousePos

=============

### Platform_SetMousePos

*void Platform_SetMousePos(int x, int y)*

*Defined at line 47 of ./engine/platform/sdl/in_sdl.cpp*

=============Platform_SetMousePos

============

### Platform_PreCreateMove

*void Platform_PreCreateMove()*

*Defined at line 471 of ./engine/platform/sdl/events.cpp*

========================Platform_PreCreateMove

this should disable mouse look on client when m_ignore enabledTODO: kill mouse in win32 clients too========================

### Platform_GetClipboardText

*void Platform_GetClipboardText(char * buffer, size_t size)*

*Defined at line 58 of ./engine/platform/sdl/in_sdl.cpp*

 Clipboard

=============Platform_GetClipobardText

=============

### Platform_SetClipboardText

*void Platform_SetClipboardText(const char * buffer, size_t size)*

*Defined at line 75 of ./engine/platform/sdl/in_sdl.cpp*

=============Platform_SetClipobardText

=============

### R_Init_Video

*qboolean R_Init_Video(const int type)*

*Defined at line 812 of ./engine/platform/sdl/vid_sdl.cpp*

 Window

==================R_Init_Video==================

### R_Free_Video

*void R_Free_Video()*

*Defined at line 1001 of ./engine/platform/sdl/vid_sdl.cpp*

==================R_Free_Video==================

### VID_SetMode

*qboolean VID_SetMode()*

*Defined at line 931 of ./engine/platform/sdl/vid_sdl.cpp*

==================VID_SetMode

Set the described video mode==================

### R_ChangeDisplaySettings

*rserr_t R_ChangeDisplaySettings(int width, int height, qboolean fullscreen)*

*Defined at line 879 of ./engine/platform/sdl/vid_sdl.cpp*

### R_MaxVideoModes

*int R_MaxVideoModes()*

*Defined at line 222 of ./engine/platform/sdl/vid_sdl.cpp*

### R_GetVideoMode

*vidmode_t * R_GetVideoMode(int num)*

*Defined at line 227 of ./engine/platform/sdl/vid_sdl.cpp*

### GL_GetProcAddress

*void * GL_GetProcAddress(const char * name)*

*Defined at line 364 of ./engine/platform/sdl/vid_sdl.cpp*

=================GL_GetProcAddress=================

### GL_UpdateSwapInterval

*void GL_UpdateSwapInterval()*

*Defined at line 385 of ./engine/platform/sdl/vid_sdl.cpp*

===============GL_UpdateSwapInterval===============

### GL_SetAttribute

*int GL_SetAttribute(int attr, int val)*

*Defined at line 726 of ./engine/platform/sdl/vid_sdl.cpp*

### GL_GetAttribute

*int GL_GetAttribute(int attr, int * val)*

*Defined at line 767 of ./engine/platform/sdl/vid_sdl.cpp*

### GL_SwapBuffers

*void GL_SwapBuffers()*

*Defined at line 721 of ./engine/platform/sdl/vid_sdl.cpp*

### SW_LockBuffer

*void * SW_LockBuffer()*

*Defined at line 146 of ./engine/platform/sdl/vid_sdl.cpp*

### SW_UnlockBuffer

*void SW_UnlockBuffer()*

*Defined at line 184 of ./engine/platform/sdl/vid_sdl.cpp*

### SW_CreateBuffer

*qboolean SW_CreateBuffer(int width, int height, uint * stride, uint * bpp, uint * r, uint * g, uint * b)*

*Defined at line 41 of ./engine/platform/sdl/vid_sdl.cpp*

### SNDDMA_Init

*qboolean SNDDMA_Init()*

*Defined at line 66 of ./engine/platform/sdl/s_sdl.cpp*

==================SNDDMA_Init

Try to find a sound device to mix for.Returns false if nothing is found.==================

==============================================================================

			AUDIO INPUT/OUTPUT

==============================================================================

 initializes cycling through a DMA buffer and returns information on it

### SNDDMA_GetSoundtime

*int SNDDMA_GetSoundtime()*

*Defined at line 152 of ./engine/platform/sdl/s_sdl.cpp*

==============SNDDMA_GetSoundtime

update global soundtime===============

### SNDDMA_Shutdown

*void SNDDMA_Shutdown()*

*Defined at line 214 of ./engine/platform/sdl/s_sdl.cpp*

==============SNDDMA_Shutdown

Reset the sound device for exiting===============

### SNDDMA_BeginPainting

*void SNDDMA_BeginPainting()*

*Defined at line 189 of ./engine/platform/sdl/s_sdl.cpp*

==============SNDDMA_BeginPainting

Makes sure dma.buffer is valid===============

### SNDDMA_Submit

*void SNDDMA_Submit()*

*Defined at line 202 of ./engine/platform/sdl/s_sdl.cpp*

==============SNDDMA_Submit

Send sound to device if buffer isn't really the dma bufferAlso unlocks the dsound buffer===============

### SNDDMA_Activate

*void SNDDMA_Activate(qboolean active)*

*Defined at line 248 of ./engine/platform/sdl/s_sdl.cpp*

===========SNDDMA_ActivateCalled when the main window gains or loses focus.The window have been destroyed and recreatedbetween a deactivate and an activate.===========

### Sys_Sleep

*void Sys_Sleep(int msec)*

*Defined at line 107 of ./engine/common/system.cpp*

================Sys_Sleep

freeze application for some time================

========================================================================internal dll's loader

two main types - native dlls and other win32 libraries will be recognized automaticallyNOTE: never change this structure because all dll descriptions in xash codewrites into struct by offsets not names========================================================================

### Sys_DoubleTime

*double Sys_DoubleTime()*

*Defined at line 45 of ./engine/common/system.cpp*

 time

================Sys_DoubleTime================

### Sys_GetClipboardData

*char * Sys_GetClipboardData()*

*Defined at line 76 of ./engine/common/system.cpp*

================Sys_GetClipboardData

create buffer, that contain clipboard================

### Sys_GetCurrentUser

*char * Sys_GetCurrentUser()*

*Defined at line 123 of ./engine/common/system.cpp*

================Sys_GetCurrentUser

returns username for current profile================

### Sys_CheckParm

*int Sys_CheckParm(const char * parm)*

*Defined at line 201 of ./engine/common/system.cpp*

================Sys_CheckParm

Returns the position (1 to argc-1) in the program's argument listwhere the given parameter apears, or 0 if not present================

### Sys_Warn

*void Sys_Warn(const char * format)*

*Defined at line 383 of ./engine/common/system.cpp*

================Sys_Warn

Just messagebox================

### Sys_Error

*void Sys_Error(const char * error)*

*Defined at line 406 of ./engine/common/system.cpp*

================Sys_Error

NOTE: we must prepare engine to shutdownbefore call this================

### Sys_LoadLibrary

*qboolean Sys_LoadLibrary(dll_info_t * dll)*

*Defined at line 268 of ./engine/common/system.cpp*

=======================================================================			DLL'S MANAGER SYSTEM=======================================================================

### Sys_GetProcAddress

*void * Sys_GetProcAddress(dll_info_t * dll, const char * name)*

*Defined at line 319 of ./engine/common/system.cpp*

### Sys_FreeLibrary

*qboolean Sys_FreeLibrary(dll_info_t * dll)*

*Defined at line 327 of ./engine/common/system.cpp*

### Sys_ParseCommandLine

*void Sys_ParseCommandLine(int argc, char ** argv)*

*Defined at line 147 of ./engine/common/system.cpp*

==================Sys_ParseCommandLine

==================

### Sys_MergeCommandLine

*void Sys_MergeCommandLine()*

*Defined at line 178 of ./engine/common/system.cpp*

==================Sys_MergeCommandLine

==================

### Sys_SetupCrashHandler

*void Sys_SetupCrashHandler()*

*Defined at line 440 of ./engine/common/crashhandler.cpp*

### Sys_RestoreCrashHandler

*void Sys_RestoreCrashHandler()*

*Defined at line 445 of ./engine/common/crashhandler.cpp*

### Sys_SetClipboardData

*void Sys_SetClipboardData(const char * buffer, size_t size)*

*Defined at line 94 of ./engine/common/system.cpp*

================Sys_SetClipboardData

write screenshot into clipboard================

### _Sys_GetParmFromCmdLine

*qboolean _Sys_GetParmFromCmdLine(const char * parm, char * out, size_t size)*

*Defined at line 223 of ./engine/common/system.cpp*

================Sys_GetParmFromCmdLine

Returns the argument for specified parm================

### Sys_GetIntFromCmdLine

*qboolean Sys_GetIntFromCmdLine(const char * parm, int * out)*

*Defined at line 235 of ./engine/common/system.cpp*

### Sys_SendKeyEvents

*void Sys_SendKeyEvents()*

*Defined at line 249 of ./engine/common/system.cpp*

### Sys_Print

*void Sys_Print(const char * pMsg)*

*Defined at line 487 of ./engine/common/system.cpp*

================Sys_Print

print into window console================

### Sys_PrintLog

*void Sys_PrintLog(const char * pMsg)*

*Defined at line 158 of ./engine/common/sys_con.cpp*

### Sys_InitLog

*void Sys_InitLog()*

*Defined at line 98 of ./engine/common/sys_con.cpp*

### Sys_CloseLog

*void Sys_CloseLog()*

*Defined at line 126 of ./engine/common/sys_con.cpp*

### Sys_Quit

*void Sys_Quit()*

*Defined at line 474 of ./engine/common/system.cpp*

================Sys_Quit================

### Sys_Input

*char * Sys_Input()*

*Defined at line 43 of ./engine/common/sys_con.cpp*

 sys_con.c

### Sys_DestroyConsole

*void Sys_DestroyConsole()*

*Defined at line 77 of ./engine/common/sys_con.cpp*

### Sys_LogFileNo

*int Sys_LogFileNo()*

*Defined at line 93 of ./engine/common/sys_con.cpp*

===============================================================================

SYSTEM LOG

===============================================================================

### Cvar_GetList

*cvar_t * Cvar_GetList()*

*Defined at line 31 of ./engine/common/cvar.cpp*

============Cvar_GetList============

### Cvar_FindVarExt

*convar_t * Cvar_FindVarExt(const char * var_name, int ignore_group)*

*Defined at line 44 of ./engine/common/cvar.cpp*

============Cvar_FindVar

find the specified variable by name============

### Cvar_RegisterVariable

*void Cvar_RegisterVariable(convar_t * var)*

*Defined at line 434 of ./engine/common/cvar.cpp*

============Cvar_RegisterVariable

Adds a freestanding variable to the variable list.============

### Cvar_Get

*convar_t * Cvar_Get(const char * var_name, const char * value, int flags, const char * description)*

*Defined at line 341 of ./engine/common/cvar.cpp*

============Cvar_Get

If the variable already exists, the value will not be setThe flags will be or'ed in if the variable exists.============

### Cvar_LookupVars

*void Cvar_LookupVars(int checkbit, void * buffer, void * ptr, setpair_t callback)*

*Defined at line 306 of ./engine/common/cvar.cpp*

============Cvar_LookupVars============

### Cvar_FullSet

*void Cvar_FullSet(const char * var_name, const char * value, int flags)*

*Defined at line 575 of ./engine/common/cvar.cpp*

============Cvar_FullSet

can set any protected cvars============

### Cvar_DirectSet

*void Cvar_DirectSet(convar_t * var, const char * value)*

*Defined at line 501 of ./engine/common/cvar.cpp*

============Cvar_DirectSet

way to change value for many cvars============

### Cvar_Set

*void Cvar_Set(const char * var_name, const char * value)*

*Defined at line 601 of ./engine/common/cvar.cpp*

============Cvar_Set============

### Cvar_SetValue

*void Cvar_SetValue(const char * var_name, float value)*

*Defined at line 620 of ./engine/common/cvar.cpp*

============Cvar_SetValue============

### Cvar_BuildAutoDescription

*const char * Cvar_BuildAutoDescription(int flags)*

*Defined at line 75 of ./engine/common/cvar.cpp*

============Cvar_BuildAutoDescription

build cvar auto description that based on the setup flags============

### Cvar_VariableValue

*float Cvar_VariableValue(const char * var_name)*

*Defined at line 646 of ./engine/common/cvar.cpp*

============Cvar_VariableValue============

### Cvar_VariableInteger

*int Cvar_VariableInteger(const char * var_name)*

*Defined at line 661 of ./engine/common/cvar.cpp*

============Cvar_VariableInteger============

### Cvar_VariableString

*const char * Cvar_VariableString(const char * var_name)*

*Defined at line 676 of ./engine/common/cvar.cpp*

============Cvar_VariableString============

### Cvar_WriteVariables

*void Cvar_WriteVariables(file_t * f, int group)*

*Defined at line 803 of ./engine/common/cvar.cpp*

============Cvar_WriteVariables

Writes lines containing "variable value" for all variableswith the specified flag set to true.============

### Cvar_Exists

*qboolean Cvar_Exists(const char * var_name)*

*Defined at line 691 of ./engine/common/cvar.cpp*

============Cvar_Exists============

### Cvar_Reset

*void Cvar_Reset(const char * var_name)*

*Defined at line 636 of ./engine/common/cvar.cpp*

============Cvar_Reset============

### Cvar_SetCheatState

*void Cvar_SetCheatState()*

*Defined at line 705 of ./engine/common/cvar.cpp*

============Cvar_SetCheatState

Any testing variables will be reset to the safe values============

### Cvar_Command

*qboolean Cvar_Command(convar_t * v)*

*Defined at line 751 of ./engine/common/cvar.cpp*

============Cvar_Command

Handles variable inspection and changing from the console============

### Cvar_Init

*void Cvar_Init()*

*Defined at line 940 of ./engine/common/cvar.cpp*

============Cvar_Init

Reads in all archived cvars============

### Cvar_Unlink

*void Cvar_Unlink(int group)*

*Defined at line 916 of ./engine/common/cvar.cpp*

============Cvar_Unlink

unlink all cvars with specified flag============

### CRC32_Init

*void CRC32_Init(dword * pulCRC)*

*Defined at line 93 of ./public/crclib.cpp*

### CRC32_BlockSequence

*byte CRC32_BlockSequence(byte * base, int length, int sequence)*

*Defined at line 183 of ./public/crclib.cpp*

====================CRC32_BlockSequence

For proxy protecting====================

### CRC32_ProcessBuffer

*void CRC32_ProcessBuffer(dword * pulCRC, const void * pBuffer, int nBuffer)*

*Defined at line 112 of ./public/crclib.cpp*

### CRC32_ProcessByte

*void CRC32_ProcessByte(dword * pulCRC, byte ch)*

*Defined at line 103 of ./public/crclib.cpp*

### CRC32_Final

*dword CRC32_Final(dword pulCRC)*

*Defined at line 98 of ./public/crclib.cpp*

### MD5Init

*void MD5Init(MD5Context_t * ctx)*

*Defined at line 218 of ./public/crclib.cpp*

==================MD5Init

Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious initialization constants.==================

### MD5Update

*void MD5Update(MD5Context_t * ctx, const byte * buf, uint len)*

*Defined at line 236 of ./public/crclib.cpp*

===================MD5Update

Update context to reflect the concatenation of another buffer full of bytes.===================

### MD5Final

*void MD5Final(byte [16] digest, MD5Context_t * ctx)*

*Defined at line 288 of ./public/crclib.cpp*

===============MD5Final

Final wrapup - pad to 64-byte boundary with the bit pattern1 0* (64-bit count of bits processed, MSB-first)===============

### COM_HashKey

*uint COM_HashKey(const char * string, uint hashSize)*

*Defined at line 462 of ./public/crclib.cpp*

=================COM_HashKey

returns hash key for string=================

### MD5_Print

*char * MD5_Print(byte [16] hash)*

*Defined at line 438 of ./public/crclib.cpp*

=================MD5_Print

transform hash to hexadecimal printable symbols=================

### NET_Init

*void NET_Init()*

*Defined at line 1682 of ./engine/common/net_ws.cpp*

====================NET_Init====================

### NET_Shutdown

*void NET_Shutdown()*

*Defined at line 1745 of ./engine/common/net_ws.cpp*

====================NET_Shutdown====================

### NET_Sleep

*void NET_Sleep(int msec)*

*Defined at line 1642 of ./engine/common/net_ws.cpp*

====================NET_Sleep

sleeps msec or until net socket is ready====================

### NET_IsActive

*qboolean NET_IsActive()*

*Defined at line 1630 of ./engine/common/net_ws.cpp*

====================NET_IsActive====================

### NET_IsConfigured

*qboolean NET_IsConfigured()*

*Defined at line 1620 of ./engine/common/net_ws.cpp*

====================NET_IsConfigured

Is winsock ip initialized?====================

### NET_Config

*void NET_Config(qboolean net_enable)*

*Defined at line 1568 of ./engine/common/net_ws.cpp*

====================NET_Config

A single player game will only use the loopback code====================

### NET_IsLocalAddress

*qboolean NET_IsLocalAddress(netadr_s adr)*

*Defined at line 662 of ./engine/common/net_ws.cpp*

====================NET_IsLocalAddress====================

### NET_AdrToString

*char * NET_AdrToString(netadr_s a)*

*Defined at line 534 of ./engine/common/net_ws.cpp*

====================NET_AdrToString====================

### NET_BaseAdrToString

*char * NET_BaseAdrToString(netadr_s a)*

*Defined at line 546 of ./engine/common/net_ws.cpp*

====================NET_BaseAdrToString====================

### NET_IsReservedAdr

*qboolean NET_IsReservedAdr(netadr_s a)*

*Defined at line 607 of ./engine/common/net_ws.cpp*

====================NET_IsReservedAdr

Check for reserved ip's====================

### NET_CompareClassBAdr

*qboolean NET_CompareClassBAdr(netadr_s a, netadr_s b)*

*Defined at line 584 of ./engine/common/net_ws.cpp*

====================NET_CompareClassBAdr

Compare local masks====================

### NET_StringToAdr

*qboolean NET_StringToAdr(const char * string, netadr_t * adr)*

*Defined at line 675 of ./engine/common/net_ws.cpp*

=============NET_StringToAdr

idnewt192.246.40.70=============

### NET_StringToAdrNB

*int NET_StringToAdrNB(const char * string, netadr_t * adr)*

*Defined at line 694 of ./engine/common/net_ws.cpp*

### NET_CompareAdr

*qboolean NET_CompareAdr(netadr_s a, netadr_s b)*

*Defined at line 638 of ./engine/common/net_ws.cpp*

====================NET_CompareAdr

Compare full address====================

### NET_CompareBaseAdr

*qboolean NET_CompareBaseAdr(netadr_s a, netadr_s b)*

*Defined at line 560 of ./engine/common/net_ws.cpp*

===================NET_CompareBaseAdr

Compares without the port===================

### NET_GetPacket

*qboolean NET_GetPacket(netsrc_t sock, netadr_t * from, byte * data, size_t * length)*

*Defined at line 1157 of ./engine/common/net_ws.cpp*

==================NET_GetPacket

Never called by the game logic, just the system event queing==================

### NET_BufferToBufferCompress

*qboolean NET_BufferToBufferCompress(byte * dest, uint * destLen, byte * source, uint sourceLen)*

*Defined at line 1323 of ./engine/common/net_ws.cpp*

====================NET_BufferToBufferCompress

generic fast compression====================

### NET_BufferToBufferDecompress

*qboolean NET_BufferToBufferDecompress(byte * dest, uint * destLen, byte * source, uint sourceLen)*

*Defined at line 1354 of ./engine/common/net_ws.cpp*

====================NET_BufferToBufferDecompress

generic fast decompression====================

### NET_SendPacket

*void NET_SendPacket(netsrc_t sock, size_t length, const void * data, netadr_s to)*

*Defined at line 1311 of ./engine/common/net_ws.cpp*

==================NET_SendPacket==================

### NET_SendPacketEx

*void NET_SendPacketEx(netsrc_t sock, size_t length, const void * data, netadr_s to, size_t splitsize)*

*Defined at line 1246 of ./engine/common/net_ws.cpp*

==================NET_SendPacketEx==================

### NET_ClearLagData

*void NET_ClearLagData(qboolean bClient, qboolean bServer)*

*Defined at line 1671 of ./engine/common/net_ws.cpp*

====================NET_ClearLagData

clear fakelag list====================

### CL_LegacyMode

*qboolean CL_LegacyMode()*

*Defined at line 3229 of ./engine/client/cl_parse.cpp*

### CL_GetSplitSize

*int CL_GetSplitSize()*

*Defined at line 1404 of ./engine/client/cl_main.cpp*

### HTTP_AddCustomServer

*void HTTP_AddCustomServer(const char * url)*

*Defined at line 2414 of ./engine/common/net_ws.cpp*

=======================HTTP_AddCustomServer=======================

### HTTP_AddDownload

*void HTTP_AddDownload(const char * path, int size, qboolean process)*

*Defined at line 2301 of ./engine/common/net_ws.cpp*

===================HTTP_AddDownload

Add new download to end of queue===================

### HTTP_ClearCustomServers

*void HTTP_ClearCustomServers()*

*Defined at line 1832 of ./engine/common/net_ws.cpp*

========================HTTP_ClearCustomServers========================

### HTTP_Shutdown

*void HTTP_Shutdown()*

*Defined at line 2596 of ./engine/common/net_ws.cpp*

====================HTTP_Shutdown====================

### HTTP_Init

*void HTTP_Init()*

*Defined at line 2546 of ./engine/common/net_ws.cpp*

=============HTTP_Init=============

### HTTP_Run

*void HTTP_Run()*

*Defined at line 2085 of ./engine/common/net_ws.cpp*

==============HTTP_Run

Download next file block of each active fileCall every frame==============

### Cbuf_Init

*void Cbuf_Init()*

*Defined at line 54 of ./engine/common/cmd.cpp*

 cmd.c

============Cbuf_Init============

### Cbuf_Clear

*void Cbuf_Clear()*

*Defined at line 67 of ./engine/common/cmd.cpp*

============Cbuf_Clear============

### Cbuf_AddText

*void Cbuf_AddText(const char * text)*

*Defined at line 101 of ./engine/common/cmd.cpp*

============Cbuf_AddText

Adds command text at the end of the buffer============

### Cbuf_InsertText

*void Cbuf_InsertText(const char * text)*

*Defined at line 123 of ./engine/common/cmd.cpp*

============Cbuf_InsertText

Adds command text immediately after the current commandAdds a **<not a builtin command>**  to the text============

### Cbuf_ExecStuffCmds

*void Cbuf_ExecStuffCmds()*

*Defined at line 228 of ./engine/common/cmd.cpp*

===============Cbuf_ExecStuffCmds

execute commandline===============

### Cbuf_Execute

*void Cbuf_Execute()*

*Defined at line 144 of ./engine/common/cmd.cpp*

============Cbuf_Execute============

### Cmd_Argc

*int Cmd_Argc()*

*Defined at line 479 of ./engine/common/cmd.cpp*

============Cmd_Argc============

### Cmd_Args

*const char * Cmd_Args()*

*Defined at line 501 of ./engine/common/cmd.cpp*

============Cmd_Args============

### Cmd_Argv

*const char * Cmd_Argv(int arg)*

*Defined at line 489 of ./engine/common/cmd.cpp*

============Cmd_Argv============

### Cmd_Argl

*const char ** Cmd_Argl()*

*Defined at line 511 of ./engine/common/cmd.cpp*

============Cmd_Argl============

### Cmd_Init

*void Cmd_Init()*

*Defined at line 1247 of ./engine/common/cmd.cpp*

============Cmd_Init============

### Cmd_Unlink

*void Cmd_Unlink(int group)*

*Defined at line 1109 of ./engine/common/cmd.cpp*

============Cmd_Unlink

unlink all commands with specified flag============

### Cmd_AddCommand

*void Cmd_AddCommand(const char * cmd_name, xcommand_t function, const char * cmd_desc)*

*Defined at line 680 of ./engine/common/cmd.cpp*

============Cmd_AddCommand============

### Cmd_AddRestrictedCommand

*void Cmd_AddRestrictedCommand(const char * cmd_name, xcommand_t function, const char * cmd_desc)*

*Defined at line 691 of ./engine/common/cmd.cpp*

============Cmd_AddRestrictedCommand============

### Cmd_AddServerCommand

*void Cmd_AddServerCommand(const char * cmd_name, xcommand_t function)*

*Defined at line 701 of ./engine/common/cmd.cpp*

============Cmd_AddServerCommand============

### Cmd_AddClientCommand

*int Cmd_AddClientCommand(const char * cmd_name, xcommand_t function)*

*Defined at line 711 of ./engine/common/cmd.cpp*

============Cmd_AddClientCommand============

### Cmd_AddGameUICommand

*int Cmd_AddGameUICommand(const char * cmd_name, xcommand_t function)*

*Defined at line 721 of ./engine/common/cmd.cpp*

============Cmd_AddGameUICommand============

### Cmd_AddRefCommand

*int Cmd_AddRefCommand(const char * cmd_name, xcommand_t function, const char * description)*

*Defined at line 731 of ./engine/common/cmd.cpp*

============Cmd_AddRefCommand============

### Cmd_RemoveCommand

*void Cmd_RemoveCommand(const char * cmd_name)*

*Defined at line 741 of ./engine/common/cmd.cpp*

============Cmd_RemoveCommand============

### Cmd_Exists

*qboolean Cmd_Exists(const char * cmd_name)*

*Defined at line 804 of ./engine/common/cmd.cpp*

============Cmd_Exists============

### Cmd_LookupCmds

*void Cmd_LookupCmds(void * buffer, void * ptr, setpair_t callback)*

*Defined at line 780 of ./engine/common/cmd.cpp*

============Cmd_LookupCmds============

### Cmd_GetMapList

*qboolean Cmd_GetMapList(const char * s, char * completedname, int length)*

*Defined at line 59 of ./engine/common/con_utils.cpp*

=======================================================================

			FILENAME AUTOCOMPLETION

=======================================================================

=====================================Cmd_GetMapList

Prints or complete map filename=====================================

### Cmd_GetDemoList

*qboolean Cmd_GetDemoList(const char * s, char * completedname, int length)*

*Defined at line 204 of ./engine/common/con_utils.cpp*

=====================================Cmd_GetDemoList

Prints or complete demo filename=====================================

### Cmd_GetMovieList

*qboolean Cmd_GetMovieList(const char * s, char * completedname, int length)*

*Defined at line 251 of ./engine/common/con_utils.cpp*

=====================================Cmd_GetMovieList

Prints or complete movie filename=====================================

### Cmd_TokenizeString

*void Cmd_TokenizeString(char * text)*

*Defined at line 575 of ./engine/common/cmd.cpp*

============Cmd_TokenizeString

Parses the given string into command line tokens.The text is copied to a seperate buffer and 0 charactersare inserted in the apropriate place, The argv arraywill point into this temporary buffer.============

### Cmd_ExecuteString

*void Cmd_ExecuteString(char * text)*

*Defined at line 900 of ./engine/common/cmd.cpp*

============Cmd_ExecuteString

A complete command line has been parsed, so try to execute it============

### Cmd_ForwardToServer

*void Cmd_ForwardToServer()*

*Defined at line 1038 of ./engine/common/cmd.cpp*

### Memory_Init

*void Memory_Init()*

*Defined at line 112 of ./engine/common/zone.cpp*

 zone.c

========================Memory_Init========================

### _Mem_Realloc

*void * _Mem_Realloc(byte * poolptr, void * memptr, size_t size, qboolean clear, const char * filename, int fileline)*

*Defined at line 62 of ./engine/common/zone.cpp*

### _Mem_Alloc

*void * _Mem_Alloc(byte * poolptr, size_t size, qboolean clear, const char * filename, int fileline)*

*Defined at line 52 of ./engine/common/zone.cpp*

 mempool_t *poolchain = NULL; // critical stuff

### _Mem_AllocPool

*byte * _Mem_AllocPool(const char * name, const char * filename, int fileline)*

*Defined at line 67 of ./engine/common/zone.cpp*

### _Mem_FreePool

*void _Mem_FreePool(byte ** poolptr, const char * filename, int fileline)*

*Defined at line 72 of ./engine/common/zone.cpp*

### _Mem_EmptyPool

*void _Mem_EmptyPool(byte * poolptr, const char * filename, int fileline)*

*Defined at line 77 of ./engine/common/zone.cpp*

### _Mem_Free

*void _Mem_Free(void * data, const char * filename, int fileline)*

*Defined at line 57 of ./engine/common/zone.cpp*

### _Mem_Check

*void _Mem_Check(const char * filename, int fileline)*

*Defined at line 92 of ./engine/common/zone.cpp*

### Mem_IsAllocatedExt

*qboolean Mem_IsAllocatedExt(byte * poolptr, void * data)*

*Defined at line 87 of ./engine/common/zone.cpp*

========================Check pointer for memory========================

### Mem_PrintList

*void Mem_PrintList(size_t minallocationsize)*

*Defined at line 102 of ./engine/common/zone.cpp*

### Mem_PrintStats

*void Mem_PrintStats()*

*Defined at line 97 of ./engine/common/zone.cpp*

### Mem_Malloc

*void * Mem_Malloc(byte * pool, size_t sz)*

*Defined at line 533 of ./engine/common/common.h*

### Mem_Calloc

*void * Mem_Calloc(byte * pool, size_t sz)*

*Defined at line 534 of ./engine/common/common.h*

### Mem_Realloc

*void * Mem_Realloc(byte * pool, void * ptr, size_t sz)*

*Defined at line 535 of ./engine/common/common.h*

### Mem_Free

*void Mem_Free(void * ptr)*

*Defined at line 536 of ./engine/common/common.h*

### Mem_AllocPool

*byte * Mem_AllocPool(const char * name)*

*Defined at line 537 of ./engine/common/common.h*

### Mem_FreePool

*void Mem_FreePool(byte ** name)*

*Defined at line 538 of ./engine/common/common.h*

### Mem_EmptyPool

*void Mem_EmptyPool(byte * name)*

*Defined at line 539 of ./engine/common/common.h*

### Mem_IsAllocated

*qboolean Mem_IsAllocated(byte * pool)*

*Defined at line 540 of ./engine/common/common.h*

### Mem_Check

*void Mem_Check()*

*Defined at line 541 of ./engine/common/common.h*

### FS_Init

*void FS_Init()*

*Defined at line 1775 of ./engine/common/filesystem.cpp*

 filesystem.c

================FS_Init================

### FS_Path

*void FS_Path()*

### FS_Rescan

*void FS_Rescan()*

*Defined at line 1266 of ./engine/common/filesystem.cpp*

================FS_Rescan================

### FS_Shutdown

*void FS_Shutdown()*

*Defined at line 1898 of ./engine/common/filesystem.cpp*

================FS_Shutdown================

### FS_ClearSearchPath

*void FS_ClearSearchPath()*

*Defined at line 1180 of ./engine/common/filesystem.cpp*

================FS_ClearSearchPath================

### FS_AllowDirectPaths

*void FS_AllowDirectPaths(qboolean enable)*

*Defined at line 1888 of ./engine/common/filesystem.cpp*

### FS_AddGameDirectory

*void FS_AddGameDirectory(const char * dir, uint flags)*

*Defined at line 1065 of ./engine/common/filesystem.cpp*

================FS_AddGameDirectory

Sets fs_writedir, adds the directory to the head of the path,then loads and adds pak1.pak pak2.pak ...================

### FS_AddGameHierarchy

*void FS_AddGameHierarchy(const char * dir, uint flags)*

*Defined at line 1128 of ./engine/common/filesystem.cpp*

================FS_AddGameHierarchy================

### FS_LoadGameInfo

*void FS_LoadGameInfo(const char * rootfolder)*

*Defined at line 1729 of ./engine/common/filesystem.cpp*

================FS_LoadGameInfo

can be passed null arg================

### FS_GetDiskPath

*const char * FS_GetDiskPath(const char * name, qboolean gamedironly)*

*Defined at line 2898 of ./engine/common/filesystem.cpp*

==================FS_GetDiskPath

Build direct path for file in the filesystemreturn NULL for file in pack==================

### W_LoadLump

*byte * W_LoadLump(wfile_t * wad, const char * lumpname, size_t * lumpsizeptr, const char type)*

### W_Close

*void W_Close(wfile_t * wad)*

*Defined at line 3728 of ./engine/common/filesystem.cpp*

===========W_Close

finalize wad or just close===========

### FS_LoadFile

*byte * FS_LoadFile(const char * path, fs_offset_t * filesizeptr, qboolean gamedironly)*

*Defined at line 2716 of ./engine/common/filesystem.cpp*

============FS_LoadFile

Filename are relative to the xash directory.Always appends a 0 byte.============

### CRC32_File

*qboolean CRC32_File(dword * crcvalue, const char * filename)*

*Defined at line 2747 of ./engine/common/filesystem.cpp*

### MD5_HashFile

*qboolean MD5_HashFile(byte [16] digest, const char * pszFileName, uint [4] seed)*

*Defined at line 2773 of ./engine/common/filesystem.cpp*

### FS_LoadDirectFile

*byte * FS_LoadDirectFile(const char * path, fs_offset_t * filesizeptr)*

*Defined at line 2817 of ./engine/common/filesystem.cpp*

============FS_LoadFile

Filename are relative to the xash directory.Always appends a 0 byte.============

### FS_WriteFile

*qboolean FS_WriteFile(const char * filename, const void * data, fs_offset_t len)*

*Defined at line 2851 of ./engine/common/filesystem.cpp*

============FS_WriteFile

The filename will be prefixed by the current game directory============

### COM_ParseVector

*qboolean COM_ParseVector(char ** pfile, float * v, size_t size)*

*Defined at line 575 of ./engine/common/common.cpp*

================COM_ParseVector

================

### COM_NormalizeAngles

*void COM_NormalizeAngles(vec3_t angles)*

*Defined at line 946 of ./engine/common/common.cpp*

=============COM_NormalizeAngles

=============

### COM_FileSize

*int COM_FileSize(const char * filename)*

*Defined at line 640 of ./engine/common/common.cpp*

=============COM_FileSize

=============

### COM_FixSlashes

*void COM_FixSlashes(char * pname)*

*Defined at line 729 of ./engine/common/common.cpp*

============COM_FixSlashes

Changes all '/' characters into '\' characters, in place.============

### COM_FreeFile

*void COM_FreeFile(void * buffer)*

*Defined at line 935 of ./engine/common/common.cpp*

=============COM_FreeFile

=============

### COM_CompareFileTime

*int COM_CompareFileTime(const char * filename1, const char * filename2, int * iCompare)*

*Defined at line 1074 of ./engine/common/common.cpp*

=============COM_CompareFileTime

=============

### FS_Search

*search_t * FS_Search(const char * pattern, int caseinsensitive, int gamedironly)*

*Defined at line 3172 of ./engine/common/filesystem.cpp*

===========FS_Search

Allocate and fill a search structure with information on matching filenames.===========

### FS_Open

*file_t * FS_Open(const char * filepath, const char * mode, qboolean gamedironly)*

*Defined at line 2331 of ./engine/common/filesystem.cpp*

=============================================================================

MAIN PUBLIC FUNCTIONS

=============================================================================

====================FS_Open

Open a file. The syntax is the same as fopen====================

### FS_Write

*fs_offset_t FS_Write(file_t * file, const void * data, size_t datasize)*

*Defined at line 2383 of ./engine/common/filesystem.cpp*

====================FS_Write

Write "datasize" bytes into a file====================

### FS_Read

*fs_offset_t FS_Read(file_t * file, void * buffer, size_t buffersize)*

*Defined at line 2415 of ./engine/common/filesystem.cpp*

====================FS_Read

Read up to "buffersize" bytes from a file====================

### FS_VPrintf

*int FS_VPrintf(file_t * file, const char * format, va_list ap)*

*Defined at line 2529 of ./engine/common/filesystem.cpp*

====================FS_VPrintf

Print a string into a file====================

### FS_Seek

*int FS_Seek(file_t * file, fs_offset_t offset, int whence)*

*Defined at line 2631 of ./engine/common/filesystem.cpp*

====================FS_Seek

Move the position index in a file====================

### FS_Gets

*int FS_Gets(file_t * file, byte * string, size_t bufsize)*

*Defined at line 2596 of ./engine/common/filesystem.cpp*

====================FS_Gets

Same as fgets====================

### FS_Printf

*int FS_Printf(file_t * file, const char * format)*

*Defined at line 2510 of ./engine/common/filesystem.cpp*

====================FS_Printf

Print a string into a file====================

### FS_FileSize

*fs_offset_t FS_FileSize(const char * filename, qboolean gamedironly)*

*Defined at line 3019 of ./engine/common/filesystem.cpp*

==================FS_FileSize

return size of file in bytes==================

### FS_FileTime

*int FS_FileTime(const char * filename, qboolean gamedironly)*

*Defined at line 3057 of ./engine/common/filesystem.cpp*

==================FS_FileTime

return time of creation file in seconds==================

### FS_Print

*int FS_Print(file_t * file, const char * msg)*

*Defined at line 2498 of ./engine/common/filesystem.cpp*

====================FS_Print

Print a string into a file====================

### FS_Rename

*qboolean FS_Rename(const char * oldname, const char * newname)*

*Defined at line 3090 of ./engine/common/filesystem.cpp*

==================FS_Rename

rename specified file from gamefolder==================

### FS_FileExists

*int FS_FileExists(const char * filename, int gamedironly)*

*Defined at line 2883 of ./engine/common/filesystem.cpp*

=============================================================================

OTHERS PUBLIC FUNCTIONS

=============================================================================

==================FS_FileExists

Look for a file in the packages and in the filesystem==================

### FS_SysFileExists

*qboolean FS_SysFileExists(const char * path, qboolean casesensitive)*

*Defined at line 2050 of ./engine/common/filesystem.cpp*

==================FS_SysFileExists

Look for a file in the filesystem only==================

### FS_FileCopy

*qboolean FS_FileCopy(file_t * pOutput, file_t * pInput, int fileSize)*

*Defined at line 3137 of ./engine/common/filesystem.cpp*

==================FS_FileCopy

==================

### FS_Delete

*qboolean FS_Delete(const char * path)*

*Defined at line 3116 of ./engine/common/filesystem.cpp*

==================FS_Delete

delete specified file from gamefolder==================

### FS_UnGetc

*int FS_UnGetc(file_t * file, byte c)*

*Defined at line 2579 of ./engine/common/filesystem.cpp*

====================FS_UnGetc

Put a character back into the read buffer (only supports one character!)====================

### FS_Tell

*fs_offset_t FS_Tell(file_t * file)*

*Defined at line 2675 of ./engine/common/filesystem.cpp*

====================FS_Tell

Give the current position in a file====================

### FS_Eof

*qboolean FS_Eof(file_t * file)*

*Defined at line 2688 of ./engine/common/filesystem.cpp*

====================FS_Eof

indicates at reached end of file====================

### FS_Close

*int FS_Close(file_t * file)*

*Defined at line 2365 of ./engine/common/filesystem.cpp*

====================FS_Close

Close a file====================

### FS_Getc

*int FS_Getc(file_t * file)*

*Defined at line 2562 of ./engine/common/filesystem.cpp*

====================FS_Getc

Get the next character of a file====================

### FS_FileLength

*fs_offset_t FS_FileLength(file_t * f)*

*Defined at line 3044 of ./engine/common/filesystem.cpp*

==================FS_FileLength

return size of file in bytes==================

### Image_Init

*void Image_Init()*

*Defined at line 142 of ./engine/common/imagelib/img_utils.cpp*

### Image_Shutdown

*void Image_Shutdown()*

*Defined at line 170 of ./engine/common/imagelib/img_utils.cpp*

### Image_AddCmdFlags

*void Image_AddCmdFlags(uint flags)*

*Defined at line 237 of ./engine/common/imagelib/img_utils.cpp*

=================Image_AddCmdFlags=================

### FS_LoadImage

*rgbdata_t * FS_LoadImage(const char * filename, const byte * buffer, size_t size)*

*Defined at line 212 of ./engine/common/imagelib/img_main.cpp*

================FS_LoadImage

loading and unpack to rgba any known image================

### FS_SaveImage

*qboolean FS_SaveImage(const char * filename, rgbdata_t * pix)*

*Defined at line 355 of ./engine/common/imagelib/img_main.cpp*

================Image_Save

writes image as any known format================

### FS_CopyImage

*rgbdata_t * FS_CopyImage(rgbdata_t * in)*

*Defined at line 461 of ./engine/common/imagelib/img_main.cpp*

================FS_CopyImage

make an image copy================

### FS_FreeImage

*void FS_FreeImage(rgbdata_t * pack)*

*Defined at line 446 of ./engine/common/imagelib/img_main.cpp*

================Image_FreeImage

free RGBA buffer================

### Image_Process

*qboolean Image_Process(rgbdata_t ** pix, int width, int height, uint flags, float bumpscale)*

*Defined at line 1468 of ./engine/common/imagelib/img_utils.cpp*

### Image_PaletteHueReplace

*void Image_PaletteHueReplace(byte * palSrc, int newHue, int start, int end, int pal_size)*

*Defined at line 447 of ./engine/common/imagelib/img_utils.cpp*

### Image_PaletteTranslate

*void Image_PaletteTranslate(byte * palSrc, int top, int bottom, int pal_size)*

*Defined at line 522 of ./engine/common/imagelib/img_utils.cpp*

### Image_SetForceFlags

*void Image_SetForceFlags(uint flags)*

*Defined at line 217 of ./engine/common/imagelib/img_utils.cpp*

=================Image_SetForceFlags=================

### Image_DXTGetLinearSize

*size_t Image_DXTGetLinearSize(int type, int width, int height, int depth)*

*Defined at line 164 of ./engine/common/imagelib/img_dds.cpp*

### Image_CustomPalette

*qboolean Image_CustomPalette()*

*Defined at line 191 of ./engine/common/imagelib/img_utils.cpp*

=================Image_CustomPalette=================

### Image_ClearForceFlags

*void Image_ClearForceFlags()*

*Defined at line 227 of ./engine/common/imagelib/img_utils.cpp*

=================Image_ClearForceFlags=================

### Image_SetMDLPointer

*void Image_SetMDLPointer(byte * p)*

*Defined at line 140 of ./engine/common/imagelib/img_wad.cpp*

### Image_CheckPaletteQ1

*void Image_CheckPaletteQ1()*

*Defined at line 361 of ./engine/common/imagelib/img_utils.cpp*

### Sound_Init

*void Sound_Init()*

*Defined at line 60 of ./engine/common/soundlib/snd_utils.cpp*

 soundlib

### Sound_Shutdown

*void Sound_Shutdown()*

*Defined at line 80 of ./engine/common/soundlib/snd_utils.cpp*

### FS_LoadSound

*wavdata_t * FS_LoadSound(const char * filename, const byte * buffer, size_t size)*

*Defined at line 57 of ./engine/common/soundlib/snd_main.cpp*

================FS_LoadSound

loading and unpack to wav any known sound================

### FS_FreeSound

*void FS_FreeSound(wavdata_t * pack)*

*Defined at line 133 of ./engine/common/soundlib/snd_main.cpp*

================Sound_FreeSound

free WAV buffer================

### FS_OpenStream

*stream_t * FS_OpenStream(const char * filename)*

*Defined at line 147 of ./engine/common/soundlib/snd_main.cpp*

================FS_OpenStream

open and reading basic info from sound stream ================

### FS_StreamInfo

*wavdata_t * FS_StreamInfo(stream_t * stream)*

*Defined at line 199 of ./engine/common/soundlib/snd_main.cpp*

================FS_StreamInfo

get basic stream info================

### FS_ReadStream

*int FS_ReadStream(stream_t * stream, int bytes, void * buffer)*

*Defined at line 226 of ./engine/common/soundlib/snd_main.cpp*

================FS_ReadStream

extract stream as wav-data and put into buffer, move file pointer================

### FS_SetStreamPos

*int FS_SetStreamPos(stream_t * stream, int newpos)*

*Defined at line 259 of ./engine/common/soundlib/snd_main.cpp*

================FS_SetStreamPos

set stream position (in bytes)================

### FS_GetStreamPos

*int FS_GetStreamPos(stream_t * stream)*

*Defined at line 244 of ./engine/common/soundlib/snd_main.cpp*

================FS_GetStreamPos

get stream position (in bytes)================

### FS_FreeStream

*void FS_FreeStream(stream_t * stream)*

*Defined at line 274 of ./engine/common/soundlib/snd_main.cpp*

================FS_FreeStream

close sound stream================

### Sound_Process

*qboolean Sound_Process(wavdata_t ** wav, int rate, int width, uint flags)*

*Defined at line 255 of ./engine/common/soundlib/snd_utils.cpp*

### Sound_GetApproxWavePlayLen

*uint Sound_GetApproxWavePlayLen(const char * filepath)*

*Defined at line 96 of ./engine/common/soundlib/snd_utils.cpp*

### Q_buildnum

*int Q_buildnum()*

*Defined at line 23 of ./engine/common/build.cpp*

 build.c

 returns days since Feb 13 2007

### Q_buildos

*const char * Q_buildos()*

*Defined at line 62 of ./engine/common/build.cpp*

============Q_buildos

Returns current name of operating system. Without any spaces.============

### Q_buildarch

*const char * Q_buildarch()*

*Defined at line 98 of ./engine/common/build.cpp*

============Q_buildos

Returns current name of operating system. Without any spaces.============

### Q_buildcommit

*const char * Q_buildcommit()*

*Defined at line 151 of ./engine/common/build.cpp*

=============Q_buildcommit

Returns a short hash of current commit in VCS as string.XASH_BUILD_COMMIT must be passed in quotes

if XASH_BUILD_COMMIT is not defined,Q_buildcommit will identify this build as "notset"=============

### Host_IsQuakeCompatible

*qboolean Host_IsQuakeCompatible()*

*Defined at line 128 of ./engine/common/host.cpp*

 host.c

==============Host_IsQuakeCompatible

==============

### Host_Shutdown

*void Host_Shutdown()*

*Defined at line 1120 of ./engine/common/host.cpp*

=================Host_Shutdown=================

### Host_CompareFileTime

*int Host_CompareFileTime(int ft1, int ft2)*

*Defined at line 81 of ./engine/common/host.cpp*

### Host_NewInstance

*void Host_NewInstance(const char * name, const char * finalmsg)*

*Defined at line 219 of ./engine/common/host.cpp*

### Host_EndGame

*void Host_EndGame(qboolean abort, const char * message)*

*Defined at line 148 of ./engine/common/host.cpp*

================Host_EndGame================

### Host_AbortCurrentFrame

*void Host_AbortCurrentFrame()*

*Defined at line 180 of ./engine/common/host.cpp*

================Host_AbortCurrentFrame

aborts the current host frame and goes on with the next one================

### Host_WriteServerConfig

*void Host_WriteServerConfig(const char * name)*

*Defined at line 1391 of ./engine/common/con_utils.cpp*

===============Host_WriteServerConfig

save serverinfo variables into server.cfg (using for dedicated server too)===============

### Host_WriteOpenGLConfig

*void Host_WriteOpenGLConfig()*

*Defined at line 1427 of ./engine/common/con_utils.cpp*

===============Host_WriteOpenGLConfig

save opengl variables into opengl.cfg===============

### Host_WriteVideoConfig

*void Host_WriteVideoConfig()*

*Defined at line 1461 of ./engine/common/con_utils.cpp*

===============Host_WriteVideoConfig

save render variables into video.cfg===============

### Host_WriteConfig

*void Host_WriteConfig()*

*Defined at line 1342 of ./engine/common/con_utils.cpp*

===============Host_WriteConfig

Writes key bindings and archived cvars to config.cfg===============

### Host_IsLocalGame

*qboolean Host_IsLocalGame()*

*Defined at line 356 of ./engine/common/host.cpp*

=================Host_IsLocalGame

singleplayer game detect=================

### Host_IsLocalClient

*qboolean Host_IsLocalClient()*

*Defined at line 368 of ./engine/common/host.cpp*

### Host_ShutdownServer

*void Host_ShutdownServer()*

*Defined at line 94 of ./engine/common/host.cpp*

### Host_Error

*void Host_Error(const char * error)*

*Defined at line 621 of ./engine/common/host.cpp*

=================Host_Error=================

### Host_PrintEngineFeatures

*void Host_PrintEngineFeatures()*

*Defined at line 104 of ./engine/common/host.cpp*

================Host_PrintEngineFeatures================

### Host_Frame

*void Host_Frame(float time)*

*Defined at line 594 of ./engine/common/host.cpp*

=================Host_Frame=================

### Host_InitDecals

*void Host_InitDecals()*

*Defined at line 455 of ./engine/common/host.cpp*

=================Host_InitDecals=================

### Host_Credits

*void Host_Credits()*

*Defined at line 394 of ./engine/client/cl_gameui.cpp*

### COM_InitHostState

*void COM_InitHostState()*

*Defined at line 19 of ./engine/common/host_state.cpp*

 host_state.c

### COM_NewGame

*void COM_NewGame(const char * pMapName)*

*Defined at line 45 of ./engine/common/host_state.cpp*

### COM_LoadLevel

*void COM_LoadLevel(const char * pMapName, qboolean background)*

*Defined at line 62 of ./engine/common/host_state.cpp*

### COM_LoadGame

*void COM_LoadGame(const char * pSaveFileName)*

*Defined at line 79 of ./engine/common/host_state.cpp*

### COM_ChangeLevel

*void COM_ChangeLevel(const char * pNewLevel, const char * pLandmarkName, qboolean background)*

*Defined at line 94 of ./engine/common/host_state.cpp*

### COM_Frame

*void COM_Frame(float time)*

*Defined at line 167 of ./engine/common/host_state.cpp*

### CL_Init

*void CL_Init()*

*Defined at line 3061 of ./engine/client/cl_main.cpp*

 cl_main.c

====================CL_Init====================

==============================================================

CLIENT / SERVER SYSTEMS

==============================================================

### CL_Shutdown

*void CL_Shutdown()*

*Defined at line 3096 of ./engine/client/cl_main.cpp*

===============CL_Shutdown

===============

### Host_ClientBegin

*void Host_ClientBegin()*

*Defined at line 2972 of ./engine/client/cl_main.cpp*

==================Host_ClientBegin

==================

### Host_ClientFrame

*void Host_ClientFrame()*

*Defined at line 2996 of ./engine/client/cl_main.cpp*

==================Host_ClientFrame

==================

### CL_Active

*int CL_Active()*

*Defined at line 91 of ./engine/client/cl_main.cpp*

======================================================================

### SV_Init

*void SV_Init()*

*Defined at line 841 of ./engine/server/sv_main.cpp*

===============SV_Init

Only called at startup, not for each game===============

### SV_Shutdown

*void SV_Shutdown(const char * finalmsg)*

*Defined at line 1041 of ./engine/server/sv_main.cpp*

================SV_Shutdown

Called when each game quits,before Sys_Quit or Sys_Error================

### SV_ShutdownFilter

*void SV_ShutdownFilter()*

*Defined at line 439 of ./engine/server/sv_filter.cpp*

### Host_ServerFrame

*void Host_ServerFrame()*

*Defined at line 613 of ./engine/server/sv_main.cpp*

==================Host_ServerFrame

==================

### SV_Active

*qboolean SV_Active()*

*Defined at line 990 of ./engine/server/sv_init.cpp*

### pfnCvar_RegisterServerVariable

*void pfnCvar_RegisterServerVariable(cvar_t * variable)*

*Defined at line 998 of ./engine/common/common.cpp*

=============pfnCvar_RegisterServerVariable

standard path to register game variable=============

==============================================================

	SHARED ENGFUNCS

==============================================================

### pfnCvar_RegisterEngineVariable

*void pfnCvar_RegisterEngineVariable(cvar_t * variable)*

*Defined at line 1013 of ./engine/common/common.cpp*

=============pfnCvar_RegisterEngineVariable

use with precaution: this cvar will NOT unlinkedafter game.dll is unloaded=============

### pfnCvar_RegisterClientVariable

*cvar_t * pfnCvar_RegisterClientVariable(const char * szName, const char * szValue, int flags)*

*Defined at line 1024 of ./engine/common/common.cpp*

=============pfnCvar_RegisterVariable

=============

### pfnCvar_RegisterGameUIVariable

*cvar_t * pfnCvar_RegisterGameUIVariable(const char * szName, const char * szValue, int flags)*

*Defined at line 1037 of ./engine/common/common.cpp*

=============pfnCvar_RegisterVariable

=============

### COM_MemFgets

*char * COM_MemFgets(byte * pMemFile, int fileSize, int * filePos, char * pBuffer, int bufferSize)*

*Defined at line 794 of ./engine/common/common.cpp*

=============COM_MemFgets

=============

### COM_HexConvert

*void COM_HexConvert(const char * pszInput, int nInputLength, byte * pOutput)*

*Defined at line 773 of ./engine/common/common.cpp*

==================COM_HexConvert

Converts pszInput Hex string to nInputLength/2 binary==================

### COM_SaveFile

*int COM_SaveFile(const char * filename, const void * data, int len)*

*Defined at line 916 of ./engine/common/common.cpp*

=============COM_SaveFile

=============

### COM_LoadFileForMe

*byte * COM_LoadFileForMe(const char * filename, int * pLength)*

*Defined at line 865 of ./engine/common/common.cpp*

=============COM_LoadFileForMe

=============

### COM_IsSafeFileToDownload

*qboolean COM_IsSafeFileToDownload(const char * filename)*

*Defined at line 1139 of ./engine/common/common.cpp*

### pfnCVarGetPointer

*cvar_t * pfnCVarGetPointer(const char * szVarName)*

*Defined at line 1051 of ./engine/common/common.cpp*

=============pfnCVarGetPointer

can return NULL=============

### pfnDrawConsoleString

*int pfnDrawConsoleString(int x, int y, char * string)*

*Defined at line 1906 of ./engine/client/cl_game.cpp*

=============pfnDrawConsoleString

drawing string like a console string =============

### pfnDrawSetTextColor

*void pfnDrawSetTextColor(float r, float g, float b)*

*Defined at line 1931 of ./engine/client/cl_game.cpp*

=============pfnDrawSetTextColor

set color for anything=============

### pfnDrawConsoleStringLen

*void pfnDrawConsoleStringLen(const char * pText, int * length, int * height)*

*Defined at line 1947 of ./engine/client/cl_game.cpp*

=============pfnDrawConsoleStringLen

compute string length in screen pixels=============

### Cache_Check

*void * Cache_Check(byte * mempool, struct cache_user_s * c)*

*Defined at line 848 of ./engine/common/common.cpp*

====================Cache_Check

consistency check====================

### COM_TrimSpace

*void COM_TrimSpace(const char * source, char * dest)*

*Defined at line 697 of ./engine/common/common.cpp*

=============COM_TrimSpace

trims all whitespace from the frontand end of a string=============

### pfnPEntityOfEntIndex

*edict_t * pfnPEntityOfEntIndex(int iEntIndex)*

*Defined at line 3326 of ./engine/server/sv_game.cpp*

=============pfnPEntityOfEntIndex

=============

### pfnGetModelBounds

*void pfnGetModelBounds(model_t * mod, float * mins, float * maxs)*

*Defined at line 977 of ./engine/common/common.cpp*

=============pfnGetModelBounds

=============

### pfnCVarDirectSet

*void pfnCVarDirectSet(cvar_t * var, const char * szValue)*

*Defined at line 1063 of ./engine/common/common.cpp*

=============pfnCVarDirectSet

allow to set cvar directly=============

### COM_CheckParm

*int COM_CheckParm(char * parm, char ** ppnext)*

*Defined at line 1102 of ./engine/common/common.cpp*

=============COM_CheckParm

=============

### pfnGetGameDir

*void pfnGetGameDir(char * szGetGameDir)*

*Defined at line 1133 of ./engine/common/common.cpp*

=============pfnGetGameDir

=============

### pfnDecalIndex

*int pfnDecalIndex(const char * m)*

*Defined at line 2528 of ./engine/server/sv_game.cpp*

=================pfnDecalIndex

register decal name on client=================

### pfnGetModelType

*int pfnGetModelType(model_t * mod)*

*Defined at line 965 of ./engine/common/common.cpp*

=============pfnGetModelType

=============

### pfnIsMapValid

*int pfnIsMapValid(char * filename)*

*Defined at line 3671 of ./engine/server/sv_game.cpp*

=============pfnIsMapValid

vaild map must contain one info_player_deatchmatch=============

### Con_Reportf

*void Con_Reportf(LoggingChannel_t channel, const char * fmt)*

*Defined at line 328 of ./engine/common/sys_con.cpp*

### Con_Reportf

*void Con_Reportf(const char * szFmt)*

*Defined at line 302 of ./engine/common/sys_con.cpp*

=============Con_Reportf

=============

### Con_DPrintf

*void Con_DPrintf(const char * fmt)*

*Defined at line 278 of ./engine/common/sys_con.cpp*

=============Con_DPrintf

=============

### Con_DPrintf

*void Con_DPrintf(LoggingChannel_t channel, const char * fmt)*

*Defined at line 349 of ./engine/common/sys_con.cpp*

### Con_Printf

*void Con_Printf(const char * szFmt)*

*Defined at line 257 of ./engine/common/sys_con.cpp*

=============================================================================

CONSOLE PRINT

=============================================================================

=============Con_Printf

=============

### Con_Printf

*void Con_Printf(LoggingChannel_t channel, const char * fmt)*

*Defined at line 370 of ./engine/common/sys_con.cpp*

### pfnNumberOfEntities

*int pfnNumberOfEntities()*

*Defined at line 3770 of ./engine/server/sv_game.cpp*

=============pfnNumberOfEntities

returns actual entity count=============

### pfnIsInGame

*int pfnIsInGame()*

### pfnTime

*float pfnTime()*

*Defined at line 1122 of ./engine/common/common.cpp*

=============pfnTime

=============

### _copystring

*char * _copystring(byte * mempool, const char * s, const char * filename, int fileline)*

*Defined at line 1183 of ./engine/common/common.cpp*

### pfnSequenceGet

*void * pfnSequenceGet(const char * fileName, const char * entryName)*

*Defined at line 1212 of ./engine/common/common.cpp*

 CS:CS engfuncs (stubs)

=============pfnSequenceGet

used by CS:CZ=============

### pfnSequencePickSentence

*void * pfnSequencePickSentence(const char * groupName, int pickMethod, int * picked)*

*Defined at line 1227 of ./engine/common/common.cpp*

=============pfnSequencePickSentence

used by CS:CZ=============

### pfnIsCareerMatch

*int pfnIsCareerMatch()*

*Defined at line 1242 of ./engine/common/common.cpp*

=============pfnIsCareerMatch

used by CS:CZ (client stub)=============

### pfnGetTimesTutorMessageShown

*int pfnGetTimesTutorMessageShown(int mid)*

*Defined at line 1265 of ./engine/common/common.cpp*

 Decay engfuncs (stubs)

=============pfnGetTimesTutorMessageShown

only exists in PlayStation version=============

### pfnRegisterTutorMessageShown

*void pfnRegisterTutorMessageShown(int mid)*

*Defined at line 1254 of ./engine/common/common.cpp*

=============pfnRegisterTutorMessageShown

only exists in PlayStation version=============

### pfnConstructTutorMessageDecayBuffer

*void pfnConstructTutorMessageDecayBuffer(int * buffer, int buflen)*

*Defined at line 1288 of ./engine/common/common.cpp*

=============pfnConstructTutorMessageDecayBuffer

only exists in PlayStation version=============

### pfnProcessTutorMessageDecayBuffer

*void pfnProcessTutorMessageDecayBuffer(int * buffer, int bufferLength)*

*Defined at line 1277 of ./engine/common/common.cpp*

=============pfnProcessTutorMessageDecayBuffer

only exists in PlayStation version=============

### pfnResetTutorMessageDecayData

*void pfnResetTutorMessageDecayData()*

*Defined at line 1299 of ./engine/common/common.cpp*

=============pfnResetTutorMessageDecayData

only exists in PlayStation version=============

### Z_Malloc

*void * Z_Malloc(size_t sz)*

*Defined at line 809 of ./engine/common/common.h*

### Z_Calloc

*void * Z_Calloc(size_t sz)*

*Defined at line 810 of ./engine/common/common.h*

### Z_Realloc

*void * Z_Realloc(void * ptr, size_t sz)*

*Defined at line 811 of ./engine/common/common.h*

### Z_Free

*void Z_Free(void * ptr)*

*Defined at line 812 of ./engine/common/common.h*

### Cmd_AutocompleteName

*qboolean Cmd_AutocompleteName(const char * source, int arg, char * buffer, size_t bufsize)*

*Defined at line 1029 of ./engine/common/con_utils.cpp*

 con_utils.c

============Cmd_AutocompleteName

Autocomplete filenamefor various cmds============

### Con_CompleteCommand

*void Con_CompleteCommand(field_t * field)*

*Defined at line 1115 of ./engine/common/con_utils.cpp*

===============Con_CompleteCommand

perform Tab expansion===============

### Cmd_AutoComplete

*void Cmd_AutoComplete(char * complete_string)*

*Defined at line 1238 of ./engine/common/con_utils.cpp*

=========Cmd_AutoComplete

NOTE: input string must be equal or longer than MAX_STRING=========

### Cmd_AutoCompleteClear

*void Cmd_AutoCompleteClear()*

*Defined at line 1263 of ./engine/common/con_utils.cpp*

============Cmd_AutoCompleteClear

============

### COM_ClearCustomizationList

*void COM_ClearCustomizationList(customization_t * pHead, qboolean bCleanDecals)*

*Defined at line 34 of ./engine/common/custom.cpp*

 custom.c

### COM_CreateCustomization

*qboolean COM_CreateCustomization(customization_t * pHead, resource_t * pRes, int playernum, int flags, customization_t ** pCust, int * nLumps)*

*Defined at line 64 of ./engine/common/custom.cpp*

### COM_SizeofResourceList

*int COM_SizeofResourceList(resource_t * pList, resourceinfo_t * ri)*

*Defined at line 136 of ./engine/common/custom.cpp*

### CSCR_LoadDefaultCVars

*int CSCR_LoadDefaultCVars(const char * scriptfilename)*

*Defined at line 280 of ./engine/common/cfgscript.cpp*

 cfgscript.c

======================CSCR_LoadDefaultCVars

Register all cvars declared in config file and set default values======================

### CSCR_WriteGameCVars

*int CSCR_WriteGameCVars(file_t * cfg, const char * scriptfilename)*

*Defined at line 210 of ./engine/common/cfgscript.cpp*

======================CSCR_WriteGameCVars

Print all cvars declared in script to game.cfg file======================

### HPAK_Init

*void HPAK_Init()*

*Defined at line 1078 of ./engine/common/hpak.cpp*

 hpak.c

### HPAK_GetDataPointer

*qboolean HPAK_GetDataPointer(const char * filename, struct resource_s * pRes, byte ** buffer, int * size)*

*Defined at line 631 of ./engine/common/hpak.cpp*

### HPAK_ResourceForHash

*qboolean HPAK_ResourceForHash(const char * filename, byte * hash, struct resource_s * pRes)*

*Defined at line 510 of ./engine/common/hpak.cpp*

### HPAK_AddLump

*void HPAK_AddLump(qboolean queue, const char * filename, struct resource_s * pRes, byte * data, file_t * f)*

*Defined at line 192 of ./engine/common/hpak.cpp*

### HPAK_RemoveLump

*void HPAK_RemoveLump(const char * name, resource_t * resource)*

*Defined at line 732 of ./engine/common/hpak.cpp*

### HPAK_CheckIntegrity

*void HPAK_CheckIntegrity(const char * filename)*

*Defined at line 475 of ./engine/common/hpak.cpp*

### HPAK_CheckSize

*void HPAK_CheckSize(const char * filename)*

*Defined at line 488 of ./engine/common/hpak.cpp*

### HPAK_FlushHostQueue

*void HPAK_FlushHostQueue()*

*Defined at line 70 of ./engine/common/hpak.cpp*

### Key_IsDown

*int Key_IsDown(int keynum)*

*Defined at line 148 of ./engine/client/keys.cpp*

 keys.c

===================Key_IsDown===================

### Key_IsBind

*const char * Key_IsBind(int keynum)*

*Defined at line 160 of ./engine/client/keys.cpp*

===================Key_GetBind===================

### Key_Event

*void Key_Event(int key, int down)*

*Defined at line 596 of ./engine/client/keys.cpp*

===================Key_Event

Called by the system for both key up and key down events===================

### Key_Init

*void Key_Init()*

*Defined at line 503 of ./engine/client/keys.cpp*

==============================================================================

			LINE TYPING INTO THE CONSOLE

==============================================================================

===================Key_Init===================

### Key_WriteBindings

*void Key_WriteBindings(file_t * f)*

*Defined at line 455 of ./engine/client/keys.cpp*

============Key_WriteBindings

Writes lines containing "bind key value"============

### Key_GetBinding

*const char * Key_GetBinding(int keynum)*

*Defined at line 298 of ./engine/client/keys.cpp*

===================Key_GetBinding===================

### Key_SetBinding

*void Key_SetBinding(int keynum, const char * binding)*

*Defined at line 277 of ./engine/client/keys.cpp*

===================Key_SetBinding===================

### Key_ClearStates

*void Key_ClearStates()*

*Defined at line 799 of ./engine/client/keys.cpp*

===================Key_ClearStates===================

### Key_KeynumToString

*const char * Key_KeynumToString(int keynum)*

*Defined at line 235 of ./engine/client/keys.cpp*

===================Key_KeynumToString

Returns a string (either a single ascii char, a K_* name, or a 0x11 hex string) for thegiven keynum.===================

### Key_StringToKeynum

*int Key_StringToKeynum(const char * str)*

*Defined at line 180 of ./engine/client/keys.cpp*

===================Key_StringToKeynum

Returns a key number to be used to index keys[] by looking atthe given string.  Single ascii characters return themselves, whilethe K_* names are matched up.

0x11 will be interpreted as raw hex, which will allow new controlers

to be configured even if they don't have defined names.===================

### Key_GetKey

*int Key_GetKey(const char * binding)*

*Defined at line 309 of ./engine/client/keys.cpp*

===================Key_GetKey===================

### Key_EnumCmds_f

*void Key_EnumCmds_f()*

*Defined at line 1483 of ./engine/common/con_utils.cpp*

### Key_SetKeyDest

*void Key_SetKeyDest(int key_dest)*

*Defined at line 766 of ./engine/client/keys.cpp*

=========Key_SetKeyDest=========

### Key_EnableTextInput

*void Key_EnableTextInput(qboolean enable, qboolean force)*

*Defined at line 750 of ./engine/client/keys.cpp*

================Key_EnableTextInput

================

### AVI_GetVideoFrameNumber

*int AVI_GetVideoFrameNumber(movie_state_t * Avi, float time)*

*Defined at line 19 of ./engine/client/avi/avi_stub.cpp*

### AVI_GetVideoFrame

*byte * AVI_GetVideoFrame(movie_state_t * Avi, int frame)*

*Defined at line 24 of ./engine/client/avi/avi_stub.cpp*

### AVI_GetVideoInfo

*qboolean AVI_GetVideoInfo(movie_state_t * Avi, int * xres, int * yres, float * duration)*

*Defined at line 29 of ./engine/client/avi/avi_stub.cpp*

### AVI_GetAudioInfo

*qboolean AVI_GetAudioInfo(movie_state_t * Avi, wavdata_t * snd_info)*

*Defined at line 34 of ./engine/client/avi/avi_stub.cpp*

### AVI_GetAudioChunk

*int AVI_GetAudioChunk(movie_state_t * Avi, char * audiodata, int offset, int length)*

*Defined at line 39 of ./engine/client/avi/avi_stub.cpp*

### AVI_OpenVideo

*void AVI_OpenVideo(movie_state_t * Avi, const char * filename, qboolean load_audio, int quiet)*

*Defined at line 44 of ./engine/client/avi/avi_stub.cpp*

### AVI_LoadVideo

*movie_state_t * AVI_LoadVideo(const char * filename, qboolean load_audio)*

*Defined at line 49 of ./engine/client/avi/avi_stub.cpp*

### AVI_TimeToSoundPosition

*int AVI_TimeToSoundPosition(movie_state_t * Avi, int time)*

*Defined at line 54 of ./engine/client/avi/avi_stub.cpp*

### AVI_GetVideoFrameCount

*int AVI_GetVideoFrameCount(movie_state_t * Avi)*

*Defined at line 59 of ./engine/client/avi/avi_stub.cpp*

### AVI_CloseVideo

*void AVI_CloseVideo(movie_state_t * Avi)*

*Defined at line 64 of ./engine/client/avi/avi_stub.cpp*

### AVI_IsActive

*qboolean AVI_IsActive(movie_state_t * Avi)*

*Defined at line 69 of ./engine/client/avi/avi_stub.cpp*

### AVI_FreeVideo

*void AVI_FreeVideo(movie_state_t * Avi)*

*Defined at line 74 of ./engine/client/avi/avi_stub.cpp*

### AVI_GetState

*movie_state_t * AVI_GetState(int num)*

*Defined at line 79 of ./engine/client/avi/avi_stub.cpp*

### AVI_Initailize

*qboolean AVI_Initailize()*

*Defined at line 84 of ./engine/client/avi/avi_stub.cpp*

### AVI_Shutdown

*void AVI_Shutdown()*

*Defined at line 89 of ./engine/client/avi/avi_stub.cpp*

### CL_IsInGame

*qboolean CL_IsInGame()*

*Defined at line 102 of ./engine/client/cl_main.cpp*

======================================================================

### CL_IsInMenu

*qboolean CL_IsInMenu()*

*Defined at line 113 of ./engine/client/cl_main.cpp*

### CL_IsInConsole

*qboolean CL_IsInConsole()*

*Defined at line 118 of ./engine/client/cl_main.cpp*

### CL_IsThirdPerson

*qboolean CL_IsThirdPerson()*

*Defined at line 148 of ./engine/client/cl_game.cpp*

====================CL_IsThirdPerson

returns true if thirdperson is enabled====================

### CL_IsIntermission

*qboolean CL_IsIntermission()*

*Defined at line 123 of ./engine/client/cl_main.cpp*

### CL_Initialized

*qboolean CL_Initialized()*

*Defined at line 96 of ./engine/client/cl_main.cpp*

### CL_Userinfo

*char * CL_Userinfo()*

*Defined at line 158 of ./engine/client/cl_main.cpp*

### CL_LegacyUpdateInfo

*void CL_LegacyUpdateInfo()*

*Defined at line 3217 of ./engine/client/cl_parse.cpp*

### CL_CharEvent

*void CL_CharEvent(int key)*

*Defined at line 827 of ./engine/client/keys.cpp*

===================CL_CharEvent

Normal keyboard characters, already shifted / capslocked / etc===================

### CL_DisableVisibility

*qboolean CL_DisableVisibility()*

*Defined at line 143 of ./engine/client/cl_main.cpp*

### CL_PointContents

*int CL_PointContents(const vec3_t point)*

*Defined at line 266 of ./engine/client/cl_game.cpp*

====================CL_PointContents

Return contents for point====================

### COM_ParseFile

*char * COM_ParseFile(char * data, char * token)*

*Defined at line 488 of ./engine/common/common.cpp*

==============COM_ParseFile

text parser==============

### COM_LoadFile

*byte * COM_LoadFile(const char * filename, int usehunk, int * pLength)*

*Defined at line 905 of ./engine/common/common.cpp*

=============COM_LoadFile

=============

### CL_GetDemoComment

*int CL_GetDemoComment(const char * demoname, char * comment)*

*Defined at line 1174 of ./engine/client/cl_demo.cpp*

================== CL_GetDemoComment================== 

### COM_AddAppDirectoryToSearchPath

*void COM_AddAppDirectoryToSearchPath(const char * pszBaseDir, const char * appName)*

*Defined at line 651 of ./engine/common/common.cpp*

=============COM_AddAppDirectoryToSearchPath

=============

### COM_ExpandFilename

*int COM_ExpandFilename(const char * fileName, char * nameOutBuffer, int nameOutBufferSize)*

*Defined at line 664 of ./engine/common/common.cpp*

===========COM_ExpandFilename

Finds the file in the search path, copies over the name with the full path name.This doesn't search in the pak file.===========

### Cmd_GetFirstFunctionHandle

*struct cmd_s * Cmd_GetFirstFunctionHandle()*

*Defined at line 540 of ./engine/common/cmd.cpp*

============Cmd_GetList============

### Cmd_GetNextFunctionHandle

*struct cmd_s * Cmd_GetNextFunctionHandle(struct cmd_s * cmd)*

*Defined at line 550 of ./engine/common/cmd.cpp*

============Cmd_GetNext============

### Cmd_AliasGetList

*struct cmdalias_s * Cmd_AliasGetList()*

*Defined at line 530 of ./engine/common/cmd.cpp*

============Cmd_AliasGetList============

### Cmd_GetName

*char * Cmd_GetName(struct cmd_s * cmd)*

*Defined at line 560 of ./engine/common/cmd.cpp*

============Cmd_GetName============

### PM_TraceLine

*struct pmtrace_s * PM_TraceLine(float * start, float * end, int flags, int usehull, int ignore_pe)*

*Defined at line 758 of ./engine/client/cl_pmove.cpp*

### SV_StartSound

*void SV_StartSound(edict_t * ent, int chan, const char * sample, float vol, float attn, int flags, int pitch)*

*Defined at line 2112 of ./engine/server/sv_game.cpp*

=================SV_StartSound

=================

### SV_StartMusic

*void SV_StartMusic(const char * curtrack, const char * looptrack, int position)*

*Defined at line 2174 of ./engine/server/sv_game.cpp*

=================SV_StartMusic

=================

### SV_CreateDecal

*void SV_CreateDecal(sizebuf_t * msg, const float * origin, int decalIndex, int entityIndex, int modelIndex, int flags, float scale)*

*Defined at line 471 of ./engine/server/sv_game.cpp*

=======================SV_CreateDecal

NOTE: static decals only accepted when game is loading=======================

### Log_Printf

*void Log_Printf(const char * fmt)*

*Defined at line 97 of ./engine/server/sv_log.cpp*

==================Log_Printf

Prints a frag log message to the server's frag log file, console, and possible a UDP port.==================

### SV_BroadcastCommand

*void SV_BroadcastCommand(const char * fmt)*

*Defined at line 91 of ./engine/server/sv_cmds.cpp*

=================SV_BroadcastCommand

Sends text to all active clients=================

### SV_RestoreCustomDecal

*qboolean SV_RestoreCustomDecal(struct decallist_s * entry, edict_t * pEdict, qboolean adjacent)*

*Defined at line 453 of ./engine/server/sv_game.cpp*

=======================SV_RestoreCustomDecal

Let the user spawn decal in game code=======================

### SV_BroadcastPrintf

*void SV_BroadcastPrintf(sv_client_t * ignore, char * fmt)*

*Defined at line 51 of ./engine/server/sv_cmds.cpp*

=================SV_BroadcastPrintf

Sends text to all active clients=================

### CL_ClearStaticEntities

*void CL_ClearStaticEntities()*

*Defined at line 3020 of ./engine/client/cl_tent.cpp*

=======================R_ClearStaticEntities

e.g. by demo request=======================

### S_StreamGetCurrentState

*qboolean S_StreamGetCurrentState(char * currentTrack, char * loopTrack, int * position)*

*Defined at line 144 of ./engine/client/s_stream.cpp*

=================S_StreamGetCurrentState

save**<not a builtin command>**  code=================

### CL_GetEntityByIndex

*struct cl_entity_s * CL_GetEntityByIndex(int index)*

*Defined at line 113 of ./engine/client/cl_game.cpp*

====================CL_GetEntityByIndex

Render callback for studio models====================

### CL_GetPlayerInfo

*struct player_info_s * CL_GetPlayerInfo(int playerIndex)*

*Defined at line 164 of ./engine/client/cl_game.cpp*

====================CL_GetPlayerInfo

get player info by render request====================

### CL_ServerCommand

*void CL_ServerCommand(qboolean reliable, char * fmt)*

*Defined at line 2537 of ./engine/client/cl_main.cpp*

====================CL_ServerCommand

send command to a server====================

### CL_HudMessage

*void CL_HudMessage(const char * pMessage)*

*Defined at line 689 of ./engine/client/cl_game.cpp*

====================CL_HudMessage

Template to show hud messages====================

### CL_MsgInfo

*const char * CL_MsgInfo(int cmd)*

*Defined at line 107 of ./engine/client/cl_debug.cpp*

### SV_DrawDebugTriangles

*void SV_DrawDebugTriangles()*

*Defined at line 1874 of ./engine/server/sv_phys.cpp*

================SV_DrawDebugTriangles

Called from renderer for debug purposes================

### SV_DrawOrthoTriangles

*void SV_DrawOrthoTriangles()*

*Defined at line 1910 of ./engine/server/sv_phys.cpp*

================SV_DrawOrthoTriangles

Called from renderer for debug purposes================

### CL_GetDemoFramerate

*double CL_GetDemoFramerate()*

*Defined at line 183 of ./engine/client/cl_demo.cpp*

====================CL_GetDemoFramerate

overwrite host.frametime====================

### UI_CreditsActive

*qboolean UI_CreditsActive()*

*Defined at line 114 of ./engine/client/cl_gameui.cpp*

### CL_StopPlayback

*void CL_StopPlayback()*

*Defined at line 1122 of ./engine/client/cl_demo.cpp*

==============CL_StopPlayback

Called when a demo file runs out, or the user starts a game==============

### CL_ExtraUpdate

*void CL_ExtraUpdate()*

*Defined at line 1409 of ./engine/client/cl_frame.cpp*

### CL_GetMaxClients

*int CL_GetMaxClients()*

*Defined at line 817 of ./engine/client/cl_game.cpp*

====================CL_GetMaxlients

Render callback for studio models====================

### SV_GetMaxClients

*int SV_GetMaxClients()*

*Defined at line 1000 of ./engine/server/sv_init.cpp*

### CL_IsRecordDemo

*qboolean CL_IsRecordDemo()*

*Defined at line 133 of ./engine/client/cl_main.cpp*

### CL_IsTimeDemo

*qboolean CL_IsTimeDemo()*

*Defined at line 138 of ./engine/client/cl_main.cpp*

### CL_IsPlaybackDemo

*qboolean CL_IsPlaybackDemo()*

*Defined at line 128 of ./engine/client/cl_main.cpp*

### CL_IsBackgroundDemo

*qboolean CL_IsBackgroundDemo()*

*Defined at line 148 of ./engine/client/cl_main.cpp*

### CL_IsBackgroundMap

*qboolean CL_IsBackgroundMap()*

*Defined at line 153 of ./engine/client/cl_main.cpp*

### SV_Initialized

*qboolean SV_Initialized()*

*Defined at line 995 of ./engine/server/sv_init.cpp*

### CL_LoadProgs

*qboolean CL_LoadProgs(const char * name)*

*Defined at line 4581 of ./engine/client/cl_game.cpp*

### CL_ProcessFile

*void CL_ProcessFile(qboolean successfully_received, const char * filename)*

*Defined at line 2402 of ./engine/client/cl_main.cpp*

====================CL_ProcessFile

A file has been received via the fragmentation/reassembly layer, put it in the right spot and see if we have finished downloading files.====================

### SV_GetSaveComment

*int SV_GetSaveComment(const char * savename, char * comment)*

*Defined at line 2187 of ./engine/server/sv_save.cpp*

================== SV_GetSaveComment

check savegame for valid================== 

### SV_NewGame

*qboolean SV_NewGame(const char * mapName, qboolean loadGame)*

### SV_ClipPMoveToEntity

*void SV_ClipPMoveToEntity(struct physent_s * pe, const vec3_t start, vec3_t mins, vec3_t maxs, const vec3_t end, struct pmtrace_s * tr)*

*Defined at line 46 of ./engine/server/sv_pmove.cpp*

### CL_ClipPMoveToEntity

*void CL_ClipPMoveToEntity(struct physent_s * pe, const vec3_t start, vec3_t mins, vec3_t maxs, const vec3_t end, struct pmtrace_s * tr)*

*Defined at line 330 of ./engine/client/cl_pmove.cpp*

### SV_SysError

*void SV_SysError(const char * error_string)*

*Defined at line 108 of ./engine/server/sv_game.cpp*

=============SV_SysError

tell the game.dll about system error=============

### SV_ShutdownGame

*void SV_ShutdownGame()*

*Defined at line 704 of ./engine/server/sv_init.cpp*

==============SV_ShutdownGame

prepare to close server==============

### SV_ExecLoadLevel

*void SV_ExecLoadLevel()*

*Defined at line 1032 of ./engine/server/sv_init.cpp*

================SV_ExecLoadLevel

State machine exec new map================

### SV_ExecLoadGame

*void SV_ExecLoadGame()*

*Defined at line 1049 of ./engine/server/sv_init.cpp*

================SV_ExecLoadGame

State machine exec load saved game================

### SV_ExecChangeLevel

*void SV_ExecChangeLevel()*

*Defined at line 1066 of ./engine/server/sv_init.cpp*

================SV_ExecChangeLevel

State machine exec changelevel path================

### SV_InitGameProgs

*void SV_InitGameProgs()*

*Defined at line 1005 of ./engine/server/sv_init.cpp*

### SV_FreeGameProgs

*void SV_FreeGameProgs()*

*Defined at line 1017 of ./engine/server/sv_init.cpp*

### Q_IsValidUChar32

*_Bool Q_IsValidUChar32(uchar32 uVal)*

*Defined at line 40 of ./mainui/unicode_strtools.cpp*

----------------------------------------------------------------------------- Purpose: determine if a uchar32 represents a valid Unicode code point-----------------------------------------------------------------------------

### CL_WriteMessageHistory

*void CL_WriteMessageHistory()*

*Defined at line 210 of ./engine/client/cl_debug.cpp*

=====================CL_WriteMessageHistory

list last 32 messages for debugging net troubleshooting=====================

### Q_UTF32ToUChar32

*int Q_UTF32ToUChar32(const uchar32 * pUTF32, uchar32 & uVal, _Bool & bErr)*

*Defined at line 48 of ./mainui/unicode_strtools.cpp*

<f38f8> ../engine/unicode_strtools.cpp:50 

### CL_SendCmd

*void CL_SendCmd()*

### CL_Disconnect

*void CL_Disconnect()*

*Defined at line 1488 of ./engine/client/cl_main.cpp*

=====================CL_Disconnect

Goes from a connected state to full screen console stateSends a disconnect message to the serverThis is also called on Host_Error, so it shouldn't cause any errors=====================

### Q_UChar32ToUTF32Len

*int Q_UChar32ToUTF32Len(uchar32 uVal)*

*Defined at line 79 of ./mainui/unicode_strtools.cpp*

<f2fab> ../engine/unicode_strtools.cpp:57 

### CL_ClearEdicts

*void CL_ClearEdicts()*

*Defined at line 1172 of ./engine/client/cl_game.cpp*

### Q_UChar32ToUTF32

*int Q_UChar32ToUTF32(uchar32 uVal, uchar32 * pUTF32)*

*Defined at line 85 of ./mainui/unicode_strtools.cpp*

<f330f> ../engine/unicode_strtools.cpp:62 

### CL_Crashed

*void CL_Crashed()*

*Defined at line 1534 of ./engine/client/cl_main.cpp*

### Q_UChar32ToUTF8Len

*int Q_UChar32ToUTF8Len(uchar32 uVal)*

*Defined at line 173 of ./mainui/unicode_strtools.cpp*

<f2fe5> ../engine/unicode_strtools.cpp:137 

### CL_NextDemo

*qboolean CL_NextDemo()*

*Defined at line 1244 of ./engine/client/cl_demo.cpp*

==================CL_NextDemo

Called when a demo finishes==================

### Q_UChar32ToUTF16Len

*int Q_UChar32ToUTF16Len(uchar32 uVal)*

*Defined at line 185 of ./mainui/unicode_strtools.cpp*

<f3030> ../engine/unicode_strtools.cpp:152 

### SV_Serverinfo

*char * SV_Serverinfo()*

*Defined at line 123 of ./engine/server/sv_game.cpp*

=============SV_Serverinfo

get server infostring=============

### CL_Drop

*void CL_Drop()*

*Defined at line 993 of ./engine/client/cl_main.cpp*

================CL_Drop

Called after an Host_Error was thrown================

### Q_UChar32ToUTF16

*int Q_UChar32ToUTF16(uchar32 uVal, uchar16 * pUTF16Out)*

*Defined at line 191 of ./mainui/unicode_strtools.cpp*

<f3002> ../engine/unicode_strtools.cpp:163 

### Con_Init

*void Con_Init()*

*Defined at line 1156 of ./engine/client/console.cpp*

================Con_Init================

### Q_UChar32ToUTF8

*int Q_UChar32ToUTF8(uchar32 uVal, char * pUTF8Out)*

*Defined at line 207 of ./mainui/unicode_strtools.cpp*

<f3192> ../engine/unicode_strtools.cpp:180 

### SCR_Init

*void SCR_Init()*

*Defined at line 756 of ./engine/client/cl_scrn.cpp*

==================SCR_Init==================

### Q_UTF16ToUChar32

*int Q_UTF16ToUChar32(const uchar16 * pUTF16, uchar32 & uValueOut, _Bool & bErrorOut)*

*Defined at line 238 of ./mainui/unicode_strtools.cpp*

<f32b4> ../engine/unicode_strtools.cpp:209 

### SCR_UpdateScreen

*void SCR_UpdateScreen()*

*Defined at line 496 of ./engine/client/cl_scrn.cpp*

==================SCR_UpdateScreen

This is called every frame, and can also be called explicitly to flushtext to the screen.==================

### SCR_BeginLoadingPlaque

*void SCR_BeginLoadingPlaque(qboolean is_background)*

*Defined at line 342 of ./engine/client/cl_scrn.cpp*

================SCR_BeginLoadingPlaque================

### Q_UTF8ToUTF16

*int Q_UTF8ToUTF16(const char * pUTF8, uchar16 * pUTF16, int cubDestSizeInBytes, enum EStringConvertErrorPolicy ePolicy)*

*Defined at line 269 of ./mainui/unicode_strtools.cpp*

<f4468> ../engine/unicode_strtools.cpp:246 

### SCR_CheckStartupVids

*void SCR_CheckStartupVids()*

*Defined at line 84 of ./engine/client/cl_video.cpp*

### Q_UTF8ToUTF32

*int Q_UTF8ToUTF32(const char * pUTF8, uchar32 * pUTF32, int cubDestSizeInBytes, enum EStringConvertErrorPolicy ePolicy)*

*Defined at line 275 of ./mainui/unicode_strtools.cpp*

<f3822> ../engine/unicode_strtools.cpp:254 

### SCR_GetAudioChunk

*int SCR_GetAudioChunk(char * rawdata, int length)*

*Defined at line 245 of ./engine/client/cl_video.cpp*

### SCR_GetMovieInfo

*wavdata_t * SCR_GetMovieInfo()*

*Defined at line 255 of ./engine/client/cl_video.cpp*

### Q_UTF16ToUTF8

*int Q_UTF16ToUTF8(const uchar16 * pUTF16, char * pUTF8, int cubDestSizeInBytes, enum EStringConvertErrorPolicy ePolicy)*

*Defined at line 281 of ./mainui/unicode_strtools.cpp*

<f3d09> ../engine/unicode_strtools.cpp:262 

### SCR_Shutdown

*void SCR_Shutdown()*

*Defined at line 797 of ./engine/client/cl_scrn.cpp*

### Q_UTF16ToUTF32

*int Q_UTF16ToUTF32(const uchar16 * pUTF16, uchar32 * pUTF32, int cubDestSizeInBytes, enum EStringConvertErrorPolicy ePolicy)*

*Defined at line 287 of ./mainui/unicode_strtools.cpp*

<f3f0d> ../engine/unicode_strtools.cpp:270 

### Con_Print

*void Con_Print(const char * txt)*

*Defined at line 1227 of ./engine/client/console.cpp*

================Con_Print

Handles cursor positioning, line wrapping, etcAll console printing must go through this in order to be displayedIf no console is visible, the notify window will pop up.================

### Q_UTF32ToUTF8

*int Q_UTF32ToUTF8(const uchar32 * pUTF32, char * pUTF8, int cubDestSizeInBytes, enum EStringConvertErrorPolicy ePolicy)*

*Defined at line 293 of ./mainui/unicode_strtools.cpp*

<f38aa> ../engine/unicode_strtools.cpp:278 

### Con_NPrintf

*void Con_NPrintf(int idx, const char * fmt)*

*Defined at line 1327 of ./engine/client/console.cpp*

================Con_NPrint

Draw a single debug line with specified height================

### Con_NXPrintf

*void Con_NXPrintf(con_nprint_t * info, const char * fmt)*

*Defined at line 1354 of ./engine/client/console.cpp*

================Con_NXPrint

Draw a single debug line with specified height, color and time to live================

### Q_UTF32ToUTF16

*int Q_UTF32ToUTF16(const uchar32 * pUTF32, uchar16 * pUTF16, int cubDestSizeInBytes, enum EStringConvertErrorPolicy ePolicy)*

*Defined at line 299 of ./mainui/unicode_strtools.cpp*

<f404a> ../engine/unicode_strtools.cpp:286 

### UI_NPrintf

*void UI_NPrintf(int idx, const char * fmt)*

*Defined at line 1383 of ./engine/client/console.cpp*

================UI_NPrint

Draw a single debug line with specified height (menu version)================

### Q_UTF8ToUChar32

*int Q_UTF8ToUChar32(const char * pUTF8_, uchar32 & uValueOut, _Bool & bErrorOut)*

*Defined at line 307 of ./mainui/unicode_strtools.cpp*

 Decode one character from a UTF-8 encoded string. Treats 6-byte CESU-8 sequences as a single character, as if they were a correctly-encoded 4-byte UTF-8 sequence.

### Q_UnicodeValidate

*qboolean Q_UnicodeValidate(const char * pUTF8)*

*Defined at line 382 of ./mainui/unicode_strtools.cpp*

----------------------------------------------------------------------------- Purpose: Returns true if UTF-8 string contains invalid sequences.-----------------------------------------------------------------------------

### Q_UnicodeLength

*int Q_UnicodeLength(const char * pUTF8)*

*Defined at line 399 of ./mainui/unicode_strtools.cpp*

<f4665> ../engine/unicode_strtools.cpp:442 

### UI_NXPrintf

*void UI_NXPrintf(con_nprint_t * info, const char * fmt)*

*Defined at line 1410 of ./engine/client/console.cpp*

================UI_NXPrint

Draw a single debug line with specified height, color and time to live (menu version)================

### Q_UnicodeAdvance

*char * Q_UnicodeAdvance(char * pUTF8, int nChars)*

*Defined at line 417 of ./mainui/unicode_strtools.cpp*

<f46d1> ../engine/unicode_strtools.cpp:459 

### Info_ValueForKey

*const char * Info_ValueForKey(const char * s, const char * key)*

*Defined at line 192 of ./engine/common/infostring.cpp*

===============Info_ValueForKey

Searches the string for the givenkey and returns the associated value, or an empty string.===============

### Q_IsDeprecatedW

*_Bool Q_IsDeprecatedW(uchar16 wch)*

*Defined at line 552 of ./mainui/unicode_strtools.cpp*

<f37f5> ../engine/unicode_strtools.cpp:566 

bool Q_IsMeanSpaceW(uchar16 wch);

### Info_RemovePrefixedKeys

*void Info_RemovePrefixedKeys(char * start, char prefix)*

*Defined at line 288 of ./engine/common/infostring.cpp*

### StripUnprintableWorker

*uchar16 * StripUnprintableWorker(uchar16 * pwch, _Bool * pbStrippedAny)*

*Defined at line 614 of ./mainui/unicode_strtools.cpp*

<f3860> ../engine/unicode_strtools.cpp:653 

### Info_RemoveKey

*qboolean Info_RemoveKey(char * s, const char * key)*

*Defined at line 236 of ./engine/common/infostring.cpp*

### Q_StripUnprintableAndSpace

*qboolean Q_StripUnprintableAndSpace(char * pch)*

*Defined at line 637 of ./mainui/unicode_strtools.cpp*

<f4800> ../engine/unicode_strtools.cpp:691 

### Info_SetValueForKey

*qboolean Info_SetValueForKey(char * s, const char * key, const char * value, int maxsize)*

*Defined at line 489 of ./engine/common/infostring.cpp*

### Info_SetValueForStarKey

*qboolean Info_SetValueForStarKey(char * s, const char * key, const char * value, int maxsize)*

*Defined at line 415 of ./engine/common/infostring.cpp*

### V_UTF8ToUChar32

*qboolean V_UTF8ToUChar32(const char * pUTF8_, uchar32 * uValueOut)*

*Defined at line 662 of ./mainui/unicode_strtools.cpp*

<f4a0d> ../engine/unicode_strtools.cpp:717 

### Info_IsValid

*qboolean Info_IsValid(const char * s)*

*Defined at line 92 of ./engine/common/infostring.cpp*

==============Info_IsValid

check infostring for potential problems==============

### Info_WriteVars

*void Info_WriteVars(file_t * f)*

*Defined at line 141 of ./engine/common/infostring.cpp*

==============Info_WriteVars

==============

### Q_UnicodeRepair

*int Q_UnicodeRepair(char * pUTF8)*

*Defined at line 670 of ./mainui/unicode_strtools.cpp*

<f4a63> ../engine/unicode_strtools.cpp:724 

### Info_Print

*void Info_Print(const char * s)*

*Defined at line 34 of ./engine/common/infostring.cpp*

=======================================================================

			INFOSTRING STUFF

=======================================================================

===============Info_Print

printing current key-value pair===============

### Cmd_WriteVariables

*void Cmd_WriteVariables(file_t * f)*

### Q_AdvanceSpace

*wchar_t * Q_AdvanceSpace(wchar_t * start)*

*Defined at line 431 of ./mainui/unicode_strtools.cpp*

### Cmd_CheckMapsList

*int Cmd_CheckMapsList(int fRefresh)*

*Defined at line 969 of ./engine/common/con_utils.cpp*

### COM_SetRandomSeed

*void COM_SetRandomSeed(int lSeed)*

*Defined at line 113 of ./engine/common/common.cpp*

### Q_ReadUToken

*wchar_t * Q_ReadUToken(wchar_t * start, wchar_t * token, int tokenBufferSize, _Bool & quoted)*

*Defined at line 439 of ./mainui/unicode_strtools.cpp*

### COM_RandomLong

*int COM_RandomLong(int lMin, int lMax)*

*Defined at line 134 of ./engine/common/common.cpp*

### COM_RandomFloat

*float COM_RandomFloat(float fMin, float fMax)*

*Defined at line 124 of ./engine/common/common.cpp*

### LZSS_IsCompressed

*qboolean LZSS_IsCompressed(const byte * source)*

*Defined at line 201 of ./engine/common/common.cpp*

### LZSS_GetActualSize

*uint LZSS_GetActualSize(const byte * source)*

*Defined at line 210 of ./engine/common/common.cpp*

### LZSS_Compress

*byte * LZSS_Compress(byte * pInput, int inputLength, uint * pOutputSize)*

*Defined at line 370 of ./engine/common/common.cpp*

### LZSS_Decompress

*uint LZSS_Decompress(const byte * pInput, byte * pOutput)*

*Defined at line 390 of ./engine/common/common.cpp*

### VID_InitDefaultResolution

*void VID_InitDefaultResolution()*

*Defined at line 52 of ./engine/client/vid_common.cpp*

=================VID_InitDefaultResolution=================

### VID_Init

*void VID_Init()*

*Defined at line 164 of ./engine/client/vid_common.cpp*

### UI_SetActiveMenu

*void UI_SetActiveMenu(qboolean fActive)*

*Defined at line 822 of ./mainui/BaseMenu.cpp*

=================UI_SetActiveMenu=================

### UI_ShowConnectionWarning

*void UI_ShowConnectionWarning()*

*Defined at line 175 of ./engine/client/cl_gameui.cpp*

=================UI_ShowConnectionWarning

show connection warning dialog implemented by gameui dll=================

### Cmd_Null_f

*void Cmd_Null_f()*

*Defined at line 1238 of ./engine/common/cmd.cpp*

============Cmd_Null_f

null function for some cmd stubs============

### S_Init

*qboolean S_Init()*

*Defined at line 1810 of ./engine/client/s_main.cpp*

 soundlib shared exports

================S_Init================

### S_Shutdown

*void S_Shutdown()*

*Defined at line 1869 of ./engine/client/s_main.cpp*

 ======================================================================= Shutdown sound engine =======================================================================

### Q_UnicodeConvertT

*int Q_UnicodeConvertT(const T_IN * pIn, T_OUT * pOut, int nOutBytes, enum EStringConvertErrorPolicy ePolicy)*

*Defined at line 109 of ./mainui/unicode_strtools.cpp*

<f4344> ../engine/unicode_strtools.cpp:70 

### S_StopSound

*void S_StopSound(int entnum, int channel, const char * soundname)*

*Defined at line 1412 of ./engine/client/s_main.cpp*

==================S_StopSound

stop all sounds for entity on a channel.==================

### S_GetCurrentStaticSounds

*int S_GetCurrentStaticSounds(soundlist_t * pout, int size)*

*Defined at line 827 of ./engine/client/s_main.cpp*

==================S_GetCurrentStaticSounds

grab all static sounds playing at current channel==================

### S_StopBackgroundTrack

*void S_StopBackgroundTrack()*

*Defined at line 115 of ./engine/client/s_stream.cpp*

=================S_StopBackgroundTrack=================

### S_StopAllSounds

*void S_StopAllSounds(qboolean ambient)*

*Defined at line 1426 of ./engine/client/s_main.cpp*

==================S_StopAllSounds==================

### BuildGammaTable

*void BuildGammaTable(float gamma, float brightness)*

*Defined at line 27 of ./engine/common/gamma.cpp*

 gamma routines

### LightToTexGamma

*byte LightToTexGamma(byte b)*

*Defined at line 79 of ./engine/common/gamma.cpp*

### TextureToGamma

*byte TextureToGamma(byte b)*

*Defined at line 84 of ./engine/common/gamma.cpp*

### ID_Init

*void ID_Init()*

*Defined at line 612 of ./engine/common/identification.cpp*

 identification.c

### ID_GetMD5

*const char * ID_GetMD5()*

*Defined at line 591 of ./engine/common/identification.cpp*

### ID_SetCustomClientID

*void ID_SetCustomClientID(const char * id)*

*Defined at line 604 of ./engine/common/identification.cpp*

===============ID_SetCustomClientID

===============

### Sequence_Get

*sequenceEntry_s * Sequence_Get(const char * fileName, const char * entryName)*

*Defined at line 1591 of ./engine/common/sequence.cpp*

--------------------------------------------------------------------------- Function declarations---------------------------------------------------------------------------

==============SequenceGet

==============

### Sequence_PickSentence

*sentenceEntry_s * Sequence_PickSentence(const char * groupName, int pickMethod, int * picked)*

*Defined at line 1120 of ./engine/common/sequence.cpp*

=============Sequence_PickSentence

=============

### NET_InitMasters

*void NET_InitMasters()*

*Defined at line 249 of ./engine/common/masterlist.cpp*

 masterlist.c

========================NET_InitMasters

Initialize master server list========================

### NET_SaveMasters

*void NET_SaveMasters()*

*Defined at line 214 of ./engine/common/masterlist.cpp*

========================NET_SaveMasters

Save master server list to xashcomm.lst, except for default========================

### NET_SendToMasters

*qboolean NET_SendToMasters(netsrc_t sock, size_t len, const void * data)*

*Defined at line 40 of ./engine/common/masterlist.cpp*

========================NET_SendToMasters

Send request to all masterservers listreturn true if would block========================

### bIsMultiplayer

*_Bool bIsMultiplayer()*

*Defined at line 108 of ./game/client/hl/hl_weapons.cpp*

Returns if it's multiplayer.Mostly used by the client side weapons.

### LoadVModel

*void LoadVModel(const char * szViewModel, class CBasePlayer * m_pPlayer)*

*Defined at line 114 of ./game/client/hl/hl_weapons.cpp*

Just loads a v_ model.

### Q_IsMeanSpaceW

*_Bool Q_IsMeanSpaceW(uchar32 wch)*

*Defined at line 514 of ./mainui/unicode_strtools.cpp*

### StripWhitespaceWorker

*uchar16 * StripWhitespaceWorker(uchar16 * pwch, int cchLength, _Bool * pbStrippedWhitespace)*

*Defined at line 585 of ./mainui/unicode_strtools.cpp*

### HPAK_TypeFromIndex

*const char * HPAK_TypeFromIndex(int type)*

*Defined at line 37 of ./engine/common/hpak.cpp*

### HPAK_AddToQueue

*void HPAK_AddToQueue(const char * name, resource_t * pResource, void * data, file_t * f)*

*Defined at line 52 of ./engine/common/hpak.cpp*

### HPAK_CreatePak

*void HPAK_CreatePak(const char * filename, resource_t * pResource, byte * pData, file_t * fin)*

*Defined at line 85 of ./engine/common/hpak.cpp*

### HPAK_FindResource

*qboolean HPAK_FindResource(hpak_info_t * hpk, byte * hash, resource_t * pResource)*

*Defined at line 175 of ./engine/common/hpak.cpp*

### HPAK_Validate

*qboolean HPAK_Validate(const char * filename, qboolean quiet)*

*Defined at line 364 of ./engine/common/hpak.cpp*

### HPAK_ValidatePak

*void HPAK_ValidatePak(const char * filename)*

*Defined at line 470 of ./engine/common/hpak.cpp*

### HPAK_ResourceForIndex

*qboolean HPAK_ResourceForIndex(const char * filename, int index, resource_t * pResource)*

*Defined at line 570 of ./engine/common/hpak.cpp*

### HPAK_List_f

*void HPAK_List_f()*

*Defined at line 856 of ./engine/common/hpak.cpp*

### HPAK_Extract_f

*void HPAK_Extract_f()*

*Defined at line 934 of ./engine/common/hpak.cpp*

### HPAK_Remove_f

*void HPAK_Remove_f()*

*Defined at line 1045 of ./engine/common/hpak.cpp*

### HPAK_Validate_f

*void HPAK_Validate_f()*

*Defined at line 1067 of ./engine/common/hpak.cpp*

### R_AllocParticle

*struct particle_s * R_AllocParticle(void (*)(struct particle_s *, float) callback)*

*Defined at line 190 of ./engine/client/cl_efx.cpp*

 EfxAPI

================R_AllocParticle

can return NULL if particles is out================

### R_Explosion

*void R_Explosion(vec3_t pos, int model, float scale, float framerate, int flags)*

*Defined at line 1635 of ./engine/client/cl_tent.cpp*

==============R_Explosion

Create an explosion (scale is magnitude)==============

### R_ParticleExplosion

*void R_ParticleExplosion(const vec3_t org)*

*Defined at line 1092 of ./engine/client/cl_efx.cpp*

===============R_ParticleExplosion

===============

### R_ParticleExplosion2

*void R_ParticleExplosion2(const vec3_t org, int colorStart, int colorLength)*

*Defined at line 1123 of ./engine/client/cl_efx.cpp*

===============R_ParticleExplosion2

===============

### R_Implosion

*void R_Implosion(const vec3_t end, float radius, int count, float life)*

*Defined at line 1915 of ./engine/client/cl_efx.cpp*

===============R_Implosion

make implosion tracers===============

### R_Blood

*void R_Blood(const vec3_t org, const vec3_t dir, int pcolor, int speed)*

*Defined at line 1227 of ./engine/client/cl_efx.cpp*

===============R_Blood

particle spray===============

### R_BloodStream

*void R_BloodStream(const vec3_t org, const vec3_t dir, int pcolor, int speed)*

*Defined at line 1263 of ./engine/client/cl_efx.cpp*

===============R_BloodStream

particle spray 2===============

### R_BlobExplosion

*void R_BlobExplosion(const vec3_t org)*

*Defined at line 1155 of ./engine/client/cl_efx.cpp*

===============R_BlobExplosion

===============

### R_EntityParticles

*void R_EntityParticles(cl_entity_t * ent)*

*Defined at line 1057 of ./engine/client/cl_efx.cpp*

===============R_EntityParticles

set EF_BRIGHTFIELD effect===============

### R_FlickerParticles

*void R_FlickerParticles(const vec3_t org)*

*Defined at line 1732 of ./engine/client/cl_efx.cpp*

===============R_FlickerParticles

===============

### R_RunParticleEffect

*void R_RunParticleEffect(const vec3_t org, const vec3_t dir, int color, int count)*

*Defined at line 1194 of ./engine/client/cl_efx.cpp*

===============ParticleEffect

PARTICLE_EFFECT on server===============

### R_ParticleBurst

*void R_ParticleBurst(const vec3_t org, int size, int color, float life)*

*Defined at line 1382 of ./engine/client/cl_efx.cpp*

===============R_ParticleBurst

===============

### R_LavaSplash

*void R_LavaSplash(const vec3_t org)*

*Defined at line 1340 of ./engine/client/cl_efx.cpp*

===============R_LavaSplash

===============

### R_TeleportSplash

*void R_TeleportSplash(const vec3_t org)*

*Defined at line 1462 of ./engine/client/cl_efx.cpp*

===============R_TeleportSplash

===============

### R_RocketTrail

*void R_RocketTrail(vec3_t start, vec3_t end, int type)*

*Defined at line 1504 of ./engine/client/cl_efx.cpp*

===============R_RocketTrail

===============

### R_LookupColor

*short R_LookupColor(byte r, byte g, byte b)*

*Defined at line 42 of ./engine/client/cl_efx.cpp*

================R_LookupColor

find nearest color in particle palette================

### R_GetPackedColor

*void R_GetPackedColor(short * packed, short color)*

*Defined at line 77 of ./engine/client/cl_efx.cpp*

================R_GetPackedColor

in hardware mode does nothing================

### R_TracerEffect

*void R_TracerEffect(const vec3_t start, const vec3_t end)*

*Defined at line 1825 of ./engine/client/cl_efx.cpp*

===============R_TracerEffect

===============

### R_UserTracerParticle

*void R_UserTracerParticle(float * org, float * vel, float life, int colorIndex, float length, byte deathcontext, void (*)(struct particle_s *) deathfunc)*

*Defined at line 1852 of ./engine/client/cl_efx.cpp*

===============R_UserTracerParticle

===============

### R_TracerParticles

*struct particle_s * R_TracerParticles(float * org, float * vel, float life)*

*Defined at line 1875 of ./engine/client/cl_efx.cpp*

===============R_TracerParticles

allow more customization===============

### R_ParticleLine

*void R_ParticleLine(const vec3_t start, const vec3_t end, byte r, byte g, byte b, float life)*

*Defined at line 1623 of ./engine/client/cl_efx.cpp*

================R_ParticleLine

================

### R_ParticleBox

*void R_ParticleBox(const vec3_t mins, const vec3_t maxs, byte r, byte g, byte b, float life)*

*Defined at line 1637 of ./engine/client/cl_efx.cpp*

================R_ParticleBox

================

### R_ShowLine

*void R_ShowLine(const vec3_t start, const vec3_t end)*

*Defined at line 1658 of ./engine/client/cl_efx.cpp*

================R_ShowLine

================

### R_BulletImpactParticles

*void R_BulletImpactParticles(const vec3_t pos)*

*Defined at line 1690 of ./engine/client/cl_efx.cpp*

===============R_BulletImpactParticles

===============

### R_SparkShower

*void R_SparkShower(const vec3_t org)*

*Defined at line 1183 of ./engine/client/cl_tent.cpp*

===============R_SparkShower

Create an animated moving sprite ===============

### CL_TempEntAlloc

*struct tempent_s * CL_TempEntAlloc(const vec3_t org, model_t * pmodel)*

*Defined at line 469 of ./engine/client/cl_tent.cpp*

==============CL_TempEntAlloc

alloc normal**<not a builtin command>**  priority tempentity==============

### CL_TempEntAllocHigh

*struct tempent_s * CL_TempEntAllocHigh(const vec3_t org, model_t * pmodel)*

*Defined at line 500 of ./engine/client/cl_tent.cpp*

==============CL_TempEntAllocHigh

alloc high priority tempentity==============

### CL_TempEntAllocNoModel

*struct tempent_s * CL_TempEntAllocNoModel(const vec3_t org)*

*Defined at line 541 of ./engine/client/cl_tent.cpp*

==============CL_TempEntAlloc

alloc normal priority tempentity with no model==============

### CL_TempEntAllocCustom

*struct tempent_s * CL_TempEntAllocCustom(const vec3_t org, model_t * model, int high, void (*)(struct tempent_s *, float, float) callback)*

*Defined at line 553 of ./engine/client/cl_tent.cpp*

==============CL_TempEntAlloc

custom tempentity allocation==============

### R_FizzEffect

*void R_FizzEffect(cl_entity_t * pent, int modelIndex, int density)*

*Defined at line 590 of ./engine/client/cl_tent.cpp*

==============================================================

	EFFECTS BASED ON TEMPENTS (presets)

==============================================================

==============R_FizzEffect

Create a fizz effect==============

### R_Bubbles

*void R_Bubbles(const vec3_t mins, const vec3_t maxs, float height, int modelIndex, int count, float speed)*

*Defined at line 653 of ./engine/client/cl_tent.cpp*

==============R_Bubbles

Create bubbles==============

### R_BubbleTrail

*void R_BubbleTrail(const vec3_t start, const vec3_t end, float flWaterZ, int modelIndex, int count, float speed)*

*Defined at line 699 of ./engine/client/cl_tent.cpp*

==============R_BubbleTrail

Create bubble trail==============

### R_AttachTentToPlayer

*void R_AttachTentToPlayer(int client, int modelIndex, float zoffset, float life)*

*Defined at line 744 of ./engine/client/cl_tent.cpp*

==============R_AttachTentToPlayer

Attaches entity to player==============

### R_KillAttachedTents

*void R_KillAttachedTents(int client)*

*Defined at line 800 of ./engine/client/cl_tent.cpp*

==============R_KillAttachedTents

Detach entity from player==============

### R_RicochetSprite

*void R_RicochetSprite(const vec3_t pos, model_t * pmodel, float duration, float scale)*

*Defined at line 831 of ./engine/client/cl_tent.cpp*

==============R_RicochetSprite

Create ricochet sprite==============

### R_RocketFlare

*void R_RocketFlare(const vec3_t pos)*

*Defined at line 857 of ./engine/client/cl_tent.cpp*

==============R_RocketFlare

Create rocket flare==============

### R_MuzzleFlash

*void R_MuzzleFlash(const vec3_t pos, int type)*

*Defined at line 883 of ./engine/client/cl_tent.cpp*

==============R_MuzzleFlash

Do muzzleflash==============

### R_BloodSprite

*void R_BloodSprite(const vec3_t org, int colorIndex, int modelIndex, int modelIndex2, float size)*

*Defined at line 922 of ./engine/client/cl_tent.cpp*

==============R_BloodSprite

Create a high priority blood spriteand some blood drops. This is high-priority tent==============

### R_BreakModel

*void R_BreakModel(const vec3_t pos, const vec3_t size, const vec3_t dir, float random, float life, int count, int modelIndex, char flags)*

*Defined at line 1008 of ./engine/client/cl_tent.cpp*

==============R_BreakModel

Create a shards==============

### R_TempModel

*struct tempent_s * R_TempModel(const vec3_t pos, const vec3_t dir, const vec3_t angles, float life, int modelIndex, int soundtype)*

*Defined at line 1096 of ./engine/client/cl_tent.cpp*

==============R_TempModel

Create a temp model with gravity, sounds and fadeout==============

### R_TempSprite

*struct tempent_s * R_TempSprite(vec3_t pos, const vec3_t dir, float scale, int modelIndex, int rendermode, int renderfx, float a, float life, int flags)*

*Defined at line 1208 of ./engine/client/cl_tent.cpp*

===============R_TempSprite

Create an animated moving sprite ===============

### R_DefaultSprite

*struct tempent_s * R_DefaultSprite(const vec3_t pos, int spriteIndex, float framerate)*

*Defined at line 1147 of ./engine/client/cl_tent.cpp*

==============R_DefaultSprite

Create an animated sprite==============

### R_Sprite_Explode

*void R_Sprite_Explode(struct tempent_s * pTemp, float scale, int flags)*

*Defined at line 1246 of ./engine/client/cl_tent.cpp*

===============R_Sprite_Explode

apply params for exploding sprite===============

### R_Sprite_Smoke

*void R_Sprite_Smoke(struct tempent_s * pTemp, float scale)*

*Defined at line 1288 of ./engine/client/cl_tent.cpp*

===============R_Sprite_Smoke

apply params for smoke sprite===============

### R_Spray

*void R_Spray(const vec3_t pos, const vec3_t dir, int modelIndex, int count, int speed, int iRand, int renderMode)*

*Defined at line 1312 of ./engine/client/cl_tent.cpp*

===============R_Spray

Throws a shower of sprites or models===============

### R_Sprite_Spray

*void R_Sprite_Spray(const vec3_t pos, const vec3_t dir, int modelIndex, int count, int speed, int iRand)*

*Defined at line 1378 of ./engine/client/cl_tent.cpp*

===============R_Sprite_Spray

Spray of alpha sprites===============

### R_Sprite_Trail

*void R_Sprite_Trail(int type, vec3_t vecStart, vec3_t vecEnd, int modelIndex, int nCount, float flLife, float flSize, float flAmplitude, int nRenderamt, float flSpeed)*

*Defined at line 1391 of ./engine/client/cl_tent.cpp*

===============R_Sprite_Trail

Line of moving glow sprites with gravity,fadeout, and collisions===============

### R_FunnelSprite

*void R_FunnelSprite(const vec3_t pos, int spriteIndex, int flags)*

*Defined at line 1443 of ./engine/client/cl_tent.cpp*

===============R_FunnelSprite

Create a funnel effect with custom sprite===============

### R_LargeFunnel

*void R_LargeFunnel(const vec3_t pos, int reverse)*

*Defined at line 1415 of ./engine/client/cl_efx.cpp*

===============R_LargeFunnel

===============

### R_SparkEffect

*void R_SparkEffect(const vec3_t pos, int count, int velocityMin, int velocityMax)*

*Defined at line 1505 of ./engine/client/cl_tent.cpp*

===============R_SparkEffect

Create a streaks + richochet sprite===============

### R_StreakSplash

*void R_StreakSplash(const vec3_t pos, const vec3_t dir, int color, int count, float speed, int velMin, int velMax)*

*Defined at line 1760 of ./engine/client/cl_efx.cpp*

===============R_StreakSplash

create a splash of streaks===============

### R_SparkStreaks

*void R_SparkStreaks(const vec3_t pos, int count, int velocityMin, int velocityMax)*

*Defined at line 1887 of ./engine/client/cl_efx.cpp*

===============R_SparkStreaks

create a streak tracers===============

### R_Projectile

*void R_Projectile(const vec3_t origin, const vec3_t velocity, int modelIndex, int life, int owner, void (*)(struct tempent_s *, struct pmtrace_s *) hitcallback)*

*Defined at line 1538 of ./engine/client/cl_tent.cpp*

==============R_Projectile

Create an projectile entity==============

### R_TempSphereModel

*void R_TempSphereModel(const vec3_t pos, float speed, float life, int count, int modelIndex)*

*Defined at line 1587 of ./engine/client/cl_tent.cpp*

==============R_TempSphereModel

Spherical shower of models, picks from set==============

### R_MultiGunshot

*void R_MultiGunshot(const vec3_t org, const vec3_t dir, const vec3_t noise, int count, int decalCount, int * decalIndices)*

*Defined at line 1827 of ./engine/client/cl_tent.cpp*

==============R_MultiGunshot

Client version of shotgun shot==============

### R_FireField

*void R_FireField(float * org, int radius, int modelIndex, int count, int flags, float life)*

*Defined at line 1752 of ./engine/client/cl_tent.cpp*

==============R_FireField

Makes a field of fire==============

### R_PlayerSprites

*void R_PlayerSprites(int client, int modelIndex, int count, int size)*

*Defined at line 1687 of ./engine/client/cl_tent.cpp*

==============R_PlayerSprites

Create a particle smoke around player==============

### R_Sprite_WallPuff

*void R_Sprite_WallPuff(struct tempent_s * pTemp, float scale)*

*Defined at line 1883 of ./engine/client/cl_tent.cpp*

==============R_Sprite_WallPuff

Create a wallpuff==============

### R_DebugParticle

*void R_DebugParticle(const vec3_t pos, byte r, byte g, byte b)*

*Defined at line 1787 of ./engine/client/cl_efx.cpp*

===============R_DebugParticle

just for debug purposes===============

### R_RicochetSound

*void R_RicochetSound(const vec3_t pos)*

*Defined at line 1518 of ./engine/client/cl_tent.cpp*

==============R_RicochetSound

Make a random ricochet sound==============

### CL_AllocDlight

*struct dlight_s * CL_AllocDlight(int key)*

*Defined at line 2484 of ./engine/client/cl_tent.cpp*

===============CL_AllocDlight

===============

### CL_AllocElight

*struct dlight_s * CL_AllocElight(int key)*

*Defined at line 2529 of ./engine/client/cl_tent.cpp*

===============CL_AllocElight

===============

### CL_UpdateFlashlight

*void CL_UpdateFlashlight(cl_entity_t * pEnt)*

*Defined at line 2624 of ./engine/client/cl_tent.cpp*

================CL_UpdateFlashlight

update client flashlight================

### CL_AddEntityEffects

*void CL_AddEntityEffects(cl_entity_t * ent)*

*Defined at line 2693 of ./engine/client/cl_tent.cpp*

================CL_AddEntityEffects

apply various effects to entity origin or attachment================

### CL_AddModelEffects

*void CL_AddModelEffects(cl_entity_t * ent)*

*Defined at line 2762 of ./engine/client/cl_tent.cpp*

================CL_AddModelEffects

these effects will be enable by flag in model header================

### CL_DecalShoot

*void CL_DecalShoot(int textureIndex, int entityIndex, int modelIndex, float * pos, int flags)*

*Defined at line 2893 of ./engine/client/cl_tent.cpp*

===============CL_DecalShoot

normal temporary decal===============

### CL_DecalRemoveAll

*void CL_DecalRemoveAll(int textureIndex)*

*Defined at line 2980 of ./engine/client/cl_tent.cpp*

===============CL_DecalRemoveAll

remove all decals with specified texture===============

### CL_DecalIndexFromName

*int CL_DecalIndexFromName(const char * name)*

*Defined at line 2936 of ./engine/client/cl_tent.cpp*

===============CL_DecalIndexFromName

get decal global index from decalname===============

### CL_DecalIndex

*int CL_DecalIndex(int id)*

*Defined at line 2959 of ./engine/client/cl_tent.cpp*

===============CL_DecalIndex

get texture index from decal global index===============

### CL_AllocParticleFast

*struct particle_s * CL_AllocParticleFast()*

*Defined at line 170 of ./engine/client/cl_efx.cpp*

 RefAPI

================CL_AllocParticleFast

unconditionally give new particle pointer from cl_free_particles================

### R_BeamLightning

*struct beam_s * R_BeamLightning(vec3_t start, vec3_t end, int modelIndex, float life, float width, float amplitude, float brightness, float speed)*

*Defined at line 1033 of ./engine/client/cl_efx.cpp*

 Beams

==============R_BeamLightning

template for new beams==============

### InstallGameRules

*class CGameRules * InstallGameRules()*

*Defined at line 310 of ./game/server/gamerules.cpp*

========================================================= instantiate the proper game rules object=========================================================

### R_BeamEnts

*struct beam_s * R_BeamEnts(int startEnt, int endEnt, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b)*

*Defined at line 831 of ./engine/client/cl_efx.cpp*

==============R_BeamEnts

Create beam between two ents==============

### R_BeamPoints

*struct beam_s * R_BeamPoints(vec3_t start, vec3_t end, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b)*

*Defined at line 876 of ./engine/client/cl_efx.cpp*

==============R_BeamPoints

Create beam between two points==============

### R_BeamCirclePoints

*struct beam_s * R_BeamCirclePoints(int type, vec3_t start, vec3_t end, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b)*

*Defined at line 907 of ./engine/client/cl_efx.cpp*

==============R_BeamCirclePoints

Create beam cicrle==============

### R_BeamEntPoint

*struct beam_s * R_BeamEntPoint(int startEnt, vec3_t end, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b)*

*Defined at line 928 of ./engine/client/cl_efx.cpp*

==============R_BeamEntPoint

Create beam between entity and point==============

### R_BeamRing

*struct beam_s * R_BeamRing(int startEnt, int endEnt, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b)*

*Defined at line 968 of ./engine/client/cl_efx.cpp*

==============R_BeamRing

Create beam between two ents==============

### R_BeamFollow

*struct beam_s * R_BeamFollow(int startEnt, int modelIndex, float life, float width, float r, float g, float b, float brightness)*

*Defined at line 1004 of ./engine/client/cl_efx.cpp*

==============R_BeamFollow

Create beam following with entity==============

### R_BeamKill

*void R_BeamKill(int deadEntity)*

*Defined at line 657 of ./engine/client/cl_efx.cpp*

==============R_BeamKill

Remove beam attached to specified entityand all particle trails (if this is a beamfollow)==============

### TriBoxInPVS

*int TriBoxInPVS(float * mins, float * maxs)*

*Defined at line 3212 of ./engine/client/cl_game.cpp*

=============TriBoxInPVS

check box in pvs (absmin, absmax)=============

### TriLightAtPoint

*void TriLightAtPoint(float * pos, float * value)*

*Defined at line 3223 of ./engine/client/cl_game.cpp*

=============TriLightAtPointNOTE: dlights are ignored=============

### TriColor4fRendermode

*void TriColor4fRendermode(float r, float g, float b, float a, int rendermode)*

*Defined at line 3242 of ./engine/client/cl_game.cpp*

=============TriColor4fRendermodeHeavy legacy of Quake...=============

### CL_CullTracer

*qboolean CL_CullTracer(particle_t * p, const vec3_t start, const vec3_t end)*

*Defined at line 124 of ./ref_gl/gl_rpart.cpp*

================CL_CullTracer

check tracer bbox================

### weapon_snark

*void weapon_snark(entvars_t * pev)*

*Defined at line 411 of ./game/shared/hl1/weapon_squeakgrenade.cpp*

### game_score

*void game_score(entvars_t * pev)*

*Defined at line 147 of ./game/server/maprules.cpp*

### game_end

*void game_end(entvars_t * pev)*

*Defined at line 193 of ./game/server/maprules.cpp*

### game_text

*void game_text(entvars_t * pev)*

*Defined at line 229 of ./game/server/maprules.cpp*

### game_team_master

*void game_team_master(entvars_t * pev)*

*Defined at line 355 of ./game/server/maprules.cpp*

### game_team_set

*void game_team_set(entvars_t * pev)*

*Defined at line 453 of ./game/server/maprules.cpp*

### game_zone_player

*void game_zone_player(entvars_t * pev)*

*Defined at line 496 of ./game/server/maprules.cpp*

### game_player_hurt

*void game_player_hurt(entvars_t * pev)*

*Defined at line 604 of ./game/server/maprules.cpp*

### game_counter

*void game_counter(entvars_t * pev)*

*Defined at line 657 of ./game/server/maprules.cpp*

### game_counter_set

*void game_counter_set(entvars_t * pev)*

*Defined at line 715 of ./game/server/maprules.cpp*

### game_player_equip

*void game_player_equip(entvars_t * pev)*

*Defined at line 753 of ./game/server/maprules.cpp*

### game_player_team

*void game_player_team(entvars_t * pev)*

*Defined at line 841 of ./game/server/maprules.cpp*

### CL_CullTracer

*qboolean CL_CullTracer(particle_t * p, const vec3_t start, const vec3_t end)*

*Defined at line 124 of ./rendersystem/r_part.cpp*

================CL_CullTracer

check tracer bbox================

### isrange

*_Bool isrange(T min, T value, T max)*

*Defined at line 26 of ./mainui/Primitive.h*

### operator+

*Point operator+(const struct Point & a, const struct Point & b)*

*Defined at line 122 of ./mainui/Primitive.h*

### operator-

*Point operator-(const struct Point & a, const struct Point & b)*

*Defined at line 127 of ./mainui/Primitive.h*

### operator+

*Size operator+(const struct Size & a, const struct Size & b)*

*Defined at line 163 of ./mainui/Primitive.h*

### operator-

*Size operator-(const struct Size & a, const struct Size & b)*

*Defined at line 168 of ./mainui/Primitive.h*

### operator+

*Point operator+(const struct Point & a, const struct Size & b)*

*Defined at line 222 of ./mainui/Primitive.h*

### operator-

*Point operator-(const struct Point & a, const struct Size & b)*

*Defined at line 227 of ./mainui/Primitive.h*

### V_strncmp

*int V_strncmp(const char * s1, const char * s2, int count)*

*Defined at line 33 of ./mainui/miniutl/strtools.cpp*

### V_strnicmp

*int V_strnicmp(const char * s1, const char * s2, int n)*

*Defined at line 123 of ./mainui/miniutl/strtools.cpp*

### V_strnchr

*const char * V_strnchr(const char * pStr, char c, int n)*

*Defined at line 108 of ./mainui/miniutl/strtools.cpp*

### V_stristr

*const char * V_stristr(const char * pStr, const char * pSearch)*

*Defined at line 153 of ./mainui/miniutl/strtools.cpp*

----------------------------------------------------------------------------- Finds a string in another string with a case insensitive test-----------------------------------------------------------------------------

### V_strnistr

*const char * V_strnistr(const char * pStr, const char * pSearch, int n)*

*Defined at line 55 of ./mainui/miniutl/strtools.cpp*

----------------------------------------------------------------------------- Finds a string in another string with a case insensitive test w/ length validation-----------------------------------------------------------------------------

### V_stricmp

*int V_stricmp(const char * s1, const char * s2)*

*Defined at line 46 of ./mainui/miniutl/strtools.h*

### V_strncpy

*void V_strncpy(char * pDest, const char * pSrc, size_t maxLen)*

*Defined at line 209 of ./mainui/miniutl/strtools.cpp*

----------------------------------------------------------------------------- Purpose: copy a string while observing the maximum length of the target buffer

 Inputs:	pDest	- pointer to the destination string		pSrc	- pointer to the source string		maxLen	- number of bytes available at pDest

 This function will always leave pDest nul-terminated if maxLen > 0

 maxLen is a count of bytes, not a count of characters. maxLen includes budget for the nul terminator at pDest, so using maxLen = 3 would copy two characters from pSrc and add a trailing nul.-----------------------------------------------------------------------------

### V_vsnprintf

*int V_vsnprintf(char * pDest, int maxLen, const char * pFormat, va_list params)*

*Defined at line 248 of ./mainui/miniutl/strtools.cpp*

### V_vsnprintfRet

*int V_vsnprintfRet(char * pDest, int maxLen, const char * pFormat, va_list params, _Bool * pbTruncated)*

*Defined at line 266 of ./mainui/miniutl/strtools.cpp*

### V_snprintf

*int V_snprintf(char * pDest, size_t destLen, const char * pFormat)*

*Defined at line 225 of ./mainui/miniutl/strtools.cpp*

### V_strncat

*char * V_strncat(char * , const char * , size_t destBufferSize, int max_chars_to_copy)*

*Defined at line 303 of ./mainui/miniutl/strtools.cpp*

----------------------------------------------------------------------------- Purpose: If COPY_ALL_CHARACTERS == max_chars_to_copy then we try to add the whole pSrc to the end of pDest, otherwise  we copy only as many characters as are specified in max_chars_to_copy (or the # of characters in pSrc if thats's less). Input  : *pDest - destination buffer			*pSrc - string to append			destBufferSize - sizeof the buffer pointed to by pDest			max_chars_to_copy - COPY_ALL_CHARACTERS in pSrc or max # to copy Output : char * the copied buffer-----------------------------------------------------------------------------

### V_isspace

*_Bool V_isspace(char c)*

*Defined at line 57 of ./mainui/miniutl/strtools.h*

 is* helpers

### V_SplitString

*void V_SplitString(const char * pString, const char * pSeparator, CUtlVector<char *, CUtlMemory<char *> > & outStrings, _Bool bIncludeEmptyStrings)*

*Defined at line 376 of ./mainui/miniutl/strtools.cpp*

 Split the specified string on the specified separator. Returns a list of strings separated by pSeparator. You are responsible for freeing the contents of outStrings (call outStrings.PurgeAndDeleteElements).

### V_StripTrailingWhitespaceASCII

*void V_StripTrailingWhitespaceASCII(char * pch)*

*Defined at line 382 of ./mainui/miniutl/strtools.cpp*

 Strips trailing *ASCII* whitespace characters.  (Any character that returns true for V_isspace returns true.)  Doesn't handle all unicode whitespace characters

-----------------------------------------------------------------------------

### V_StrTrim

*int V_StrTrim(char * pStr)*

*Defined at line 405 of ./mainui/miniutl/strtools.cpp*

 trim whitespace from both ends of the string

### AssertMsg

*void AssertMsg(int pred, const char * fmt)*

*Defined at line 98 of ./mainui/miniutl/miniutl.h*

### Error

*void Error(const char * msg)*

*Defined at line 132 of ./mainui/miniutl/miniutl.h*

### Min

*const T & Min(const T & val1, const T & val2)*

*Defined at line 143 of ./mainui/miniutl/miniutl.h*

 This is the preferred Min operator. Using the MIN macro can lead to unexpected side-effects or more expensive code.

### Max

*const T & Max(const T & val1, const T & val2)*

*Defined at line 151 of ./mainui/miniutl/miniutl.h*

 This is the preferred Max operator. Using the MAX macro can lead to unexpected side-effects or more expensive code.

### Construct

*void Construct(T * pMemory)*

*Defined at line 195 of ./mainui/miniutl/miniutl.h*

### CopyConstruct

*void CopyConstruct(T * pMemory, const T & src)*

*Defined at line 201 of ./mainui/miniutl/miniutl.h*

### Destruct

*void Destruct(T * pMemory)*

*Defined at line 207 of ./mainui/miniutl/miniutl.h*

### SWAP

*void SWAP(T & a, T & b)*

*Defined at line 211 of ./mainui/miniutl/utlmemory.h*

### DBG_AssertFunction

*void DBG_AssertFunction(_Bool fExpr, const char * szExpr, const char * szFile, int szLine, const char * szMessage)*

*Defined at line 32 of ./mainui/Utils.cpp*

### UI_VidInit

*int UI_VidInit()*

*Defined at line 1070 of ./mainui/BaseMenu.cpp*

 exports

=================UI_VidInit=================

### UI_Init

*void UI_Init()*

*Defined at line 1190 of ./mainui/BaseMenu.cpp*

=================UI_Init=================

### UI_Shutdown

*void UI_Shutdown()*

*Defined at line 1258 of ./mainui/BaseMenu.cpp*

=================UI_Shutdown=================

### UI_UpdateMenu

*void UI_UpdateMenu(float flTime)*

*Defined at line 629 of ./mainui/BaseMenu.cpp*

=================UI_UpdateMenu=================

### UI_KeyEvent

*void UI_KeyEvent(int key, int down)*

*Defined at line 717 of ./mainui/BaseMenu.cpp*

=================UI_KeyEvent=================

### UI_MouseMove

*void UI_MouseMove(int x, int y)*

*Defined at line 769 of ./mainui/BaseMenu.cpp*

=================UI_MouseMove=================

### UI_AddServerToList

*void UI_AddServerToList(netadr_s adr, const char * info)*

*Defined at line 90 of ./engine/client/cl_gameui.cpp*

=================UI_AddServerToList=================

### UI_GetCursorPos

*void UI_GetCursorPos(int * pos_x, int * pos_y)*

*Defined at line 910 of ./mainui/BaseMenu.cpp*

### UI_SetCursorPos

*void UI_SetCursorPos(int pos_x, int pos_y)*

*Defined at line 917 of ./mainui/BaseMenu.cpp*

 dead callback

### UI_ShowCursor

*void UI_ShowCursor(int show)*

*Defined at line 924 of ./mainui/BaseMenu.cpp*

### UI_CharEvent

*void UI_CharEvent(int key)*

*Defined at line 746 of ./mainui/BaseMenu.cpp*

=================UI_CharEvent=================

### UI_MouseInRect

*int UI_MouseInRect()*

*Defined at line 929 of ./mainui/BaseMenu.cpp*

### UI_IsVisible

*int UI_IsVisible()*

*Defined at line 903 of ./mainui/BaseMenu.cpp*

=================UI_IsVisible

Some systems may need to know if it is visible or not=================

### UI_FinalCredits

*void UI_FinalCredits()*

*Defined at line 232 of ./mainui/menus/Credits.cpp*

### UI_MenuResetPing_f

*void UI_MenuResetPing_f()*

*Defined at line 641 of ./mainui/menus/ServerBrowser.cpp*

 extended exports

=================UI_MenuResetPing_f=================

### UI_ConnectionWarning_f

*void UI_ConnectionWarning_f()*

*Defined at line 132 of ./mainui/menus/ConnectionWarning.cpp*

### UI_ShowMessageBox

*void UI_ShowMessageBox(const char * text)*

*Defined at line 219 of ./engine/client/cl_gameui.cpp*

=================UI_ShowConnectionWarning

show message box=================

### UI_UpdateDialog

*void UI_UpdateDialog(int preferStore)*

*Defined at line 1150 of ./mainui/BaseMenu.cpp*

### UI_ConnectionProgress_Disconnect

*void UI_ConnectionProgress_Disconnect()*

*Defined at line 227 of ./engine/client/cl_gameui.cpp*

 exports

### UI_ConnectionProgress_Download

*void UI_ConnectionProgress_Download(const char * pszFileName, const char * pszServerName, int iCurrent, int iTotal, const char * comment)*

*Defined at line 346 of ./mainui/menus/ConnectionProgress.cpp*

### UI_ConnectionProgress_DownloadEnd

*void UI_ConnectionProgress_DownloadEnd()*

*Defined at line 253 of ./engine/client/cl_gameui.cpp*

### UI_ConnectionProgress_Precache

*void UI_ConnectionProgress_Precache()*

*Defined at line 261 of ./engine/client/cl_gameui.cpp*

### UI_ConnectionProgress_Connect

*void UI_ConnectionProgress_Connect(const char * server)*

*Defined at line 269 of ./engine/client/cl_gameui.cpp*

### UI_ConnectionProgress_ChangeLevel

*void UI_ConnectionProgress_ChangeLevel()*

*Defined at line 277 of ./engine/client/cl_gameui.cpp*

### UI_ConnectionProgress_ParseServerInfo

*void UI_ConnectionProgress_ParseServerInfo(const char * server)*

*Defined at line 285 of ./engine/client/cl_gameui.cpp*

### AddTouchButtonToList

*void AddTouchButtonToList(const char * name, const char * texture, const char * command, unsigned char * color, int flags)*

*Defined at line 141 of ./mainui/menus/TouchButtons.cpp*

 Engine callback

 defined as exported to keep compatibility with old interface

### PackRGBA

*unsigned int PackRGBA(const unsigned int r, const unsigned int g, const unsigned int b, const unsigned int a)*

*Defined at line 100 of ./mainui/Utils.h*

### PackRGB

*unsigned int PackRGB(const unsigned int r, const unsigned int g, const unsigned int b)*

*Defined at line 105 of ./mainui/Utils.h*

### UnpackRGB

*void UnpackRGB(int & r, int & g, int & b, const unsigned int ulRGB)*

*Defined at line 110 of ./mainui/Utils.h*

### UnpackRGBA

*void UnpackRGBA(int & r, int & g, int & b, int & a, const unsigned int ulRGBA)*

*Defined at line 117 of ./mainui/Utils.h*

### PackAlpha

*unsigned int PackAlpha(const unsigned int ulRGB, const unsigned int ulAlpha)*

*Defined at line 123 of ./mainui/Utils.h*

### UnpackAlpha

*unsigned int UnpackAlpha(const unsigned int ulRGBA)*

*Defined at line 128 of ./mainui/Utils.h*

### InterpVal

*float InterpVal(const float from, const float to, const float frac)*

*Defined at line 133 of ./mainui/Utils.h*

### InterpColor

*unsigned int InterpColor(const unsigned int from, const unsigned int to, const float frac)*

*Defined at line 138 of ./mainui/Utils.h*

### RemapVal

*float RemapVal(const float val, const float A, const float B, const float C, const float D)*

*Defined at line 147 of ./mainui/Utils.h*

### colorstricmp

*int colorstricmp(const char * a, const char * b)*

*Defined at line 80 of ./mainui/Utils.cpp*

### colorstrcmp

*int colorstrcmp(const char * a, const char * b)*

*Defined at line 44 of ./mainui/Utils.cpp*

### ColorStrlen

*int ColorStrlen(const char * str)*

*Defined at line 120 of ./mainui/Utils.cpp*

### ColorPrexfixCount

*int ColorPrexfixCount(const char * str)*

*Defined at line 148 of ./mainui/Utils.cpp*

### UI_FadeAlpha

*int UI_FadeAlpha(int starttime, int endtime)*

*Defined at line 324 of ./mainui/Utils.cpp*

================UI_FadeAlpha================

### KEY_GetKey

*int KEY_GetKey(const char * binding)*

*Defined at line 301 of ./mainui/Utils.cpp*

===================Key_GetKey===================

### StringCopy

*char * StringCopy(const char * input)*

*Defined at line 178 of ./mainui/Utils.cpp*

### COM_CompareSaves

*int COM_CompareSaves(const void ** a, const void ** b)*

*Defined at line 193 of ./mainui/Utils.cpp*

============COM_CompareSaves============

### Com_EscapeCommand

*void Com_EscapeCommand(char * newCommand, const char * oldCommand, int len)*

*Defined at line 604 of ./mainui/Utils.cpp*

### UI_EnableTextInput

*void UI_EnableTextInput(_Bool enable)*

*Defined at line 354 of ./mainui/Utils.cpp*

### UI_LoadCustomStrings

*void UI_LoadCustomStrings()*

*Defined at line 415 of ./mainui/MenuStrings.cpp*

### L

*const char * L(const char * szStr)*

*Defined at line 449 of ./mainui/MenuStrings.cpp*

### UI_FreeCustomStrings

*void UI_FreeCustomStrings()*

*Defined at line 465 of ./mainui/MenuStrings.cpp*

### Con_UtfProcessChar

*int Con_UtfProcessChar(int in)*

*Defined at line 773 of ./engine/client/console.cpp*

============================Con_UtfProcessChar

Ripped from engine.

Xash3D FWGS uses multibyte, converting it to current single-byte encodingConverting to single-byte not necessary anymore, as UI uses custom font render which works with 32-bit chars============================

### Con_UtfMoveLeft

*int Con_UtfMoveLeft(const char * str, int pos)*

*Defined at line 526 of ./mainui/Utils.cpp*

=================Con_UtfMoveLeft

get position of previous printful char=================

### Con_UtfMoveRight

*int Con_UtfMoveRight(const char * str, int pos, int length)*

*Defined at line 546 of ./mainui/Utils.cpp*

=================Con_UtfMoveRight

get next of previous printful char=================

### FindFontByName

*HFont FindFontByName(const char * name)*

*Defined at line 1278 of ./mainui/BaseMenu.cpp*

 Finds a font by name or returns a default 

### FindFontDescByName

*font_t FindFontDescByName(const char * name)*

*Defined at line 1288 of ./mainui/BaseMenu.cpp*

### FindColorByName

*const byte * FindColorByName(const char * name)*

*Defined at line 1299 of ./mainui/BaseMenu.cpp*

### UI_IsXashFWGS

*_Bool UI_IsXashFWGS()*

*Defined at line 98 of ./mainui/BaseMenu.cpp*

 TODO: Move it under namespace?

### UI_ScaleCoords

*void UI_ScaleCoords(int * x, int * y, int * w, int * h)*

*Defined at line 119 of ./mainui/BaseMenu.cpp*

=================UI_ScaleCoords

Any parameter can be NULL if you don't want it=================

### UI_ScaleCoords

*void UI_ScaleCoords(int & x, int & y, int & w, int & h)*

*Defined at line 133 of ./mainui/BaseMenu.cpp*

### UI_ScaleCoords

*void UI_ScaleCoords(int & x, int & y)*

*Defined at line 127 of ./mainui/BaseMenu.cpp*

### UI_CursorInRect

*_Bool UI_CursorInRect(int x, int y, int w, int h)*

*Defined at line 154 of ./mainui/BaseMenu.cpp*

=================UI_CursorInRect=================

### UI_CursorInRect

*_Bool UI_CursorInRect(Point pos, Size size)*

*Defined at line 201 of ./mainui/BaseMenu.h*

### UI_EnableAlphaFactor

*void UI_EnableAlphaFactor(float a)*

*Defined at line 168 of ./mainui/BaseMenu.cpp*

 temporarily override alpha by multiplying given alpha and factor

=================UI_EnableAlphaFactor=================

### UI_DisableAlphaFactor

*void UI_DisableAlphaFactor()*

*Defined at line 179 of ./mainui/BaseMenu.cpp*

=================UI_DisableAlphaFactor=================

### UI_DrawString

*int UI_DrawString(HFont font, int x, int y, int w, int h, const char * str, const unsigned int col, int charH, uint justify, uint flags)*

*Defined at line 295 of ./mainui/BaseMenu.cpp*

=================UI_DrawString=================

### UI_DrawString

*int UI_DrawString(HFont font, Point pos, Size size, const char * str, const unsigned int col, int charH, uint justify, uint flags)*

*Defined at line 219 of ./mainui/BaseMenu.h*

### UI_DrawPic

*void UI_DrawPic(int x, int y, int w, int h, const unsigned int color, const char * pic, const enum ERenderMode eRenderMode)*

*Defined at line 189 of ./mainui/BaseMenu.cpp*

=================UI_DrawPic=================

### UI_DrawPic

*void UI_DrawPic(Point pos, Size size, const unsigned int color, const char * pic, const enum ERenderMode eRenderMode)*

*Defined at line 225 of ./mainui/BaseMenu.h*

### UI_FillRect

*void UI_FillRect(int x, int y, int w, int h, const unsigned int color)*

*Defined at line 226 of ./mainui/BaseMenu.cpp*

=================UI_FillRect=================

### UI_FillRect

*void UI_FillRect(Point pos, Size size, const unsigned int color)*

*Defined at line 230 of ./mainui/BaseMenu.h*

### UI_DrawRectangleExt

*void UI_DrawRectangleExt(int in_x, int in_y, int in_w, int in_h, const unsigned int color, int outlineWidth, int flag)*

*Defined at line 239 of ./mainui/BaseMenu.cpp*

=================UI_DrawRectangleExt=================

### UI_DrawRectangle

*void UI_DrawRectangle(int x, int y, int w, int h, const unsigned int color, int flag)*

*Defined at line 236 of ./mainui/BaseMenu.h*

### UI_DrawRectangle

*void UI_DrawRectangle(Point pos, Size size, const unsigned int color, int flag)*

*Defined at line 240 of ./mainui/BaseMenu.h*

### UI_DrawRectangleExt

*void UI_DrawRectangleExt(Point pos, Size size, const unsigned int color, int outlineWidth, int flag)*

*Defined at line 244 of ./mainui/BaseMenu.h*

### UI_CursorToUIPos

*void UI_CursorToUIPos(int & x, int & y)*

*Defined at line 249 of ./mainui/BaseMenu.h*

### UI_StartSound

*void UI_StartSound(const char * sound)*

### UI_LoadBmpButtons

*void UI_LoadBmpButtons()*

*Defined at line 70 of ./mainui/Btns.cpp*

=================UI_LoadBmpButtons=================

### UI_DrawFinalCredits

*void UI_DrawFinalCredits()*

*Defined at line 211 of ./mainui/menus/Credits.cpp*

### UI_CloseMenu

*void UI_CloseMenu()*

*Defined at line 611 of ./mainui/BaseMenu.cpp*

=================UI_CloseMenu=================

### UI_LoadScriptConfig

*void UI_LoadScriptConfig()*

*Defined at line 337 of ./mainui/menus/dynamic/ScriptMenu.cpp*

 SCR support

### UI_Main_Menu

*void UI_Main_Menu()*

*Defined at line 388 of ./mainui/menus/Main.cpp*

 Menus

=================UI_Main_Menu=================

### UI_NewGame_Menu

*void UI_NewGame_Menu()*

*Defined at line 129 of ./mainui/menus/NewGame.cpp*

=================UI_NewGame_Menu=================

### UI_LoadGame_Menu

*void UI_LoadGame_Menu()*

*Defined at line 394 of ./mainui/menus/LoadGame.cpp*

=================UI_LoadGame_Menu=================

### UI_SaveGame_Menu

*void UI_SaveGame_Menu()*

*Defined at line 399 of ./mainui/menus/LoadGame.cpp*

### UI_SaveLoad_Menu

*void UI_SaveLoad_Menu()*

*Defined at line 86 of ./mainui/menus/SaveLoad.cpp*

=================UI_SaveLoad_Menu=================

### UI_MultiPlayer_Menu

*void UI_MultiPlayer_Menu()*

*Defined at line 102 of ./mainui/menus/Multiplayer.cpp*

=================UI_MultiPlayer_Menu=================

### UI_Options_Menu

*void UI_Options_Menu()*

*Defined at line 95 of ./mainui/menus/Configuration.cpp*

=================CMenuOptions::Menu=================

### UI_InternetGames_Menu

*void UI_InternetGames_Menu()*

*Defined at line 607 of ./mainui/menus/ServerBrowser.cpp*

### UI_LanGame_Menu

*void UI_LanGame_Menu()*

*Defined at line 614 of ./mainui/menus/ServerBrowser.cpp*

### UI_ServerBrowser_Menu

*void UI_ServerBrowser_Menu()*

*Defined at line 591 of ./mainui/menus/ServerBrowser.cpp*

=================CMenuServerBrowser::Menu=================

### UI_PlayerSetup_Menu

*void UI_PlayerSetup_Menu()*

*Defined at line 499 of ./mainui/menus/PlayerSetup.cpp*

=================UI_PlayerSetup_Menu=================

### UI_Controls_Menu

*void UI_Controls_Menu()*

*Defined at line 430 of ./mainui/menus/Controls.cpp*

=================UI_Controls_Menu=================

### UI_AdvControls_Menu

*void UI_AdvControls_Menu()*

*Defined at line 231 of ./mainui/menus/AdvancedControls.cpp*

=================UI_AdvControls_Menu=================

### UI_GameOptions_Menu

*void UI_GameOptions_Menu()*

*Defined at line 302 of ./mainui/menus/GameOptions.cpp*

=================UI_GameOptions_Menu=================

### UI_CreateGame_Menu

*void UI_CreateGame_Menu()*

*Defined at line 335 of ./mainui/menus/CreateGame.cpp*

=================CMenuCreateGame::Menu=================

### UI_Audio_Menu

*void UI_Audio_Menu()*

*Defined at line 213 of ./mainui/menus/Audio.cpp*

=================UI_Audio_Menu=================

### UI_Video_Menu

*void UI_Video_Menu()*

*Defined at line 43 of ./mainui/menus/Video.cpp*

=================UI_Video_Menu=================

### UI_VidOptions_Menu

*void UI_VidOptions_Menu()*

*Defined at line 247 of ./mainui/menus/VideoOptions.cpp*

=================CMenuVidOptions::Menu=================

### UI_VidModes_Menu

*void UI_VidModes_Menu()*

*Defined at line 380 of ./mainui/menus/VideoModes.cpp*

=================UI_VidModes_Menu=================

### UI_CustomGame_Menu

*void UI_CustomGame_Menu()*

*Defined at line 199 of ./mainui/menus/CustomGame.cpp*

=================UI_CustomGame_Menu=================

### UI_Credits_Menu

*void UI_Credits_Menu()*

*Defined at line 227 of ./mainui/menus/Credits.cpp*

=================UI_Credits_Menu=================

### UI_Touch_Menu

*void UI_Touch_Menu()*

*Defined at line 42 of ./mainui/menus/Touch.cpp*

=================UI_Touch_Menu=================

### UI_TouchOptions_Menu

*void UI_TouchOptions_Menu()*

*Defined at line 458 of ./mainui/menus/TouchOptions.cpp*

=================UI_TouchOptions_Menu=================

### UI_TouchButtons_Menu

*void UI_TouchButtons_Menu()*

*Defined at line 552 of ./mainui/menus/TouchButtons.cpp*

=================UI_TouchButtons_Menu=================

### UI_TouchEdit_Menu

*void UI_TouchEdit_Menu()*

*Defined at line 114 of ./mainui/menus/TouchEdit.cpp*

=================UI_TouchEdit_Menu=================

### UI_FileDialog_Menu

*void UI_FileDialog_Menu()*

*Defined at line 159 of ./mainui/menus/FileDialog.cpp*

=================UI_FileDialog_Menu=================

### UI_TouchButtons_GetButtonList

*void UI_TouchButtons_GetButtonList()*

*Defined at line 558 of ./mainui/menus/TouchButtons.cpp*

### UI_GamePad_Menu

*void UI_GamePad_Menu()*

*Defined at line 292 of ./mainui/menus/Gamepad.cpp*

=================CMenuGamePad::Menu=================

### UI_Zoo_Menu

*void UI_Zoo_Menu()*

*Defined at line 161 of ./mainui/menus/Zoo.cpp*

### UI_AdvUserOptions_IsAvailable

*_Bool UI_AdvUserOptions_IsAvailable()*

*Defined at line 344 of ./mainui/menus/dynamic/ScriptMenu.cpp*

### UI_AdvUserOptions_Menu

*void UI_AdvUserOptions_Menu()*

*Defined at line 330 of ./mainui/menus/dynamic/ScriptMenu.cpp*

### UI_AdvServerOptions_IsAvailable

*_Bool UI_AdvServerOptions_IsAvailable()*

*Defined at line 349 of ./mainui/menus/dynamic/ScriptMenu.cpp*

### UI_AdvServerOptions_Menu

*void UI_AdvServerOptions_Menu()*

*Defined at line 323 of ./mainui/menus/dynamic/ScriptMenu.cpp*

### UI_InputDevices_Menu

*void UI_InputDevices_Menu()*

*Defined at line 146 of ./mainui/menus/InputDevices.cpp*

=================UI_AdvControls_Menu=================

### UI_OpenUpdatePage

*void UI_OpenUpdatePage(_Bool engine, _Bool preferstore)*

*Defined at line 1127 of ./mainui/BaseMenu.cpp*

### UI_DrawMouseCursor

*void UI_DrawMouseCursor()*

*Defined at line 517 of ./mainui/BaseMenu.cpp*

=================UI_DrawMouseCursor=================

### UI_Options_Precache

*void UI_Options_Precache()*

*Defined at line 85 of ./mainui/menus/Configuration.cpp*

=================CMenuOptions::Precache=================

### GL_TargetToString

*const char * GL_TargetToString(GLenum target)*

*Defined at line 44 of ./rendersystem/r_image.cpp*

=================GL_TargetToString=================

### GL_UpdateTextureParams

*void GL_UpdateTextureParams(int iTexture)*

*Defined at line 247 of ./rendersystem/r_image.cpp*

=================GL_UpdateTextureParams=================

### GL_CalcTextureSamples

*int GL_CalcTextureSamples(int flags)*

*Defined at line 333 of ./rendersystem/r_image.cpp*

================GL_CalcTextureSamples================

### GL_CalcImageSize

*size_t GL_CalcImageSize(pixformat_t format, int width, int height, int depth)*

*Defined at line 345 of ./rendersystem/r_image.cpp*

==================GL_CalcImageSize==================

### GL_CalcTextureSize

*size_t GL_CalcTextureSize(GLenum format, int width, int height, int depth)*

*Defined at line 383 of ./rendersystem/r_image.cpp*

==================GL_CalcTextureSize==================

### GL_CalcMipmapCount

*int GL_CalcMipmapCount(gl_texture_t * tex, qboolean haveBuffer)*

*Defined at line 484 of ./rendersystem/r_image.cpp*

### GL_SetTextureDimensions

*void GL_SetTextureDimensions(gl_texture_t * tex, int width, int height, int depth)*

*Defined at line 515 of ./rendersystem/r_image.cpp*

================GL_SetTextureDimensions================

### GL_SetTextureTarget

*void GL_SetTextureTarget(gl_texture_t * tex, rgbdata_t * pic)*

*Defined at line 604 of ./rendersystem/r_image.cpp*

===============GL_SetTextureTarget===============

### GL_SetTextureFormat

*void GL_SetTextureFormat(gl_texture_t * tex, pixformat_t format, int channelMask)*

*Defined at line 656 of ./rendersystem/r_image.cpp*

===============GL_SetTextureFormat===============

### GL_BoxFilter3x3

*void GL_BoxFilter3x3(byte * out, const byte * in, int w, int h, int x, int y)*

*Defined at line 845 of ./rendersystem/r_image.cpp*

=================GL_BoxFilter3x3

box filter 3x3=================

### GL_ApplyFilter

*byte * GL_ApplyFilter(const byte * source, int width, int height)*

*Defined at line 892 of ./rendersystem/r_image.cpp*

=================GL_ApplyFilter

Apply box-filter to 1-bit alpha=================

### GL_BuildMipMap

*void GL_BuildMipMap(byte * in, int srcWidth, int srcHeight, int srcDepth, int flags)*

*Defined at line 917 of ./rendersystem/r_image.cpp*

=================GL_BuildMipMap

Operates in place, quartering the size of the texture=================

### GL_TextureImageRAW

*void GL_TextureImageRAW(gl_texture_t * tex, GLint side, GLint level, GLint width, GLint height, GLint depth, GLint type, const void * data)*

*Defined at line 1001 of ./rendersystem/r_image.cpp*

### GL_TextureImageDXT

*void GL_TextureImageDXT(gl_texture_t * tex, GLint side, GLint level, GLint width, GLint height, GLint depth, size_t size, const void * data)*

*Defined at line 1040 of ./rendersystem/r_image.cpp*

### GL_CheckTexImageError

*void GL_CheckTexImageError(gl_texture_t * tex)*

*Defined at line 1078 of ./rendersystem/r_image.cpp*

===============GL_CheckTexImageError

show GL-errors on load images===============

### GL_UploadTexture

*qboolean GL_UploadTexture(gl_texture_t * tex, rgbdata_t * pic)*

*Defined at line 1096 of ./rendersystem/r_image.cpp*

===============GL_UploadTexture

upload texture into video memory===============

### GL_ProcessImage

*void GL_ProcessImage(gl_texture_t * tex, rgbdata_t * pic)*

*Defined at line 1233 of ./rendersystem/r_image.cpp*

===============GL_ProcessImage

do specified actions on pixels===============

### GL_CheckTexName

*qboolean GL_CheckTexName(const char * name)*

*Defined at line 1298 of ./rendersystem/r_image.cpp*

================GL_CheckTexName================

### GL_TextureForName

*gl_texture_t * GL_TextureForName(const char * name)*

*Defined at line 1318 of ./rendersystem/r_image.cpp*

================GL_TextureForName================

### GL_AllocTexture

*gl_texture_t * GL_AllocTexture(const char * name, texFlags_t flags)*

*Defined at line 1340 of ./rendersystem/r_image.cpp*

================GL_AllocTexture================

### GL_DeleteTexture

*void GL_DeleteTexture(gl_texture_t * tex)*

*Defined at line 1378 of ./rendersystem/r_image.cpp*

================GL_DeleteTexture================

### GL_FakeImage

*rgbdata_t * GL_FakeImage(int width, int height, int depth, int flags)*

*Defined at line 1889 of ./rendersystem/r_image.cpp*

==============================================================================

INTERNAL TEXTURES

==============================================================================

==================GL_FakeImage==================

### GL_CreateInternalTextures

*void GL_CreateInternalTextures()*

*Defined at line 1940 of ./rendersystem/r_image.cpp*

==================GL_CreateInternalTextures==================

### monster_player

*void monster_player(entvars_t * pev)*

*Defined at line 36 of ./game/server/playermonster.cpp*

### Mod_Init

*void Mod_Init()*

*Defined at line 204 of ./engine/common/model.cpp*

 model.c

===============================================================================

			MODEL INITIALIZE**<not a builtin command>** 

===============================================================================

================Mod_Init================

### Mod_FreeModel

*void Mod_FreeModel(model_t * mod)*

*Defined at line 171 of ./engine/common/model.cpp*

================Mod_FreeModel================

### Mod_FreeAll

*void Mod_FreeAll()*

*Defined at line 223 of ./engine/common/model.cpp*

================Mod_FreeAll================

### Mod_Shutdown

*void Mod_Shutdown()*

*Defined at line 253 of ./engine/common/model.cpp*

================Mod_Shutdown================

### Mod_ClearUserData

*void Mod_ClearUserData()*

*Defined at line 240 of ./engine/common/model.cpp*

================Mod_ClearUserData================

### Mod_LoadWorld

*model_t * Mod_LoadWorld(const char * name, qboolean preload)*

*Defined at line 560 of ./engine/common/model.cpp*

==================Mod_LoadWorld

Loads in the map and all submodels==================

### Mod_Calloc

*void * Mod_Calloc(int number, size_t size)*

*Defined at line 615 of ./engine/common/model.cpp*

===============================================================================

			MODEL ROUTINES

===============================================================================

===============Mod_Calloc

===============

### Mod_CacheCheck

*void * Mod_CacheCheck(struct cache_user_s * c)*

*Defined at line 632 of ./engine/common/model.cpp*

===============Mod_CacheCheck

===============

### Mod_LoadCacheFile

*void Mod_LoadCacheFile(const char * path, struct cache_user_s * cu)*

*Defined at line 643 of ./engine/common/model.cpp*

===============Mod_LoadCacheFile

===============

### Mod_AliasExtradata

*void * Mod_AliasExtradata(model_t * mod)*

*Defined at line 673 of ./engine/common/model.cpp*

===============Mod_AliasExtradata

===============

### Mod_StudioExtradata

*void * Mod_StudioExtradata(model_t * mod)*

*Defined at line 686 of ./engine/common/model.cpp*

===============Mod_StudioExtradata

===============

### Mod_FindName

*model_t * Mod_FindName(const char * name, qboolean trackCRC)*

*Defined at line 273 of ./engine/common/model.cpp*

===============================================================================

			MODELS MANAGEMENT

===============================================================================

==================Mod_FindName

never return NULL==================

### Mod_LoadModel

*model_t * Mod_LoadModel(model_t * mod, qboolean crash, enum EModelType type)*

*Defined at line 322 of ./engine/common/model.cpp*

==================Mod_LoadModel

Loads a model into the cache==================

### Mod_ForName

*model_t * Mod_ForName(const char * name, qboolean crash, qboolean trackCRC)*

*Defined at line 508 of ./engine/common/model.cpp*

==================Mod_ForName

Loads in a model for the given name==================

### Mod_ValidateCRC

*qboolean Mod_ValidateCRC(const char * name, CRC32_t crc)*

*Defined at line 699 of ./engine/common/model.cpp*

==================Mod_ValidateCRC

==================

### Mod_NeedCRC

*void Mod_NeedCRC(const char * name, qboolean needCRC)*

*Defined at line 720 of ./engine/common/model.cpp*

==================Mod_NeedCRC

==================

### Mod_FreeUnused

*void Mod_FreeUnused()*

*Defined at line 589 of ./engine/common/model.cpp*

==================Mod_FreeUnused

Purge all unused models==================

### Mod_Handle

*model_t * Mod_Handle(int handle)*

*Defined at line 739 of ./engine/common/model.cpp*

==================Mod_Handle

==================

### Mod_LoadBrushModel

*void Mod_LoadBrushModel(model_t * mod, const void * buffer, qboolean * loaded)*

*Defined at line 2916 of ./engine/common/mod_bmodel.cpp*

 mod_bmodel.c

=================Mod_LoadBrushModel=================

### Mod_TestBmodelLumps

*qboolean Mod_TestBmodelLumps(const char * name, const byte * mod_base, qboolean silent)*

*Defined at line 2853 of ./engine/common/mod_bmodel.cpp*

=================Mod_TestBmodelLumps

check for possible errors=================

### Mod_HeadnodeVisible

*qboolean Mod_HeadnodeVisible(mnode_t * node, const byte * visbits, int * lastleaf)*

*Defined at line 723 of ./engine/common/mod_bmodel.cpp*

=============Mod_HeadnodeVisible=============

### Mod_FatPVS

*int Mod_FatPVS(const vec3_t org, float radius, byte * visbuffer, int visbytes, qboolean merge, qboolean fullvis)*

*Defined at line 590 of ./engine/common/mod_bmodel.cpp*

==================Mod_FatPVS_RecursiveBSPNode

Calculates a PVS that is the inclusive or of all leafswithin radius pixels of the given point.==================

### Mod_BoxVisible

*qboolean Mod_BoxVisible(const vec3_t mins, const vec3_t maxs, const byte * visbits)*

*Defined at line 700 of ./engine/common/mod_bmodel.cpp*

=============Mod_BoxVisible

Returns true if any leaf in boxspaceis potentially visible=============

### Mod_CheckLump

*int Mod_CheckLump(const char * filename, const int lump, int * lumpsize)*

*Defined at line 2939 of ./engine/common/mod_bmodel.cpp*

==================Mod_CheckLump

check lump for existing==================

### Mod_ReadLump

*int Mod_ReadLump(const char * filename, const int lump, void ** lumpdata, int * lumpsize)*

*Defined at line 2998 of ./engine/common/mod_bmodel.cpp*

==================Mod_ReadLump

reading random lump by user request==================

### Mod_SaveLump

*int Mod_SaveLump(const char * filename, const int lump, void * lumpdata, int lumpsize)*

*Defined at line 3080 of ./engine/common/mod_bmodel.cpp*

==================Mod_SaveLump

writing lump by user requestonly empty lumps is allows==================

### Mod_PointInLeaf

*mleaf_t * Mod_PointInLeaf(const vec3_t p, mnode_t * node)*

*Defined at line 499 of ./engine/common/mod_bmodel.cpp*

==================Mod_PointInLeaf

==================

### Mod_AmbientLevels

*void Mod_AmbientLevels(const vec3_t p, byte * pvolumes)*

*Defined at line 754 of ./engine/common/mod_bmodel.cpp*

==================Mod_AmbientLevels

grab the ambient sound levels for current point==================

### Mod_SampleSizeForFace

*int Mod_SampleSizeForFace(msurface_t * surf)*

*Defined at line 869 of ./engine/common/mod_bmodel.cpp*

==================Mod_SampleSizeForFace

return the current lightmap resolution per face==================

### Mod_GetPVSForPoint

*byte * Mod_GetPVSForPoint(const vec3_t p)*

*Defined at line 522 of ./engine/common/mod_bmodel.cpp*

==================Mod_GetPVSForPoint

Returns PVS data for a given pointNOTE: can return NULL==================

### Mod_UnloadBrushModel

*void Mod_UnloadBrushModel(model_t * mod)*

### Mod_PrintWorldStats_f

*void Mod_PrintWorldStats_f()*

*Defined at line 404 of ./engine/common/mod_bmodel.cpp*

=============Mod_PrintWorldStats_f

Dumps info about world=============

### Mod_InitDebugHulls

*void Mod_InitDebugHulls()*

*Defined at line 662 of ./engine/client/mod_dbghulls.cpp*

 mod_dbghulls.c

### Mod_CreatePolygonsForHull

*void Mod_CreatePolygonsForHull(int hullnum)*

*Defined at line 678 of ./engine/client/mod_dbghulls.cpp*

### Mod_ReleaseHullPolygons

*void Mod_ReleaseHullPolygons()*

*Defined at line 704 of ./engine/client/mod_dbghulls.cpp*

### Mod_UnloadStudioModel

*void Mod_UnloadStudioModel(model_t * mod)*

### Mod_InitStudioAPI

*void Mod_InitStudioAPI()*

*Defined at line 1161 of ./engine/common/mod_studio.cpp*

===============Mod_InitStudioAPI

Initialize server studio (blending interface)===============

### Mod_InitStudioHull

*void Mod_InitStudioHull()*

*Defined at line 67 of ./engine/common/mod_studio.cpp*

====================Mod_InitStudioHull====================

### Mod_ResetStudioAPI

*void Mod_ResetStudioAPI()*

*Defined at line 1185 of ./engine/common/mod_studio.cpp*

===============Mod_ResetStudioAPI

Returns to default callbacks===============

### Mod_StudioTexName

*const char * Mod_StudioTexName(const char * modname)*

*Defined at line 970 of ./engine/common/mod_studio.cpp*

===============Mod_StudioTexName

extract texture filename from modelname===============

### Mod_GetStudioBounds

*qboolean Mod_GetStudioBounds(const char * name, vec3_t mins, vec3_t maxs)*

*Defined at line 940 of ./engine/common/mod_studio.cpp*

====================Mod_GetStudioBounds====================

### Mod_StudioGetAttachment

*void Mod_StudioGetAttachment(const edict_t * e, int iAttachment, float * org, float * ang)*

*Defined at line 748 of ./engine/common/mod_studio.cpp*

====================StudioGetAttachment====================

### Mod_GetBonePosition

*void Mod_GetBonePosition(const edict_t * e, int iBone, float * org, float * ang)*

*Defined at line 797 of ./engine/common/mod_studio.cpp*

====================GetBonePosition====================

### Mod_HullForStudio

*hull_t * Mod_HullForStudio(model_t * m, float frame, int seq, vec3_t ang, vec3_t org, vec3_t size, byte * pcnt, byte * pbl, int * hitboxes, edict_t * ed)*

*Defined at line 231 of ./engine/common/mod_studio.cpp*

====================HullForStudio

NOTE: pEdict may be NULL====================

### R_StudioSlerpBones

*void R_StudioSlerpBones(int numbones, vec4_t [] q1, float [][3] pos1, vec4_t [] q2, float [][3] pos2, float s)*

*Defined at line 578 of ./engine/common/mod_studio.cpp*

====================StudioSlerpBones

====================

### R_StudioCalcBoneQuaternion

*void R_StudioCalcBoneQuaternion(int frame, float s, mstudiobone_t * pbone, mstudioanim_t * panim, float * adj, vec4_t q)*

*Defined at line 406 of ./engine/common/mod_studio.cpp*

====================StudioCalcBoneQuaternion

====================

### R_StudioCalcBonePosition

*void R_StudioCalcBonePosition(int frame, float s, mstudiobone_t * pbone, mstudioanim_t * panim, vec3_t adj, vec3_t pos)*

*Defined at line 494 of ./engine/common/mod_studio.cpp*

====================StudioCalcBonePosition

====================

### R_StudioGetAnim

*void * R_StudioGetAnim(studiohdr_t * m_pStudioHeader, model_t * m_pSubModel, mstudioseqdesc_t * pseqdesc)*

*Defined at line 597 of ./engine/common/mod_studio.cpp*

====================StudioGetAnim

====================

### Mod_StudioComputeBounds

*void Mod_StudioComputeBounds(void * buffer, vec3_t mins, vec3_t maxs, qboolean ignore_sequences)*

*Defined at line 864 of ./engine/common/mod_studio.cpp*

====================StudioComputeBounds====================

### Mod_HitgroupForStudioHull

*int Mod_HitgroupForStudioHull(int index)*

*Defined at line 816 of ./engine/common/mod_studio.cpp*

====================HitgroupForStudioHull====================

### Mod_ClearStudioCache

*void Mod_ClearStudioCache()*

*Defined at line 106 of ./engine/common/mod_studio.cpp*

===============================================================================

	STUDIO MODELS CACHE

===============================================================================

====================ClearStudioCache====================

### BitByte

*int BitByte(int bits)*

*Defined at line 33 of ./engine/common/net_buffer.h*

### MSG_InitExt

*void MSG_InitExt(sizebuf_t * sb, const char * pDebugName, void * pData, int nBytes, int nMaxBits)*

*Defined at line 56 of ./engine/common/net_buffer.cpp*

 common functions

### MSG_InitMasks

*void MSG_InitMasks()*

*Defined at line 36 of ./engine/common/net_buffer.cpp*

### MSG_SeekToBit

*int MSG_SeekToBit(sizebuf_t * sb, int bitPos, int whence)*

*Defined at line 110 of ./engine/common/net_buffer.cpp*

### MSG_ExciseBits

*void MSG_ExciseBits(sizebuf_t * sb, int startbit, int bitstoremove)*

*Defined at line 672 of ./engine/common/net_buffer.cpp*

### MSG_TellBit

*int MSG_TellBit(sizebuf_t * sb)*

*Defined at line 63 of ./engine/common/net_buffer.h*

### MSG_GetName

*const char * MSG_GetName(sizebuf_t * sb)*

*Defined at line 64 of ./engine/common/net_buffer.h*

### MSG_CheckOverflow

*qboolean MSG_CheckOverflow(sizebuf_t * sb)*

*Defined at line 105 of ./engine/common/net_buffer.cpp*

### MSG_BigShort

*short MSG_BigShort(short swap)*

*Defined at line 31 of ./engine/common/net_buffer.cpp*

### MSG_StartWriting

*void MSG_StartWriting(sizebuf_t * sb, void * pData, int nBytes, int iStartBit, int nBits)*

*Defined at line 63 of ./engine/common/net_buffer.cpp*

 init writing

### MSG_Clear

*void MSG_Clear(sizebuf_t * sb)*

*Defined at line 92 of ./engine/common/net_buffer.cpp*

=======================MSG_Clear

for clearing overflowed buffer=======================

### MSG_WriteOneBit

*void MSG_WriteOneBit(sizebuf_t * sb, int nValue)*

*Defined at line 140 of ./engine/common/net_buffer.cpp*

 Bit-write functions

### MSG_WriteUBitLong

*void MSG_WriteUBitLong(sizebuf_t * sb, uint curData, int numbits)*

*Defined at line 151 of ./engine/common/net_buffer.cpp*

### MSG_WriteSBitLong

*void MSG_WriteSBitLong(sizebuf_t * sb, int data, int numbits)*

*Defined at line 199 of ./engine/common/net_buffer.cpp*

=======================MSG_WriteSBitLong

sign bit comes first=======================

### MSG_WriteBitLong

*void MSG_WriteBitLong(sizebuf_t * sb, int data, int numbits, qboolean bSigned)*

*Defined at line 218 of ./engine/common/net_buffer.cpp*

### MSG_WriteBits

*qboolean MSG_WriteBits(sizebuf_t * sb, const void * pData, int nBits)*

*Defined at line 225 of ./engine/common/net_buffer.cpp*

### MSG_WriteBitAngle

*void MSG_WriteBitAngle(sizebuf_t * sb, float fAngle, int numbits)*

*Defined at line 266 of ./engine/common/net_buffer.cpp*

### MSG_WriteBitFloat

*void MSG_WriteBitFloat(sizebuf_t * sb, float val)*

*Defined at line 306 of ./engine/common/net_buffer.cpp*

### MSG_WriteCmdExt

*void MSG_WriteCmdExt(sizebuf_t * sb, int cmd, netsrc_t type, const char * name)*

*Defined at line 317 of ./engine/common/net_buffer.cpp*

### MSG_WriteChar

*void MSG_WriteChar(sizebuf_t * sb, int val)*

*Defined at line 344 of ./engine/common/net_buffer.cpp*

### MSG_WriteByte

*void MSG_WriteByte(sizebuf_t * sb, int val)*

*Defined at line 349 of ./engine/common/net_buffer.cpp*

### MSG_WriteShort

*void MSG_WriteShort(sizebuf_t * sb, int val)*

*Defined at line 354 of ./engine/common/net_buffer.cpp*

### MSG_WriteWord

*void MSG_WriteWord(sizebuf_t * sb, int val)*

*Defined at line 359 of ./engine/common/net_buffer.cpp*

### MSG_WriteLong

*void MSG_WriteLong(sizebuf_t * sb, int val)*

*Defined at line 364 of ./engine/common/net_buffer.cpp*

### MSG_WriteDword

*void MSG_WriteDword(sizebuf_t * sb, dword val)*

*Defined at line 369 of ./engine/common/net_buffer.cpp*

### MSG_WriteCoord

*void MSG_WriteCoord(sizebuf_t * sb, float val)*

*Defined at line 284 of ./engine/common/net_buffer.cpp*

### MSG_WriteFloat

*void MSG_WriteFloat(sizebuf_t * sb, float val)*

*Defined at line 374 of ./engine/common/net_buffer.cpp*

### MSG_WriteVec3Coord

*void MSG_WriteVec3Coord(sizebuf_t * sb, const float * fa)*

*Defined at line 292 of ./engine/common/net_buffer.cpp*

### MSG_WriteVec3Angles

*void MSG_WriteVec3Angles(sizebuf_t * sb, const float * fa)*

*Defined at line 299 of ./engine/common/net_buffer.cpp*

### MSG_WriteBytes

*qboolean MSG_WriteBytes(sizebuf_t * sb, const void * pBuf, int nBytes)*

*Defined at line 379 of ./engine/common/net_buffer.cpp*

### MSG_WriteString

*qboolean MSG_WriteString(sizebuf_t * sb, const char * pStr)*

*Defined at line 384 of ./engine/common/net_buffer.cpp*

### MSG_GetNumBytesWritten

*int MSG_GetNumBytesWritten(sizebuf_t * sb)*

*Defined at line 99 of ./engine/common/net_buffer.h*

 helper functions

### MSG_GetRealBytesWritten

*int MSG_GetRealBytesWritten(sizebuf_t * sb)*

*Defined at line 100 of ./engine/common/net_buffer.h*

### MSG_GetNumBitsWritten

*int MSG_GetNumBitsWritten(sizebuf_t * sb)*

*Defined at line 101 of ./engine/common/net_buffer.h*

### MSG_GetMaxBits

*int MSG_GetMaxBits(sizebuf_t * sb)*

*Defined at line 102 of ./engine/common/net_buffer.h*

### MSG_GetMaxBytes

*int MSG_GetMaxBytes(sizebuf_t * sb)*

*Defined at line 103 of ./engine/common/net_buffer.h*

### MSG_GetNumBitsLeft

*int MSG_GetNumBitsLeft(sizebuf_t * sb)*

*Defined at line 104 of ./engine/common/net_buffer.h*

### MSG_GetNumBytesLeft

*int MSG_GetNumBytesLeft(sizebuf_t * sb)*

*Defined at line 105 of ./engine/common/net_buffer.h*

### MSG_GetData

*byte * MSG_GetData(sizebuf_t * sb)*

*Defined at line 106 of ./engine/common/net_buffer.h*

### MSG_GetBuf

*byte * MSG_GetBuf(sizebuf_t * sb)*

*Defined at line 107 of ./engine/common/net_buffer.h*

### MSG_ReadOneBit

*int MSG_ReadOneBit(sizebuf_t * sb)*

*Defined at line 399 of ./engine/common/net_buffer.cpp*

 Bit-read functions

### MSG_ReadBitFloat

*float MSG_ReadBitFloat(sizebuf_t * sb)*

*Defined at line 458 of ./engine/common/net_buffer.cpp*

### MSG_ReadBits

*qboolean MSG_ReadBits(sizebuf_t * sb, void * pOutData, int nBits)*

*Defined at line 484 of ./engine/common/net_buffer.cpp*

### MSG_ReadBitAngle

*float MSG_ReadBitAngle(sizebuf_t * sb, int numbits)*

*Defined at line 522 of ./engine/common/net_buffer.cpp*

### MSG_ReadSBitLong

*int MSG_ReadSBitLong(sizebuf_t * sb, int numbits)*

*Defined at line 540 of ./engine/common/net_buffer.cpp*

 Append numbits least significant bits from data to the current bit stream

### MSG_ReadUBitLong

*uint MSG_ReadUBitLong(sizebuf_t * sb, int numbits)*

*Defined at line 410 of ./engine/common/net_buffer.cpp*

### MSG_ReadBitLong

*uint MSG_ReadBitLong(sizebuf_t * sb, int numbits, qboolean bSigned)*

*Defined at line 554 of ./engine/common/net_buffer.cpp*

### MSG_ReadCmd

*int MSG_ReadCmd(sizebuf_t * sb, netsrc_t type)*

*Defined at line 561 of ./engine/common/net_buffer.cpp*

### MSG_ReadChar

*int MSG_ReadChar(sizebuf_t * sb)*

*Defined at line 578 of ./engine/common/net_buffer.cpp*

### MSG_ReadByte

*int MSG_ReadByte(sizebuf_t * sb)*

*Defined at line 583 of ./engine/common/net_buffer.cpp*

### MSG_ReadShort

*int MSG_ReadShort(sizebuf_t * sb)*

*Defined at line 588 of ./engine/common/net_buffer.cpp*

### MSG_ReadWord

*int MSG_ReadWord(sizebuf_t * sb)*

*Defined at line 593 of ./engine/common/net_buffer.cpp*

### MSG_ReadLong

*int MSG_ReadLong(sizebuf_t * sb)*

*Defined at line 620 of ./engine/common/net_buffer.cpp*

### MSG_ReadDword

*dword MSG_ReadDword(sizebuf_t * sb)*

*Defined at line 625 of ./engine/common/net_buffer.cpp*

### MSG_ReadCoord

*float MSG_ReadCoord(sizebuf_t * sb)*

*Defined at line 598 of ./engine/common/net_buffer.cpp*

### MSG_ReadFloat

*float MSG_ReadFloat(sizebuf_t * sb)*

*Defined at line 630 of ./engine/common/net_buffer.cpp*

### MSG_ReadVec3Coord

*void MSG_ReadVec3Coord(sizebuf_t * sb, vec3_t fa)*

*Defined at line 606 of ./engine/common/net_buffer.cpp*

### MSG_ReadVec3Angles

*void MSG_ReadVec3Angles(sizebuf_t * sb, vec3_t fa)*

*Defined at line 613 of ./engine/common/net_buffer.cpp*

### MSG_ReadBytes

*qboolean MSG_ReadBytes(sizebuf_t * sb, void * pOut, int nBytes)*

*Defined at line 641 of ./engine/common/net_buffer.cpp*

### MSG_ReadStringExt

*char * MSG_ReadStringExt(sizebuf_t * sb, qboolean bLine)*

*Defined at line 646 of ./engine/common/net_buffer.cpp*

### NetSplit_GetLong

*qboolean NetSplit_GetLong(netsplit_t * ns, netadr_t * from, byte * data, size_t * length)*

*Defined at line 122 of ./engine/common/net_chan.cpp*

 packet splitting

======================NetSplit_GetLong

Collect fragmrnts with signature 0xFFFFFFFE to single packetreturn true when got full packet======================

### Netchan_Init

*void Netchan_Init()*

*Defined at line 245 of ./engine/common/net_chan.cpp*

===============Netchan_Init===============

### Netchan_Shutdown

*void Netchan_Shutdown()*

*Defined at line 263 of ./engine/common/net_chan.cpp*

### Netchan_Setup

*void Netchan_Setup(netsrc_t sock, netchan_t * chan, netadr_s adr, int qport, void * client, int (*)(void *, fragsize_t) pfnBlockSize)*

*Defined at line 305 of ./engine/common/net_chan.cpp*

==============Netchan_Setup

called to open a channel to a remote system==============

### Netchan_CreateFileFragmentsFromBuffer

*void Netchan_CreateFileFragmentsFromBuffer(netchan_t * chan, const char * filename, byte * pbuf, int size)*

*Defined at line 861 of ./engine/common/net_chan.cpp*

==============================Netchan_CreateFileFragmentsFromBuffer

==============================

### Netchan_CopyNormalFragments

*qboolean Netchan_CopyNormalFragments(netchan_t * chan, sizebuf_t * msg, size_t * length)*

*Defined at line 1089 of ./engine/common/net_chan.cpp*

==============================Netchan_CopyNormalFragments

==============================

### Netchan_CopyFileFragments

*qboolean Netchan_CopyFileFragments(netchan_t * chan, sizebuf_t * msg)*

*Defined at line 1154 of ./engine/common/net_chan.cpp*

==============================Netchan_CopyFileFragments

==============================

### Netchan_CreateFragments

*void Netchan_CreateFragments(netchan_t * chan, sizebuf_t * msg)*

*Defined at line 773 of ./engine/common/net_chan.cpp*

==============================Netchan_CreateFragments

==============================

### Netchan_CreateFileFragments

*int Netchan_CreateFileFragments(netchan_t * chan, const char * filename)*

*Defined at line 950 of ./engine/common/net_chan.cpp*

==============================Netchan_CreateFileFragments

==============================

### Netchan_Transmit

*void Netchan_Transmit(netchan_t * chan, int lengthInBytes, byte * data)*

*Defined at line 1712 of ./engine/common/net_chan.cpp*

===============Netchan_Transmit

tries to send an unreliable message to a connection, and handles thetransmition / retransmition of the reliable messages.

A 0 length will still generate a packet and deal with the reliable messages.================

### Netchan_TransmitBits

*void Netchan_TransmitBits(netchan_t * chan, int lengthInBits, byte * data)*

*Defined at line 1405 of ./engine/common/net_chan.cpp*

===============Netchan_TransmitBits

tries to send an unreliable message to a connection, and handles thetransmition / retransmition of the reliable messages.

A 0 length will still generate a packet and deal with the reliable messages.================

### Netchan_OutOfBand

*void Netchan_OutOfBand(int net_socket, netadr_s adr, int length, byte * data)*

*Defined at line 497 of ./engine/common/net_chan.cpp*

===============Netchan_OutOfBand

Sends an out-of-band datagram================

### Netchan_OutOfBandPrint

*void Netchan_OutOfBandPrint(int net_socket, netadr_s adr, char * format)*

*Defined at line 522 of ./engine/common/net_chan.cpp*

===============Netchan_OutOfBandPrint

Sends a text message in an out-of-band datagram================

### Netchan_Process

*qboolean Netchan_Process(netchan_t * chan, sizebuf_t * msg)*

*Defined at line 1725 of ./engine/common/net_chan.cpp*

=================Netchan_Process

called when the current net_message is from remote_addressmodifies net_message so that it points to the packet payload=================

### Netchan_UpdateProgress

*void Netchan_UpdateProgress(netchan_t * chan)*

*Defined at line 1313 of ./engine/common/net_chan.cpp*

==============================Netchan_UpdateProgress

==============================

### Netchan_IncomingReady

*qboolean Netchan_IncomingReady(netchan_t * chan)*

*Defined at line 331 of ./engine/common/net_chan.cpp*

==============================Netchan_IncomingReady

==============================

### Netchan_CanPacket

*qboolean Netchan_CanPacket(netchan_t * chan, qboolean choke)*

*Defined at line 351 of ./engine/common/net_chan.cpp*

===============Netchan_CanPacket

Returns true if the bandwidth choke isn't active================

### Netchan_IsLocal

*qboolean Netchan_IsLocal(netchan_t * chan)*

*Defined at line 291 of ./engine/common/net_chan.cpp*

==============Netchan_IsLocal

detect a loopback message==============

### Netchan_ReportFlow

*void Netchan_ReportFlow(netchan_t * chan)*

*Defined at line 268 of ./engine/common/net_chan.cpp*

### Netchan_FragSend

*void Netchan_FragSend(netchan_t * chan)*

*Defined at line 619 of ./engine/common/net_chan.cpp*

==============================Netchan_FragSend

Fragmentation buffer is full and user is prepared to send==============================

### Netchan_Clear

*void Netchan_Clear(netchan_t * chan)*

*Defined at line 461 of ./engine/common/net_chan.cpp*

==============================Netchan_Clear

==============================

### InsertLinkBefore

*void InsertLinkBefore(link_t * l, link_t * before)*

*Defined at line 72 of ./engine/common/world.cpp*

 linked list

===============InsertLinkBefore

kept trigger and solid entities seperate===============

### RemoveLink

*void RemoveLink(link_t * l)*

*Defined at line 59 of ./engine/common/world.cpp*

===============RemoveLink

remove link from chain===============

### ClearLink

*void ClearLink(link_t * l)*

*Defined at line 47 of ./engine/common/world.cpp*

===============================================================================

	ENTITY LINKING

===============================================================================

===============ClearLink

ClearLink is used for new headnodes===============

### World_MoveBounds

*void World_MoveBounds(const vec3_t start, vec3_t mins, vec3_t maxs, const vec3_t end, vec3_t boxmins, vec3_t boxmaxs)*

*Defined at line 85 of ./engine/common/world.cpp*

 trace common

==================World_MoveBounds==================

### World_TransformAABB

*void World_TransformAABB(matrix4x4 transform, const vec3_t mins, const vec3_t maxs, vec3_t outmins, vec3_t outmaxs)*

*Defined at line 126 of ./engine/common/world.cpp*

==================World_TransformAABB==================

### World_CombineTraces

* World_CombineTraces(trace_t * cliptrace, trace_t * trace, edict_t * touch)*

*Defined at line 104 of ./engine/common/world.cpp*

### RankForContents

*int RankForContents(int contents)*

*Defined at line 175 of ./engine/common/world.cpp*

==================RankForContents

Used for determine contents priority==================

### GL_RenderFrame

*void GL_RenderFrame(const struct ref_viewpass_s * rvp)*

*Defined at line 41 of ./engine/client/ref_common.cpp*

### CL_SetLightstyle

*void CL_SetLightstyle(int style, const char * s, float f)*

*Defined at line 2419 of ./engine/client/cl_tent.cpp*

=============================================================================

### CL_DecayLights

*void CL_DecayLights()*

*Defined at line 2574 of ./engine/client/cl_tent.cpp*

===============CL_DecayLights

===============

### CL_GetDynamicLight

*dlight_t * CL_GetDynamicLight(int number)*

*Defined at line 2605 of ./engine/client/cl_tent.cpp*

### CL_GetEntityLight

*dlight_t * CL_GetEntityLight(int number)*

*Defined at line 2611 of ./engine/client/cl_tent.cpp*

### CL_Quit_f

*void CL_Quit_f()*

*Defined at line 980 of ./engine/client/cl_main.cpp*

 cl_cmds.c

==================CL_Quit_f==================

### CL_ScreenShot_f

*void CL_ScreenShot_f()*

*Defined at line 214 of ./engine/client/cl_cmds.cpp*

============================================================================== 

			SCREEN SHOTS 

============================================================================== 

================== CL_ScreenShot_f

normal screenshot================== 

### CL_SnapShot_f

*void CL_SnapShot_f()*

*Defined at line 252 of ./engine/client/cl_cmds.cpp*

================== CL_SnapShot_f

save screenshots into root dir================== 

### CL_PlayCDTrack_f

*void CL_PlayCDTrack_f()*

*Defined at line 61 of ./engine/client/cl_cmds.cpp*

===============CL_PlayCDTrack_f

Emulate audio-cd system===============

### CL_EnvShot_f

*void CL_EnvShot_f()*

*Defined at line 293 of ./engine/client/cl_cmds.cpp*

================== CL_EnvShot_f

cubemap view================== 

### CL_SkyShot_f

*void CL_SkyShot_f()*

*Defined at line 314 of ./engine/client/cl_cmds.cpp*

================== CL_SkyShot_f

skybox view================== 

### CL_SaveShot_f

*void CL_SaveShot_f()*

*Defined at line 375 of ./engine/client/cl_cmds.cpp*

================== CL_SaveShot_f

mini-pic in loadgame menu================== 

### CL_LevelShot_f

*void CL_LevelShot_f()*

*Defined at line 335 of ./engine/client/cl_cmds.cpp*

================== CL_LevelShot_f

splash logo while map is loading================== 

### CL_SetSky_f

*void CL_SetSky_f()*

*Defined at line 418 of ./engine/client/cl_cmds.cpp*

=================CL_SetSky_f

Set a specified skybox (only for local clients)=================

### SCR_Viewpos_f

*void SCR_Viewpos_f()*

*Defined at line 436 of ./engine/client/cl_cmds.cpp*

=============SCR_Viewpos_f

viewpos (level-designer helper)=============

### CL_CheckFile

*qboolean CL_CheckFile(sizebuf_t * msg, resource_t * pResource)*

*Defined at line 20 of ./engine/client/cl_custom.cpp*

 cl_custom.c

### CL_AddToResourceList

*void CL_AddToResourceList(resource_t * pResource, resource_t * pList)*

*Defined at line 87 of ./engine/client/cl_custom.cpp*

### CL_RemoveFromResourceList

*void CL_RemoveFromResourceList(resource_t * pResource)*

*Defined at line 104 of ./engine/client/cl_custom.cpp*

### CL_MoveToOnHandList

*void CL_MoveToOnHandList(resource_t * pResource)*

*Defined at line 118 of ./engine/client/cl_custom.cpp*

### CL_ClearResourceLists

*void CL_ClearResourceLists()*

*Defined at line 146 of ./engine/client/cl_custom.cpp*

### CL_Parse_Debug

*void CL_Parse_Debug(qboolean enable)*

*Defined at line 141 of ./engine/client/cl_debug.cpp*

 cl_debug.c

=====================CL_Parse_Debug

enable message debugging=====================

### CL_Parse_RecordCommand

*void CL_Parse_RecordCommand(int cmd, int startoffset)*

*Defined at line 153 of ./engine/client/cl_debug.cpp*

=====================CL_Parse_RecordCommand

record new message params into debug buffer=====================

### CL_ResetFrame

*void CL_ResetFrame(frame_t * frame)*

*Defined at line 170 of ./engine/client/cl_debug.cpp*

=====================CL_ResetFrame=====================

### CL_Particle

*void CL_Particle(const vec3_t org, int color, float life, int zpos, int zvel)*

*Defined at line 1806 of ./engine/client/cl_efx.cpp*

 cl_efx.c

===============CL_Particle

pmove debugging particle===============

### CL_SendCommand

*void CL_SendCommand()*

*Defined at line 897 of ./engine/client/cl_main.cpp*

=================CL_SendCommand

Called every frame to builds and sends a command packet to the server.=================

### CL_Disconnect_f

*void CL_Disconnect_f()*

*Defined at line 1527 of ./engine/client/cl_main.cpp*

### CL_WriteUsercmd

*void CL_WriteUsercmd(sizebuf_t * msg, int from, int to)*

*Defined at line 685 of ./engine/client/cl_main.cpp*

### CL_GetFragmentSize

*int CL_GetFragmentSize(void * unused, fragsize_t mode)*

*Defined at line 204 of ./engine/client/cl_main.cpp*

### CL_PrecacheResources

*qboolean CL_PrecacheResources()*

*Defined at line 2614 of ./engine/client/cl_main.cpp*

### CL_SetupOverviewParams

*void CL_SetupOverviewParams()*

*Defined at line 1842 of ./engine/client/cl_main.cpp*

===================================================================

===============CL_SetupOverviewParams

Get initial overview values===============

### CL_UpdateFrameLerp

*void CL_UpdateFrameLerp()*

*Defined at line 421 of ./engine/client/cl_main.cpp*

=================CL_UpdateFrameLerp

=================

### CL_IsDevOverviewMode

*int CL_IsDevOverviewMode()*

*Defined at line 163 of ./engine/client/cl_main.cpp*

### CL_PingServers_f

*void CL_PingServers_f()*

### CL_SignonReply

*void CL_SignonReply()*

*Defined at line 225 of ./engine/client/cl_main.cpp*

=====================CL_SignonReply

An svc_signonnum has been received, perform a client side setup=====================

### CL_ClearState

*void CL_ClearState()*

*Defined at line 1336 of ./engine/client/cl_main.cpp*

=====================CL_ClearState

=====================

### CL_StartupDemoHeader

*void CL_StartupDemoHeader()*

*Defined at line 118 of ./engine/client/cl_demo.cpp*

 cl_demo.c

====================CL_StartupDemoHeader

spooling demo header in casewe record a demo on this level====================

### CL_DrawDemoRecording

*void CL_DrawDemoRecording()*

*Defined at line 489 of ./engine/client/cl_demo.cpp*

=================CL_DrawDemoRecording=================

### CL_WriteDemoUserCmd

*void CL_WriteDemoUserCmd(int cmdnumber)*

*Defined at line 238 of ./engine/client/cl_demo.cpp*

====================CL_WriteDemoUserCmd

Writes the current user cmd====================

### CL_WriteDemoMessage

*void CL_WriteDemoMessage(qboolean startup, int start, sizebuf_t * msg)*

*Defined at line 290 of ./engine/client/cl_demo.cpp*

====================CL_WriteDemoMessage

Dumps the current net message, prefixed by the length====================

### CL_WriteDemoUserMessage

*void CL_WriteDemoUserMessage(const byte * buffer, size_t size)*

*Defined at line 327 of ./engine/client/cl_demo.cpp*

====================CL_WriteDemoUserMessage

Dumps the user message (demoaction)====================

### CL_DemoReadMessage

*qboolean CL_DemoReadMessage(byte * buffer, size_t * length)*

*Defined at line 884 of ./engine/client/cl_demo.cpp*

=================CL_DemoReadMessage

reads demo data and write it to client=================

### CL_DemoInterpolateAngles

*void CL_DemoInterpolateAngles()*

*Defined at line 1057 of ./engine/client/cl_demo.cpp*

==============CL_DemoInterpolateAngles

We can predict or inpolate player movement with standed client codebut viewangles interpolate here==============

### CL_CheckStartupDemos

*void CL_CheckStartupDemos()*

*Defined at line 1277 of ./engine/client/cl_demo.cpp*

================== CL_CheckStartupDemos

queue demos loop after movie playing================== 

### CL_WriteDemoJumpTime

*void CL_WriteDemoJumpTime()*

*Defined at line 219 of ./engine/client/cl_demo.cpp*

====================CL_WriteDemoJumpTime

Update level time on a next level====================

### CL_CloseDemoHeader

*void CL_CloseDemoHeader()*

*Defined at line 144 of ./engine/client/cl_demo.cpp*

====================CL_CloseDemoHeader

close demoheader file on engine shutdown====================

### CL_DemoCompleted

*void CL_DemoCompleted()*

*Defined at line 697 of ./engine/client/cl_demo.cpp*

=================CL_DemoCompleted=================

### CL_StopRecord

*void CL_StopRecord()*

*Defined at line 439 of ./engine/client/cl_demo.cpp*

=================CL_StopRecord

finish recording demo=================

### CL_PlayDemo_f

*void CL_PlayDemo_f()*

*Defined at line 1411 of ./engine/client/cl_demo.cpp*

====================CL_PlayDemo_f

playdemo <demoname>====================

### CL_TimeDemo_f

*void CL_TimeDemo_f()*

*Defined at line 1539 of ./engine/client/cl_demo.cpp*

====================CL_TimeDemo_f

timedemo <demoname>====================

### CL_StartDemos_f

*void CL_StartDemos_f()*

*Defined at line 1562 of ./engine/client/cl_demo.cpp*

==================CL_StartDemos_f==================

### CL_Demos_f

*void CL_Demos_f()*

*Defined at line 1593 of ./engine/client/cl_demo.cpp*

==================CL_Demos_f

Return to looping demos==================

### CL_DeleteDemo_f

*void CL_DeleteDemo_f()*

*Defined at line 393 of ./engine/client/cl_cmds.cpp*

==============CL_DeleteDemo_f

==============

### CL_Record_f

*void CL_Record_f()*

*Defined at line 1335 of ./engine/client/cl_demo.cpp*

====================CL_Record_f

record <demoname>Begins recording a demo from the current position====================

### CL_Stop_f

*void CL_Stop_f()*

*Defined at line 1620 of ./engine/client/cl_demo.cpp*

====================CL_Stop_f

stop any client activity====================

### CL_ParseEvent

*void CL_ParseEvent(sizebuf_t * msg)*

*Defined at line 376 of ./engine/client/cl_events.cpp*

 cl_events.c

=============CL_ParseEvent

=============

### CL_ParseReliableEvent

*void CL_ParseReliableEvent(sizebuf_t * msg)*

*Defined at line 347 of ./engine/client/cl_events.cpp*

=============CL_ParseReliableEvent

=============

### CL_SetEventIndex

*void CL_SetEventIndex(const char * szEvName, int ev_index)*

*Defined at line 106 of ./engine/client/cl_events.cpp*

=============CL_SetEventIndex

=============

### CL_QueueEvent

*void CL_QueueEvent(int flags, int index, float delay, event_args_t * args)*

*Defined at line 317 of ./engine/client/cl_events.cpp*

=============CL_QueueEvent

=============

### CL_PlaybackEvent

*void CL_PlaybackEvent(int flags, const edict_t * pInvoker, word eventindex, float delay, float * origin, float * angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2)*

*Defined at line 453 of ./engine/client/cl_events.cpp*

=============CL_PlaybackEvent

=============

### CL_RegisterEvent

*void CL_RegisterEvent(int lastnum, const char * szEvName, pfnEventHook func)*

*Defined at line 155 of ./engine/client/cl_events.cpp*

=============CL_RegisterEvent

=============

### CL_BatchResourceRequest

*void CL_BatchResourceRequest(qboolean initialize)*

*Defined at line 457 of ./engine/client/cl_parse.cpp*

### CL_EstimateNeededResources

*int CL_EstimateNeededResources()*

*Defined at line 554 of ./engine/client/cl_parse.cpp*

### CL_ResetEvent

*void CL_ResetEvent(event_info_t * ei)*

*Defined at line 28 of ./engine/client/cl_events.cpp*

===============CL_ResetEvent

===============

### CL_EventIndex

*word CL_EventIndex(const char * name)*

*Defined at line 134 of ./engine/client/cl_events.cpp*

=============CL_EventIndex

=============

### CL_FireEvents

*void CL_FireEvents()*

*Defined at line 226 of ./engine/client/cl_events.cpp*

=============CL_FireEvents

called right before draw frame=============

### CL_UnloadProgs

*void CL_UnloadProgs()*

*Defined at line 4553 of ./engine/client/cl_game.cpp*

 cl_game.c

### CL_ParseUserMessage

*void CL_ParseUserMessage(sizebuf_t * msg, int svc_num)*

*Defined at line 1950 of ./engine/client/cl_parse.cpp*

==============CL_ParseUserMessage

handles all user messages==============

### CL_LinkUserMessage

*void CL_LinkUserMessage(char * pszName, const int svc_num, int iSize)*

*Defined at line 1068 of ./engine/client/cl_game.cpp*

### CL_ParseFinaleCutscene

*void CL_ParseFinaleCutscene(sizebuf_t * msg, int level)*

*Defined at line 752 of ./engine/client/cl_game.cpp*

================CL_ParseFinaleCutscene

show display finale or cutscene message================

### CL_ParseTextMessage

*void CL_ParseTextMessage(sizebuf_t * msg)*

*Defined at line 702 of ./engine/client/cl_game.cpp*

====================CL_ParseTextMessage

Parse TE_TEXTMESSAGE====================

### CL_DrawHUD

*void CL_DrawHUD(int state)*

*Defined at line 1021 of ./engine/client/cl_game.cpp*

### CL_InitEdicts

*void CL_InitEdicts()*

*Defined at line 1128 of ./engine/client/cl_game.cpp*

### CL_FreeEdicts

*void CL_FreeEdicts()*

*Defined at line 1151 of ./engine/client/cl_game.cpp*

### CL_ClearWorld

*void CL_ClearWorld()*

*Defined at line 1111 of ./engine/client/cl_game.cpp*

### CL_DrawCenterPrint

*void CL_DrawCenterPrint()*

*Defined at line 542 of ./engine/client/cl_game.cpp*

=============CL_DrawCenterPrint

called each frame=============

### CL_ClearSpriteTextures

*void CL_ClearSpriteTextures()*

*Defined at line 1189 of ./engine/client/cl_game.cpp*

==================CL_ClearSpriteTextures

free studio cache on change level==================

### CL_FreeEntity

*void CL_FreeEntity(cl_entity_t * pEdict)*

*Defined at line 1104 of ./engine/client/cl_game.cpp*

### CL_CenterPrint

*void CL_CenterPrint(const char * text, float y)*

*Defined at line 345 of ./engine/client/cl_game.cpp*

=============CL_CenterPrint

print centerscreen message=============

### CL_TextMessageParse

*void CL_TextMessageParse(byte * pMemFile, int fileSize)*

*Defined at line 211 of ./engine/client/titles.cpp*

### CL_TextMessageGet

*client_textmessage_t * CL_TextMessageGet(const char * pName)*

*Defined at line 1850 of ./engine/client/cl_game.cpp*

=============pfnTextMessageGet

returns specified message from titles.txt=============

### pfnDecalIndexFromName

*int pfnDecalIndexFromName(const char * szDecalName)*

### pfnIndexFromTrace

*int pfnIndexFromTrace(struct pmtrace_s * pTrace)*

*Defined at line 2442 of ./engine/client/cl_game.cpp*

=============pfnIndexFromTrace

=============

### CL_ModelHandle

*model_t * CL_ModelHandle(int modelindex)*

*Defined at line 134 of ./engine/client/cl_game.cpp*

================CL_ModelHandle

get model handle by index================

### NetAPI_CancelAllRequests

*void NetAPI_CancelAllRequests()*

*Defined at line 3489 of ./engine/client/cl_game.cpp*

=================NetAPI_CancelAllRequests

=================

### CL_FindModelIndex

*int CL_FindModelIndex(const char * m)*

*Defined at line 2355 of ./engine/client/cl_game.cpp*

=============CL_FindModelIndex

=============

### CL_GetLocalPlayer

*cl_entity_t * CL_GetLocalPlayer()*

*Defined at line 800 of ./engine/client/cl_game.cpp*

====================CL_GetLocalPlayer

Render callback for studio models====================

### CL_LoadClientSprite

*model_t * CL_LoadClientSprite(const char * filename)*

*Defined at line 1323 of ./engine/client/cl_game.cpp*

=============CL_LoadClientSprite

load sprites for temp ents=============

### CL_LoadModel

*model_t * CL_LoadModel(const char * modelname, int * index)*

*Defined at line 2582 of ./engine/client/cl_game.cpp*

=============CL_LoadModel

=============

### pfnSPR_Load

*HSPRITE pfnSPR_Load(const char * szPicName)*

*Defined at line 1356 of ./engine/client/cl_game.cpp*

=========pfnSPR_Load

=========

### pfnSPR_LoadExt

*HSPRITE pfnSPR_LoadExt(const char * szPicName, uint texFlags)*

*Defined at line 1340 of ./engine/client/cl_game.cpp*

===============================================================================	CGame Builtin Functions

===============================================================================

=========pfnSPR_LoadExt

=========

### PicAdjustSize

*void PicAdjustSize(float * x, float * y, float * w, float * h)*

*Defined at line 409 of ./engine/client/cl_game.cpp*

====================PictAdjustSize

draw hudsprite routine====================

### CL_GetScreenInfo

*int CL_GetScreenInfo(SCREENINFO * pscrinfo)*

*Defined at line 1655 of ./engine/client/cl_game.cpp*

=============pfnGetScreenInfo

get actual screen info=============

### CL_FillRGBA

*void CL_FillRGBA(int x, int y, int width, int height, int r, int g, int b, int a)*

*Defined at line 1615 of ./engine/client/cl_game.cpp*

=============CL_FillRGBA

=============

### CL_PlayerTrace

*void CL_PlayerTrace(float * start, float * end, int traceFlags, int ignore_pe, pmtrace_t * tr)*

*Defined at line 2502 of ./engine/client/cl_game.cpp*

=============pfnPlayerTrace

=============

### CL_PlayerTraceExt

*void CL_PlayerTraceExt(float * start, float * end, int traceFlags, int (*)(physent_t *) pfnIgnore, pmtrace_t * tr)*

*Defined at line 2514 of ./engine/client/cl_game.cpp*

=============pfnPlayerTraceExt

=============

### CL_SetTraceHull

*void CL_SetTraceHull(int hull)*

*Defined at line 2490 of ./engine/client/cl_game.cpp*

=============pfnSetTraceHull

=============

### CL_GetMousePosition

*void CL_GetMousePosition(int * mx, int * my)*

### CL_GetViewModel

*cl_entity_t * CL_GetViewModel()*

*Defined at line 2104 of ./engine/client/cl_game.cpp*

=============pfnGetViewModel

=============

### pfnGetScreenFade

*void pfnGetScreenFade(struct screenfade_s * fade)*

*Defined at line 2655 of ./engine/client/cl_game.cpp*

=============pfnGetScreenFade

=============

### pfnGetPhysent

*physent_t * pfnGetPhysent(int idx)*

*Defined at line 2458 of ./engine/client/cl_game.cpp*

=============pfnGetPhysent

=============

### pfnTraceSurface

*struct msurface_s * pfnTraceSurface(int ground, float * vstart, float * vend)*

*Defined at line 2543 of ./engine/client/cl_game.cpp*

=============pfnTraceSurface

=============

### pfnGetMoveVars

*movevars_t * pfnGetMoveVars()*

*Defined at line 2560 of ./engine/client/cl_game.cpp*

=============pfnGetMovevars

=============

### CL_EDICT_NUM

*cl_entity_t * CL_EDICT_NUM(int n)*

*Defined at line 842 of ./engine/client/client.h*

### CL_ParseServerMessage

*void CL_ParseServerMessage(sizebuf_t * msg, qboolean normal_message)*

*Defined at line 2045 of ./engine/client/cl_parse.cpp*

 cl_parse.c

=====================================================================

ACTION MESSAGES

=====================================================================

=====================CL_ParseServerMessage

dispatch messages=====================

### CL_ParseLegacyServerMessage

*void CL_ParseLegacyServerMessage(sizebuf_t * msg, qboolean normal_message)*

*Defined at line 2841 of ./engine/client/cl_parse.cpp*

=====================CL_ParseLegacyServerMessage

dispatch messages=====================

### CL_LegacyPrecache_f

*void CL_LegacyPrecache_f()*

*Defined at line 3169 of ./engine/client/cl_parse.cpp*

### CL_ParseTempEntity

*void CL_ParseTempEntity(sizebuf_t * msg)*

*Defined at line 1904 of ./engine/client/cl_tent.cpp*

==============CL_ParseTempEntity

handle temp-entity messages==============

### CL_StartResourceDownloading

*void CL_StartResourceDownloading(const char * pszMessage, qboolean bCustom)*

*Defined at line 602 of ./engine/client/cl_parse.cpp*

### CL_DispatchUserMessage

*qboolean CL_DispatchUserMessage(const char * pszName, int iSize, void * pbuf)*

*Defined at line 1911 of ./engine/client/cl_parse.cpp*

==============CL_DispatchUserMessage

Dispatch user message by engine request==============

### CL_RequestMissingResources

*qboolean CL_RequestMissingResources()*

*Defined at line 434 of ./engine/client/cl_parse.cpp*

==================CL_RequestMissingResources

==================

### CL_RegisterResources

*void CL_RegisterResources(sizebuf_t * msg)*

*Defined at line 1521 of ./engine/client/cl_parse.cpp*

==================CL_RegisterResources

Clean up and move to next part of sequence.==================

### CL_ParseViewEntity

*void CL_ParseViewEntity(sizebuf_t * msg)*

*Defined at line 46 of ./engine/client/cl_parse.cpp*

==================CL_ParseViewEntity

==================

### CL_ParseServerTime

*void CL_ParseServerTime(sizebuf_t * msg)*

*Defined at line 185 of ./engine/client/cl_parse.cpp*

==================CL_ParseServerTime

==================

### SCR_VidInit

*void SCR_VidInit()*

*Defined at line 726 of ./engine/client/cl_scrn.cpp*

 cl_scrn.c

==================SCR_VidInit==================

### SCR_TileClear

*void SCR_TileClear()*

*Defined at line 415 of ./engine/client/cl_scrn.cpp*

================SCR_TileClear================

### SCR_DirtyScreen

*void SCR_DirtyScreen()*

*Defined at line 404 of ./engine/client/cl_scrn.cpp*

================SCR_DirtyScreen================

### SCR_AddDirtyPoint

*void SCR_AddDirtyPoint(int x, int y)*

*Defined at line 391 of ./engine/client/cl_scrn.cpp*

=================SCR_AddDirtyPoint=================

### SCR_InstallParticlePalette

*void SCR_InstallParticlePalette()*

*Defined at line 630 of ./engine/client/cl_scrn.cpp*

================SCR_InstallParticlePalette

INTERNAL RESOURCE================

### SCR_EndLoadingPlaque

*void SCR_EndLoadingPlaque()*

*Defined at line 379 of ./engine/client/cl_scrn.cpp*

================SCR_EndLoadingPlaque================

### SCR_RegisterTextures

*void SCR_RegisterTextures()*

*Defined at line 671 of ./engine/client/cl_scrn.cpp*

================SCR_RegisterTextures

INTERNAL RESOURCE================

### SCR_LoadCreditsFont

*void SCR_LoadCreditsFont()*

*Defined at line 603 of ./engine/client/cl_scrn.cpp*

================SCR_LoadCreditsFont

INTERNAL RESOURCE================

### SCR_MakeScreenShot

*void SCR_MakeScreenShot()*

*Defined at line 267 of ./engine/client/cl_scrn.cpp*

================SCR_MakeScreenShot

create a requested screenshot type================

### SCR_MakeLevelShot

*void SCR_MakeLevelShot()*

*Defined at line 220 of ./engine/client/cl_scrn.cpp*

================SCR_MakeLevelShot

creates levelshot at next frame================

### SCR_NetSpeeds

*void SCR_NetSpeeds()*

*Defined at line 111 of ./engine/client/cl_scrn.cpp*

==============SCR_NetSpeeds

same as r_speeds but for network channel==============

### SCR_RSpeeds

*void SCR_RSpeeds()*

*Defined at line 176 of ./engine/client/cl_scrn.cpp*

================SCR_RSpeeds================

### SCR_DrawFPS

*void SCR_DrawFPS(int height)*

*Defined at line 45 of ./engine/client/cl_scrn.cpp*

==============SCR_DrawFPS==============

### CL_InitNetgraph

*void CL_InitNetgraph()*

*Defined at line 668 of ./engine/client/cl_netgraph.cpp*

 cl_netgraph.c

### SCR_DrawNetGraph

*void SCR_DrawNetGraph()*

*Defined at line 627 of ./engine/client/cl_netgraph.cpp*

===========SCR_DrawNetGraph

===========

### V_Init

*void V_Init()*

*Defined at line 1584 of ./game/client/view.cpp*

 cl_view.c

=============V_Init=============

### V_Shutdown

*void V_Shutdown()*

### V_PreRender

*qboolean V_PreRender()*

*Defined at line 274 of ./engine/client/cl_view.cpp*

==================V_PreRender

==================

### V_PostRender

*void V_PostRender()*

*Defined at line 450 of ./engine/client/cl_view.cpp*

==================V_PostRender

==================

### V_RenderView

*void V_RenderView()*

*Defined at line 312 of ./engine/client/cl_view.cpp*

==================V_RenderView

==================

### CL_SetSolidEntities

*void CL_SetSolidEntities()*

*Defined at line 507 of ./engine/client/cl_pmove.cpp*

 cl_pmove.c

===============CL_SetSolidEntities

Builds all the pmove physents for the current frame===============

### CL_SetSolidPlayers

*void CL_SetSolidPlayers(int playernum)*

*Defined at line 541 of ./engine/client/cl_pmove.cpp*

===============CL_SetSolidPlayers

Builds all the pmove physents for the current frameNote that CL_SetUpPlayerPrediction() must be called first!pmove must be setup with world and solid entity hulls before calling(via CL_PredictMove)===============

### CL_InitClientMove

*void CL_InitClientMove()*

*Defined at line 896 of ./engine/client/cl_pmove.cpp*

===============CL_InitClientMove

===============

### CL_PredictMovement

*void CL_PredictMovement(qboolean repredicting)*

*Defined at line 1154 of ./engine/client/cl_pmove.cpp*

=================CL_PredictMovement

Sets cl.predicted.origin and cl.predicted.angles=================

### CL_CheckPredictionError

*void CL_CheckPredictionError()*

*Defined at line 230 of ./engine/client/cl_pmove.cpp*

===================CL_CheckPredictionError===================

### CL_IsPredicted

*qboolean CL_IsPredicted()*

*Defined at line 101 of ./engine/client/cl_pmove.cpp*

===============CL_IsPredicted===============

### CL_TruePointContents

*int CL_TruePointContents(const vec3_t p)*

### CL_WaterEntity

*int CL_WaterEntity(const float * rgflPos)*

*Defined at line 597 of ./engine/client/cl_pmove.cpp*

=============CL_WaterEntity

=============

### CL_GetWaterEntity

*cl_entity_t * CL_GetWaterEntity(const float * rgflPos)*

*Defined at line 692 of ./engine/client/cl_pmove.cpp*

=============CL_GetWaterEntity

returns water brush where inside pos=============

### CL_SetupPMove

*void CL_SetupPMove(playermove_t * pmove, local_state_t * from, usercmd_t * ucmd, qboolean runfuncs, double time)*

*Defined at line 965 of ./engine/client/cl_pmove.cpp*

### CL_TestLine

*int CL_TestLine(const vec3_t start, const vec3_t end, int flags)*

*Defined at line 702 of ./engine/client/cl_pmove.cpp*

### CL_VisTraceLine

*pmtrace_t * CL_VisTraceLine(vec3_t start, vec3_t end, int flags)*

*Defined at line 672 of ./engine/client/cl_pmove.cpp*

=============CL_VisTraceLine

trace by visible objects (thats can be non-solid)=============

### CL_TraceLine

*pmtrace_s CL_TraceLine(vec3_t start, vec3_t end, int flags)*

*Defined at line 652 of ./engine/client/cl_pmove.cpp*

=============CL_TraceLine

a simple engine traceline=============

### CL_PushTraceBounds

*void CL_PushTraceBounds(int hullnum, const float * mins, const float * maxs)*

*Defined at line 77 of ./engine/client/cl_pmove.cpp*

=============CL_PushTraceBounds

=============

### CL_PopTraceBounds

*void CL_PopTraceBounds()*

*Defined at line 90 of ./engine/client/cl_pmove.cpp*

=============CL_PopTraceBounds

=============

### CL_MoveSpectatorCamera

*void CL_MoveSpectatorCamera()*

*Defined at line 1130 of ./engine/client/cl_pmove.cpp*

=================CL_MoveSpectatorCamera

spectator movement code=================

### CL_SetLastUpdate

*void CL_SetLastUpdate()*

*Defined at line 117 of ./engine/client/cl_pmove.cpp*

===============CL_SetLastUpdate===============

### CL_RedoPrediction

*void CL_RedoPrediction()*

*Defined at line 127 of ./engine/client/cl_pmove.cpp*

===============CL_RedoPrediction===============

### CL_ClearPhysEnts

*void CL_ClearPhysEnts()*

*Defined at line 35 of ./engine/client/cl_pmove.cpp*

=============CL_ClearPhysEnts

=============

### CL_PushPMStates

*void CL_PushPMStates()*

*Defined at line 49 of ./engine/client/cl_pmove.cpp*

=============CL_PushPMStates

=============

### CL_PopPMStates

*void CL_PopPMStates()*

*Defined at line 63 of ./engine/client/cl_pmove.cpp*

=============CL_PopPMStates

=============

### CL_SetUpPlayerPrediction

*void CL_SetUpPlayerPrediction(int dopred, int bIncludeLocalClient)*

*Defined at line 283 of ./engine/client/cl_pmove.cpp*

=============CL_SetUpPlayerPrediction

Calculate the new position of players, without other player clippingWe do this to set up real player prediction.Players are predicted twice, first without clipping other players,then with clipping against them.This sets up the first phase.=============

### CL_ParseQuakeMessage

*void CL_ParseQuakeMessage(sizebuf_t * msg, qboolean normal_message)*

*Defined at line 896 of ./engine/client/cl_qparse.cpp*

 cl_qparse.c

==================CL_ParseQuakeMessage

==================

### CL_ParsePacketEntities

*int CL_ParsePacketEntities(sizebuf_t * msg, qboolean delta)*

*Defined at line 742 of ./engine/client/cl_frame.cpp*

==================CL_ParsePacketEntities

An svc_packetentities has just been parsed, deal with therest of the data stream.==================

### CL_AddVisibleEntity

*qboolean CL_AddVisibleEntity(cl_entity_t * ent, int entityType)*

*Defined at line 956 of ./engine/client/cl_frame.cpp*

==========================================================================

INTERPOLATE BETWEEN FRAMES TO GET RENDERING PARMS

==========================================================================

=============CL_AddVisibleEntity

all the visible entities should pass this filter=============

### CL_ResetLatchedVars

*void CL_ResetLatchedVars(cl_entity_t * ent, qboolean full_reset)*

*Defined at line 265 of ./engine/client/cl_frame.cpp*

====================CL_ResetLatchedVars

====================

### CL_GetEntitySpatialization

*qboolean CL_GetEntitySpatialization(struct channel_s * ch)*

*Defined at line 1350 of ./engine/client/cl_frame.cpp*

==========================================================================

SOUND ENGINE IMPLEMENTATION

==========================================================================

### CL_GetMovieSpatialization

*qboolean CL_GetMovieSpatialization(struct rawchan_s * ch)*

*Defined at line 1386 of ./engine/client/cl_frame.cpp*

### CL_ProcessPlayerState

*void CL_ProcessPlayerState(int playerindex, entity_state_t * state)*

*Defined at line 557 of ./engine/client/cl_frame.cpp*

=================CL_ProcessPlayerState

process player states after the new packet has received=================

### CL_ComputePlayerOrigin

*void CL_ComputePlayerOrigin(cl_entity_t * clent)*

*Defined at line 522 of ./engine/client/cl_frame.cpp*

=============CL_ComputePlayerOrigin

interpolate non-local clients=============

### CL_ProcessPacket

*void CL_ProcessPacket(frame_t * frame)*

*Defined at line 600 of ./engine/client/cl_frame.cpp*

=================CL_ProcessPacket

process player states after the new packet has received=================

### CL_MoveThirdpersonCamera

*void CL_MoveThirdpersonCamera()*

*Defined at line 1278 of ./engine/client/cl_frame.cpp*

===============CL_MoveThirdpersonCamera

think thirdperson===============

### CL_IsPlayerIndex

*qboolean CL_IsPlayerIndex(int idx)*

*Defined at line 36 of ./engine/client/cl_frame.cpp*

==================CL_IsPlayerIndex

detect player entity==================

### CL_SetIdealPitch

*void CL_SetIdealPitch()*

*Defined at line 141 of ./engine/client/cl_pmove.cpp*

===============CL_SetIdealPitch===============

### CL_EmitEntities

*void CL_EmitEntities()*

*Defined at line 1295 of ./engine/client/cl_frame.cpp*

===============CL_EmitEntities

add visible entities to refresh listprocess frame interpolation etc===============

### CL_GetRemapInfoForEntity

*remap_info_t * CL_GetRemapInfoForEntity(cl_entity_t * e)*

*Defined at line 27 of ./engine/client/cl_remap.cpp*

 cl_remap.c

====================CL_GetRemapInfoForEntity

Returns remapinfo slot for specified entity====================

### CL_AllocRemapInfo

*void CL_AllocRemapInfo(int topcolor, int bottomcolor)*

*Defined at line 245 of ./engine/client/cl_remap.cpp*

====================CL_AllocRemapInfo

Allocate new remap info per entityand make copy of remap textures====================

### CL_FreeRemapInfo

*void CL_FreeRemapInfo(remap_info_t * info)*

*Defined at line 394 of ./engine/client/cl_remap.cpp*

====================CL_FreeRemapInfo

Release remap info per entity====================

### CL_UpdateRemapInfo

*void CL_UpdateRemapInfo(int topcolor, int bottomcolor)*

*Defined at line 361 of ./engine/client/cl_remap.cpp*

====================CL_UpdateRemapInfo

Update all remaps per entity====================

### CL_ClearAllRemaps

*void CL_ClearAllRemaps()*

*Defined at line 423 of ./engine/client/cl_remap.cpp*

====================CL_ClearAllRemaps

Release all remap infos====================

### R_InitRenderAPI

*qboolean R_InitRenderAPI()*

*Defined at line 323 of ./engine/client/cl_render.cpp*

 cl_render.c

===============R_InitRenderAPI

Initialize client external rendering===============

### CL_RenderGetParm

*int CL_RenderGetParm(const int parm, const int arg, const qboolean checkRef)*

*Defined at line 138 of ./engine/client/cl_render.cpp*

### CL_GetLightStyle

*lightstyle_t * CL_GetLightStyle(int number)*

*Defined at line 28 of ./engine/client/cl_render.cpp*

### R_FatPVS

*int R_FatPVS(const vec3_t org, float radius, byte * visbuffer, qboolean merge, qboolean fullvis)*

*Defined at line 23 of ./engine/client/cl_render.cpp*

### GL_GetOverviewParms

*const ref_overview_t * GL_GetOverviewParms()*

*Defined at line 34 of ./engine/client/cl_render.cpp*

### R_StoreEfrags

*void R_StoreEfrags(efrag_t ** ppefrag, int framecount)*

*Defined at line 174 of ./engine/client/cl_efrag.cpp*

 cl_efrag.c

================R_StoreEfrags

================

### CL_AddEntity

*int CL_AddEntity(int entityType, cl_entity_t * pEnt)*

*Defined at line 2596 of ./engine/client/cl_game.cpp*

### CL_WeaponAnim

*void CL_WeaponAnim(int iAnim, int body)*

*Defined at line 364 of ./engine/client/cl_parse.cpp*

==================CL_WeaponAnim

Set new weapon animation==================

### CL_ClearEffects

*void CL_ClearEffects()*

*Defined at line 3041 of ./engine/client/cl_tent.cpp*

==============CL_ClearEffects==============

### CL_ClearEfrags

*void CL_ClearEfrags()*

*Defined at line 3000 of ./engine/client/cl_tent.cpp*

==============CL_ClearEfrags==============

### CL_TestLights

*void CL_TestLights()*

*Defined at line 2836 of ./engine/client/cl_tent.cpp*

================CL_TestLights

if cl_testlights is set, create 32 lights models================

### CL_FireCustomDecal

*void CL_FireCustomDecal(int textureIndex, int entityIndex, int modelIndex, float * pos, int flags, float scale)*

*Defined at line 2881 of ./engine/client/cl_tent.cpp*

==============================================================

DECAL MANAGEMENT

==============================================================

===============CL_FireCustomDecal

custom temporary decal===============

### CL_PlayerDecal

*void CL_PlayerDecal(int playerIndex, int textureIndex, int entityIndex, float * pos)*

*Defined at line 2905 of ./engine/client/cl_tent.cpp*

===============CL_PlayerDecal

spray custom colored decal (clan logo etc)===============

### R_FreeDeadParticles

*void R_FreeDeadParticles(struct particle_s ** ppparticles)*

*Defined at line 1949 of ./engine/client/cl_efx.cpp*

==============R_FreeDeadParticles

Free particles that time has expired==============

### CL_AddClientResource

*void CL_AddClientResource(const char * filename, int type)*

*Defined at line 116 of ./engine/client/cl_tent.cpp*

================CL_AddClientResource

add client-side resource to list================

### CL_AddClientResources

*void CL_AddClientResources()*

*Defined at line 147 of ./engine/client/cl_tent.cpp*

================CL_AddClientResources

client resources not precached by server================

### CL_InitParticles

*void CL_InitParticles()*

*Defined at line 88 of ./engine/client/cl_efx.cpp*

================CL_InitParticles

================

### CL_ClearParticles

*void CL_ClearParticles()*

*Defined at line 114 of ./engine/client/cl_efx.cpp*

================CL_ClearParticles

================

### CL_FreeParticles

*void CL_FreeParticles()*

*Defined at line 136 of ./engine/client/cl_efx.cpp*

================CL_FreeParticles

================

### CL_InitTempEnts

*void CL_InitTempEnts()*

*Defined at line 206 of ./engine/client/cl_tent.cpp*

================CL_InitTempents

================

### CL_ClearTempEnts

*void CL_ClearTempEnts()*

*Defined at line 221 of ./engine/client/cl_tent.cpp*

================CL_ClearTempEnts

================

### CL_FreeTempEnts

*void CL_FreeTempEnts()*

*Defined at line 244 of ./engine/client/cl_tent.cpp*

================CL_FreeTempEnts

================

### CL_TempEntUpdate

*void CL_TempEntUpdate()*

*Defined at line 420 of ./engine/client/cl_tent.cpp*

==============CL_AddTempEnts

temp-entities will be added on a user-sidesetup client callback==============

### CL_InitViewBeams

*void CL_InitViewBeams()*

*Defined at line 363 of ./engine/client/cl_efx.cpp*

================CL_InitViewBeams

================

### CL_ClearViewBeams

*void CL_ClearViewBeams()*

*Defined at line 375 of ./engine/client/cl_efx.cpp*

================CL_ClearViewBeams

================

### CL_FreeViewBeams

*void CL_FreeViewBeams()*

*Defined at line 396 of ./engine/client/cl_efx.cpp*

================CL_FreeViewBeams

================

### R_BeamGetEntity

*cl_entity_t * R_BeamGetEntity(int index)*

*Defined at line 411 of ./engine/client/cl_efx.cpp*

==============R_BeamGetEntity

extract entity number from indexhandle user entities==============

### CL_KillDeadBeams

*void CL_KillDeadBeams(cl_entity_t * pDeadEntity)*

*Defined at line 424 of ./engine/client/cl_efx.cpp*

==============CL_KillDeadBeams

==============

### CL_ParseViewBeam

*void CL_ParseViewBeam(sizebuf_t * msg, int beamType)*

*Defined at line 674 of ./engine/client/cl_efx.cpp*

==============CL_ParseViewBeam

handle beam messages==============

### CL_LoadClientSprites

*void CL_LoadClientSprites()*

*Defined at line 97 of ./engine/client/cl_tent.cpp*

================CL_LoadClientSprites

INTERNAL RESOURCE================

### CL_ReadPointFile_f

*void CL_ReadPointFile_f()*

*Defined at line 1997 of ./engine/client/cl_efx.cpp*

===============CL_ReadPointFile_f

===============

### CL_DrawEFX

*void CL_DrawEFX(float time, qboolean fTrans)*

*Defined at line 2091 of ./engine/client/cl_efx.cpp*

### CL_ThinkParticle

*void CL_ThinkParticle(double frametime, particle_t * p)*

*Defined at line 2108 of ./engine/client/cl_efx.cpp*

### CL_ReadLineFile_f

*void CL_ReadLineFile_f()*

*Defined at line 489 of ./engine/client/cl_efx.cpp*

===============CL_ReadLineFile_f

Optimized version of pointfile - use beams instead of particles===============

### Con_Visible

*int Con_Visible()*

*Defined at line 523 of ./engine/client/console.cpp*

================Con_Visible================

### Con_FixedFont

*qboolean Con_FixedFont()*

*Defined at line 533 of ./engine/client/console.cpp*

================Con_FixedFont================

### Con_VidInit

*void Con_VidInit()*

*Defined at line 2358 of ./engine/client/console.cpp*

=========Con_VidInit

INTERNAL RESOURCE=========

### Con_Shutdown

*void Con_Shutdown()*

*Defined at line 1203 of ./engine/client/console.cpp*

================Con_Shutdown================

### Con_ToggleConsole_f

*void Con_ToggleConsole_f()*

*Defined at line 260 of ./engine/client/console.cpp*

================Con_ToggleConsole_f================

### Con_ClearNotify

*void Con_ClearNotify()*

*Defined at line 176 of ./engine/client/console.cpp*

================Con_ClearNotify================

### Con_DrawDebug

*void Con_DrawDebug()*

*Defined at line 1932 of ./engine/client/console.cpp*

================Con_DrawDebug

Draws the debug messages (not passed to console history)================

### Con_RunConsole

*void Con_RunConsole()*

*Defined at line 2271 of ./engine/client/console.cpp*

==================Con_RunConsole

Scroll it up or down==================

### Con_DrawConsole

*void Con_DrawConsole()*

*Defined at line 2156 of ./engine/client/console.cpp*

==================Con_DrawConsole==================

### Con_DrawVersion

*void Con_DrawVersion()*

*Defined at line 2225 of ./engine/client/console.cpp*

==================Con_DrawVersion

Used by menu==================

### Con_UtfProcessCharForce

*int Con_UtfProcessCharForce(int in)*

*Defined at line 700 of ./engine/client/console.cpp*

============================Con_UtfProcessChar

Convert utf char to current font's single-byte encoding============================

### Con_UtfMoveLeft

*int Con_UtfMoveLeft(char * str, int pos)*

*Defined at line 787 of ./engine/client/console.cpp*

=================Con_UtfMoveLeft

get position of previous printful char=================

### Con_UtfMoveRight

*int Con_UtfMoveRight(char * str, int pos, int length)*

*Defined at line 809 of ./engine/client/console.cpp*

=================Con_UtfMoveRight

get next of previous printful char=================

### Con_DrawStringLen

*void Con_DrawStringLen(const char * pText, int * length, int * height)*

*Defined at line 982 of ./engine/client/console.cpp*

====================Con_DrawStringLen

compute string width and height in screen pixels====================

### Con_DrawString

*int Con_DrawString(int x, int y, const char * string, rgba_t setColor)*

*Defined at line 1090 of ./engine/client/console.cpp*

====================Con_DrawString

client version of routine====================

### Con_DrawCharacter

*int Con_DrawCharacter(int x, int y, int number, rgba_t color)*

*Defined at line 956 of ./engine/client/console.cpp*

====================Con_DrawCharacter

client version of routine====================

### Con_DrawCharacterLen

*void Con_DrawCharacterLen(int number, int * width, int * height)*

*Defined at line 969 of ./engine/client/console.cpp*

====================Con_DrawCharacterLen

returns character sizes in screen pixels====================

### Con_DefaultColor

*void Con_DefaultColor(int r, int g, int b)*

*Defined at line 2474 of ./engine/client/console.cpp*

=========Con_DefaultColor

called from MainUI=========

### Con_InvalidateFonts

*void Con_InvalidateFonts()*

*Defined at line 2446 of ./engine/client/console.cpp*

=========Con_InvalidateFonts

=========

### Con_SetFont

*void Con_SetFont(int fontNum)*

*Defined at line 930 of ./engine/client/console.cpp*

====================Con_SetFont

choose font size====================

### Con_CharEvent

*void Con_CharEvent(int key)*

*Defined at line 2338 of ./engine/client/console.cpp*

==============================================================================

CONSOLE INTERFACE

==============================================================================

================Con_CharEvent

Console input================

### Con_RestoreFont

*void Con_RestoreFont()*

*Defined at line 944 of ./engine/client/console.cpp*

====================Con_RestoreFont

restore auto-selected console font(that based on screen resolution)====================

### Key_Console

*void Key_Console(int key)*

*Defined at line 1700 of ./engine/client/console.cpp*

=============================================================================

CONSOLE LINE EDITING

==============================================================================

====================Key_Console

Handles history and console scrollback====================

### Key_Message

*void Key_Message(int key)*

*Defined at line 1833 of ./engine/client/console.cpp*

================Key_Message

In game talk message================

### Con_FastClose

*void Con_FastClose()*

*Defined at line 2459 of ./engine/client/console.cpp*

=========Con_FastClose

immediately close the console=========

### Con_Bottom

*void Con_Bottom()*

*Defined at line 513 of ./engine/client/console.cpp*

================Con_Bottom================

### Con_Top

*void Con_Top()*

*Defined at line 503 of ./engine/client/console.cpp*

================Con_Top================

### Con_PageDown

*void Con_PageDown(int lines)*

*Defined at line 493 of ./engine/client/console.cpp*

================Con_PageDown================

### Con_PageUp

*void Con_PageUp(int lines)*

*Defined at line 483 of ./engine/client/console.cpp*

================Con_PageUp================

### Con_LoadHistory

*void Con_LoadHistory()*

*Defined at line 1095 of ./engine/client/console.cpp*

### S_StreamRawSamples

*void S_StreamRawSamples(int samples, int rate, int width, int channels, const byte * data)*

 s_main.c

### S_StreamAviSamples

*void S_StreamAviSamples(void * Avi, int entnum, float fvol, float attn, float synctime)*

*Defined at line 1163 of ./engine/client/s_main.cpp*

===================S_PositionedRawSamples===================

### S_StartBackgroundTrack

*void S_StartBackgroundTrack(const char * intro, const char * loop, int position, qboolean fullpath)*

*Defined at line 74 of ./engine/client/s_stream.cpp*

=================S_StartBackgroundTrack=================

### S_StreamSetPause

*void S_StreamSetPause(int pause)*

*Defined at line 132 of ./engine/client/s_stream.cpp*

=================S_StreamSetPause=================

### S_StartStreaming

*void S_StartStreaming()*

*Defined at line 265 of ./engine/client/s_stream.cpp*

=================S_StartStreaming=================

### S_StopStreaming

*void S_StopStreaming()*

*Defined at line 277 of ./engine/client/s_stream.cpp*

=================S_StopStreaming=================

### S_BeginRegistration

*void S_BeginRegistration()*

*Defined at line 269 of ./engine/client/s_load.cpp*

=====================S_BeginRegistration

=====================

### S_RegisterSound

*sound_t S_RegisterSound(const char * sample)*

*Defined at line 329 of ./engine/client/s_load.cpp*

==================S_RegisterSound

==================

### S_EndRegistration

*void S_EndRegistration()*

*Defined at line 295 of ./engine/client/s_load.cpp*

=====================S_EndRegistration

=====================

### S_RestoreSound

*void S_RestoreSound(const vec3_t pos, int ent, int chan, sound_t handle, float fvol, float attn, int pitch, int flags, double sample, double end, int wordIndex)*

*Defined at line 618 of ./engine/client/s_main.cpp*

====================S_RestoreSound

Restore a sound effect for the given entity on the given channel====================

### S_StartSound

*void S_StartSound(const vec3_t pos, int ent, int chan, sound_t sfx, float vol, float attn, int pitch, int flags)*

*Defined at line 491 of ./engine/client/s_main.cpp*

====================S_StartSound

Start a sound effect for the given entity on the given channel (ie; voice, weapon etc).  Try to grab a channel out of the 8 dynamic spots available.Currently used for looping sounds, streaming sounds, sentences, and regular entity sounds.NOTE: volume is 0.0 - 1.0 and attenuation is 0.0 - 1.0 when passed in.Pitch changes playback pitch of wave by % above or below 100.  Ignored if pitch == 100

NOTE: it's not a good idea to play looping sounds through StartDynamicSound, becauseif the looping sound starts out of range, or is bumped from the buffer by another soundit will never be restarted.  Use StartStaticSound (pass CHAN_STATIC to EMIT_SOUND orSV_StartSound.====================

### S_AmbientSound

*void S_AmbientSound(const vec3_t pos, int ent, sound_t handle, float fvol, float attn, int pitch, int flags)*

*Defined at line 731 of ./engine/client/s_main.cpp*

=================S_AmbientSound

Start playback of a sound, loaded into the static portion of the channel array.Currently, this should be used for looping ambient sounds, looping soundsthat should not be interrupted until complete, non-creature sentences,and one-shot ambient streaming sounds.  Can also play 'regular' sounds one-shot,in case designers want to trigger regular game sounds.Pitch changes playback pitch of wave by % above or below 100.  Ignored if pitch == 100

NOTE: volume is 0.0 - 1.0 and attenuation is 0.0 - 1.0 when passed in.=================

### S_FadeClientVolume

*void S_FadeClientVolume(float fadePercent, float fadeOutSeconds, float holdTime, float fadeInSeconds)*

*Defined at line 79 of ./engine/client/s_main.cpp*

=================S_FadeClientVolume=================

### S_FadeMusicVolume

*void S_FadeMusicVolume(float fadePercent)*

*Defined at line 46 of ./engine/client/s_stream.cpp*

=================S_FadeMusicVolume=================

### S_StartLocalSound

*void S_StartLocalSound(const char * name, float volume, qboolean reliable)*

*Defined at line 807 of ./engine/client/s_main.cpp*

==================S_StartLocalSound==================

### SND_UpdateSound

*void SND_UpdateSound()*

*Defined at line 1524 of ./engine/client/s_main.cpp*

============SND_UpdateSound

Called once each time through the main loop============

### S_ExtraUpdate

*void S_ExtraUpdate()*

*Defined at line 1494 of ./engine/client/s_main.cpp*

=================S_ExtraUpdate

Don't let sound skip if going slow=================

### UI_UnloadProgs

*void UI_UnloadProgs()*

*Defined at line 1226 of ./engine/client/cl_gameui.cpp*

 cl_gameui.c

### UI_LoadProgs

*qboolean UI_LoadProgs()*

*Defined at line 1243 of ./engine/client/cl_gameui.cpp*

### UI_ResetPing

*void UI_ResetPing()*

*Defined at line 160 of ./engine/client/cl_gameui.cpp*

=================UI_ResetPing

notify gameui dll about latency reset=================

### UI_ShowUpdateDialog

*void UI_ShowUpdateDialog(qboolean preferStore)*

*Defined at line 202 of ./engine/client/cl_gameui.cpp*

=================UI_ShowConnectionWarning

show update dialog=================

### UI_AddTouchButtonToList

*void UI_AddTouchButtonToList(const char * name, const char * texture, const char * command, unsigned char * color, int flags)*

*Defined at line 145 of ./engine/client/cl_gameui.cpp*

=======================UI_AddTouchButtonToList

send button parameters to menu=======================

### UI_ConnectionProgress_Download

*void UI_ConnectionProgress_Download(const char * pszFileName, const char * pszServerName, const char * pszServerPath, int iCurrent, int iTotal, const char * comment)*

*Defined at line 235 of ./engine/client/cl_gameui.cpp*

### pfnPIC_Set

*void pfnPIC_Set(HIMAGE hPic, int r, int g, int b, int a)*

*Defined at line 588 of ./engine/client/cl_gameui.cpp*

=========pfnPIC_Set

=========

### pfnPIC_Draw

*void pfnPIC_Draw(int x, int y, int width, int height, const wrect_t * prc)*

*Defined at line 604 of ./engine/client/cl_gameui.cpp*

=========pfnPIC_Draw

=========

### pfnPIC_DrawTrans

*void pfnPIC_DrawTrans(int x, int y, int width, int height, const wrect_t * prc)*

*Defined at line 616 of ./engine/client/cl_gameui.cpp*

=========pfnPIC_DrawTrans

=========

### pfnPIC_DrawHoles

*void pfnPIC_DrawHoles(int x, int y, int width, int height, const wrect_t * prc)*

*Defined at line 628 of ./engine/client/cl_gameui.cpp*

=========pfnPIC_DrawHoles

=========

### pfnPIC_DrawAdditive

*void pfnPIC_DrawAdditive(int x, int y, int width, int height, const wrect_t * prc)*

*Defined at line 640 of ./engine/client/cl_gameui.cpp*

=========pfnPIC_DrawAdditive

=========

### Mobile_Init

*qboolean Mobile_Init()*

*Defined at line 116 of ./engine/client/cl_mobile.cpp*

 cl_mobile.c

### Mobile_Shutdown

*void Mobile_Shutdown()*

*Defined at line 136 of ./engine/client/cl_mobile.cpp*

### SCR_InitCinematic

*void SCR_InitCinematic()*

*Defined at line 287 of ./engine/client/cl_video.cpp*

 cl_video.c

==================SCR_InitCinematic==================

### SCR_FreeCinematic

*void SCR_FreeCinematic()*

*Defined at line 298 of ./engine/client/cl_video.cpp*

==================SCR_FreeCinematic==================

### SCR_PlayCinematic

*qboolean SCR_PlayCinematic(const char * name)*

*Defined at line 203 of ./engine/client/cl_video.cpp*

==================SCR_PlayCinematic==================

### SCR_DrawCinematic

*qboolean SCR_DrawCinematic()*

*Defined at line 177 of ./engine/client/cl_video.cpp*

==================SCR_DrawCinematic

Returns true if a cinematic is active, meaning the view renderingshould be skipped==================

### SCR_NextMovie

*qboolean SCR_NextMovie()*

*Defined at line 42 of ./engine/client/cl_video.cpp*

==================SCR_NextMovie

Called when a demo or cinematic finishesIf the "nextmovie" cvar is set, that command will be issued==================

### SCR_RunCinematic

*void SCR_RunCinematic()*

*Defined at line 131 of ./engine/client/cl_video.cpp*

==================SCR_RunCinematic==================

### SCR_StopCinematic

*void SCR_StopCinematic()*

*Defined at line 267 of ./engine/client/cl_video.cpp*

==================SCR_StopCinematic==================

### CL_PlayVideo_f

*void CL_PlayVideo_f()*

*Defined at line 26 of ./engine/client/cl_cmds.cpp*

====================CL_PlayVideo_f

movie <moviename>====================

### SV_FinalMessage

*void SV_FinalMessage(const char * message, qboolean reconnect)*

*Defined at line 965 of ./engine/server/sv_main.cpp*

==================SV_FinalMessage

Used by SV_Shutdown to send a final message to allconnected clients before the server goes down.  The messages are sent immediately,not just stuck on the outgoing message list, because the server is goingto totally exit after returning from this function.==================

===========================================================

 sv_main.c

### SV_DropClient

*void SV_DropClient(sv_client_t * cl, qboolean crash)*

*Defined at line 538 of ./engine/server/sv_client.cpp*

=====================SV_DropClient

Called when the player is totally leaving the server, either willinglyor unwillingly.  This is NOT called if the entire server is quitingor crashing.=====================

### SV_UpdateMovevars

*void SV_UpdateMovevars(qboolean initialize)*

*Defined at line 159 of ./engine/server/sv_main.cpp*

===================SV_UpdateMovevars

check movevars for changes every framesend updates to client if changed===================

### SV_ModelIndex

*int SV_ModelIndex(const char * name)*

*Defined at line 91 of ./engine/server/sv_init.cpp*

================SV_ModelIndex

register unique model for a server and client================

### SV_SoundIndex

*int SV_SoundIndex(const char * name)*

*Defined at line 136 of ./engine/server/sv_init.cpp*

================SV_SoundIndex

register unique sound for client================

### SV_EventIndex

*int SV_EventIndex(const char * name)*

*Defined at line 187 of ./engine/server/sv_init.cpp*

================SV_EventIndex

register network event for a server and client================

### SV_GenericIndex

*int SV_GenericIndex(const char * name)*

*Defined at line 229 of ./engine/server/sv_init.cpp*

================SV_GenericIndex

register generic resourse for a server and client================

### SV_CalcPacketLoss

*int SV_CalcPacketLoss(sv_client_t * cl)*

### SV_ExecuteUserCommand

*void SV_ExecuteUserCommand(char * s)*

### SV_InitOperatorCommands

*void SV_InitOperatorCommands()*

*Defined at line 964 of ./engine/server/sv_cmds.cpp*

==================SV_InitOperatorCommands==================

### SV_KillOperatorCommands

*void SV_KillOperatorCommands()*

*Defined at line 999 of ./engine/server/sv_cmds.cpp*

==================SV_KillOperatorCommands==================

### SV_UserinfoChanged

*void SV_UserinfoChanged(sv_client_t * cl)*

*Defined at line 1677 of ./engine/server/sv_client.cpp*

=================SV_UserinfoChanged

Pull specific info from a newly changed userinfo stringinto a more C freindly form.=================

### SV_RemoteCommand

*void SV_RemoteCommand(netadr_s from, sizebuf_t * msg)*

*Defined at line 973 of ./engine/server/sv_client.cpp*

===============SV_RemoteCommand

A client issued an rcon command.Shift down the remaining argsRedirect all printfs===============

### SV_PrepWorldFrame

*void SV_PrepWorldFrame()*

*Defined at line 521 of ./engine/server/sv_main.cpp*

================SV_PrepWorldFrame

This has to be done before the world logic, becauseplayer processing happens outside RunWorldFrame================

### SV_ProcessFile

*void SV_ProcessFile(sv_client_t * cl, const char * filename)*

*Defined at line 279 of ./engine/server/sv_main.cpp*

=================SV_ProcessFile

process incoming file (customization)=================

### SV_SendResource

*void SV_SendResource(resource_t * pResource, sizebuf_t * msg)*

*Defined at line 534 of ./engine/server/sv_custom.cpp*

### SV_SendResourceList

*void SV_SendResourceList(sv_client_t * cl)*

### SV_AddToMaster

*void SV_AddToMaster(netadr_s from, sizebuf_t * msg)*

*Defined at line 733 of ./engine/server/sv_main.cpp*

=================SV_AddToMaster

A server info answer to master server.Master will validate challenge and this server to public list=================

### SV_ProcessUserAgent

*qboolean SV_ProcessUserAgent(netadr_s from, const char * useragent)*

*Defined at line 781 of ./engine/server/sv_main.cpp*

====================SV_ProcessUserAgent

send error message and return false on wrong input devices====================

### Host_SetServerState

*void Host_SetServerState(int state)*

*Defined at line 658 of ./engine/server/sv_main.cpp*

==================Host_SetServerState==================

### SV_IsSimulating

*qboolean SV_IsSimulating()*

*Defined at line 543 of ./engine/server/sv_main.cpp*

=================SV_IsSimulating=================

### SV_InitGame

*qboolean SV_InitGame()*

*Defined at line 673 of ./engine/server/sv_init.cpp*

==============SV_InitGame

A brand new game has been started==============

### SV_FreeClients

*void SV_FreeClients()*

*Defined at line 1012 of ./engine/server/sv_main.cpp*

================SV_FreeClients

release server clients================

### Master_Add

*void Master_Add()*

*Defined at line 671 of ./engine/server/sv_main.cpp*

=================Master_Add=================

### Master_Heartbeat

*void Master_Heartbeat()*

*Defined at line 690 of ./engine/server/sv_main.cpp*

================Master_Heartbeat

Send a message to the master every few minutes tolet it know we are alive, and log information================

### Master_Packet

*void Master_Packet()*

### SV_ActivateServer

*void SV_ActivateServer(int runPhysics)*

*Defined at line 521 of ./engine/server/sv_init.cpp*

 sv_init.c

================SV_ActivateServer

activate server on changed map, run physics================

### SV_SpawnServer

*qboolean SV_SpawnServer(const char * server, const char * startspot, qboolean background)*

*Defined at line 859 of ./engine/server/sv_init.cpp*

================SV_SpawnServer

Change the server to a new map, taking all connectedclients along with it.================

### SV_ModelHandle

*model_t * SV_ModelHandle(int modelindex)*

*Defined at line 271 of ./engine/server/sv_init.cpp*

================SV_ModelHandle

get model by handle================

### SV_DeactivateServer

*void SV_DeactivateServer()*

*Defined at line 633 of ./engine/server/sv_init.cpp*

================SV_DeactivateServer

deactivate server, free edicts, strings etc================

### SV_Physics

*void SV_Physics()*

*Defined at line 1777 of ./engine/server/sv_phys.cpp*

 sv_phys.c

================SV_Physics

================

### SV_InitPhysicsAPI

*qboolean SV_InitPhysicsAPI()*

*Defined at line 2064 of ./engine/server/sv_phys.cpp*

===============SV_InitPhysicsAPI

Initialize server external physics===============

### SV_CheckVelocity

*void SV_CheckVelocity(edict_t * ent)*

*Defined at line 120 of ./engine/server/sv_phys.cpp*

================SV_CheckVelocity================

### SV_CheckWater

*qboolean SV_CheckWater(edict_t * ent)*

*Defined at line 425 of ./engine/server/sv_phys.cpp*

=============SV_CheckWater=============

### SV_RunThink

*qboolean SV_RunThink(edict_t * ent)*

*Defined at line 196 of ./engine/server/sv_phys.cpp*

=============SV_RunThink

Runs thinking code if time.  There is some play in the exact time the thinkfunction will be called, because it is called before any movement is donein a frame.  Not used for pushmove objects, because they must be exact.Returns false if the entity removed itself.=============

### SV_PlayerRunThink

*qboolean SV_PlayerRunThink(edict_t * ent, float frametime, double time)*

*Defined at line 231 of ./engine/server/sv_phys.cpp*

=============SV_PlayerRunThink

Runs thinking code if player time.  There is some play in the exact time the thinkfunction will be called, because it is called before any movement is donein a frame.  Not used for pushmove objects, because they must be exact.Returns false if the entity removed itself.=============

### SV_TestEntityPosition

*qboolean SV_TestEntityPosition(edict_t * ent, edict_t * blocker)*

*Defined at line 822 of ./engine/server/sv_world.cpp*

============SV_TestEntityPosition

returns true if the entity is in solid currently============

### SV_Impact

*void SV_Impact(edict_t * e1, edict_t * e2, trace_t * trace)*

*Defined at line 267 of ./engine/server/sv_phys.cpp*

==================SV_Impact

Two entities have touched, so run their touch functions==================

### SV_CanPushed

*qboolean SV_CanPushed(edict_t * ent)*

*Defined at line 844 of ./engine/server/sv_phys.cpp*

============SV_CanPushed

filter entities for push============

### SV_FreeOldEntities

*void SV_FreeOldEntities()*

*Defined at line 496 of ./engine/server/sv_init.cpp*

================SV_FreeOldEntities

remove immediate entities================

### SV_CheckAllEnts

*void SV_CheckAllEnts()*

*Defined at line 68 of ./engine/server/sv_phys.cpp*

===============================================================================

Utility functions

===============================================================================

================SV_CheckAllEnts================

### SV_MoveStep

*qboolean SV_MoveStep(edict_t * ent, vec3_t move, qboolean relink)*

*Defined at line 254 of ./engine/server/sv_move.cpp*

 sv_move.c

============================================================================

### SV_MoveTest

*qboolean SV_MoveTest(edict_t * ent, vec3_t move, qboolean relink)*

*Defined at line 366 of ./engine/server/sv_move.cpp*

### SV_MoveToOrigin

*void SV_MoveToOrigin(edict_t * ed, const vec3_t goal, float dist, int iMode)*

*Defined at line 544 of ./engine/server/sv_move.cpp*

### SV_CheckBottom

*qboolean SV_CheckBottom(edict_t * ent, int iMode)*

*Defined at line 34 of ./engine/server/sv_move.cpp*

=============SV_CheckBottom

Returns false if any part of the bottom of the entity is off an edge thatis not a staircase.

=============

### SV_VecToYaw

*float SV_VecToYaw(const vec3_t src)*

*Defined at line 234 of ./engine/server/sv_move.cpp*

=============SV_VecToYaw

converts dir to yaw=============

### SV_WaterMove

*void SV_WaterMove(edict_t * ent)*

*Defined at line 106 of ./engine/server/sv_move.cpp*

### SV_SendClientMessages

*void SV_SendClientMessages()*

*Defined at line 838 of ./engine/server/sv_frame.cpp*

 sv_send.c

=======================SV_SendClientMessages=======================

### SV_ClientPrintf

*void SV_ClientPrintf(sv_client_t * cl, char * fmt)*

*Defined at line 28 of ./engine/server/sv_cmds.cpp*

=================SV_ClientPrintf

Sends text across to be displayed if the level passes=================

### SV_StatusString

*char * SV_StatusString()*

 sv_client.c

### SV_RefreshUserinfo

*void SV_RefreshUserinfo()*

*Defined at line 1182 of ./engine/server/sv_client.cpp*

===================SV_RefreshUserinfo

===================

### SV_GetChallenge

*void SV_GetChallenge(netadr_s from)*

*Defined at line 56 of ./engine/server/sv_client.cpp*

=================SV_GetChallenge

Returns a challenge number that can be usedin a subsequent client_connect command.We do this to prevent denial of service attacks thatflood the server with invalid connection IPs.  With achallenge, they must give a valid IP address.=================

### SV_TogglePause

*void SV_TogglePause(const char * msg)*

*Defined at line 1427 of ./engine/server/sv_client.cpp*

==================SV_TogglePause==================

### SV_ShouldUpdatePing

*qboolean SV_ShouldUpdatePing(sv_client_t * cl)*

*Defined at line 1218 of ./engine/server/sv_client.cpp*

===================SV_ShouldUpdatePing

determine should we recalculateping times now===================

### SV_GetClientIDString

*const char * SV_GetClientIDString(sv_client_t * cl)*

*Defined at line 663 of ./engine/server/sv_client.cpp*

===============SV_GetClientIDString

Returns a pointer to a static char for most likely only printing.===============

### SV_ClientById

*sv_client_t * SV_ClientById(int id)*

*Defined at line 689 of ./engine/server/sv_client.cpp*

### SV_ClientByName

*sv_client_t * SV_ClientByName(const char * name)*

*Defined at line 708 of ./engine/server/sv_client.cpp*

### SV_ClientByEdict

*sv_client_t * SV_ClientByEdict(edict_t * edict)*

*Defined at line 727 of ./engine/server/sv_client.cpp*

### SV_FullClientUpdate

*void SV_FullClientUpdate(sv_client_t * cl, sizebuf_t * msg)*

*Defined at line 1141 of ./engine/server/sv_client.cpp*

===================SV_FullClientUpdate

Writes all update values to a bitbuf===================

### SV_FullUpdateMovevars

*void SV_FullUpdateMovevars(sv_client_t * cl, sizebuf_t * msg)*

*Defined at line 1202 of ./engine/server/sv_client.cpp*

===================SV_FullUpdateMovevars

this is send all movevars values when client connectedotherwise see code SV_UpdateMovevars()===================

### SV_GetPlayerStats

*void SV_GetPlayerStats(sv_client_t * cl, int * ping, int * packet_loss)*

*Defined at line 1255 of ./engine/server/sv_client.cpp*

===================SV_GetPlayerStats

This function and its static vars track some of the networkingconditions.  I haven't bothered to trace it beyond that, becausethis fucntion sucks pretty badly.===================

### SV_SendServerdata

*void SV_SendServerdata(sizebuf_t * msg, sv_client_t * cl)*

*Defined at line 1483 of ./engine/server/sv_client.cpp*

================SV_SendServerdata

Sends the first message from the server to a connected client.This will be sent on the initial connection and upon each server load.================

### SV_ClientThink

*void SV_ClientThink(sv_client_t * cl, usercmd_t * cmd)*

### SV_ExecuteClientMessage

*void SV_ExecuteClientMessage(sv_client_t * cl, sizebuf_t * msg)*

*Defined at line 2563 of ./engine/server/sv_client.cpp*

===================SV_ExecuteClientMessage

Parse a client packet===================

### SV_ConnectionlessPacket

*void SV_ConnectionlessPacket(netadr_s from, sizebuf_t * msg)*

*Defined at line 2218 of ./engine/server/sv_client.cpp*

=================SV_ConnectionlessPacket

A connectionless packet has four leading 0xffcharacters to distinguish it from a game channel.Clients that are in the game can still sendconnectionless packets.=================

### SV_FakeConnect

*edict_t * SV_FakeConnect(const char * netname)*

*Defined at line 467 of ./engine/server/sv_client.cpp*

==================SV_FakeConnect

A connection request that came from the game module==================

### SV_ExecuteClientCommand

*void SV_ExecuteClientCommand(sv_client_t * cl, char * s)*

*Defined at line 2107 of ./engine/server/sv_client.cpp*

==================SV_ExecuteUserCommand==================

### SV_RunCmd

*void SV_RunCmd(sv_client_t * cl, usercmd_t * ucmd, int random_seed)*

*Defined at line 1028 of ./engine/server/sv_pmove.cpp*

===========SV_RunCmd===========

### SV_BuildReconnect

*void SV_BuildReconnect(sizebuf_t * msg)*

*Defined at line 1448 of ./engine/server/sv_client.cpp*

================SV_SendReconnect

Tell all the clients that the server is changing levels================

### SV_IsPlayerIndex

*qboolean SV_IsPlayerIndex(int idx)*

*Defined at line 1239 of ./engine/server/sv_client.cpp*

===================SV_IsPlayerIndex

===================

### SV_CalcPing

*int SV_CalcPing(sv_client_t * cl)*

*Defined at line 1005 of ./engine/server/sv_client.cpp*

===================SV_CalcPing

recalc ping on current client===================

### SV_InitClientMove

*void SV_InitClientMove()*

*Defined at line 584 of ./engine/server/sv_pmove.cpp*

===============SV_InitClientMove

===============

### SV_UpdateServerInfo

*void SV_UpdateServerInfo()*

### SV_EndRedirect

*void SV_EndRedirect()*

*Defined at line 645 of ./engine/server/sv_client.cpp*

### SV_RejectConnection

*void SV_RejectConnection(netadr_s from, char * fmt)*

*Defined at line 140 of ./engine/server/sv_client.cpp*

================SV_RejectConnection

Rejects connection request and sends back a message================

### SV_Status_f

*void SV_Status_f()*

*Defined at line 629 of ./engine/server/sv_cmds.cpp*

 sv_cmds.c

================SV_Status_f================

### SV_Newgame_f

*void SV_Newgame_f()*

### SV_InitHostCommands

*void SV_InitHostCommands()*

*Defined at line 942 of ./engine/server/sv_cmds.cpp*

==================SV_InitHostCommands

commands that create serveris available always==================

### SV_AddToResourceList

*void SV_AddToResourceList(resource_t * pResource, resource_t * pList)*

*Defined at line 324 of ./engine/server/sv_custom.cpp*

 sv_custom.c

### SV_MoveToOnHandList

*void SV_MoveToOnHandList(sv_client_t * cl, resource_t * pResource)*

*Defined at line 312 of ./engine/server/sv_custom.cpp*

### SV_RemoveFromResourceList

*void SV_RemoveFromResourceList(resource_t * pResource)*

*Defined at line 352 of ./engine/server/sv_custom.cpp*

### SV_ParseConsistencyResponse

*void SV_ParseConsistencyResponse(sv_client_t * cl, sizebuf_t * msg)*

*Defined at line 89 of ./engine/server/sv_custom.cpp*

### SV_EstimateNeededResources

*int SV_EstimateNeededResources(sv_client_t * cl)*

*Defined at line 383 of ./engine/server/sv_custom.cpp*

### SV_ClearResourceList

*void SV_ClearResourceList(resource_t * pList)*

*Defined at line 360 of ./engine/server/sv_custom.cpp*

### SV_BatchUploadRequest

*void SV_BatchUploadRequest(sv_client_t * cl)*

*Defined at line 501 of ./engine/server/sv_custom.cpp*

### SV_SendResources

*void SV_SendResources(sv_client_t * cl, sizebuf_t * msg)*

*Defined at line 555 of ./engine/server/sv_custom.cpp*

### SV_ClearResourceLists

*void SV_ClearResourceLists(sv_client_t * cl)*

*Defined at line 377 of ./engine/server/sv_custom.cpp*

### SV_TransferConsistencyInfo

*void SV_TransferConsistencyInfo()*

*Defined at line 194 of ./engine/server/sv_custom.cpp*

### SV_RequestMissingResources

*void SV_RequestMissingResources()*

*Defined at line 486 of ./engine/server/sv_custom.cpp*

### SV_InitFilter

*void SV_InitFilter()*

*Defined at line 427 of ./engine/server/sv_filter.cpp*

 sv_filter.c

### SV_CheckIP

*qboolean SV_CheckIP(netadr_t * adr)*

*Defined at line 125 of ./engine/server/sv_filter.cpp*

### SV_CheckID

*qboolean SV_CheckID(const char * id)*

*Defined at line 96 of ./engine/server/sv_filter.cpp*

### SV_InactivateClients

*void SV_InactivateClients()*

*Defined at line 972 of ./engine/server/sv_frame.cpp*

 sv_frame.c

=======================SV_InactivateClients

Purpose: Prepare for level transition, etc.=======================

### SV_FindBestBaselineForStatic

*int SV_FindBestBaselineForStatic(int index, entity_state_t ** baseline, entity_state_t * to)*

*Defined at line 222 of ./engine/server/sv_frame.cpp*

=============SV_FindBestBaselineForStatic

trying to deltas with previous static entities=============

### SV_WriteFrameToClient

*void SV_WriteFrameToClient(sv_client_t * client, sizebuf_t * msg)*

### SV_BuildClientFrame

*void SV_BuildClientFrame(sv_client_t * client)*

### SV_SendMessagesToAll

*void SV_SendMessagesToAll()*

*Defined at line 924 of ./engine/server/sv_frame.cpp*

=======================SV_SendMessagesToAll

e.g. before changing level=======================

### SV_SkipUpdates

*void SV_SkipUpdates()*

*Defined at line 948 of ./engine/server/sv_frame.cpp*

=======================SV_SkipUpdates

used before changing level=======================

### SV_LoadProgs

*qboolean SV_LoadProgs(const char * name)*

*Defined at line 5015 of ./engine/server/sv_game.cpp*

 sv_game.c

### SV_UnloadProgs

*void SV_UnloadProgs()*

*Defined at line 4975 of ./engine/server/sv_game.cpp*

### SV_FreeEdicts

*void SV_FreeEdicts()*

*Defined at line 1151 of ./engine/server/sv_game.cpp*

==============SV_FreeEdicts

release all the edicts from server==============

### SV_AllocEdict

*edict_t * SV_AllocEdict()*

*Defined at line 1031 of ./engine/server/sv_game.cpp*

==============SV_AllocEdict

allocate new or reuse existing==============

### SV_FreeEdict

*void SV_FreeEdict(edict_t * pEdict)*

*Defined at line 994 of ./engine/server/sv_game.cpp*

==============SV_FreeEdict

unlink edict from world and free it==============

### SV_InitEdict

*void SV_InitEdict(edict_t * pEdict)*

*Defined at line 973 of ./engine/server/sv_game.cpp*

==============SV_InitEdict

clear edict for reuse==============

### SV_ClassName

*const char * SV_ClassName(const edict_t * e)*

*Defined at line 1201 of ./engine/server/sv_game.cpp*

==============SV_ClassName

template to get edict classname==============

### SV_FreePrivateData

*void SV_FreePrivateData(edict_t * pEdict)*

*Defined at line 951 of ./engine/server/sv_game.cpp*

==============SV_FreePrivateData

release private edict memory==============

### SV_CopyTraceToGlobal

*void SV_CopyTraceToGlobal(trace_t * trace)*

*Defined at line 220 of ./engine/server/sv_game.cpp*

=============SV_CopyTraceToGlobal

each trace will share their result into global state=============

### SV_CheckEdict

*qboolean SV_CheckEdict(const edict_t * e, const char * file, const int line)*

*Defined at line 47 of ./engine/server/sv_game.cpp*

### SV_SetMinMaxSize

*void SV_SetMinMaxSize(edict_t * e, const float * min, const float * max, qboolean relink)*

*Defined at line 190 of ./engine/server/sv_game.cpp*

=============SV_SetMinMaxSize

update entity bounds, relink into world=============

### SV_FindEntityByString

*edict_t * SV_FindEntityByString(edict_t * pStartEdict, const char * pszField, const char * pszValue)*

*Defined at line 1529 of ./engine/server/sv_game.cpp*

=========SV_FindEntityByString

=========

### SV_PlaybackEventFull

*void SV_PlaybackEventFull(int flags, const edict_t * pInvoker, word eventindex, float delay, float * origin, float * angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2)*

*Defined at line 3932 of ./engine/server/sv_game.cpp*

=============pfnPlaybackEvent

=============

### SV_PlaybackReliableEvent

*void SV_PlaybackReliableEvent(sizebuf_t * msg, word eventindex, float delay, event_args_t * args)*

*Defined at line 1171 of ./engine/server/sv_game.cpp*

==============SV_PlaybackReliableEvent

reliable event is must be delivered always==============

### SV_BuildSoundMsg

*int SV_BuildSoundMsg(sizebuf_t * msg, edict_t * ent, int chan, const char * sample, int vol, float attn, int flags, int pitch, const vec3_t pos)*

*Defined at line 2005 of ./engine/server/sv_game.cpp*

=================SV_BuildSoundMsg

=================

### SV_BoxInPVS

*qboolean SV_BoxInPVS(const vec3_t org, const vec3_t absmin, const vec3_t absmax)*

*Defined at line 668 of ./engine/server/sv_game.cpp*

==============SV_BoxInPVS

check brush boxes in fat pvs==============

### SV_QueueChangeLevel

*void SV_QueueChangeLevel(const char * level, const char * landname)*

*Defined at line 682 of ./engine/server/sv_game.cpp*

=============SV_ChangeLevel

Issue changing level=============

### SV_WriteEntityPatch

*void SV_WriteEntityPatch(const char * filename)*

*Defined at line 767 of ./engine/server/sv_game.cpp*

==============SV_WriteEntityPatch

Create entity patch for selected map==============

### SV_AngleMod

*float SV_AngleMod(float ideal, float current, float speed)*

*Defined at line 147 of ./engine/server/sv_game.cpp*

=============SV_AngleMod

do modulo on entity angles=============

### SV_SpawnEntities

*void SV_SpawnEntities(const char * mapname)*

*Defined at line 4940 of ./engine/server/sv_game.cpp*

==============SpawnEntities

Creates a server's entity / program execution context byparsing textual entity definitions out of an ent file.==============

### SV_AllocPrivateData

*edict_t * SV_AllocPrivateData(edict_t * ent, string_t className)*

*Defined at line 1078 of ./engine/server/sv_game.cpp*

==============SV_AllocPrivateData

allocate private data for a given edict==============

### SV_CreateNamedEntity

*edict_t * SV_CreateNamedEntity(edict_t * ent, string_t className)*

*Defined at line 1134 of ./engine/server/sv_game.cpp*

==============SV_CreateNamedEntity

create specified entity, alloc private data==============

### SV_AllocString

*string_t SV_AllocString(const char * szValue)*

*Defined at line 3172 of ./engine/server/sv_game.cpp*

=============SV_AllocString

allocate new engine stringon 64bit platforms find in array string if deduplication enabled (default)if not found, add to arrayuse -str64dup to disable deduplication, -str64alloc to set array size=============

### SV_MakeString

*string_t SV_MakeString(const char * szValue)*

*Defined at line 3237 of ./engine/server/sv_game.cpp*

=============SV_MakeString

make constant string=============

### SV_GetString

*const char * SV_GetString(string_t iString)*

*Defined at line 3260 of ./engine/server/sv_game.cpp*

=============SV_GetString

=============

### SV_SetStringArrayMode

*void SV_SetStringArrayMode(qboolean dynamic)*

*Defined at line 3037 of ./engine/server/sv_game.cpp*

===============SV_SetStringArrayMode

use different arrays on 64 bit platformsset dynamic after complete server spawnthis helps not to lose strings that belongs to static game part===============

### SV_EmptyStringPool

*void SV_EmptyStringPool()*

*Defined at line 3013 of ./engine/server/sv_game.cpp*

==================SV_EmptyStringPool

Free strings on server stop. Reset string pointer on 64 bits==================

### SV_PrintStr64Stats_f

*void SV_PrintStr64Stats_f()*

*Defined at line 3217 of ./engine/server/sv_game.cpp*

### SV_ClientFromEdict

*sv_client_t * SV_ClientFromEdict(const edict_t * pEdict, qboolean spawned_only)*

*Defined at line 1232 of ./engine/server/sv_game.cpp*

==============SV_AllocPrivateData

get edict that attached to the client structure==============

### SV_MapIsValid

*int SV_MapIsValid(const char * filename, const char * spawn_entity, const char * landmark_name)*

*Defined at line 881 of ./engine/server/sv_game.cpp*

==============SV_MapIsValid

Validate map==============

### SV_FindGlobalEntity

*edict_t * SV_FindGlobalEntity(string_t classname, string_t globalname)*

*Defined at line 1589 of ./engine/server/sv_game.cpp*

=========SV_FindGlobalEntity

ripped out from the hl.dll=========

### SV_CreateStaticEntity

*qboolean SV_CreateStaticEntity(struct sizebuf_s * msg, int index)*

*Defined at line 501 of ./engine/server/sv_game.cpp*

=======================SV_CreateStaticEntity

NOTE: static entities only accepted when game is loading=======================

### SV_SendUserReg

*void SV_SendUserReg(sizebuf_t * msg, sv_user_message_t * user)*

*Defined at line 3397 of ./engine/server/sv_game.cpp*

=============SV_SendUserReg

=============

### pfnIndexOfEdict

*int pfnIndexOfEdict(const edict_t * pEdict)*

*Defined at line 3308 of ./engine/server/sv_game.cpp*

=============pfnIndexOfEdict

=============

### pfnWriteBytes

*void pfnWriteBytes(const byte * bytes, int count)*

*Defined at line 2789 of ./engine/server/sv_game.cpp*

=============pfnWriteBytes

=============

### SV_UpdateBaseVelocity

*void SV_UpdateBaseVelocity(edict_t * ent)*

*Defined at line 162 of ./engine/server/sv_phys.cpp*

================SV_UpdateBaseVelocity================

### pfnSetFatPVS

*byte * pfnSetFatPVS(const float * org)*

*Defined at line 4137 of ./engine/server/sv_game.cpp*

=============pfnSetFatPVS

The client will interpolate the view position,so we can't use a single PVS point=============

### pfnSetFatPAS

*byte * pfnSetFatPAS(const float * org)*

*Defined at line 4187 of ./engine/server/sv_game.cpp*

=============pfnSetFatPHS

The client will interpolate the hear position,so we can't use a single PHS point=============

### pfnPrecacheModel

*int pfnPrecacheModel(const char * s)*

*Defined at line 1266 of ./engine/server/sv_game.cpp*

===============================================================================

	Game Builtin Functions

===============================================================================

=========pfnPrecacheModel

=========

### pfnModelIndex

*int pfnModelIndex(const char * m)*

*Defined at line 1359 of ./engine/server/sv_game.cpp*

=================pfnModelIndex

=================

### pfnRemoveEntity

*void pfnRemoveEntity(edict_t * e)*

*Defined at line 1851 of ./engine/server/sv_game.cpp*

==============pfnRemoveEntity

free edict private mem, unlink physics etc==============

### SV_RestartAmbientSounds

*void SV_RestartAmbientSounds()*

*Defined at line 570 of ./engine/server/sv_game.cpp*

=================SV_RestartAmbientSounds

Write ambient sounds into demo=================

### SV_RestartDecals

*void SV_RestartDecals()*

*Defined at line 608 of ./engine/server/sv_game.cpp*

=================SV_RestartDecals

Write all the decals into demo=================

### SV_RestartStaticEnts

*void SV_RestartStaticEnts()*

*Defined at line 551 of ./engine/server/sv_game.cpp*

=================SV_RestartStaticEnts

Write all the static ents into demo=================

### pfnGetCurrentPlayer

*int pfnGetCurrentPlayer()*

*Defined at line 4302 of ./engine/server/sv_game.cpp*

=============pfnGetCurrentPlayer

=============

### SV_EdictNum

*edict_t * SV_EdictNum(int n)*

*Defined at line 39 of ./engine/server/sv_game.cpp*

### SV_Localinfo

*char * SV_Localinfo()*

*Defined at line 135 of ./engine/server/sv_game.cpp*

=============SV_LocalInfo

get local infostring=============

### Log_Close

*void Log_Close()*

*Defined at line 80 of ./engine/server/sv_log.cpp*

 sv_log.c

### Log_Open

*void Log_Open()*

*Defined at line 19 of ./engine/server/sv_log.cpp*

### Log_PrintServerVars

*void Log_PrintServerVars()*

*Defined at line 146 of ./engine/server/sv_log.cpp*

==================Log_PrintServerVars

==================

### SV_ServerLog_f

*qboolean SV_ServerLog_f(sv_client_t * cl)*

*Defined at line 162 of ./engine/server/sv_log.cpp*

====================SV_ServerLog_f

====================

### SV_SaveGame

*void SV_SaveGame(const char * pName)*

*Defined at line 2095 of ./engine/server/sv_save.cpp*

 sv_save.c

================== SV_SaveGame================== 

### SV_LoadGame

*qboolean SV_LoadGame(const char * pName)*

*Defined at line 2019 of ./engine/server/sv_save.cpp*

=============SV_LoadGame=============

### SV_LoadGameState

*int SV_LoadGameState(const char * level)*

*Defined at line 1928 of ./engine/server/sv_save.cpp*

=============SV_LoadGameState

loading entities from the savegame=============

### SV_ChangeLevel

*void SV_ChangeLevel(qboolean loadfromsavedgame, const char * mapname, const char * start, qboolean background)*

*Defined at line 1953 of ./engine/server/sv_save.cpp*

=============SV_ChangeLevel=============

### SV_GetLatestSave

*const char * SV_GetLatestSave()*

*Defined at line 2146 of ./engine/server/sv_save.cpp*

================== SV_GetLatestSave

used for reload game after player death================== 

### SV_InitSaveRestore

*void SV_InitSaveRestore()*

*Defined at line 2371 of ./engine/server/sv_save.cpp*

### SV_ClearGameState

*void SV_ClearGameState()*

*Defined at line 1940 of ./engine/server/sv_save.cpp*

=============SV_ClearGameState

clear current game state=============

### SV_GetTrueOrigin

*void SV_GetTrueOrigin(sv_client_t * cl, int edictnum, vec3_t origin)*

*Defined at line 176 of ./engine/server/sv_pmove.cpp*

 sv_pmove.c

### SV_GetTrueMinMax

*void SV_GetTrueMinMax(sv_client_t * cl, int edictnum, vec3_t mins, vec3_t maxs)*

*Defined at line 188 of ./engine/server/sv_pmove.cpp*

### SV_PlayerIsFrozen

*qboolean SV_PlayerIsFrozen(edict_t * pClient)*

*Defined at line 33 of ./engine/server/sv_pmove.cpp*

### SV_ClearWorld

*void SV_ClearWorld()*

*Defined at line 463 of ./engine/server/sv_world.cpp*

 sv_world.c

===============SV_ClearWorld

===============

### SV_UnlinkEdict

*void SV_UnlinkEdict(edict_t * ent)*

*Defined at line 488 of ./engine/server/sv_world.cpp*

===============SV_UnlinkEdict===============

### SV_ClipMoveToEntity

*void SV_ClipMoveToEntity(edict_t * ent, const vec3_t start, vec3_t mins, vec3_t maxs, const vec3_t end, trace_t * trace)*

*Defined at line 862 of ./engine/server/sv_world.cpp*

===============================================================================

LINE TESTING IN HULLS

===============================================================================

==================SV_ClipMoveToEntity

Handles selection or creation of a clipping hull, and offseting (andeventually rotation) of the end points==================

### SV_CustomClipMoveToEntity

*void SV_CustomClipMoveToEntity(edict_t * ent, const vec3_t start, vec3_t mins, vec3_t maxs, const vec3_t end, trace_t * trace)*

*Defined at line 1114 of ./engine/server/sv_world.cpp*

==================SV_CustomClipMoveToEntity

A part of physics engine implementationor custom physics implementation==================

### SV_TraceHull

* SV_TraceHull(edict_t * ent, int hullNum, const vec3_t start, vec3_t mins, vec3_t maxs, const vec3_t end)*

### SV_Move

* SV_Move(const vec3_t start, vec3_t mins, vec3_t maxs, const vec3_t end, int type, edict_t * e, qboolean monsterclip)*

*Defined at line 1349 of ./engine/server/sv_world.cpp*

==================SV_Move==================

### SV_MoveNoEnts

* SV_MoveNoEnts(const vec3_t start, vec3_t mins, vec3_t maxs, const vec3_t end, int type, edict_t * e)*

*Defined at line 1409 of ./engine/server/sv_world.cpp*

==================SV_MoveNoEnts==================

### SV_MoveNormal

* SV_MoveNormal(const vec3_t start, vec3_t mins, vec3_t maxs, const vec3_t end, int type, edict_t * e)*

*Defined at line 1399 of ./engine/server/sv_world.cpp*

### SV_TraceTexture

*const char * SV_TraceTexture(edict_t * ent, const vec3_t start, const vec3_t end)*

*Defined at line 1492 of ./engine/server/sv_world.cpp*

==================SV_TraceTexture

find the face where the traceline hitassume pTextureEntity is valid==================

### SV_TraceSurface

*msurface_t * SV_TraceSurface(edict_t * ent, const vec3_t start, const vec3_t end)*

*Defined at line 1456 of ./engine/server/sv_world.cpp*

==================SV_TraceSurface

find the face where the traceline hitassume pTextureEntity is valid==================

### SV_MoveToss

* SV_MoveToss(edict_t * tossent, edict_t * ignore)*

*Defined at line 1507 of ./engine/server/sv_world.cpp*

==================SV_MoveToss==================

### SV_LinkEdict

*void SV_LinkEdict(edict_t * ent, qboolean touch_triggers)*

*Defined at line 632 of ./engine/server/sv_world.cpp*

===============SV_LinkEdict===============

### SV_TouchLinks

*void SV_TouchLinks(edict_t * ent, areanode_t * node)*

*Defined at line 503 of ./engine/server/sv_world.cpp*

====================SV_TouchLinks====================

### SV_TruePointContents

*int SV_TruePointContents(const vec3_t p)*

*Defined at line 782 of ./engine/server/sv_world.cpp*

=============SV_TruePointContents

=============

### SV_PointContents

*int SV_PointContents(const vec3_t p)*

*Defined at line 804 of ./engine/server/sv_world.cpp*

=============SV_PointContents

=============

### SV_RunLightStyles

*void SV_RunLightStyles()*

*Defined at line 1650 of ./engine/server/sv_world.cpp*

### SV_SetLightStyle

*void SV_SetLightStyle(int style, const char * s, float f)*

*Defined at line 1677 of ./engine/server/sv_world.cpp*

==================SV_SetLightStyle

needs to get correct working SV_LightPoint==================

### SV_GetLightStyle

*const char * SV_GetLightStyle(int style)*

*Defined at line 1706 of ./engine/server/sv_world.cpp*

==================SV_GetLightStyle

needs to get correct working SV_LightPoint==================

### SV_LightForEntity

*int SV_LightForEntity(edict_t * pEdict)*

*Defined at line 1722 of ./engine/server/sv_world.cpp*

==================SV_LightForEntity

grab the ambient lighting color for current point==================

### SV_ClearPhysEnts

*void SV_ClearPhysEnts()*

*Defined at line 25 of ./engine/server/sv_pmove.cpp*

### BaseCmd_Init

*void BaseCmd_Init()*

*Defined at line 190 of ./engine/common/base_cmd.cpp*

============BaseCmd_Init

initialize base command hashmap system============

### BaseCmd_GetBucket

*base_command_hashmap_t * BaseCmd_GetBucket(const char * name)*

*Defined at line 47 of ./engine/common/base_cmd.cpp*

============BaseCmd_GetBucket

Get bucket which contain basecmd by given name============

### BaseCmd_FindInBucket

*base_command_hashmap_t * BaseCmd_FindInBucket(base_command_hashmap_t * bucket, base_command_type_e type, const char * name)*

*Defined at line 31 of ./engine/common/base_cmd.cpp*

============BaseCmd_FindInBucket

Find base command in bucket============

### BaseCmd_Find

*base_command_t * BaseCmd_Find(base_command_type_e type, const char * name)*

*Defined at line 59 of ./engine/common/base_cmd.cpp*

============BaseCmd_Find

Find base command in hashmap============

### BaseCmd_FindAll

*void BaseCmd_FindAll(const char * name, base_command_t ** cmd, base_command_t ** alias, base_command_t ** cvar)*

*Defined at line 76 of ./engine/common/base_cmd.cpp*

============BaseCmd_Find

Find every type of base command and write into arguments============

### BaseCmd_Insert

*void BaseCmd_Insert(base_command_type_e type, base_command_t * basecmd, const char * name)*

*Defined at line 114 of ./engine/common/base_cmd.cpp*

============BaseCmd_Insert

Add new typed base command to hashmap============

### BaseCmd_Replace

*qboolean BaseCmd_Replace(base_command_type_e type, base_command_t * basecmd, const char * name)*

*Defined at line 134 of ./engine/common/base_cmd.cpp*

============BaseCmd_Replace

Used in case, when basecmd has been registered, but gamedll wants to register it's own============

### BaseCmd_Remove

*void BaseCmd_Remove(base_command_type_e type, const char * name)*

*Defined at line 160 of ./engine/common/base_cmd.cpp*

============BaseCmd_Remove

Remove base command from hashmap============

### BaseCmd_Stats_f

*void BaseCmd_Stats_f()*

*Defined at line 201 of ./engine/common/base_cmd.cpp*

============BaseCmd_Stats_f

============

### BaseCmd_Test_f

*void BaseCmd_Test_f()*

*Defined at line 251 of ./engine/common/base_cmd.cpp*

============BaseCmd_Stats_f

testing order matches cbuf execute============

### Cbuf_GetSpace

*void * Cbuf_GetSpace(cmdbuf_t * buf, int length)*

*Defined at line 78 of ./engine/common/cmd.cpp*

============Cbuf_GetSpace============

### Cmd_StuffCmds_f

*void Cmd_StuffCmds_f()*

*Defined at line 298 of ./engine/common/cmd.cpp*

==============================================================================

			SCRIPT COMMANDS

==============================================================================

===============Cmd_StuffCmds_f

Adds command line parameters as script statementsCommands lead with a +, and continue until a - or another +hl.exe -dev 3 +map c1a0dhl.exe -nosound -game bshift===============

### Cmd_Wait_f

*void Cmd_Wait_f()*

*Defined at line 312 of ./engine/common/cmd.cpp*

============Cmd_Wait_f

Causes execution of the remainder of the command buffer to be delayed untilnext frame.  This allows commands like:bind g "cmd use rocket ; +attack ; wait ; -attack ; cmd use blaster"============

### Cmd_Echo_f

*void Cmd_Echo_f()*

*Defined at line 324 of ./engine/common/cmd.cpp*

===============Cmd_Echo_f

Just prints the rest of the line to the console===============

### Cmd_Alias_f

*void Cmd_Alias_f()*

*Defined at line 340 of ./engine/common/cmd.cpp*

===============Cmd_Alias_f

Creates a new command that executes a command string (possibly ; seperated)===============

### Cmd_UnAlias_f

*void Cmd_UnAlias_f()*

*Defined at line 415 of ./engine/common/cmd.cpp*

===============Cmd_UnAlias_f

Remove existing aliases.===============

### Cmd_AddCommandEx

*int Cmd_AddCommandEx(const char * funcname, const char * cmd_name, xcommand_t function, const char * cmd_desc, int iFlags)*

*Defined at line 629 of ./engine/common/cmd.cpp*

============Cmd_AddCommandEx============

### Cmd_If_f

*void Cmd_If_f()*

*Defined at line 827 of ./engine/common/cmd.cpp*

============Cmd_If_f

Compare and et condition bit if true============

### Cmd_Else_f

*void Cmd_Else_f()*

*Defined at line 888 of ./engine/common/cmd.cpp*

============Cmd_Else_f

Invert condition bit============

### Cmd_List_f

*void Cmd_List_f()*

*Defined at line 1078 of ./engine/common/cmd.cpp*

============Cmd_List_f============

### Cmd_Apropos_f

*void Cmd_Apropos_f()*

*Defined at line 1154 of ./engine/common/cmd.cpp*

### sqrt

*double sqrt(double x)*

### mz_free

*void mz_free(void * p)*

*Defined at line 1059 of ./engine/common/miniz.h*

 mz_free() internally uses the MZ_FREE() macro (which by default calls free() unless you've modified the MZ_MALLOC macro) to release a block allocated from the heap. 

### mz_adler32

*mz_ulong mz_adler32(mz_ulong adler, const unsigned char * ptr, size_t buf_len)*

*Defined at line 943 of ./engine/common/miniz.h*

 ------------------- zlib-style API's 

 mz_adler32() returns the initial adler-32 value to use when called with ptr==NULL. 

### mz_crc32

*mz_ulong mz_crc32(mz_ulong crc, const unsigned char * ptr, size_t buf_len)*

*Defined at line 992 of ./engine/common/miniz.h*

 Faster, but larger CPU cache footprint.

 mz_crc32() returns the initial CRC-32 value to use when called with ptr==NULL. 

### mz_version

*const char * mz_version()*

*Defined at line 1080 of ./engine/common/miniz.h*

 Returns the version string of miniz.c. 

### mz_deflateInit

*int mz_deflateInit(mz_streamp pStream, int level)*

*Defined at line 1087 of ./engine/common/miniz.h*

 mz_deflateInit() initializes a compressor with default options: 

 Parameters: 

  pStream must point to an initialized mz_stream struct. 

  level must be between [MZ_NO_COMPRESSION, MZ_BEST_COMPRESSION]. 

  level 1 enables a specially optimized compression function that's been optimized purely for performance, not ratio. 

  (This special func. is currently only enabled when MINIZ_USE_UNALIGNED_LOADS_AND_STORES and MINIZ_LITTLE_ENDIAN are defined.) 

 Return values: 

  MZ_OK on success. 

  MZ_STREAM_ERROR if the stream is bogus. 

  MZ_PARAM_ERROR if the input parameters are bogus. 

  MZ_MEM_ERROR on out of memory. 

### mz_deflateInit2

*int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy)*

*Defined at line 1092 of ./engine/common/miniz.h*

 mz_deflateInit2() is like mz_deflate(), except with more control: 

 Additional parameters: 

   method must be MZ_DEFLATED 

   window_bits must be MZ_DEFAULT_WINDOW_BITS (to wrap the deflate stream with zlib header/adler-32 footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate/no header or footer) 

   mem_level must be between [1, 9] (it's checked but ignored by miniz.c) 

### mz_deflateReset

*int mz_deflateReset(mz_streamp pStream)*

*Defined at line 1128 of ./engine/common/miniz.h*

 Quickly resets a compressor without having to reallocate anything. Same as calling mz_deflateEnd() followed by mz_deflateInit()/mz_deflateInit2(). 

### mz_deflate

*int mz_deflate(mz_streamp pStream, int flush)*

*Defined at line 1137 of ./engine/common/miniz.h*

 mz_deflate() compresses the input to output, consuming as much of the input and producing as much output as possible. 

 Parameters: 

   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members. 

   flush may be MZ_NO_FLUSH, MZ_PARTIAL_FLUSH/MZ_SYNC_FLUSH, MZ_FULL_FLUSH, or MZ_FINISH. 

 Return values: 

   MZ_OK on success (when flushing, or if more input is needed but not available, and/or there's more output to be written but the output buffer is full). 

   MZ_STREAM_END if all input has been consumed and all output bytes have been written. Don't call mz_deflate() on the stream anymore. 

   MZ_STREAM_ERROR if the stream is bogus. 

   MZ_PARAM_ERROR if one of the parameters is invalid. 

   MZ_BUF_ERROR if no forward progress is possible because the input and/or output buffers are empty. (Fill up the input buffer or free up some output space and try again.) 

### mz_deflateEnd

*int mz_deflateEnd(mz_streamp pStream)*

*Defined at line 1195 of ./engine/common/miniz.h*

 mz_deflateEnd() deinitializes a compressor: 

 Return values: 

  MZ_OK on success. 

  MZ_STREAM_ERROR if the stream is bogus. 

### mz_deflateBound

*mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len)*

*Defined at line 1207 of ./engine/common/miniz.h*

 mz_deflateBound() returns a (very) conservative upper bound on the amount of data that could be generated by deflate(), assuming flush is set to only MZ_NO_FLUSH or MZ_FINISH. 

### mz_compress

*int mz_compress(unsigned char * pDest, mz_ulong * pDest_len, const unsigned char * pSource, mz_ulong source_len)*

*Defined at line 1244 of ./engine/common/miniz.h*

 Single-call compression functions mz_compress() and mz_compress2(): 

 Returns MZ_OK on success, or one of the error codes from mz_deflate() on failure. 

### mz_compress2

*int mz_compress2(unsigned char * pDest, mz_ulong * pDest_len, const unsigned char * pSource, mz_ulong source_len, int level)*

*Defined at line 1214 of ./engine/common/miniz.h*

### mz_compressBound

*mz_ulong mz_compressBound(mz_ulong source_len)*

*Defined at line 1249 of ./engine/common/miniz.h*

 mz_compressBound() returns a (very) conservative upper bound on the amount of data that could be generated by calling mz_compress(). 

### mz_inflateInit

*int mz_inflateInit(mz_streamp pStream)*

*Defined at line 1299 of ./engine/common/miniz.h*

 Initializes a decompressor. 

### mz_inflateInit2

*int mz_inflateInit2(mz_streamp pStream, int window_bits)*

*Defined at line 1263 of ./engine/common/miniz.h*

 mz_inflateInit2() is like mz_inflateInit() with an additional option that controls the window size and whether or not the stream has been wrapped with a zlib header/footer: 

 window_bits must be MZ_DEFAULT_WINDOW_BITS (to parse zlib header/footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate). 

### mz_inflateReset

*int mz_inflateReset(mz_streamp pStream)*

*Defined at line 1304 of ./engine/common/miniz.h*

 Quickly resets a compressor without having to reallocate anything. Same as calling mz_inflateEnd() followed by mz_inflateInit()/mz_inflateInit2(). 

### mz_inflate

*int mz_inflate(mz_streamp pStream, int flush)*

*Defined at line 1330 of ./engine/common/miniz.h*

 Decompresses the input stream to the output, consuming only as much of the input as needed, and writing as much to the output as possible. 

 Parameters: 

   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members. 

   flush may be MZ_NO_FLUSH, MZ_SYNC_FLUSH, or MZ_FINISH. 

   On the first call, if flush is MZ_FINISH it's assumed the input and output buffers are both sized large enough to decompress the entire stream in a single call (this is slightly faster). 

   MZ_FINISH implies that there are no more source bytes available beside what's already in the input buffer, and that the output buffer is large enough to hold the rest of the decompressed data. 

 Return values: 

   MZ_OK on success. Either more input is needed but not available, and/or there's more output to be written but the output buffer is full. 

   MZ_STREAM_END if all needed input has been consumed and all output bytes have been written. For zlib streams, the adler-32 of the decompressed data has also been verified. 

   MZ_STREAM_ERROR if the stream is bogus. 

   MZ_DATA_ERROR if the deflate stream is invalid. 

   MZ_PARAM_ERROR if one of the parameters is invalid. 

   MZ_BUF_ERROR if no forward progress is possible because the input buffer is empty but the inflater needs more input to continue, or if the output buffer is not large enough. Call mz_inflate() again 

   with more input data, or with more room in the output buffer (except when using single call decompression, described above). 

### mz_inflateEnd

*int mz_inflateEnd(mz_streamp pStream)*

*Defined at line 1442 of ./engine/common/miniz.h*

 Deinitializes a decompressor. 

### mz_uncompress

*int mz_uncompress(unsigned char * pDest, mz_ulong * pDest_len, const unsigned char * pSource, mz_ulong source_len)*

*Defined at line 1454 of ./engine/common/miniz.h*

 Single-call decompression. 

 Returns MZ_OK on success, or one of the error codes from mz_inflate() on failure. 

### mz_error

*const char * mz_error(int err)*

*Defined at line 1484 of ./engine/common/miniz.h*

 Returns a string description of the specified error code, or NULL if the error code is invalid. 

### miniz_def_alloc_func

*void * miniz_def_alloc_func(void * opaque, size_t items, size_t size)*

*Defined at line 1064 of ./engine/common/miniz.h*

### miniz_def_free_func

*void miniz_def_free_func(void * opaque, void * address)*

*Defined at line 1069 of ./engine/common/miniz.h*

### miniz_def_realloc_func

*void * miniz_def_realloc_func(void * opaque, void * address, size_t items, size_t size)*

*Defined at line 1074 of ./engine/common/miniz.h*

### tdefl_compress_mem_to_heap

*void * tdefl_compress_mem_to_heap(const void * pSrc_buf, size_t src_buf_len, size_t * pOut_len, int flags)*

*Defined at line 2947 of ./engine/common/miniz.h*

 High level compression functions: 

 tdefl_compress_mem_to_heap() compresses a block in memory to a heap block allocated via malloc(). 

 On entry: 

  pSrc_buf, src_buf_len: Pointer and size of source block to compress. 

  flags: The max match finder probes (default is 128) logically OR'd against the above flags. Higher probes are slower but improve compression. 

 On return: 

  Function returns a pointer to the compressed data, or NULL on failure. 

  *pOut_len will be set to the compressed data's size, which could be larger than src_buf_len on uncompressible data. 

  The caller must free() the returned block when it's no longer needed. 

### tdefl_compress_mem_to_mem

*size_t tdefl_compress_mem_to_mem(void * pOut_buf, size_t out_buf_len, const void * pSrc_buf, size_t src_buf_len, int flags)*

*Defined at line 2962 of ./engine/common/miniz.h*

 tdefl_compress_mem_to_mem() compresses a block in memory to another block in memory. 

 Returns 0 on failure. 

### tdefl_write_image_to_png_file_in_memory_ex

*void * tdefl_write_image_to_png_file_in_memory_ex(const void * pImage, int w, int h, int num_chans, size_t * pLen_out, mz_uint level, mz_bool flip)*

*Defined at line 3006 of ./engine/common/miniz.h*

 Compresses an image to a compressed PNG file in memory. 

 On entry: 

  pImage, w, h, and num_chans describe the image to compress. num_chans may be 1, 2, 3, or 4. 

  The image pitch in bytes per scanline will be w*num_chans. The leftmost pixel on the top scanline is stored first in memory. 

  level may range from [0,10], use MZ_NO_COMPRESSION, MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc. or a decent default is MZ_DEFAULT_LEVEL 

  If flip is true, the image will be flipped on the Y axis (useful for OpenGL apps). 

 On return: 

  Function returns a pointer to the compressed data, or NULL on failure. 

  *pLen_out will be set to the size of the PNG image file. 

  The caller must mz_free() the returned heap block (which will typically be larger than *pLen_out) when it's no longer needed. 

 Simple PNG writer function by Alex Evans, 2011. Released into the public domain: https://gist.github.com/908299, more context at http://altdevblogaday.org/2011/04/06/a-smaller-jpg-encoder/. This is actually a modification of Alex's original code so PNG files generated by this function pass pngcheck. 

### tdefl_write_image_to_png_file_in_memory

*void * tdefl_write_image_to_png_file_in_memory(const void * pImage, int w, int h, int num_chans, size_t * pLen_out)*

*Defined at line 3084 of ./engine/common/miniz.h*

### tdefl_compress_mem_to_output

*mz_bool tdefl_compress_mem_to_output(const void * pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void * pPut_buf_user, int flags)*

*Defined at line 2900 of ./engine/common/miniz.h*

 tdefl_compress_mem_to_output() compresses a block to an output stream. The above helpers use this function internally. 

### tdefl_init

*tdefl_status tdefl_init(tdefl_compressor * d, tdefl_put_buf_func_ptr pPut_buf_func, void * pPut_buf_user, int flags)*

*Defined at line 2855 of ./engine/common/miniz.h*

 Initializes the compressor. 

 There is no corresponding deinit() function because the tdefl API's do not dynamically allocate memory. 

 pBut_buf_func: If NULL, output data will be supplied to the specified callback. In this case, the user should call the tdefl_compress_buffer() API for compression. 

 If pBut_buf_func is NULL the user should always call the tdefl_compress() API. 

 flags: See the above enums (TDEFL_HUFFMAN_ONLY, TDEFL_WRITE_ZLIB_HEADER, etc.) 

### tdefl_compress

*tdefl_status tdefl_compress(tdefl_compressor * d, const void * pIn_buf, size_t * pIn_buf_size, void * pOut_buf, size_t * pOut_buf_size, tdefl_flush flush)*

*Defined at line 2781 of ./engine/common/miniz.h*

 Compresses a block of data, consuming as much of the specified input buffer as possible, and writing as much compressed data to the specified output buffer as possible. 

### tdefl_compress_buffer

*tdefl_status tdefl_compress_buffer(tdefl_compressor * d, const void * pIn_buf, size_t in_buf_size, tdefl_flush flush)*

*Defined at line 2849 of ./engine/common/miniz.h*

 tdefl_compress_buffer() is only usable when the tdefl_init() is called with a non-NULL tdefl_put_buf_func_ptr. 

 tdefl_compress_buffer() always consumes the entire input buffer. 

### tdefl_get_prev_return_status

*tdefl_status tdefl_get_prev_return_status(tdefl_compressor * d)*

*Defined at line 2890 of ./engine/common/miniz.h*

### tdefl_get_adler32

*mz_uint32 tdefl_get_adler32(tdefl_compressor * d)*

*Defined at line 2895 of ./engine/common/miniz.h*

### tdefl_create_comp_flags_from_zip_params

*mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy)*

*Defined at line 2978 of ./engine/common/miniz.h*

 Create tdefl_compress() flags given zlib-style compression parameters. 

 level may range from [0,10] (where 10 is absolute max compression, but may be much slower on some files) 

 window_bits may be -15 (raw deflate) or 15 (zlib) 

 strategy may be either MZ_DEFAULT_STRATEGY, MZ_FILTERED, MZ_HUFFMAN_ONLY, MZ_RLE, or MZ_FIXED 

 level may actually range from [0,10] (10 is a "hidden" max level, where we want a bit more compression and it's fine if throughput to fall off a cliff on some files). 

### tdefl_compressor_alloc

*tdefl_compressor * tdefl_compressor_alloc()*

*Defined at line 3094 of ./engine/common/miniz.h*

 Allocate the tdefl_compressor and tinfl_decompressor structures in C so that 

 non-C language bindings to tdefL_ and tinfl_ API don't need to worry about 

 structure size and allocation mechanism. 

 Allocate the tdefl_compressor structure in C so that 

 non-C language bindings to tdefl_ API don't need to worry about 

 structure size and allocation mechanism. 

### tdefl_compressor_free

*void tdefl_compressor_free(tdefl_compressor * pComp)*

*Defined at line 3099 of ./engine/common/miniz.h*

### tinfl_decompress_mem_to_heap

*void * tinfl_decompress_mem_to_heap(const void * pSrc_buf, size_t src_buf_len, size_t * pOut_len, int flags)*

*Defined at line 3758 of ./engine/common/miniz.h*

 High level decompression functions: 

 tinfl_decompress_mem_to_heap() decompresses a block in memory to a heap block allocated via malloc(). 

 On entry: 

  pSrc_buf, src_buf_len: Pointer and size of the Deflate or zlib source data to decompress. 

 On return: 

  Function returns a pointer to the decompressed data, or NULL on failure. 

  *pOut_len will be set to the decompressed data's size, which could be larger than src_buf_len on uncompressible data. 

  The caller must call mz_free() on the returned block when it's no longer needed. 

 Higher level helper functions. 

### tinfl_decompress_mem_to_mem

*size_t tinfl_decompress_mem_to_mem(void * pOut_buf, size_t out_buf_len, const void * pSrc_buf, size_t src_buf_len, int flags)*

*Defined at line 3796 of ./engine/common/miniz.h*

### tinfl_decompress_mem_to_callback

*int tinfl_decompress_mem_to_callback(const void * pIn_buf, size_t * pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void * pPut_buf_user, int flags)*

*Defined at line 3805 of ./engine/common/miniz.h*

### tinfl_decompressor_alloc

*tinfl_decompressor * tinfl_decompressor_alloc()*

*Defined at line 3835 of ./engine/common/miniz.h*

 Allocate the tinfl_decompressor structure in C so that 

 non-C language bindings to tinfl_ API don't need to worry about 

 structure size and allocation mechanism. 

### tinfl_decompressor_free

*void tinfl_decompressor_free(tinfl_decompressor * pDecomp)*

*Defined at line 3843 of ./engine/common/miniz.h*

### tinfl_decompress

*tinfl_status tinfl_decompress(tinfl_decompressor * r, const mz_uint8 * pIn_buf_next, size_t * pIn_buf_size, mz_uint8 * pOut_buf_start, mz_uint8 * pOut_buf_next, size_t * pOut_buf_size, const mz_uint32 decomp_flags)*

*Defined at line 3285 of ./engine/common/miniz.h*

 Main low-level decompressor coroutine function. This is the only function actually needed for decompression. All the other functions are just high-level helpers for improved usability. 

 This is a universal API, i.e. it can be used as a building block to build any desired higher level decompression API. In the limit case, it can be called once per every byte input or output. 

### CropByPreviousScissors

*void CropByPreviousScissors(Point pt, Size sz, int & x, int & y, int & w, int & h)*

*Defined at line 16 of ./mainui/Scissor.cpp*

### Image_ResampleInternal

*byte * Image_ResampleInternal(const void * indata, int in_w, int in_h, int out_w, int out_h, int intype, qboolean * done)*

*Defined at line 1060 of ./engine/common/imagelib/img_utils.cpp*

================Image_Resample================

### Image_FlipInternal

*byte * Image_FlipInternal(const byte * in, word * srcwidth, word * srcheight, int type, int flags)*

*Defined at line 1105 of ./engine/common/imagelib/img_utils.cpp*

================Image_Flip================

### Image_Load

*rgbdata_t * Image_Load(const char * filename, const byte * buffer, size_t buffsize)*

### Image_Copy8bitRGBA

*qboolean Image_Copy8bitRGBA(const byte * in, byte * out, int pixels)*

*Defined at line 583 of ./engine/common/imagelib/img_utils.cpp*

============Image_Copy8bitRGBA

NOTE: must call Image_GetPaletteXXX before used============

### Image_AddIndexedImageToPack

*qboolean Image_AddIndexedImageToPack(const byte * in, int width, int height)*

*Defined at line 1198 of ./engine/common/imagelib/img_utils.cpp*

### Image_AddRGBAImageToPack

*qboolean Image_AddRGBAImageToPack(uint imageSize, const void * data)*

### Image_Save

*void Image_Save(const char * filename, rgbdata_t * pix)*

### Image_GetPaletteLMP

*void Image_GetPaletteLMP(const byte * pal, int rendermode)*

*Defined at line 420 of ./engine/common/imagelib/img_utils.cpp*

### Image_GetPaletteBMP

*void Image_GetPaletteBMP(const byte * pal)*

*Defined at line 409 of ./engine/common/imagelib/img_utils.cpp*

### Image_ComparePalette

*int Image_ComparePalette(const byte * pal)*

*Defined at line 267 of ./engine/common/imagelib/img_utils.cpp*

=============Image_ComparePalette=============

### Image_FreeImage

*void Image_FreeImage(rgbdata_t * pack)*

### Image_CopyPalette24bit

*void Image_CopyPalette24bit()*

### Image_CopyPalette32bit

*void Image_CopyPalette32bit()*

*Defined at line 354 of ./engine/common/imagelib/img_utils.cpp*

### Image_SetPixelFormat

*void Image_SetPixelFormat()*

### Image_GetPaletteQ1

*void Image_GetPaletteQ1()*

*Defined at line 382 of ./engine/common/imagelib/img_utils.cpp*

### Image_GetPaletteHL

*void Image_GetPaletteHL()*

*Defined at line 396 of ./engine/common/imagelib/img_utils.cpp*

### Image_LoadMIP

*qboolean Image_LoadMIP(const char * name, const byte * buffer, fs_offset_t filesize)*

*Defined at line 349 of ./engine/common/imagelib/img_wad.cpp*

 formats load

=============Image_LoadMIP=============

### Image_LoadMDL

*qboolean Image_LoadMDL(const char * name, const byte * buffer, fs_offset_t filesize)*

*Defined at line 150 of ./engine/common/imagelib/img_wad.cpp*

============Image_LoadMDL============

### Image_LoadSPR

*qboolean Image_LoadSPR(const char * name, const byte * buffer, fs_offset_t filesize)*

*Defined at line 200 of ./engine/common/imagelib/img_wad.cpp*

============Image_LoadSPR============

### Image_LoadTGA

*qboolean Image_LoadTGA(const char * name, const byte * buffer, fs_offset_t filesize)*

*Defined at line 24 of ./engine/common/imagelib/img_tga.cpp*

=============Image_LoadTGA=============

### Image_LoadBMP

*qboolean Image_LoadBMP(const char * name, const byte * buffer, fs_offset_t filesize)*

*Defined at line 36 of ./engine/common/imagelib/img_bmp.cpp*

=============Image_LoadBMP=============

### Image_LoadPNG

*qboolean Image_LoadPNG(const char * name, const byte * buffer, fs_offset_t filesize)*

*Defined at line 35 of ./engine/common/imagelib/img_png.cpp*

=============Image_LoadPNG=============

### Image_LoadDDS

*qboolean Image_LoadDDS(const char * name, const byte * buffer, fs_offset_t filesize)*

*Defined at line 250 of ./engine/common/imagelib/img_dds.cpp*

=============Image_LoadDDS=============

### Image_LoadFNT

*qboolean Image_LoadFNT(const char * name, const byte * buffer, fs_offset_t filesize)*

*Defined at line 77 of ./engine/common/imagelib/img_wad.cpp*

============Image_LoadFNT============

### Image_LoadLMP

*qboolean Image_LoadLMP(const char * name, const byte * buffer, fs_offset_t filesize)*

*Defined at line 264 of ./engine/common/imagelib/img_wad.cpp*

============Image_LoadLMP============

### Image_LoadPAL

*qboolean Image_LoadPAL(const char * name, const byte * buffer, fs_offset_t filesize)*

*Defined at line 28 of ./engine/common/imagelib/img_wad.cpp*

============Image_LoadPAL============

### Image_SaveTGA

*qboolean Image_SaveTGA(const char * name, rgbdata_t * pix)*

*Defined at line 234 of ./engine/common/imagelib/img_tga.cpp*

 formats save

=============Image_SaveTGA=============

### Image_SaveBMP

*qboolean Image_SaveBMP(const char * name, rgbdata_t * pix)*

*Defined at line 307 of ./engine/common/imagelib/img_bmp.cpp*

### Image_SavePNG

*qboolean Image_SavePNG(const char * name, rgbdata_t * pix)*

*Defined at line 397 of ./engine/common/imagelib/img_png.cpp*

=============Image_SavePNG=============

### Image_Quantize

*rgbdata_t * Image_Quantize(rgbdata_t * pic)*

*Defined at line 429 of ./engine/common/imagelib/img_quant.cpp*

 img_quant.c

 returns the actual number of palette entries.

### Image_Reset

*void Image_Reset()*

*Defined at line 89 of ./engine/common/imagelib/img_main.cpp*

 img_utils.c

### ImagePack

*rgbdata_t * ImagePack()*

*Defined at line 112 of ./engine/common/imagelib/img_main.cpp*

### Image_Copy

*byte * Image_Copy(size_t size)*

*Defined at line 176 of ./engine/common/imagelib/img_utils.cpp*

### Image_CopyParms

*void Image_CopyParms(rgbdata_t * src)*

*Defined at line 562 of ./engine/common/imagelib/img_utils.cpp*

### Image_ValidSize

*qboolean Image_ValidSize(const char * name)*

*Defined at line 242 of ./engine/common/imagelib/img_utils.cpp*

### Image_LumpValidSize

*qboolean Image_LumpValidSize(const char * name)*

*Defined at line 252 of ./engine/common/imagelib/img_utils.cpp*

### Image_CheckFlag

*qboolean Image_CheckFlag(int bit)*

*Defined at line 201 of ./engine/common/imagelib/img_utils.cpp*

=================Image_CheckFlag=================

### CAM_ToFirstPerson

*void CAM_ToFirstPerson()*

*Defined at line 483 of ./game/client/in_camera.cpp*

### MurmurHash3_32

*uint32 MurmurHash3_32(const void * key, size_t len, uint32 seed, _Bool bCaselessStringVariant)*

*Defined at line 45 of ./mainui/miniutl/generichash.cpp*

-----------------------------------------------------------------------------

### MurmurHash3_128

*void MurmurHash3_128(const void * key, const int len, const uint32 seed, void * out)*

*Defined at line 116 of ./mainui/miniutl/generichash.cpp*

### HashString

*uint32 HashString(const char * pszKey, size_t len)*

*Defined at line 28 of ./mainui/miniutl/generichash.h*

### HashStringCaseless

*uint32 HashStringCaseless(const char * pszKey, size_t len)*

*Defined at line 33 of ./mainui/miniutl/generichash.h*

### HashString

*uint32 HashString(const char * pszKey)*

*Defined at line 38 of ./mainui/miniutl/generichash.h*

### HashStringCaseless

*uint32 HashStringCaseless(const char * pszKey)*

*Defined at line 43 of ./mainui/miniutl/generichash.h*

### HashInt64

*uint32 HashInt64(uint64 h)*

*Defined at line 48 of ./mainui/miniutl/generichash.h*

### HashInt

*uint32 HashInt(uint32 h)*

*Defined at line 73 of ./mainui/miniutl/generichash.h*

### HashItemAsBytes

*uint32 HashItemAsBytes(const T & item)*

*Defined at line 84 of ./mainui/miniutl/generichash.h*

### HashItem

*uint32 HashItem(const T & item)*

*Defined at line 96 of ./mainui/miniutl/generichash.h*

### HashItem

*uint32 HashItem(const class CUtlString & item)*

*Defined at line 679 of ./mainui/miniutl/utlstring.h*

 HashItem() overload that works automatically with our hash containers

### IndexOf

*ptrdiff_t IndexOf(const char * pstrToSearch, const char * pstrTarget)*

*Defined at line 19 of ./mainui/miniutl/utlstring.cpp*

----------------------------------------------------------------------------- Purpose: Helper: Find s substring-----------------------------------------------------------------------------

### BEndsWith

*_Bool BEndsWith(const char * pstrToSearch, const char * pstrToFind, _Bool bCaseless)*

*Defined at line 33 of ./mainui/miniutl/utlstring.cpp*

----------------------------------------------------------------------------- Purpose: returns true if the string ends with the string passed in-----------------------------------------------------------------------------

### BStartsWith

*_Bool BStartsWith(const char * pstrToSearch, const char * pstrToFind, _Bool bCaseless)*

*Defined at line 62 of ./mainui/miniutl/utlstring.cpp*

----------------------------------------------------------------------------- Purpose: returns true if the string starts with the string passed in-----------------------------------------------------------------------------

### RemoveWhitespace

*size_t RemoveWhitespace(char * pszString)*

*Defined at line 87 of ./mainui/miniutl/utlstring.cpp*

----------------------------------------------------------------------------- Purpose: Helper: kill all whitespace.-----------------------------------------------------------------------------

### BVerifyValidUTF8Continuation

*_Bool BVerifyValidUTF8Continuation(size_t unStart, size_t unContinuationLength, const uint8 * pbCharacters)*

*Defined at line 448 of ./mainui/miniutl/utlstring.cpp*

 Catch invalid UTF-8 sequences and return false if found, or true if the sequence is correct

### CheckSkybox

*int CheckSkybox(const char * name)*

*Defined at line 67 of ./rendersystem/r_warp.cpp*

### DrawSkyPolygon

*void DrawSkyPolygon(int nump, vec3_t vecs)*

*Defined at line 104 of ./rendersystem/r_warp.cpp*

### ClipSkyPolygon

*void ClipSkyPolygon(int nump, vec3_t vecs, int stage)*

*Defined at line 152 of ./rendersystem/r_warp.cpp*

==============ClipSkyPolygon==============

### MakeSkyVec

*void MakeSkyVec(float s, float t, int axis)*

*Defined at line 247 of ./rendersystem/r_warp.cpp*

### R_UnloadSkybox

*void R_UnloadSkybox()*

*Defined at line 342 of ./rendersystem/r_warp.cpp*

==============R_UnloadSkybox

Unload previous skybox==============

### R_CloudVertex

*void R_CloudVertex(float s, float t, int axis, vec3_t v)*

*Defined at line 475 of ./rendersystem/r_warp.cpp*

==============================================================================

  RENDER CLOUDS

==============================================================================

==============R_CloudVertex==============

### R_CloudTexCoord

*void R_CloudTexCoord(vec3_t v, float speed, float * s, float * t)*

*Defined at line 499 of ./rendersystem/r_warp.cpp*

=============R_CloudTexCoord=============

### R_CloudDrawPoly

*void R_CloudDrawPoly(glpoly_t * p)*

*Defined at line 522 of ./rendersystem/r_warp.cpp*

===============R_CloudDrawPoly===============

### R_CloudRenderSide

*void R_CloudRenderSide(int axis)*

*Defined at line 560 of ./rendersystem/r_warp.cpp*

==============R_CloudRenderSide==============

### GlobalAllocator

*class CZoneAllocator & GlobalAllocator()*

*Defined at line 70 of ./public/mem.cpp*

### FS_FindLibrary

*dll_user_t * FS_FindLibrary(const char * dllname, qboolean directpath)*

*Defined at line 2945 of ./engine/common/filesystem.cpp*

==================FS_FindLibrary

search for library, assume index is validonly for internal use==================

### COM_LoadLibrary

*void * COM_LoadLibrary(const char * dllname, int build_ordinals_table, qboolean directpath)*

*Defined at line 67 of ./engine/platform/posix/lib_posix.cpp*

### COM_GetProcAddress

*void * COM_GetProcAddress(void * hInstance, const char * name)*

*Defined at line 164 of ./engine/platform/posix/lib_posix.cpp*

### COM_NameForFunction

*const char * COM_NameForFunction(void * hInstance, void * function)*

*Defined at line 206 of ./engine/platform/posix/lib_posix.cpp*

### COM_FunctionFromName_SR

*void * COM_FunctionFromName_SR(void * hInstance, const char * pName)*

*Defined at line 39 of ./engine/common/lib_common.cpp*

### COM_FunctionFromName

*void * COM_FunctionFromName(void * hInstance, const char * pName)*

*Defined at line 179 of ./engine/platform/posix/lib_posix.cpp*

### COM_FreeLibrary

*void COM_FreeLibrary(void * hInstance)*

*Defined at line 151 of ./engine/platform/posix/lib_posix.cpp*

### COM_GetLibraryError

*const char * COM_GetLibraryError()*

*Defined at line 23 of ./engine/common/lib_common.cpp*

### COM_CheckLibraryDirectDependency

*qboolean COM_CheckLibraryDirectDependency(const char * name, const char * depname, qboolean directpath)*

*Defined at line 61 of ./engine/platform/posix/lib_posix.cpp*

### COM_ResetLibraryError

*void COM_ResetLibraryError()*

*Defined at line 28 of ./engine/common/lib_common.cpp*

 TODO: Move to internal?

### COM_PushLibraryError

*void COM_PushLibraryError(const char * error)*

*Defined at line 33 of ./engine/common/lib_common.cpp*

### COM_OffsetNameForFunction

*const char * COM_OffsetNameForFunction(void * function)*

*Defined at line 48 of ./engine/common/lib_common.cpp*

### COM_GetCommonLibraryPath

*void COM_GetCommonLibraryPath(ECommonLibraryType eLibType, char * out, size_t size)*

*Defined at line 144 of ./engine/common/lib_common.cpp*

==============COM_GetCommonLibraryPath

Generates platform-unique and compatible name for server library==============

### __MsgFunc_Health

*int __MsgFunc_Health(const char * pszName, int iSize, void * pbuf)*

*Defined at line 32 of ./game/client/health.cpp*

### __MsgFunc_Damage

*int __MsgFunc_Damage(const char * pszName, int iSize, void * pbuf)*

*Defined at line 33 of ./game/client/health.cpp*

### COM_GenerateCommonLibraryName

*void COM_GenerateCommonLibraryName(const char * name, const char * ext, char * out, size_t size)*

*Defined at line 64 of ./engine/common/lib_common.cpp*

=============================================================================

	LIBRARY NAMING(see Documentation/library-naming.md for more info)

=============================================================================

### COM_GenerateClientLibraryPath

*void COM_GenerateClientLibraryPath(const char * name, char * out, size_t size)*

*Defined at line 82 of ./engine/common/lib_common.cpp*

==============COM_GenerateClientLibraryPath

Generates platform-unique and compatible name for client libraries==============

### COM_GenerateServerLibraryPath

*void COM_GenerateServerLibraryPath(char * out, size_t size)*

*Defined at line 103 of ./engine/common/lib_common.cpp*

==============COM_GenerateServerLibraryPath

Generates platform-unique and compatible name for server library==============

### U_Random

*unsigned int U_Random()*

*Defined at line 66 of ./game/server/util.cpp*

### U_Srand

*void U_Srand(unsigned int seed)*

*Defined at line 74 of ./game/server/util.cpp*

### UTIL_ParametricRocket

*void UTIL_ParametricRocket(entvars_t * pev, Vector vecOrigin, Vector vecAngles, edict_t * owner)*

*Defined at line 140 of ./game/server/util.cpp*

### FixedUnsigned16

*unsigned short FixedUnsigned16(float value, float scale)*

*Defined at line 625 of ./game/server/util.cpp*

### FixedSigned16

*short FixedSigned16(float value, float scale)*

*Defined at line 638 of ./game/server/util.cpp*

### UTIL_ScreenFadeBuild

*void UTIL_ScreenFadeBuild(ScreenFade & fade, const class Vector & color, float fadeTime, float fadeHold, int alpha, int flags)*

*Defined at line 705 of ./game/server/util.cpp*

### UTIL_ScreenFadeWrite

*void UTIL_ScreenFadeWrite(const ScreenFade & fade, class CBaseEntity * pEntity)*

*Defined at line 716 of ./game/server/util.cpp*

### _rotr

*unsigned int _rotr(unsigned int val, int shift)*

*Defined at line 1735 of ./game/server/util.cpp*

### EntvarsKeyvalue

*void EntvarsKeyvalue(entvars_t * pev, KeyValueData * pkvd)*

*Defined at line 1928 of ./game/server/util.cpp*

### VectorNormalize

*float VectorNormalize(Vector v)*

*Defined at line 701 of ./mathlib/vector.h*

### PM_ViewEntity

*void PM_ViewEntity()*

*Defined at line 279 of ./pm_shared/pm_debug.cpp*

================PM_ViewEntity

Shows a particle trail from player to entity in crosshair.Shows particles at that entities bbox

Tries to shoot a ray out by about 128 units.================

### PM_DrawBBox

*void PM_DrawBBox(Vector mins, Vector maxs, Vector origin, int pcolor, float life)*

*Defined at line 237 of ./pm_shared/pm_debug.cpp*

================PM_DrawBBox(vec3_t mins, vec3_t maxs, vec3_t origin, int pcolor, float life)

================

### PM_ParticleLine

*void PM_ParticleLine(Vector start, Vector end, int pcolor, float life, float vert)*

*Defined at line 101 of ./pm_shared/pm_debug.cpp*

===============PM_ParticleLine(vec3_t start, vec3_t end, int color, float life)

================

### PM_ShowClipBox

*void PM_ShowClipBox()*

*Defined at line 46 of ./pm_shared/pm_debug.cpp*

### PM_SwapTextures

*void PM_SwapTextures(int i, int j)*

*Defined at line 133 of ./pm_shared/pm_shared.cpp*

### PM_SortTextures

*void PM_SortTextures()*

*Defined at line 148 of ./pm_shared/pm_shared.cpp*

### PM_InitTextureTypes

*void PM_InitTextureTypes()*

*Defined at line 168 of ./pm_shared/pm_shared.cpp*

### PM_PlayStepSound

*void PM_PlayStepSound(int step, float fvol)*

*Defined at line 269 of ./pm_shared/pm_shared.cpp*

### PM_MapTextureTypeStepType

*int PM_MapTextureTypeStepType(char chTextureType)*

*Defined at line 491 of ./pm_shared/pm_shared.cpp*

### PM_CatagorizeTextureType

*void PM_CatagorizeTextureType()*

*Defined at line 520 of ./pm_shared/pm_shared.cpp*

====================PM_CatagorizeTextureType

Determine texture info for the texture we are standing on.====================

### PM_UpdateStepSound

*void PM_UpdateStepSound()*

*Defined at line 554 of ./pm_shared/pm_shared.cpp*

### PM_AddToTouched

*qboolean PM_AddToTouched(pmtrace_s tr, Vector impactvelocity)*

*Defined at line 691 of ./pm_shared/pm_shared.cpp*

================PM_AddToTouched

Add's the trace result to touch list, if contact is not already in list.================

### PM_CheckVelocity

*void PM_CheckVelocity()*

*Defined at line 719 of ./pm_shared/pm_shared.cpp*

================PM_CheckVelocity

See if the player has a bogus velocity value.================

### PM_ClipVelocity

*int PM_ClipVelocity(Vector in, Vector normal, Vector out, float overbounce)*

*Defined at line 764 of ./pm_shared/pm_shared.cpp*

==================PM_ClipVelocity

Slide off of the impacting objectreturns the blocked flags:0x01 == floor0x02 == step / wall==================

### PM_AddCorrectGravity

*void PM_AddCorrectGravity()*

*Defined at line 796 of ./pm_shared/pm_shared.cpp*

### PM_FixupGravityVelocity

*void PM_FixupGravityVelocity()*

*Defined at line 817 of ./pm_shared/pm_shared.cpp*

### PM_FlyMove

*int PM_FlyMove()*

*Defined at line 842 of ./pm_shared/pm_shared.cpp*

============PM_FlyMove

The basic solid body movement clip that slides along multiple planes============

### PM_Accelerate

*void PM_Accelerate(Vector wishdir, float wishspeed, float accel)*

*Defined at line 1027 of ./pm_shared/pm_shared.cpp*

==============PM_Accelerate==============

### PM_WalkMove

*void PM_WalkMove()*

*Defined at line 1071 of ./pm_shared/pm_shared.cpp*

=====================PM_WalkMove

Only used by players.  Moves along the ground when player is a MOVETYPE_WALK.======================

### PM_Friction

*void PM_Friction()*

*Defined at line 1240 of ./pm_shared/pm_shared.cpp*

==================PM_Friction

Handles both ground friction and water friction==================

### PM_AirAccelerate

*void PM_AirAccelerate(Vector wishdir, float wishspeed, float accel)*

*Defined at line 1316 of ./pm_shared/pm_shared.cpp*

### PM_WaterMove

*void PM_WaterMove()*

*Defined at line 1358 of ./pm_shared/pm_shared.cpp*

===================PM_WaterMove

===================

### PM_AirMove

*void PM_AirMove()*

*Defined at line 1453 of ./pm_shared/pm_shared.cpp*

===================PM_AirMove

===================

### PM_InWater

*qboolean PM_InWater()*

*Defined at line 1499 of ./pm_shared/pm_shared.cpp*

### PM_CheckWater

*qboolean PM_CheckWater()*

*Defined at line 1511 of ./pm_shared/pm_shared.cpp*

=============PM_CheckWater

Sets pmove->waterlevel and pmove->watertype values.=============

### PM_CatagorizePosition

*void PM_CatagorizePosition()*

*Defined at line 1585 of ./pm_shared/pm_shared.cpp*

=============PM_CatagorizePosition=============

### PM_GetRandomStuckOffsets

*int PM_GetRandomStuckOffsets(int nIndex, int server, Vector offset)*

*Defined at line 1646 of ./pm_shared/pm_shared.cpp*

=================PM_GetRandomStuckOffsets

When a player is stuck, it's costly to try and unstick themGrab a test offset for the player based on a passed in index=================

### PM_ResetStuckOffsets

*void PM_ResetStuckOffsets(int nIndex, int server)*

*Defined at line 1657 of ./pm_shared/pm_shared.cpp*

### PM_CheckStuck

*int PM_CheckStuck()*

*Defined at line 1673 of ./pm_shared/pm_shared.cpp*

### PM_SpectatorMove

*void PM_SpectatorMove()*

*Defined at line 1793 of ./pm_shared/pm_shared.cpp*

===============PM_SpectatorMove===============

### PM_SplineFraction

*float PM_SplineFraction(float value, float scale)*

*Defined at line 1921 of ./pm_shared/pm_shared.cpp*

==================PM_SplineFraction

Use for ease-in, ease-out style interpolation (accel/decel)Used by ducking code.==================

### PM_FixPlayerCrouchStuck

*void PM_FixPlayerCrouchStuck(int direction)*

*Defined at line 1932 of ./pm_shared/pm_shared.cpp*

### PM_UnDuck

*void PM_UnDuck()*

*Defined at line 1954 of ./pm_shared/pm_shared.cpp*

### PM_Duck

*void PM_Duck()*

*Defined at line 1998 of ./pm_shared/pm_shared.cpp*

### PM_LadderMove

*void PM_LadderMove(physent_t * pLadder)*

*Defined at line 2092 of ./pm_shared/pm_shared.cpp*

### PM_Ladder

*physent_t * PM_Ladder()*

*Defined at line 2200 of ./pm_shared/pm_shared.cpp*

### PM_WaterJump

*void PM_WaterJump()*

*Defined at line 2232 of ./pm_shared/pm_shared.cpp*

### PM_AddGravity

*void PM_AddGravity()*

*Defined at line 2259 of ./pm_shared/pm_shared.cpp*

============PM_AddGravity

============

### PM_PushEntity

*pmtrace_s PM_PushEntity(Vector push)*

*Defined at line 2282 of ./pm_shared/pm_shared.cpp*

============PM_PushEntity

Does not change the entities velocity at all============

### PM_Physics_Toss

*void PM_Physics_Toss()*

*Defined at line 2309 of ./pm_shared/pm_shared.cpp*

============PM_Physics_Toss()

Dead player flying through air., e.g.============

### PM_NoClip

*void PM_NoClip()*

*Defined at line 2410 of ./pm_shared/pm_shared.cpp*

====================PM_NoClip

====================

### PM_PreventMegaBunnyJumping

*void PM_PreventMegaBunnyJumping()*

*Defined at line 2446 of ./pm_shared/pm_shared.cpp*

----------------------------------------------------------------------------- Purpose: Corrects bunny jumping ( where player initiates a bunny jump before other  movement logic runs, thus making onground == -1 thus making PM_Friction get skipped and  running PM_AirMove, which doesn't crop velocity to maxspeed like the ground / other  movement logic does.-----------------------------------------------------------------------------

### PM_Jump

*void PM_Jump()*

*Defined at line 2476 of ./pm_shared/pm_shared.cpp*

=============PM_Jump=============

### PM_CheckWaterJump

*void PM_CheckWaterJump()*

*Defined at line 2618 of ./pm_shared/pm_shared.cpp*

### PM_CheckFalling

*void PM_CheckFalling()*

*Defined at line 2682 of ./pm_shared/pm_shared.cpp*

### PM_PlayWaterSounds

*void PM_PlayWaterSounds()*

*Defined at line 2755 of ./pm_shared/pm_shared.cpp*

=================PM_PlayWaterSounds

=================

### PM_CalcRoll

*float PM_CalcRoll(Vector angles, Vector velocity, float rollangle, float rollspeed)*

*Defined at line 2784 of ./pm_shared/pm_shared.cpp*

===============PM_CalcRoll

===============

### PM_DropPunchAngle

*void PM_DropPunchAngle(Vector punchangle)*

*Defined at line 2819 of ./pm_shared/pm_shared.cpp*

=============PM_DropPunchAngle

=============

### PM_CheckParamters

*void PM_CheckParamters()*

*Defined at line 2835 of ./pm_shared/pm_shared.cpp*

==============PM_CheckParamters

==============

### PM_ReduceTimers

*void PM_ReduceTimers()*

*Defined at line 2897 of ./pm_shared/pm_shared.cpp*

### PM_PlayerMove

*void PM_PlayerMove(qboolean server)*

*Defined at line 2935 of ./pm_shared/pm_shared.cpp*

=============PlayerMove

Returns with origin, angles, and velocity modified in place.

Numtouch and touchindex[] will be set if any of the physentswere contacted during the move.=============

### PM_CreateStuckTable

*void PM_CreateStuckTable()*

*Defined at line 3182 of ./pm_shared/pm_shared.cpp*

### PM_GetVisEntInfo

*int PM_GetVisEntInfo(int ent)*

*Defined at line 3323 of ./pm_shared/pm_shared.cpp*

### PM_GetPhysEntInfo

*int PM_GetPhysEntInfo(int ent)*

*Defined at line 3332 of ./pm_shared/pm_shared.cpp*

### squidspit

*void squidspit(entvars_t * pev)*

*Defined at line 74 of ./game/server/npc/npc_bullsquid.cpp*

### monster_bullchicken

*void monster_bullchicken(entvars_t * pev)*

*Defined at line 227 of ./game/server/npc/npc_bullsquid.cpp*

### CL_FreeParticle

*void CL_FreeParticle(particle_t * p)*

*Defined at line 150 of ./engine/client/cl_efx.cpp*

================CL_FreeParticle

move particle to freelist================

### R_AllocTracer

*particle_t * R_AllocTracer(const vec3_t org, const vec3_t vel, float life)*

*Defined at line 241 of ./engine/client/cl_efx.cpp*

================R_AllocTracer

can return NULL if particles is out================

### R_BeamSetAttributes

*void R_BeamSetAttributes(BEAM * pbeam, float r, float g, float b, float framerate, int startFrame)*

*Defined at line 306 of ./engine/client/cl_efx.cpp*

==============R_BeamSetAttributes

set beam attributes==============

### R_BeamAlloc

*BEAM * R_BeamAlloc()*

*Defined at line 323 of ./engine/client/cl_efx.cpp*

==============R_BeamAlloc

==============

### R_BeamFree

*void R_BeamFree(BEAM * pBeam)*

*Defined at line 346 of ./engine/client/cl_efx.cpp*

==============R_BeamFree

==============

### CL_BeamSprite

*void CL_BeamSprite(vec3_t start, vec3_t end, int beamIndex, int spriteIndex)*

*Defined at line 575 of ./engine/client/cl_efx.cpp*

==============R_BeamSprite

Create a beam with sprite at the endValve legacy==============

### R_BeamSetup

*void R_BeamSetup(BEAM * pbeam, vec3_t start, vec3_t end, int modelIndex, float life, float width, float amplitude, float brightness, float speed)*

*Defined at line 590 of ./engine/client/cl_efx.cpp*

==============R_BeamSetup

generic function. all beams must bepassed through this==============

### CL_BeamAttemptToDie

*qboolean CL_BeamAttemptToDie(BEAM * pBeam)*

*Defined at line 628 of ./engine/client/cl_efx.cpp*

==============CL_BeamAttemptToDie

Check for expired beams==============

### CL_FreeDeadBeams

*void CL_FreeDeadBeams()*

*Defined at line 2064 of ./engine/client/cl_efx.cpp*

### monster_scientist

*void monster_scientist(entvars_t * pev)*

*Defined at line 121 of ./game/server/npc/npc_scientist.cpp*

### monster_scientist_dead

*void monster_scientist_dead(entvars_t * pev)*

*Defined at line 1117 of ./game/server/npc/npc_scientist.cpp*

### monster_sitting_scientist

*void monster_sitting_scientist(entvars_t * pev)*

*Defined at line 1181 of ./game/server/npc/npc_scientist.cpp*

### Mod_Modellist_f

*void Mod_Modellist_f()*

*Defined at line 118 of ./engine/common/model.cpp*

===============================================================================

			MOD COMMON UTILS

===============================================================================

================Mod_Modellist_f================

### Mod_FreeUserData

*void Mod_FreeUserData(model_t * mod)*

*Defined at line 144 of ./engine/common/model.cpp*

================Mod_FreeUserData================

### Mod_PurgeStudioCache

*void Mod_PurgeStudioCache()*

*Defined at line 526 of ./engine/common/model.cpp*

==================Mod_PurgeStudioCache

free studio cache on change level==================

### R_StudioSetupTimings

*void R_StudioSetupTimings()*

*Defined at line 180 of ./rendersystem/r_studio.cpp*

================R_StudioSetupTimings

init current time for a given model================

### R_AllowFlipViewModel

*qboolean R_AllowFlipViewModel(cl_entity_t * e)*

*Defined at line 203 of ./rendersystem/r_studio.cpp*

================R_AllowFlipViewModel

should a flip the viewmodel if cl_righthand is set to 1================

### R_StudioComputeBBox

*qboolean R_StudioComputeBBox(vec3_t [8] bbox)*

*Defined at line 221 of ./rendersystem/r_studio.cpp*

================R_StudioComputeBBox

Compute a full bounding box for current sequence================

### R_StudioComputeSkinMatrix

*void R_StudioComputeSkinMatrix(mstudioboneweight_t * boneweights, matrix3x4 result)*

*Defined at line 272 of ./rendersystem/r_studio.cpp*

### pfnGetCurrentEntity

*cl_entity_t * pfnGetCurrentEntity()*

*Defined at line 371 of ./rendersystem/r_studio.cpp*

===============pfnGetCurrentEntity

===============

### pfnMod_ForName

*model_t * pfnMod_ForName(const char * model, int crash)*

*Defined at line 396 of ./rendersystem/r_studio.cpp*

===============pfnMod_ForName

===============

### R_StudioGetPlayerState

*entity_state_t * R_StudioGetPlayerState(int index)*

*Defined at line 407 of ./rendersystem/r_studio.cpp*

===============pfnGetPlayerState

===============

### pfnGetViewEntity

*cl_entity_t * pfnGetViewEntity()*

*Defined at line 421 of ./rendersystem/r_studio.cpp*

===============pfnGetViewEntity

===============

### pfnGetEngineTimes

*void pfnGetEngineTimes(int * framecount, double * current, double * old)*

*Defined at line 432 of ./rendersystem/r_studio.cpp*

===============pfnGetEngineTimes

===============

### pfnGetViewInfo

*void pfnGetViewInfo(float * origin, float * upv, float * rightv, float * forwardv)*

*Defined at line 445 of ./rendersystem/r_studio.cpp*

===============pfnGetViewInfo

===============

### R_GetChromeSprite

*model_t * R_GetChromeSprite()*

*Defined at line 459 of ./rendersystem/r_studio.cpp*

===============R_GetChromeSprite

===============

### pfnGetModelCounters

*void pfnGetModelCounters(int ** s, int ** a)*

*Defined at line 470 of ./rendersystem/r_studio.cpp*

===============pfnGetModelCounters

===============

### pfnGetAliasScale

*void pfnGetAliasScale(float * x, float * y)*

*Defined at line 482 of ./rendersystem/r_studio.cpp*

===============pfnGetAliasScale

===============

### pfnStudioGetBoneTransform

*float **** pfnStudioGetBoneTransform()*

*Defined at line 494 of ./rendersystem/r_studio.cpp*

===============pfnStudioGetBoneTransform

===============

### pfnStudioGetLightTransform

*float **** pfnStudioGetLightTransform()*

*Defined at line 505 of ./rendersystem/r_studio.cpp*

===============pfnStudioGetLightTransform

===============

### pfnStudioGetAliasTransform

*float *** pfnStudioGetAliasTransform()*

*Defined at line 516 of ./rendersystem/r_studio.cpp*

===============pfnStudioGetAliasTransform

===============

### pfnStudioGetRotationMatrix

*float *** pfnStudioGetRotationMatrix()*

*Defined at line 527 of ./rendersystem/r_studio.cpp*

===============pfnStudioGetRotationMatrix

===============

### R_StudioPlayerBlend

*void R_StudioPlayerBlend(mstudioseqdesc_t * pseqdesc, int * pBlend, float * pPitch)*

*Defined at line 538 of ./rendersystem/r_studio.cpp*

====================StudioPlayerBlend

====================

### R_StudioSetUpTransform

*void R_StudioSetUpTransform(cl_entity_t * e)*

*Defined at line 599 of ./rendersystem/r_studio.cpp*

====================StudioSetUpTransform

====================

### R_StudioEstimateInterpolant

*float R_StudioEstimateInterpolant(cl_entity_t * e)*

*Defined at line 671 of ./rendersystem/r_studio.cpp*

====================StudioEstimateInterpolant

====================

### R_StudioFxTransform

*void R_StudioFxTransform(cl_entity_t * ent, matrix3x4 transform)*

*Defined at line 719 of ./rendersystem/r_studio.cpp*

====================StudioFxTransform

====================

### R_StudioCalcBoneAdj

*void R_StudioCalcBoneAdj(float dadt, float * adj, const byte * pcontroller1, const byte * pcontroller2, byte mouthopen)*

*Defined at line 763 of ./rendersystem/r_studio.cpp*

====================StudioCalcBoneAdj

====================

### R_StudioCalcRotations

*void R_StudioCalcRotations(cl_entity_t * e, float [][3] pos, vec4_t * q, mstudioseqdesc_t * pseqdesc, mstudioanim_t * panim, float f)*

*Defined at line 828 of ./rendersystem/r_studio.cpp*

====================StudioCalcRotations

====================

### R_StudioMergeBones

*void R_StudioMergeBones(cl_entity_t * e, model_t * m_pSubModel)*

*Defined at line 875 of ./rendersystem/r_studio.cpp*

====================StudioMergeBones

====================

### R_StudioSetupBones

*void R_StudioSetupBones(cl_entity_t * e)*

*Defined at line 935 of ./rendersystem/r_studio.cpp*

====================StudioSetupBones

====================

### R_StudioSaveBones

*void R_StudioSaveBones()*

*Defined at line 1094 of ./rendersystem/r_studio.cpp*

====================StudioSaveBones

====================

### R_StudioBuildNormalTable

*void R_StudioBuildNormalTable()*

*Defined at line 1117 of ./rendersystem/r_studio.cpp*

====================StudioBuildNormalTable

NOTE: m_pSubModel must be set====================

### R_StudioGenerateNormals

*void R_StudioGenerateNormals()*

*Defined at line 1168 of ./rendersystem/r_studio.cpp*

====================StudioGenerateNormals

NOTE: m_pSubModel must be setg_studio.verts must be computed====================

### R_StudioSetupChrome

*void R_StudioSetupChrome(float * pchrome, int bone, vec3_t normal)*

*Defined at line 1263 of ./rendersystem/r_studio.cpp*

====================StudioSetupChrome

====================

### R_StudioCalcAttachments

*void R_StudioCalcAttachments()*

*Defined at line 1306 of ./rendersystem/r_studio.cpp*

====================StudioCalcAttachments

====================

### R_StudioSetupModel

*void R_StudioSetupModel(int bodypart, void ** ppbodypart, void ** ppsubmodel)*

*Defined at line 1326 of ./rendersystem/r_studio.cpp*

===============pfnStudioSetupModel

===============

### R_StudioCheckBBox

*int R_StudioCheckBBox()*

*Defined at line 1350 of ./rendersystem/r_studio.cpp*

===============R_StudioCheckBBox

===============

### R_StudioDynamicLight

*void R_StudioDynamicLight(cl_entity_t * ent, alight_t * plight)*

*Defined at line 1364 of ./rendersystem/r_studio.cpp*

===============R_StudioDynamicLight

===============

### R_StudioEntityLight

*void R_StudioEntityLight(alight_t * lightinfo)*

*Defined at line 1548 of ./rendersystem/r_studio.cpp*

===============pfnStudioEntityLight

===============

### R_StudioSetupLighting

*void R_StudioSetupLighting(alight_t * plight)*

*Defined at line 1630 of ./rendersystem/r_studio.cpp*

===============R_StudioSetupLighting

===============

### R_StudioLighting

*void R_StudioLighting(float * lv, int bone, int flags, vec3_t normal)*

*Defined at line 1660 of ./rendersystem/r_studio.cpp*

===============R_StudioLighting

===============

### R_LightLambert

*void R_LightLambert(vec4_t [4] light, vec3_t normal, vec3_t color, byte * out)*

*Defined at line 1716 of ./rendersystem/r_studio.cpp*

====================R_LightLambert

====================

### R_StudioSetColorBegin

*void R_StudioSetColorBegin(short * ptricmds, vec3_t * pstudionorms)*

*Defined at line 1759 of ./rendersystem/r_studio.cpp*

### R_StudioSetColorArray

*void R_StudioSetColorArray(short * ptricmds, vec3_t * pstudionorms, byte * color)*

*Defined at line 1782 of ./rendersystem/r_studio.cpp*

### R_LightStrength

*void R_LightStrength(int bone, vec3_t localpos, vec4_t [4] light)*

*Defined at line 1809 of ./rendersystem/r_studio.cpp*

====================R_LightStrength

====================

### R_StudioSetupSkin

*void R_StudioSetupSkin(studiohdr_t * ptexturehdr, int index)*

*Defined at line 1837 of ./rendersystem/r_studio.cpp*

===============R_StudioSetupSkin

===============

### R_StudioSetRenderamt

*void R_StudioSetRenderamt(int iRenderamt)*

*Defined at line 1880 of ./rendersystem/r_studio.cpp*

### R_StudioSetCullState

*void R_StudioSetCullState(int iCull)*

*Defined at line 1895 of ./rendersystem/r_studio.cpp*

===============R_StudioSetCullState

sets true for enable backculling (for left-hand viewmodel)===============

### R_StudioRenderShadow

*void R_StudioRenderShadow(int iSprite, float * p1, float * p2, float * p3, float * p4)*

*Defined at line 1907 of ./rendersystem/r_studio.cpp*

===============R_StudioRenderShadow

just a prefab for render shadow===============

### R_StudioMeshCompare

*int R_StudioMeshCompare(const void * a, const void * b)*

*Defined at line 1939 of ./rendersystem/r_studio.cpp*

===============R_StudioMeshCompare

Sorting opaque entities by model type===============

### R_StudioDrawNormalMesh

*void R_StudioDrawNormalMesh(short * ptricmds, vec3_t * pstudionorms, float s, float t)*

*Defined at line 1957 of ./rendersystem/r_studio.cpp*

===============R_StudioDrawNormalMesh

generic path===============

### R_StudioDrawFloatMesh

*void R_StudioDrawFloatMesh(short * ptricmds, vec3_t * pstudionorms)*

*Defined at line 1990 of ./rendersystem/r_studio.cpp*

===============R_StudioDrawNormalMesh

generic path===============

### R_StudioDrawChromeMesh

*void R_StudioDrawChromeMesh(short * ptricmds, vec3_t * pstudionorms, float s, float t, float scale)*

*Defined at line 2022 of ./rendersystem/r_studio.cpp*

===============R_StudioDrawNormalMesh

generic path===============

### R_StudioBuildIndices

*int R_StudioBuildIndices(qboolean tri_strip, int vertexState)*

*Defined at line 2067 of ./rendersystem/r_studio.cpp*

### R_StudioBuildArrayNormalMesh

*void R_StudioBuildArrayNormalMesh(short * ptricmds, vec3_t * pstudionorms, float s, float t)*

*Defined at line 2110 of ./rendersystem/r_studio.cpp*

===============R_StudioDrawNormalMesh

generic path===============

### R_StudioBuildArrayFloatMesh

*void R_StudioBuildArrayFloatMesh(short * ptricmds, vec3_t * pstudionorms)*

*Defined at line 2153 of ./rendersystem/r_studio.cpp*

===============R_StudioDrawNormalMesh

generic path===============

### R_StudioBuildArrayChromeMesh

*void R_StudioBuildArrayChromeMesh(short * ptricmds, vec3_t * pstudionorms, float s, float t, float scale)*

*Defined at line 2196 of ./rendersystem/r_studio.cpp*

===============R_StudioDrawNormalMesh

generic path===============

### R_StudioDrawArrays

*void R_StudioDrawArrays(uint startverts, uint startelems)*

*Defined at line 2253 of ./rendersystem/r_studio.cpp*

### R_StudioDrawPoints

*void R_StudioDrawPoints()*

*Defined at line 2286 of ./rendersystem/r_studio.cpp*

===============R_StudioDrawPoints

===============

### R_StudioDrawHulls

*void R_StudioDrawHulls()*

*Defined at line 2479 of ./rendersystem/r_studio.cpp*

===============R_StudioDrawHulls

===============

### R_StudioDrawAbsBBox

*void R_StudioDrawAbsBBox()*

*Defined at line 2532 of ./rendersystem/r_studio.cpp*

===============R_StudioDrawAbsBBox

===============

### R_StudioDrawBones

*void R_StudioDrawBones()*

*Defined at line 2572 of ./rendersystem/r_studio.cpp*

===============R_StudioDrawBones

===============

### R_StudioDrawAttachments

*void R_StudioDrawAttachments()*

*Defined at line 2622 of ./rendersystem/r_studio.cpp*

### R_StudioSetRemapColors

*void R_StudioSetRemapColors(int newTop, int newBottom)*

*Defined at line 2673 of ./rendersystem/r_studio.cpp*

===============R_StudioSetRemapColors

===============

### R_StudioSetupPlayerModel

*model_t * R_StudioSetupPlayerModel(int index)*

*Defined at line 2695 of ./rendersystem/r_studio.cpp*

===============R_StudioSetupPlayerModel

===============

### R_StudioClientEvents

*void R_StudioClientEvents()*

*Defined at line 2786 of ./rendersystem/r_studio.cpp*

===============R_StudioClientEvents

===============

### R_StudioGetForceFaceFlags

*int R_StudioGetForceFaceFlags()*

*Defined at line 2854 of ./rendersystem/r_studio.cpp*

===============R_StudioGetForceFaceFlags

===============

### R_StudioSetForceFaceFlags

*void R_StudioSetForceFaceFlags(int flags)*

*Defined at line 2865 of ./rendersystem/r_studio.cpp*

===============R_StudioSetForceFaceFlags

===============

### R_StudioSetHeader

*void R_StudioSetHeader(studiohdr_t * pheader)*

*Defined at line 2876 of ./rendersystem/r_studio.cpp*

===============pfnStudioSetHeader

===============

### R_StudioSetRenderModel

*void R_StudioSetRenderModel(model_t * model)*

*Defined at line 2888 of ./rendersystem/r_studio.cpp*

===============R_StudioSetRenderModel

===============

### R_StudioSetupRenderer

*void R_StudioSetupRenderer(int rendermode)*

*Defined at line 2899 of ./rendersystem/r_studio.cpp*

===============R_StudioSetupRenderer

===============

### R_StudioRestoreRenderer

*void R_StudioRestoreRenderer()*

*Defined at line 2928 of ./rendersystem/r_studio.cpp*

===============R_StudioRestoreRenderer

===============

### R_StudioSetChromeOrigin

*void R_StudioSetChromeOrigin()*

*Defined at line 2944 of ./rendersystem/r_studio.cpp*

===============R_StudioSetChromeOrigin

===============

### pfnIsHardware

*int pfnIsHardware()*

*Defined at line 2956 of ./rendersystem/r_studio.cpp*

===============pfnIsHardware

Xash3D is always works in hardware mode===============

### R_StudioDrawPointsShadow

*void R_StudioDrawPointsShadow()*

*Defined at line 2967 of ./rendersystem/r_studio.cpp*

===============R_StudioDrawPointsShadow

===============

### GL_StudioSetRenderMode

*void GL_StudioSetRenderMode(int rendermode)*

*Defined at line 3032 of ./rendersystem/r_studio.cpp*

===============GL_StudioSetRenderMode

set rendermode for studiomodel===============

### GL_StudioDrawShadow

*void GL_StudioDrawShadow()*

*Defined at line 3069 of ./rendersystem/r_studio.cpp*

===============GL_StudioDrawShadow

g-cont: don't modify this code it's 100% matched withoriginal GoldSrc code and used in some mods to enablestudio shadows with some asm tricks===============

### R_StudioRenderFinal

*void R_StudioRenderFinal()*

*Defined at line 3099 of ./rendersystem/r_studio.cpp*

====================StudioRenderFinal

====================

### R_StudioRenderModel

*void R_StudioRenderModel()*

*Defined at line 3185 of ./rendersystem/r_studio.cpp*

====================StudioRenderModel

====================

### R_StudioEstimateGait

*void R_StudioEstimateGait(entity_state_t * pplayer)*

*Defined at line 3214 of ./rendersystem/r_studio.cpp*

====================StudioEstimateGait

====================

### R_StudioProcessGait

*void R_StudioProcessGait(entity_state_t * pplayer)*

*Defined at line 3270 of ./rendersystem/r_studio.cpp*

====================StudioProcessGait

====================

### R_StudioDrawPlayer

*int R_StudioDrawPlayer(int flags, entity_state_t * pplayer)*

*Defined at line 3345 of ./rendersystem/r_studio.cpp*

===============R_StudioDrawPlayer

===============

### R_StudioDrawModel

*int R_StudioDrawModel(int flags)*

*Defined at line 3487 of ./rendersystem/r_studio.cpp*

===============R_StudioDrawModel

===============

### R_StudioDrawModelInternal

*void R_StudioDrawModelInternal(cl_entity_t * e, int flags)*

*Defined at line 3583 of ./rendersystem/r_studio.cpp*

=================R_StudioDrawModelInternal=================

### R_StudioLoadTexture

*void R_StudioLoadTexture(model_t * mod, studiohdr_t * phdr, mstudiotexture_t * ptexture)*

*Defined at line 3757 of ./rendersystem/r_studio.cpp*

====================R_StudioLoadTexture

load model texture with unique name====================

### pfnModelHandle

*model_t * pfnModelHandle(int modelindex)*

*Defined at line 3891 of ./rendersystem/r_studio.cpp*

### pfnMod_CacheCheck

*void * pfnMod_CacheCheck(struct cache_user_s * c)*

*Defined at line 3896 of ./rendersystem/r_studio.cpp*

### pfnMod_StudioExtradata

*void * pfnMod_StudioExtradata(model_t * mod)*

*Defined at line 3901 of ./rendersystem/r_studio.cpp*

### pfnMod_LoadCacheFile

*void pfnMod_LoadCacheFile(const char * path, struct cache_user_s * cu)*

*Defined at line 3906 of ./rendersystem/r_studio.cpp*

### pfnGetCvarPointer

*cvar_t * pfnGetCvarPointer(const char * name)*

*Defined at line 3911 of ./rendersystem/r_studio.cpp*

### pfnMod_Calloc

*void * pfnMod_Calloc(int number, size_t size)*

*Defined at line 3916 of ./rendersystem/r_studio.cpp*

### CreateInterface

*void * CreateInterface(const char * name, int * retcode)*

*Defined at line 4248 of ./rendersystem/r_studio.cpp*

### GetInterfaces

*iface_t * GetInterfaces(int * num)*

*Defined at line 4248 of ./rendersystem/r_studio.cpp*

### weapon_mp5

*void weapon_mp5(entvars_t * pev)*

*Defined at line 39 of ./game/shared/hl1/weapon_mp5.cpp*

### weapon_9mmAR

*void weapon_9mmAR(entvars_t * pev)*

*Defined at line 40 of ./game/shared/hl1/weapon_mp5.cpp*

### ammo_mp5clip

*void ammo_mp5clip(entvars_t * pev)*

*Defined at line 304 of ./game/shared/hl1/weapon_mp5.cpp*

### ammo_9mmAR

*void ammo_9mmAR(entvars_t * pev)*

*Defined at line 305 of ./game/shared/hl1/weapon_mp5.cpp*

### ammo_9mmbox

*void ammo_9mmbox(entvars_t * pev)*

*Defined at line 331 of ./game/shared/hl1/weapon_mp5.cpp*

### ammo_mp5grenades

*void ammo_mp5grenades(entvars_t * pev)*

*Defined at line 358 of ./game/shared/hl1/weapon_mp5.cpp*

### ammo_ARgrenades

*void ammo_ARgrenades(entvars_t * pev)*

*Defined at line 359 of ./game/shared/hl1/weapon_mp5.cpp*

### Delta_Init

*void Delta_Init()*

*Defined at line 793 of ./engine/common/net_encode.cpp*

 net_encode.c

### Delta_InitClient

*void Delta_InitClient()*

*Defined at line 846 of ./engine/common/net_encode.cpp*

### Delta_Shutdown

*void Delta_Shutdown()*

*Defined at line 865 of ./engine/common/net_encode.cpp*

### Delta_InitFields

*void Delta_InitFields()*

*Defined at line 752 of ./engine/common/net_encode.cpp*

### Delta_NumTables

*int Delta_NumTables()*

*Defined at line 330 of ./engine/common/net_encode.cpp*

### Delta_FindStructByIndex

*delta_info_t * Delta_FindStructByIndex(int index)*

*Defined at line 335 of ./engine/common/net_encode.cpp*

### Delta_AddEncoder

*void Delta_AddEncoder(char * name, pfnDeltaEncode encodeFunc)*

*Defined at line 1874 of ./engine/common/net_encode.cpp*

=============================================================================

	game.dll interface

=============================================================================

### Delta_FindField

*int Delta_FindField(delta_t * pFields, const char * fieldname)*

*Defined at line 1896 of ./engine/common/net_encode.cpp*

### Delta_SetField

*void Delta_SetField(delta_t * pFields, const char * fieldname)*

*Defined at line 1914 of ./engine/common/net_encode.cpp*

### Delta_UnsetField

*void Delta_UnsetField(delta_t * pFields, const char * fieldname)*

*Defined at line 1934 of ./engine/common/net_encode.cpp*

### Delta_SetFieldByIndex

*void Delta_SetFieldByIndex(delta_t * pFields, int fieldNumber)*

*Defined at line 1954 of ./engine/common/net_encode.cpp*

### Delta_UnsetFieldByIndex

*void Delta_UnsetFieldByIndex(delta_t * pFields, int fieldNumber)*

*Defined at line 1965 of ./engine/common/net_encode.cpp*

### Delta_WriteTableField

*void Delta_WriteTableField(sizebuf_t * msg, int tableIndex, const delta_t * pField)*

*Defined at line 474 of ./engine/common/net_encode.cpp*

 send table over network

### Delta_ParseTableField

*void Delta_ParseTableField(sizebuf_t * msg)*

*Defined at line 512 of ./engine/common/net_encode.cpp*

### MSG_WriteDeltaUsercmd

*void MSG_WriteDeltaUsercmd(sizebuf_t * msg, usercmd_t * from, usercmd_t * to)*

*Defined at line 1323 of ./engine/common/net_encode.cpp*

=============================================================================

usercmd_t communication

=============================================================================

=====================MSG_WriteDeltaUsercmd=====================

### MSG_ReadDeltaUsercmd

*void MSG_ReadDeltaUsercmd(sizebuf_t * msg, usercmd_t * from, usercmd_t * to)*

*Defined at line 1350 of ./engine/common/net_encode.cpp*

=====================MSG_ReadDeltaUsercmd=====================

### MSG_WriteDeltaEvent

*void MSG_WriteDeltaEvent(sizebuf_t * msg, event_args_t * from, event_args_t * to)*

*Defined at line 1385 of ./engine/common/net_encode.cpp*

============================================================================

event_args_t communication

============================================================================

=====================MSG_WriteDeltaEvent=====================

### MSG_ReadDeltaEvent

*void MSG_ReadDeltaEvent(sizebuf_t * msg, event_args_t * from, event_args_t * to)*

*Defined at line 1412 of ./engine/common/net_encode.cpp*

=====================MSG_ReadDeltaEvent=====================

### MSG_WriteDeltaMovevars

*qboolean MSG_WriteDeltaMovevars(sizebuf_t * msg, movevars_t * from, movevars_t * to)*

*Defined at line 1440 of ./engine/common/net_encode.cpp*

=============================================================================

movevars_t communication

=============================================================================

### MSG_ReadDeltaMovevars

*void MSG_ReadDeltaMovevars(sizebuf_t * msg, movevars_t * from, movevars_t * to)*

*Defined at line 1476 of ./engine/common/net_encode.cpp*

### MSG_WriteClientData

*void MSG_WriteClientData(sizebuf_t * msg, clientdata_t * from, clientdata_t * to, float timebase)*

*Defined at line 1512 of ./engine/common/net_encode.cpp*

=============================================================================

clientdata_t communication

=============================================================================

==================MSG_WriteClientData

Writes current client data only for local clientOther clients can grab the client state from entity_state_t==================

### MSG_ReadClientData

*void MSG_ReadClientData(sizebuf_t * msg, clientdata_t * from, clientdata_t * to, float timebase)*

*Defined at line 1552 of ./engine/common/net_encode.cpp*

==================MSG_ReadClientData

Read the clientdata==================

### MSG_WriteWeaponData

*void MSG_WriteWeaponData(sizebuf_t * msg, weapon_data_t * from, weapon_data_t * to, float timebase, int index)*

*Defined at line 1593 of ./engine/common/net_encode.cpp*

=============================================================================

weapon_data_t communication

=============================================================================

==================MSG_WriteWeaponData

Writes current client data only for local clientOther clients can grab the client state from entity_state_t==================

### MSG_ReadWeaponData

*void MSG_ReadWeaponData(sizebuf_t * msg, weapon_data_t * from, weapon_data_t * to, float timebase)*

*Defined at line 1632 of ./engine/common/net_encode.cpp*

==================MSG_ReadWeaponData

Read the clientdata==================

### MSG_WriteDeltaEntity

*void MSG_WriteDeltaEntity(entity_state_t * from, entity_state_t * to, sizebuf_t * msg, qboolean force, int type, float tbase, int ofs)*

*Defined at line 1671 of ./engine/common/net_encode.cpp*

=============================================================================

entity_state_t communication

=============================================================================

==================MSG_WriteDeltaEntity

Writes part of a packetentities message, including the entity number.Can delta from either a baseline or a previous packet_entityIf to is NULL, a remove entity update will be sentIf force is not set, then nothing at all will be generated if the entity isidentical, under the assumption that the in-order delta code will catch it.==================

### MSG_ReadDeltaEntity

*qboolean MSG_ReadDeltaEntity(sizebuf_t * msg, entity_state_t * from, entity_state_t * to, int num, int type, float timebase)*

*Defined at line 1773 of ./engine/common/net_encode.cpp*

==================MSG_ReadDeltaEntity

The entity number has already been read from the message, whichis how the from state is identified.

If the delta removes the entity, entity_state_t->number will be set to MAX_EDICTSCan go from either a baseline or a previous packet_entity==================

### Delta_TestBaseline

*int Delta_TestBaseline(entity_state_t * from, entity_state_t * to, qboolean player, float timebase)*

*Defined at line 1047 of ./engine/common/net_encode.cpp*

=====================Delta_TestBaseline

compare baselines to find optimal=====================

### CL_CalcPlayerVelocity

*void CL_CalcPlayerVelocity(int idx, vec3_t velocity)*

*Defined at line 43 of ./engine/client/cl_events.cpp*

=============CL_CalcPlayerVelocity

compute velocity for a given client=============

### CL_DescribeEvent

*void CL_DescribeEvent(int slot, int flags, const char * eventname)*

*Defined at line 81 of ./engine/client/cl_events.cpp*

=============CL_DescribeEvent

=============

### CL_FireEvent

*qboolean CL_FireEvent(event_info_t * ei, int slot)*

*Defined at line 180 of ./engine/client/cl_events.cpp*

=============CL_FireEvent

=============

### CL_FindEmptyEvent

*event_info_t * CL_FindEmptyEvent()*

*Defined at line 259 of ./engine/client/cl_events.cpp*

=============CL_FindEvent

find first empty event=============

### CL_FindUnreliableEvent

*event_info_t * CL_FindUnreliableEvent()*

*Defined at line 287 of ./engine/client/cl_events.cpp*

=============CL_FindEvent

replace only unreliable events=============

### mpg123_par

*int mpg123_par(mpg123_parm_t * mp, enum mpg123_parms key, long val)*

*Defined at line 86 of ./engine/common/soundlib/libmpg/mpg123.cpp*

### mpg123_close

*int mpg123_close(mpg123_handle_t * mh)*

*Defined at line 192 of ./engine/common/soundlib/libmpg/mpg123.cpp*

### decode_update

*int decode_update(mpg123_handle_t * mh)*

*Defined at line 266 of ./engine/common/soundlib/libmpg/mpg123.cpp*

 update decoding engine for a) a new choice of decoder b) a changed native format of the MPEG stream ... calls are only valid after parsing some MPEG frame!

### mpg123_safe_buffer

*size_t mpg123_safe_buffer()*

*Defined at line 323 of ./engine/common/soundlib/libmpg/mpg123.cpp*

### mpg123_outblock

*size_t mpg123_outblock(mpg123_handle_t * mh)*

*Defined at line 329 of ./engine/common/soundlib/libmpg/mpg123.cpp*

### get_next_frame

*int get_next_frame(mpg123_handle_t * mh)*

*Defined at line 339 of ./engine/common/soundlib/libmpg/mpg123.cpp*

 read in the next frame we actually want for decoding. this includes skipping/ignoring frames, in additon to skipping junk in the parser.

### init_track

*int init_track(mpg123_handle_t * mh)*

*Defined at line 441 of ./engine/common/soundlib/libmpg/mpg123.cpp*

### sample_adjust

*mpg_off_t sample_adjust(mpg123_handle_t * mh, mpg_off_t x)*

*Defined at line 454 of ./engine/common/soundlib/libmpg/mpg123.cpp*

 from internal sample number to external.

### sample_unadjust

*mpg_off_t sample_unadjust(mpg123_handle_t * mh, mpg_off_t x)*

*Defined at line 479 of ./engine/common/soundlib/libmpg/mpg123.cpp*

 from external samples to internal

### frame_buffercheck

*void frame_buffercheck(mpg123_handle_t * fr)*

*Defined at line 500 of ./engine/common/soundlib/libmpg/mpg123.cpp*

 take the buffer after a frame decode (strictly: it is the data from frame fr->num!) and cut samples out. fr->buffer.fill may then be smaller than before...

### decode_the_frame

*void decode_the_frame(mpg123_handle_t * fr)*

*Defined at line 548 of ./engine/common/soundlib/libmpg/mpg123.cpp*

 not part of the api. This just decodes the frame and fills missing bits with zeroes. there can be frames that are broken and thus make do_layer() fail.

### mpg123_scan

*int mpg123_scan(mpg123_handle_t * mh)*

*Defined at line 700 of ./engine/common/soundlib/libmpg/mpg123.cpp*

### do_the_seek

*int do_the_seek(mpg123_handle_t * mh)*

*Defined at line 797 of ./engine/common/soundlib/libmpg/mpg123.cpp*

### get_error

*const char * get_error(mpg123_handle_t * mh)*

*Defined at line 969 of ./engine/common/soundlib/libmpg/mpg123.cpp*

### respawn

*void respawn(entvars_t * pev, BOOL fCopyCorpse)*

*Defined at line 137 of ./game/server/client.cpp*

 called by ClientKill and DeadThink

### ClientConnect

*BOOL ClientConnect(edict_t * pEntity, const char * pszName, const char * pszAddress, char [128] szRejectReason)*

*Defined at line 88 of ./game/server/client.cpp*

===========ClientConnect

called when a player connects to a server============

### ClientDisconnect

*void ClientDisconnect(edict_t * pEntity)*

*Defined at line 106 of ./game/server/client.cpp*

===========ClientDisconnect

called when a player disconnects from a server

GLOBALS ASSUMED SET:  g_fGameOver============

### ClientKill

*void ClientKill(edict_t * pEntity)*

*Defined at line 165 of ./game/server/client.cpp*

============ClientKill

Player entered the suicide command

GLOBALS ASSUMED SET:  g_ulModelIndexPlayer============

### ClientPutInServer

*void ClientPutInServer(edict_t * pEntity)*

*Defined at line 192 of ./game/server/client.cpp*

===========ClientPutInServer

called each time a player is spawned============

### ClientCommand

*void ClientCommand(edict_t * pEntity)*

*Defined at line 473 of ./game/server/client.cpp*

 Use CMD_ARGV,  CMD_ARGV, and CMD_ARGC to get pointers the character string command.

### ClientUserInfoChanged

*void ClientUserInfoChanged(edict_t * pEntity, char * infobuffer)*

*Defined at line 641 of ./game/server/client.cpp*

========================ClientUserInfoChanged

called after the player changesuserinfo - gives dll a chance to modify it beforeit gets sent into the rest of the engine.========================

### ServerActivate

*void ServerActivate(edict_t * pEdictList, int edictCount, int clientMax)*

*Defined at line 719 of ./game/server/client.cpp*

### ServerDeactivate

*void ServerDeactivate()*

*Defined at line 702 of ./game/server/client.cpp*

### StartFrame

*void StartFrame()*

*Defined at line 805 of ./game/server/client.cpp*

 GLOBALS ASSUMED SET:  g_ulFrameCount

### PlayerPostThink

*void PlayerPostThink(edict_t * pEntity)*

*Defined at line 779 of ./game/server/client.cpp*

================PlayerPostThink

Called every frame after physics are run================

### PlayerPreThink

*void PlayerPreThink(edict_t * pEntity)*

*Defined at line 762 of ./game/server/client.cpp*

================PlayerPreThink

Called every frame before physics are run================

### ParmsNewLevel

*void ParmsNewLevel()*

*Defined at line 789 of ./game/server/client.cpp*

### ParmsChangeLevel

*void ParmsChangeLevel()*

*Defined at line 793 of ./game/server/client.cpp*

### ClientPrecache

*void ClientPrecache()*

*Defined at line 828 of ./game/server/client.cpp*

### GetGameDescription

*const char * GetGameDescription()*

*Defined at line 947 of ./game/server/client.cpp*

===============GetGameDescription

Returns the descriptive name of this .dll.  E.g., Half-Life, or Team Fortress 2===============

### PlayerCustomization

*void PlayerCustomization(edict_t * pEntity, customization_t * pCust)*

*Defined at line 976 of ./game/server/client.cpp*

================PlayerCustomization

A new player customization has been registered on the serverUNDONE:  This only sets the # of frames of the spray can logoanimation right now.================

### SpectatorConnect

*void SpectatorConnect(edict_t * pEntity)*

*Defined at line 1015 of ./game/server/client.cpp*

================SpectatorConnect

A spectator has joined the game================

### SpectatorDisconnect

*void SpectatorDisconnect(edict_t * pEntity)*

*Defined at line 1030 of ./game/server/client.cpp*

================SpectatorConnect

A spectator has left the game================

### SpectatorThink

*void SpectatorThink(edict_t * pEntity)*

*Defined at line 1045 of ./game/server/client.cpp*

================SpectatorConnect

A spectator has sent a usercmd================

### Sys_Error

*void Sys_Error(const char * error_string)*

*Defined at line 962 of ./game/server/client.cpp*

================Sys_Error

Engine is going to shut down, allows setting a breakpoint in game .dll to catch that occasion================

### SetupVisibility

*void SetupVisibility(edict_t * pViewEntity, edict_t * pClient, unsigned char ** pvs, unsigned char ** pas)*

*Defined at line 1071 of ./game/server/client.cpp*

================SetupVisibility

A client can have a separate "view entity" indicating that his/her view should depend on the origin of thatview entity.  If that's the case, then pViewEntity will be non-NULL and will be used.  Otherwise, the currententity's origin is used.  Either is offset by the view_ofs to get the eye position.

From the eye position, we set up the PAS and PVS to use for filtering network messages to the client.  At this point, we could override the actual PAS or PVS values, or use a different origin.

NOTE:  Do not cache the values of pas and pvs, as they depend on reusable memory in the engine, they are only good for this one frame================

### UpdateClientData

*void UpdateClientData(const struct edict_s * ent, int sendweapons, struct clientdata_s * cd)*

*Defined at line 1698 of ./game/server/client.cpp*

=================UpdateClientData

Data sent to current client onlyengine sets cd to 0 before calling.=================

### AddToFullPack

*int AddToFullPack(struct entity_state_s * state, int e, edict_t * ent, edict_t * host, int hostflags, int player, unsigned char * pSet)*

*Defined at line 1125 of ./game/server/client.cpp*

AddToFullPack

Return 1 if the entity state has been filled in for the ent and the entity will be propagated to the client, 0 otherwise

state is the server maintained copy of the state info that is transmitted to the clienta MOD could alter values copied into state to send the "host" a different look for a particular entity update, etc.e and ent are the entity that is being added to the update, if 1 is returnedhost is the player's edict of the player whom we are sending the update toplayer is 1 if the ent/e is a player and 0 otherwisepSet is either the PAS or PVS that we previous set up.  We can use it to ask the engine to filter the entity against the PAS or PVS.we could also use the pas/ pvs that we set in SetupVisibility, if we wanted to.  Caching the value is valid in that case, but still only for the current frame

### CreateBaseline

*void CreateBaseline(int player, int eindex, struct entity_state_s * baseline, struct edict_s * entity, int playermodelindex, Vector player_mins, Vector player_maxs)*

*Defined at line 1326 of ./game/server/client.cpp*

===================CreateBaseline

Creates baselines used for network encoding, especially for player data since players are not spawned until connect time.===================

### RegisterEncoders

*void RegisterEncoders()*

*Defined at line 1620 of ./game/server/client.cpp*

=================RegisterEncoders

Allows game .dll to override network encoding of certain types of entities and tweak values, etc.=================

### GetWeaponData

*int GetWeaponData(struct edict_s * player, struct weapon_data_s * info)*

*Defined at line 1627 of ./game/server/client.cpp*

### CmdStart

*void CmdStart(const edict_t * player, const struct usercmd_s * cmd, unsigned int random_seed)*

*Defined at line 1811 of ./game/server/client.cpp*

=================CmdStart

We're about to run this usercmd for the specified player.  We can set up groupinfo and masking here, etc.This is the time to examine the usercmd for anything extra.  This call happens even if think does not.=================

### CmdEnd

*void CmdEnd(const edict_t * player)*

*Defined at line 1834 of ./game/server/client.cpp*

=================CmdEnd

Each cmdstart is exactly matched with a cmd end, clean up any group trace flags, etc. here=================

### ConnectionlessPacket

*int ConnectionlessPacket(const struct netadr_s * net_from, const char * args, char * response_buffer, int * response_buffer_size)*

*Defined at line 1855 of ./game/server/client.cpp*

================================ConnectionlessPacket

 Return 1 if the packet is valid.  Set response_buffer_size if you want to send a response packet.  Incoming, it holds the max  size of the response_buffer, so you must zero it out if you choose not to respond.================================

### GetHullBounds

*int GetHullBounds(int hullnumber, float * mins, float * maxs)*

*Defined at line 1876 of ./game/server/client.cpp*

================================GetHullBounds

  Engine calls this to enumerate player collision hulls, for prediction.  Return 0 if the hullnumber doesn't exist.================================

### CreateInstancedBaselines

*void CreateInstancedBaselines()*

*Defined at line 1910 of ./game/server/client.cpp*

================================CreateInstancedBaselines

Create pseudo-baselines for items that aren't placed in the map at spawn time, but which are likelyto be created during play ( e.g., grenades, ammo packs, projectiles, corpses, etc. )================================

### InconsistentFile

*int InconsistentFile(const edict_t * player, const char * filename, char * disconnect_message)*

*Defined at line 1932 of ./game/server/client.cpp*

================================InconsistentFile

One of the ENGINE_FORCE_UNMODIFIED files failed the consistency check for the specified player Return 0 to allow the client to continue, 1 to force immediate disconnection ( with an optional disconnect message of up to 256 characters )================================

### AllowLagCompensation

*int AllowLagCompensation()*

*Defined at line 1956 of ./game/server/client.cpp*

================================AllowLagCompensation

 The game .dll should return 1 if lag compensation should be allowed ( could also just set  the sv_unlag cvar. Most games right now should return 0, until client-side weapon prediction code is written  and tested for them ( note you can predict weapons, but not do lag compensation, too,   if you want.================================

### SetObjectCollisionBox

*void SetObjectCollisionBox(entvars_t * pev)*

*Defined at line 609 of ./game/server/cbase.cpp*

 Initialize absmin & absmax to the appropriate box

### FindGlobalEntity

*class CBaseEntity * FindGlobalEntity(string_t classname, string_t globalname)*

*Defined at line 462 of ./game/server/cbase.cpp*

 Find the matching global entity.  Spit out an error if the designer made entities of different classes with the same global name

### weapon_python

*void weapon_python(entvars_t * pev)*

*Defined at line 37 of ./game/shared/hl1/weapon_python.cpp*

### weapon_357

*void weapon_357(entvars_t * pev)*

*Defined at line 38 of ./game/shared/hl1/weapon_python.cpp*

### ammo_357

*void ammo_357(entvars_t * pev)*

*Defined at line 308 of ./game/shared/hl1/weapon_python.cpp*

### R_Mem_Alloc

*void * R_Mem_Alloc(size_t cb, const char * filename, const int fileline)*

*Defined at line 39 of ./engine/client/cl_render.cpp*

### R_Mem_Free

*void R_Mem_Free(void * mem, const char * filename, const int fileline)*

*Defined at line 44 of ./engine/client/cl_render.cpp*

### pfnGetFilesList

*char ** pfnGetFilesList(const char * pattern, int * numFiles, int gamedironly)*

*Defined at line 56 of ./engine/client/cl_render.cpp*

=========pfnGetFilesList

=========

### pfnFileBufferCRC32

*uint pfnFileBufferCRC32(const void * buffer, const int length)*

*Defined at line 74 of ./engine/client/cl_render.cpp*

### R_EnvShot

*void R_EnvShot(const float * vieworg, const char * name, qboolean skyshot, int shotsize)*

*Defined at line 92 of ./engine/client/cl_render.cpp*

=================R_EnvShot

=================

### CL_GenericHandle

*const char * CL_GenericHandle(int fileindex)*

*Defined at line 131 of ./engine/client/cl_render.cpp*

=============CL_GenericHandle

=============

### pfnRenderGetParm

*int pfnRenderGetParm(int parm, int arg)*

*Defined at line 209 of ./engine/client/cl_render.cpp*

### R_FillRenderAPIFromRef

*void R_FillRenderAPIFromRef(render_api_t * to, const ref_interface_t * from)*

*Defined at line 283 of ./engine/client/cl_render.cpp*

### ANDROID_LoadLibrary

*void * ANDROID_LoadLibrary(const char * dllname)*

### ANDROID_GetProcAddress

*void * ANDROID_GetProcAddress(void * hInstance, const char * name)*

### FS_AddSideToPack

*qboolean FS_AddSideToPack(const char * name, int adjust_flags)*

*Defined at line 165 of ./engine/common/imagelib/img_main.cpp*

================FS_AddSideToPack

================

### synth_1to1

*int synth_1to1(float * bandPtr, int channel, mpg123_handle_t * fr, int final)*

*Defined at line 28 of ./engine/common/soundlib/libmpg/synth.cpp*

 main synth function, uses the plain dct64

### synth_stereo

*int synth_stereo(float * bandPtr_l, float * bandPtr_r, mpg123_handle_t * fr)*

*Defined at line 140 of ./engine/common/soundlib/libmpg/synth.cpp*

 the call of left and right plain synth, wrapped. this may be replaced by a direct stereo optimized synth.

### synth_1to1_m2s

*int synth_1to1_m2s(float * bandPtr, mpg123_handle_t * fr)*

*Defined at line 150 of ./engine/common/soundlib/libmpg/synth.cpp*

 mono to stereo synth, wrapping over synth_1to1

### synth_1to1_mono

*int synth_1to1_mono(float * bandPtr, mpg123_handle_t * fr)*

*Defined at line 168 of ./engine/common/soundlib/libmpg/synth.cpp*

 mono synth, wrapping over synth_1to1

### find_synth

*int find_synth(func_synth synth, const func_synth [1][1] synths)*

*Defined at line 219 of ./engine/common/soundlib/libmpg/synth.cpp*

### find_dectype

*int find_dectype(mpg123_handle_t * fr)*

*Defined at line 247 of ./engine/common/soundlib/libmpg/synth.cpp*

 determine what kind of decoder is actually active this depends on runtime choices which may cause fallback to i386 or generic code.

### weapon_glock

*void weapon_glock(entvars_t * pev)*

*Defined at line 38 of ./game/shared/hl1/weapon_glock.cpp*

### weapon_9mmhandgun

*void weapon_9mmhandgun(entvars_t * pev)*

*Defined at line 39 of ./game/shared/hl1/weapon_glock.cpp*

### ammo_glockclip

*void ammo_glockclip(entvars_t * pev)*

*Defined at line 260 of ./game/shared/hl1/weapon_glock.cpp*

### ammo_9mmclip

*void ammo_9mmclip(entvars_t * pev)*

*Defined at line 261 of ./game/shared/hl1/weapon_glock.cpp*

### UI_PlayerSetup_Precache

*void UI_PlayerSetup_Precache()*

*Defined at line 489 of ./mainui/menus/PlayerSetup.cpp*

=================UI_PlayerSetup_Precache=================

### UTIL_LogPrintf

*void UTIL_LogPrintf(char * )*

*Defined at line 67 of ./game/client/hl/hl_baseentity.cpp*

### ShouldSimplify

*int ShouldSimplify(int routeType)*

*Defined at line 121 of ./game/client/hl/hl_baseentity.cpp*

### ExplosionCreate

*void ExplosionCreate(const class Vector & center, const class Vector & angles, edict_t * pOwner, int magnitude, BOOL doDamage)*

*Defined at line 267 of ./game/server/explode.cpp*

 HACKHACK -- create one of these and fake a keyvalue to get the right explosion setup

### TrainSpeed

*int TrainSpeed(int iSpeed, int iMax)*

*Defined at line 220 of ./game/client/hl/hl_baseentity.cpp*

### func_tank

*void func_tank(entvars_t * pev)*

*Defined at line 707 of ./game/server/func_tank.cpp*

### FindEntityForward

*class CBaseEntity * FindEntityForward(class CBaseEntity * pMe)*

*Defined at line 251 of ./game/client/hl/hl_baseentity.cpp*

### func_tanklaser

*void func_tanklaser(entvars_t * pev)*

*Defined at line 765 of ./game/server/func_tank.cpp*

### AddAmmoNameToAmmoRegistry

*void AddAmmoNameToAmmoRegistry(const char * szAmmoname)*

*Defined at line 292 of ./game/client/hl/hl_baseentity.cpp*

 Precaches the ammo and queues the ammo info for sending to clients

### func_tankrocket

*void func_tankrocket(entvars_t * pev)*

*Defined at line 876 of ./game/server/func_tank.cpp*

### func_tankmortar

*void func_tankmortar(entvars_t * pev)*

*Defined at line 911 of ./game/server/func_tank.cpp*

### func_tankcontrols

*void func_tankcontrols(entvars_t * pev)*

*Defined at line 966 of ./game/server/func_tank.cpp*

### VOX_LoadWord

*void VOX_LoadWord(channel_t * pchan)*

*Defined at line 346 of ./engine/client/s_vox.cpp*

### VOX_FreeWord

*void VOX_FreeWord(channel_t * pchan)*

*Defined at line 382 of ./engine/client/s_vox.cpp*

### S_InitScaletable

*void S_InitScaletable()*

*Defined at line 44 of ./engine/client/s_mix.cpp*

### S_LoadSound

*wavdata_t * S_LoadSound(sfx_t * sfx)*

*Defined at line 127 of ./engine/client/s_load.cpp*

=================S_LoadSound=================

### S_GetMasterVolume

*float S_GetMasterVolume()*

*Defined at line 62 of ./engine/client/s_main.cpp*

=============================================================================

		SOUNDS PROCESSING

=============================================================================

=================S_GetMasterVolume=================

### S_GetMusicVolume

*float S_GetMusicVolume()*

*Defined at line 56 of ./engine/client/s_stream.cpp*

=================S_GetMusicVolume=================

### S_FreeChannel

*void S_FreeChannel(channel_t * ch)*

*Defined at line 108 of ./engine/client/s_main.cpp*

 free channel so that it may be allocated by the next request to play a sound.  If sound is a  word in a sentence, release the sentence. Works for static, dynamic, sentence and stream sounds

=================S_FreeChannel=================

 s_main.c

### S_MixDataToDevice

*int S_MixDataToDevice(channel_t * pChannel, int sampleCount, int outputRate, int outputOffset, int timeCompress)*

*Defined at line 422 of ./engine/client/s_mix.cpp*

 s_mix.c

### MIX_ClearAllPaintBuffers

*void MIX_ClearAllPaintBuffers(int SampleCount, qboolean clearFilters)*

*Defined at line 810 of ./engine/client/s_mix.cpp*

 zero out all paintbuffers

### MIX_InitAllPaintbuffers

*void MIX_InitAllPaintbuffers()*

*Defined at line 198 of ./engine/client/s_mix.cpp*

 Initialize paintbuffers array, set current paint buffer to main output buffer IPAINTBUFFER

### MIX_FreeAllPaintbuffers

*void MIX_FreeAllPaintbuffers()*

*Defined at line 191 of ./engine/client/s_mix.cpp*

### MIX_PaintChannels

*void MIX_PaintChannels(int endtime)*

*Defined at line 1015 of ./engine/client/s_mix.cpp*

### S_TestSoundChar

*qboolean S_TestSoundChar(const char * pch, char c)*

*Defined at line 71 of ./engine/client/s_load.cpp*

 return true if char 'c' is one of 1st 2 characters in pch

 s_load.c

### S_SkipSoundChar

*char * S_SkipSoundChar(const char * pch)*

*Defined at line 90 of ./engine/client/s_load.cpp*

 return pointer to first valid character in file name

### S_FindName

*sfx_t * S_FindName(const char * name, int * pfInCache)*

*Defined at line 172 of ./engine/client/s_load.cpp*

 ======================================================================= Load a sound =======================================================================

==================S_FindName

==================

### S_FreeSound

*void S_FreeSound(sfx_t * sfx)*

*Defined at line 234 of ./engine/client/s_load.cpp*

==================S_FreeSound==================

### S_InitSounds

*void S_InitSounds()*

*Defined at line 375 of ./engine/client/s_load.cpp*

=================S_InitSounds=================

### SX_Init

*void SX_Init()*

*Defined at line 182 of ./engine/client/s_dsp.cpp*

 s_dsp.c

============SX_Init()

Starts sound crackling system============

### SX_Free

*void SX_Free()*

*Defined at line 246 of ./engine/client/s_dsp.cpp*

==========SX_Shutdown

Stop DSP processor==========

### CheckNewDspPresets

*void CheckNewDspPresets()*

*Defined at line 812 of ./engine/client/s_dsp.cpp*

===========CheckNewDspPresets

(xash dsp interface)===========

### DSP_Process

*void DSP_Process(int idsp, portable_samplepair_t * pbfront, int sampleCount)*

*Defined at line 774 of ./engine/client/s_dsp.cpp*

===========DSP_Process

(xash dsp interface)===========

### DSP_GetGain

*float DSP_GetGain(int idsp)*

### DSP_ClearState

*void DSP_ClearState()*

*Defined at line 799 of ./engine/client/s_dsp.cpp*

===========DSP_ClearState

(xash dsp interface)===========

### S_SoundList_f

*void S_SoundList_f()*

*Defined at line 38 of ./engine/client/s_load.cpp*

=================S_SoundList_f=================

### S_SoundInfo_f

*void S_SoundInfo_f()*

*Defined at line 1793 of ./engine/client/s_main.cpp*

=================S_SoundInfo_f=================

### SND_PickDynamicChannel

*channel_t * SND_PickDynamicChannel(int entnum, int channel, sfx_t * sfx, qboolean * ignore)*

*Defined at line 208 of ./engine/client/s_main.cpp*

=================SND_PickDynamicChannel

Select a channel from the dynamic channel allocation area.  For the given entity, override any other sound playing on the same channel (see code comments below forexceptions).=================

### SND_PickStaticChannel

*channel_t * SND_PickStaticChannel(const vec3_t pos, sfx_t * sfx)*

*Defined at line 298 of ./engine/client/s_main.cpp*

=====================SND_PickStaticChannel

Pick an empty channel from the static sound area, or allocate a newchannel.  Only fails if we're at max_channels (128!!!) or if we're trying to allocate a channel for a stream sound that is already playing.=====================

### S_GetCurrentDynamicSounds

*int S_GetCurrentDynamicSounds(soundlist_t * pout, int size)*

*Defined at line 868 of ./engine/client/s_main.cpp*

==================S_GetCurrentStaticSounds

grab all static sounds playing at current channel==================

### S_GetSfxByHandle

*sfx_t * S_GetSfxByHandle(sound_t handle)*

*Defined at line 355 of ./engine/client/s_load.cpp*

### S_FindRawChannel

*rawchan_t * S_FindRawChannel(int entnum, qboolean create)*

*Defined at line 999 of ./engine/client/s_main.cpp*

=============================================================================

		SOUND STREAM RAW SAMPLES

=============================================================================

===================S_FindRawChannel===================

### S_RawSamples

*void S_RawSamples(uint samples, uint rate, word width, word channels, const byte * data, int entnum)*

*Defined at line 1148 of ./engine/client/s_main.cpp*

===================S_RawSamples===================

### S_UpdateFrame

*void S_UpdateFrame(struct ref_viewpass_s * rvp)*

*Defined at line 1507 of ./engine/client/s_main.cpp*

============S_UpdateFrame

update listener position============

### S_GetRawSamplesLength

*uint S_GetRawSamplesLength(int entnum)*

*Defined at line 1243 of ./engine/client/s_main.cpp*

===================S_GetRawSamplesLength===================

### S_ClearRawChannel

*void S_ClearRawChannel(int entnum)*

*Defined at line 1258 of ./engine/client/s_main.cpp*

===================S_ClearRawChannel===================

### S_FreeSounds

*void S_FreeSounds()*

*Defined at line 391 of ./engine/client/s_load.cpp*

=================S_FreeSounds=================

### SND_InitMouth

*void SND_InitMouth(int entnum, int entchannel)*

*Defined at line 23 of ./engine/client/s_mouth.cpp*

 s_mouth.c

### SND_MoveMouth8

*void SND_MoveMouth8(channel_t * ch, wavdata_t * pSource, int count)*

*Defined at line 57 of ./engine/client/s_mouth.cpp*

### SND_MoveMouth16

*void SND_MoveMouth16(channel_t * ch, wavdata_t * pSource, int count)*

*Defined at line 105 of ./engine/client/s_mouth.cpp*

### SND_CloseMouth

*void SND_CloseMouth(channel_t * ch)*

*Defined at line 41 of ./engine/client/s_mouth.cpp*

### S_StreamSoundTrack

*void S_StreamSoundTrack()*

*Defined at line 288 of ./engine/client/s_stream.cpp*

 s_stream.c

=================S_StreamSoundTrack=================

### S_StreamBackgroundTrack

*void S_StreamBackgroundTrack()*

*Defined at line 174 of ./engine/client/s_stream.cpp*

=================S_StreamBackgroundTrack=================

### S_PrintBackgroundTrackState

*void S_PrintBackgroundTrackState()*

*Defined at line 28 of ./engine/client/s_stream.cpp*

=================S_PrintBackgroundTrackState=================

### S_ZeroCrossingAfter

*int S_ZeroCrossingAfter(wavdata_t * pWaveData, int sample)*

*Defined at line 125 of ./engine/client/s_utils.cpp*

 s_utils.c

----------------------------------------------------------------------------- Purpose: Search forward for a zero crossing Input  : sample - starting point Output : position of found zero crossing-----------------------------------------------------------------------------

### S_ZeroCrossingBefore

*int S_ZeroCrossingBefore(wavdata_t * pWaveData, int sample)*

*Defined at line 28 of ./engine/client/s_utils.cpp*

----------------------------------------------------------------------------- Purpose: Search backward for a zero crossing starting at sample Input  : sample - starting point Output : position of zero crossing-----------------------------------------------------------------------------

### S_GetOutputData

*int S_GetOutputData(wavdata_t * pSource, void ** pData, int samplePosition, int sampleCount, qboolean use_loop)*

*Defined at line 247 of ./engine/client/s_utils.cpp*

### S_SetSampleStart

*void S_SetSampleStart(channel_t * pChan, wavdata_t * pSource, int newPosition)*

*Defined at line 284 of ./engine/client/s_utils.cpp*

 move the current position to newPosition

### S_SetSampleEnd

*void S_SetSampleEnd(channel_t * pChan, wavdata_t * pSource, int newEndPosition)*

*Defined at line 293 of ./engine/client/s_utils.cpp*

 end playback at newEndPosition

### VOX_Init

*void VOX_Init()*

*Defined at line 676 of ./engine/client/s_vox.cpp*

 s_vox.c

### VOX_Shutdown

*void VOX_Shutdown()*

*Defined at line 685 of ./engine/client/s_vox.cpp*

### VOX_SetChanVol

*void VOX_SetChanVol(channel_t * ch)*

*Defined at line 207 of ./engine/client/s_vox.cpp*

### VOX_LoadSound

*void VOX_LoadSound(channel_t * pchan, const char * psz)*

*Defined at line 452 of ./engine/client/s_vox.cpp*

 link all sounds in sentence, start playing first word.

### VOX_ModifyPitch

*float VOX_ModifyPitch(channel_t * ch, float pitch)*

*Defined at line 221 of ./engine/client/s_vox.cpp*

### VOX_MixDataToDevice

*int VOX_MixDataToDevice(channel_t * pChannel, int sampleCount, int outputRate, int outputOffset)*

*Defined at line 419 of ./engine/client/s_vox.cpp*

 return number of samples mixed

### CL_PrepareTEnt

*void CL_PrepareTEnt(TEMPENTITY * pTemp, model_t * pmodel)*

*Defined at line 258 of ./engine/client/cl_tent.cpp*

==============CL_PrepareTEnt

set default values==============

### CL_TempEntPlaySound

*void CL_TempEntPlaySound(TEMPENTITY * pTemp, float damp)*

*Defined at line 299 of ./engine/client/cl_tent.cpp*

==============CL_TempEntPlaySound

play collide sound==============

### CL_TempEntAddEntity

*int CL_TempEntAddEntity(cl_entity_t * pEntity)*

*Defined at line 383 of ./engine/client/cl_tent.cpp*

==============CL_TEntAddEntity

add entity to renderlist==============

### CL_FreeLowPriorityTempEnt

*qboolean CL_FreeLowPriorityTempEnt()*

*Defined at line 435 of ./engine/client/cl_tent.cpp*

==============CL_TEntAddEntity

free the first low priority tempent it finds.==============

### CL_ClearLightStyles

*void CL_ClearLightStyles()*

*Defined at line 2414 of ./engine/client/cl_tent.cpp*

================CL_ClearLightStyles================

### CL_ClearDlights

*void CL_ClearDlights()*

*Defined at line 2472 of ./engine/client/cl_tent.cpp*

================CL_ClearDlights================

### monster_flyer

*void monster_flyer(entvars_t * pev)*

*Defined at line 111 of ./game/server/npc/npc_aflock.cpp*

### monster_flyer_flock

*void monster_flyer_flock(entvars_t * pev)*

*Defined at line 112 of ./game/server/npc/npc_aflock.cpp*

### Game_HookEvents

*void Game_HookEvents()*

*Defined at line 58 of ./game/client/hl/hl_events.cpp*

======================Game_HookEvents

Associate script file name with callback functions.  Callback's must be extern "C" so the engine doesn't get confused about name mangling stuff.  Note that the format is always the same.  Of course, a clever mod team could actually embed parameters, behavior into the actual .sc files and create a .sc file parser and hook their functionality through that.. i.e., a scripting system.

That was what we were going to do, but we ran out of time...oh well.======================

### EV_HookEvents

*void EV_HookEvents()*

*Defined at line 20 of ./game/client/events.cpp*

===================EV_HookEvents

See if game specific code wants to hook any events.===================

### IsNextWord

*int IsNextWord(const char c)*

*Defined at line 27 of ./engine/client/s_vox.cpp*

### IsSkipSpace

*int IsSkipSpace(const char c)*

*Defined at line 34 of ./engine/client/s_vox.cpp*

### IsWhiteSpace

*int IsWhiteSpace(const char space)*

*Defined at line 41 of ./engine/client/s_vox.cpp*

### IsCommandChar

*int IsCommandChar(const char c)*

*Defined at line 48 of ./engine/client/s_vox.cpp*

### IsDelimitChar

*int IsDelimitChar(const char c)*

*Defined at line 55 of ./engine/client/s_vox.cpp*

### ScanForwardUntil

*char * ScanForwardUntil(char * string, const char scan)*

*Defined at line 62 of ./engine/client/s_vox.cpp*

### VOX_GetDirectory

*char * VOX_GetDirectory(char * szpath, char * psz)*

*Defined at line 76 of ./engine/client/s_vox.cpp*

 backwards scan psz for last '/' return substring in szpath null terminated if '/' not found, return 'vox/'

### VOX_LookupString

*char * VOX_LookupString(const char * pSentenceName, int * psentencenum)*

*Defined at line 108 of ./engine/client/s_vox.cpp*

 scan g_Sentences, looking for pszin sentence name return pointer to sentence data if found, null if not CONSIDER: if we have a large number of sentences, should CONSIDER: sort strings in g_Sentences and do binary search.

### VOX_ParseString

*char ** VOX_ParseString(char * psz)*

*Defined at line 133 of ./engine/client/s_vox.cpp*

 parse a null terminated string of text into component words, with pointers to each word stored in rgpparseword note: this code actually alters the passed in string!

### VOX_GetVolumeScale

*float VOX_GetVolumeScale(channel_t * pchan)*

*Defined at line 193 of ./engine/client/s_vox.cpp*

### VOX_ParseWordParams

*int VOX_ParseWordParams(char * psz, voxword_t * pvoxword, int fFirst)*

*Defined at line 256 of ./engine/client/s_vox.cpp*

===============================================================================  Get any pitch, volume, start, end params into voxword  and null out trailing format characters  Format: 		someword(v100 p110 s10 e20)

		v is volume, 0% to n%		p is pitch shift up 0% to n%		s is start wave offset %		e is end wave offset %		t is timecompression %

  pass fFirst == 1 if this is the first string in sentence  returns 1 if valid string, 0 if parameter block only.

  If a ( xxx ) parameter block does not directly follow a word,   then that 'default' parameter block will be used as the default value  for all following words.  Default parameter values are reset  by another 'default' parameter block.  Default parameter values  for a single word are overridden for that word if it has a parameter block.

===============================================================================

### VOX_LoadFirstWord

*void VOX_LoadFirstWord(channel_t * pchan, voxword_t * pwords)*

*Defined at line 400 of ./engine/client/s_vox.cpp*

### VOX_ParseLineCommands

*void VOX_ParseLineCommands(char * pSentenceData, int sentenceIndex)*

*Defined at line 530 of ./engine/client/s_vox.cpp*

----------------------------------------------------------------------------- Purpose: Take a NULL terminated sentence, and parse any commands contained in			{}.  The string is rewritten in place with those commands removed.

 Input  : *pSentenceData - sentence data to be modified in place			sentenceIndex - global sentence table index for any data that is 							parsed out-----------------------------------------------------------------------------

### VOX_ReadSentenceFile

*void VOX_ReadSentenceFile(const char * psentenceFileName)*

*Defined at line 606 of ./engine/client/s_vox.cpp*

 Load sentence file into memory, insert null terminators to delimit sentence name/sentence pairs.  Keep pointer to each sentence name so we can search later.

### world_items

*void world_items(entvars_t * pev)*

*Defined at line 42 of ./game/server/items.cpp*

### item_suit

*void item_suit(entvars_t * pev)*

*Defined at line 201 of ./game/server/items.cpp*

### item_battery

*void item_battery(entvars_t * pev)*

*Defined at line 255 of ./game/server/items.cpp*

### item_antidote

*void item_antidote(entvars_t * pev)*

*Defined at line 278 of ./game/server/items.cpp*

### item_security

*void item_security(entvars_t * pev)*

*Defined at line 299 of ./game/server/items.cpp*

### item_longjump

*void item_longjump(entvars_t * pev)*

*Defined at line 337 of ./game/server/items.cpp*

### StripLength

*int StripLength(int starttri, int startv)*

*Defined at line 95 of ./rendersystem/r_alias.cpp*

================StripLength================

### FanLength

*int FanLength(int starttri, int startv)*

*Defined at line 161 of ./rendersystem/r_alias.cpp*

===========FanLength===========

### BuildTris

*void BuildTris()*

*Defined at line 228 of ./rendersystem/r_alias.cpp*

================BuildTris

Generate a list of trifans or stripsfor the model, which holds for all frames================

### GL_MakeAliasModelDisplayLists

*void GL_MakeAliasModelDisplayLists(model_t * m)*

*Defined at line 308 of ./rendersystem/r_alias.cpp*

================GL_MakeAliasModelDisplayLists================

### Mod_LoadAliasFrame

*void * Mod_LoadAliasFrame(void * pin, maliasframedesc_t * frame)*

*Defined at line 345 of ./rendersystem/r_alias.cpp*

==============================================================================

ALIAS MODELS

==============================================================================

=================Mod_LoadAliasFrame=================

### Mod_LoadAliasGroup

*void * Mod_LoadAliasGroup(void * pin, maliasframedesc_t * frame)*

*Defined at line 377 of ./rendersystem/r_alias.cpp*

=================Mod_LoadAliasGroup=================

### Mod_CreateSkinData

*rgbdata_t * Mod_CreateSkinData(model_t * mod, byte * data, int width, int height)*

*Defined at line 418 of ./rendersystem/r_alias.cpp*

===============Mod_CreateSkinData===============

### Mod_LoadSingleSkin

*void * Mod_LoadSingleSkin(daliasskintype_t * pskintype, int skinnum, int size)*

*Defined at line 481 of ./rendersystem/r_alias.cpp*

### Mod_LoadGroupSkin

*void * Mod_LoadGroupSkin(daliasskintype_t * pskintype, int skinnum, int size)*

*Defined at line 513 of ./rendersystem/r_alias.cpp*

### Mod_LoadAllSkins

*void * Mod_LoadAllSkins(int numskins, daliasskintype_t * pskintype)*

*Defined at line 560 of ./rendersystem/r_alias.cpp*

===============Mod_LoadAllSkins===============

### Mod_CalcAliasBounds

*void Mod_CalcAliasBounds(model_t * mod)*

*Defined at line 590 of ./rendersystem/r_alias.cpp*

=========================================================================

=================Mod_CalcAliasBounds=================

### R_AliasDynamicLight

*void R_AliasDynamicLight(cl_entity_t * ent, alight_t * plight)*

*Defined at line 769 of ./rendersystem/r_alias.cpp*

===============R_AliasDynamicLight

similar to R_StudioDynamicLight===============

### R_AliasSetupLighting

*void R_AliasSetupLighting(alight_t * plight)*

*Defined at line 949 of ./rendersystem/r_alias.cpp*

===============R_AliasSetupLighting

===============

### R_AliasLighting

*void R_AliasLighting(float * lv, const vec3_t normal)*

*Defined at line 970 of ./rendersystem/r_alias.cpp*

===============R_AliasLighting

===============

### R_AliasSetRemapColors

*void R_AliasSetRemapColors(int newTop, int newBottom)*

*Defined at line 1008 of ./rendersystem/r_alias.cpp*

===============R_AliasSetRemapColors

===============

### GL_DrawAliasFrame

*void GL_DrawAliasFrame(aliashdr_t * paliashdr)*

*Defined at line 1024 of ./rendersystem/r_alias.cpp*

=============GL_DrawAliasFrame=============

### GL_DrawAliasShadow

*void GL_DrawAliasShadow(aliashdr_t * paliashdr)*

*Defined at line 1086 of ./rendersystem/r_alias.cpp*

=============GL_DrawAliasShadow=============

### R_AliasLerpMovement

*void R_AliasLerpMovement(cl_entity_t * e)*

*Defined at line 1164 of ./rendersystem/r_alias.cpp*

====================R_AliasLerpMovement

====================

### R_SetupAliasFrame

*void R_SetupAliasFrame(cl_entity_t * e, aliashdr_t * paliashdr)*

*Defined at line 1207 of ./rendersystem/r_alias.cpp*

=================R_SetupAliasFrame

=================

### R_AliasDrawAbsBBox

*void R_AliasDrawAbsBBox(cl_entity_t * e, const vec3_t absmin, const vec3_t absmax)*

*Defined at line 1261 of ./rendersystem/r_alias.cpp*

===============R_StudioDrawAbsBBox

===============

### R_AliasDrawLightTrace

*void R_AliasDrawLightTrace(cl_entity_t * e)*

*Defined at line 1297 of ./rendersystem/r_alias.cpp*

### R_AliasSetupTimings

*void R_AliasSetupTimings()*

*Defined at line 1338 of ./rendersystem/r_alias.cpp*

================R_AliasSetupTimings

init current time for a given model================

### QuaternionAlign

*void QuaternionAlign(const vec4_t p, const vec4_t q, vec4_t qt)*

*Defined at line 673 of ./mathlib/mathlib.cpp*

====================QuaternionAlign

make sure quaternions are within 180 degrees of one another,if not, reverse q====================

### QuaternionSlerpNoAlign

*void QuaternionSlerpNoAlign(const vec4_t p, const vec4_t q, float t, vec4_t qt)*

*Defined at line 703 of ./mathlib/mathlib.cpp*

====================QuaternionSlerpNoAlign====================

### CheckSkybox

*int CheckSkybox(const char * name)*

*Defined at line 67 of ./ref_gl/gl_warp.cpp*

### GetMenuAPI

*int GetMenuAPI(UI_FUNCTIONS * pFunctionTable, ui_enginefuncs_t * pEngfuncsFromEngine, ui_globalvars_t * pGlobals)*

*Defined at line 50 of ./mainui/udll_int.cpp*

=======================================================================			GetApi=======================================================================

### GetExtAPI

*int GetExtAPI(int version, UI_EXTENDED_FUNCTIONS * pFunctionTable, ui_extendedfuncs_t * pEngfuncsFromEngine)*

*Defined at line 88 of ./mainui/udll_int.cpp*

### good_enc

*int good_enc(const int enc)*

*Defined at line 46 of ./engine/common/soundlib/libmpg/format.cpp*

 check if encoding is a valid one in this build.

### mpg123_rates

*void mpg123_rates(const long ** list, size_t * number)*

*Defined at line 59 of ./engine/common/soundlib/libmpg/format.cpp*

### mpg123_encodings

*void mpg123_encodings(const int ** list, size_t * number)*

*Defined at line 66 of ./engine/common/soundlib/libmpg/format.cpp*

 now that's a bit tricky... One build of the library knows only a subset of the encodings.

### mpg123_encsize

*int mpg123_encsize(int encoding)*

*Defined at line 72 of ./engine/common/soundlib/libmpg/format.cpp*

### rate2num

*int rate2num(long r)*

*Defined at line 77 of ./engine/common/soundlib/libmpg/format.cpp*

### enc2num

*int enc2num(int encoding)*

*Defined at line 90 of ./engine/common/soundlib/libmpg/format.cpp*

### cap_fit

*int cap_fit(mpg123_handle_t * fr, audioformat_t * nf, int f0, int f2)*

*Defined at line 103 of ./engine/common/soundlib/libmpg/format.cpp*

### freq_fit

*int freq_fit(mpg123_handle_t * fr, audioformat_t * nf, int f0, int f2)*

*Defined at line 124 of ./engine/common/soundlib/libmpg/format.cpp*

### mpg123_fmt_none

*int mpg123_fmt_none(mpg123_parm_t * mp)*

*Defined at line 230 of ./engine/common/soundlib/libmpg/format.cpp*

### mpg123_fmt

*int mpg123_fmt(mpg123_parm_t * mp, long rate, int channels, int encodings)*

*Defined at line 258 of ./engine/common/soundlib/libmpg/format.cpp*

### mpg123_fmt_support

*int mpg123_fmt_support(mpg123_parm_t * mp, long rate, int encoding)*

*Defined at line 293 of ./engine/common/soundlib/libmpg/format.cpp*

### mpg123_format_support

*int mpg123_format_support(mpg123_handle_t * mh, long rate, int encoding)*

*Defined at line 367 of ./engine/common/soundlib/libmpg/format.cpp*

### conv_s16_to_u16

*void conv_s16_to_u16(outbuffer_t * buf)*

*Defined at line 408 of ./engine/common/soundlib/libmpg/format.cpp*

### HUD_GetFOV

*float HUD_GetFOV()*

*Defined at line 501 of ./game/client/hud.cpp*

=====================HUD_GetFOV

Returns last FOV=====================

### NetGraph_DrawRect

*void NetGraph_DrawRect(wrect_t * rect, byte [4] colors)*

*Defined at line 75 of ./engine/client/cl_netgraph.cpp*

==========NetGraph_DrawRect

NetGraph_FillRGBA shortcut==========

### NetGraph_AtEdge

*qboolean NetGraph_AtEdge(int x, int width)*

*Defined at line 92 of ./engine/client/cl_netgraph.cpp*

==========NetGraph_AtEdge

edge detect==========

### NetGraph_InitColors

*void NetGraph_InitColors()*

*Defined at line 110 of ./engine/client/cl_netgraph.cpp*

==========NetGraph_InitColors

init netgraph colors==========

### NetGraph_GetFrameData

*void NetGraph_GetFrameData(float * latency, int * latency_count)*

*Defined at line 164 of ./engine/client/cl_netgraph.cpp*

==========NetGraph_GetFrameData

get frame data info, like chokes, packet losses, also update graph, packet and cmdinfo==========

### NetGraph_DrawTimes

*void NetGraph_DrawTimes(wrect_s rect, int x, int w)*

*Defined at line 246 of ./engine/client/cl_netgraph.cpp*

===========NetGraph_DrawTimes

===========

### NetGraph_DrawHatches

*void NetGraph_DrawHatches(int x, int y)*

*Defined at line 321 of ./engine/client/cl_netgraph.cpp*

===========NetGraph_DrawHatches

===========

### NetGraph_DrawTextFields

*void NetGraph_DrawTextFields(int x, int y, int w, wrect_s rect, int count, float avg, int packet_loss, int packet_choke)*

*Defined at line 350 of ./engine/client/cl_netgraph.cpp*

===========NetGraph_DrawTextFields

===========

### NetGraph_DrawDataSegment

*int NetGraph_DrawDataSegment(wrect_t * fill, int bytes, byte r, byte g, byte b, byte a)*

*Defined at line 420 of ./engine/client/cl_netgraph.cpp*

===========NetGraph_DrawDataSegment

===========

### NetGraph_ColorForHeight

*void NetGraph_ColorForHeight(struct packet_latency_t * packet, byte [4] color, int * ping)*

*Defined at line 447 of ./engine/client/cl_netgraph.cpp*

===========NetGraph_ColorForHeight

color based on packet latency===========

### NetGraph_DrawDataUsage

*void NetGraph_DrawDataUsage(int x, int y, int w)*

*Defined at line 482 of ./engine/client/cl_netgraph.cpp*

===========NetGraph_DrawDataUsage

===========

### NetGraph_GetScreenPos

*void NetGraph_GetScreenPos(wrect_t * rect, int * w, int * x, int * y)*

*Defined at line 594 of ./engine/client/cl_netgraph.cpp*

===========NetGraph_GetScreenPos

===========

### weapon_crowbar

*void weapon_crowbar(entvars_t * pev)*

*Defined at line 28 of ./game/shared/hl1/weapon_crowbar.cpp*

### FindHullIntersection

*void FindHullIntersection(const class Vector & vecSrc, TraceResult & tr, float * mins, float * maxs, edict_t * pEntity)*

*Defined at line 112 of ./game/shared/hl1/weapon_crowbar.cpp*

### SV_CreateCustomizationList

*void SV_CreateCustomizationList(sv_client_t * cl)*

*Defined at line 19 of ./engine/server/sv_custom.cpp*

### SV_FileInConsistencyList

*qboolean SV_FileInConsistencyList(const char * filename, consistency_t ** ppout)*

*Defined at line 64 of ./engine/server/sv_custom.cpp*

### SV_SendConsistencyList

*void SV_SendConsistencyList(sv_client_t * cl, sizebuf_t * msg)*

*Defined at line 247 of ./engine/server/sv_custom.cpp*

### SV_CheckFile

*qboolean SV_CheckFile(sizebuf_t * msg, const char * filename)*

*Defined at line 289 of ./engine/server/sv_custom.cpp*

### SV_SendCustomization

*void SV_SendCustomization(sv_client_t * cl, int playernum, resource_t * pResource)*

*Defined at line 338 of ./engine/server/sv_custom.cpp*

### SV_Customization

*void SV_Customization(sv_client_t * pClient, resource_t * pResource, qboolean bSkipPlayer)*

*Defined at line 411 of ./engine/server/sv_custom.cpp*

### SV_PropagateCustomizations

*void SV_PropagateCustomizations(sv_client_t * pHost)*

*Defined at line 436 of ./engine/server/sv_custom.cpp*

### SV_RegisterResources

*void SV_RegisterResources(sv_client_t * pHost)*

*Defined at line 460 of ./engine/server/sv_custom.cpp*

### SV_UploadComplete

*qboolean SV_UploadComplete(sv_client_t * cl)*

*Defined at line 471 of ./engine/server/sv_custom.cpp*

### R_RankForRenderMode

*int R_RankForRenderMode(int rendermode)*

*Defined at line 28 of ./ref_gl/gl_rmain.cpp*

### R_OpaqueEntity

*qboolean R_OpaqueEntity(cl_entity_t * ent)*

*Defined at line 63 of ./ref_gl/gl_rmain.cpp*

===============R_OpaqueEntity

Opaque entity can be brush or studio model but sprite===============

### R_TransEntityCompare

*int R_TransEntityCompare(const void * a, const void * b)*

*Defined at line 77 of ./ref_gl/gl_rmain.cpp*

===============R_TransEntityCompare

Sorting translucent entities by rendermode then by distance===============

### R_Clear

*void R_Clear(int bitMask)*

*Defined at line 286 of ./ref_gl/gl_rmain.cpp*

=============R_Clear=============

### R_GetFarClip

*float R_GetFarClip()*

*Defined at line 325 of ./ref_gl/gl_rmain.cpp*

=============================================================================

===============R_GetFarClip===============

### R_SetupProjectionMatrix

*void R_SetupProjectionMatrix(matrix4x4 m)*

*Defined at line 368 of ./ref_gl/gl_rmain.cpp*

=============R_SetupProjectionMatrix=============

### R_SetupModelviewMatrix

*void R_SetupModelviewMatrix(matrix4x4 m)*

*Defined at line 398 of ./ref_gl/gl_rmain.cpp*

=============R_SetupModelviewMatrix=============

### R_SetupFrame

*void R_SetupFrame()*

*Defined at line 492 of ./ref_gl/gl_rmain.cpp*

===============R_SetupFrame===============

### R_EndGL

*void R_EndGL()*

*Defined at line 578 of ./ref_gl/gl_rmain.cpp*

=============R_EndGL=============

### R_RecursiveFindWaterTexture

*gl_texture_t * R_RecursiveFindWaterTexture(const mnode_t * node, const mnode_t * ignore, qboolean down)*

*Defined at line 592 of ./ref_gl/gl_rmain.cpp*

=============R_RecursiveFindWaterTexture

using to find source waterleaf withwatertexture to grab fog values from it=============

### R_CheckFog

*void R_CheckFog()*

*Defined at line 664 of ./ref_gl/gl_rmain.cpp*

=============R_CheckFog

check for underwater fogUsing backward recursion to find waterline leaffrom underwater leaf (idea: XaeroX)=============

### R_CheckGLFog

*void R_CheckGLFog()*

*Defined at line 775 of ./ref_gl/gl_rmain.cpp*

=============R_CheckGLFog

special condition for Spirit 1.9that used direct calls of glFog-functions=============

### R_DrawEntitiesOnList

*void R_DrawEntitiesOnList()*

*Defined at line 811 of ./ref_gl/gl_rmain.cpp*

=============R_DrawEntitiesOnList=============

### R_RecursiveLightPoint

*qboolean R_RecursiveLightPoint(model_t * model, mnode_t * node, float p1f, float p2f, colorVec * cv, const vec3_t start, const vec3_t end)*

*Defined at line 231 of ./rendersystem/r_rlight.cpp*

=================R_RecursiveLightPoint=================

### R_RankForRenderMode

*int R_RankForRenderMode(int rendermode)*

*Defined at line 28 of ./rendersystem/r_main.cpp*

### R_OpaqueEntity

*qboolean R_OpaqueEntity(cl_entity_t * ent)*

*Defined at line 63 of ./rendersystem/r_main.cpp*

===============R_OpaqueEntity

Opaque entity can be brush or studio model but sprite===============

### R_TransEntityCompare

*int R_TransEntityCompare(const void * a, const void * b)*

*Defined at line 77 of ./rendersystem/r_main.cpp*

===============R_TransEntityCompare

Sorting translucent entities by rendermode then by distance===============

### R_Clear

*void R_Clear(int bitMask)*

*Defined at line 286 of ./rendersystem/r_main.cpp*

=============R_Clear=============

### R_GetFarClip

*float R_GetFarClip()*

*Defined at line 325 of ./rendersystem/r_main.cpp*

=============================================================================

===============R_GetFarClip===============

### R_SetupProjectionMatrix

*void R_SetupProjectionMatrix(matrix4x4 m)*

*Defined at line 368 of ./rendersystem/r_main.cpp*

=============R_SetupProjectionMatrix=============

### R_SetupModelviewMatrix

*void R_SetupModelviewMatrix(matrix4x4 m)*

*Defined at line 398 of ./rendersystem/r_main.cpp*

=============R_SetupModelviewMatrix=============

### R_SetupFrame

*void R_SetupFrame()*

*Defined at line 492 of ./rendersystem/r_main.cpp*

===============R_SetupFrame===============

### R_EndGL

*void R_EndGL()*

*Defined at line 578 of ./rendersystem/r_main.cpp*

=============R_EndGL=============

### R_RecursiveFindWaterTexture

*gl_texture_t * R_RecursiveFindWaterTexture(const mnode_t * node, const mnode_t * ignore, qboolean down)*

*Defined at line 592 of ./rendersystem/r_main.cpp*

=============R_RecursiveFindWaterTexture

using to find source waterleaf withwatertexture to grab fog values from it=============

### R_CheckFog

*void R_CheckFog()*

*Defined at line 664 of ./rendersystem/r_main.cpp*

=============R_CheckFog

check for underwater fogUsing backward recursion to find waterline leaffrom underwater leaf (idea: XaeroX)=============

### R_CheckGLFog

*void R_CheckGLFog()*

*Defined at line 775 of ./rendersystem/r_main.cpp*

=============R_CheckGLFog

special condition for Spirit 1.9that used direct calls of glFog-functions=============

### Info_IsKeyImportant

*qboolean Info_IsKeyImportant(const char * key)*

*Defined at line 334 of ./engine/common/infostring.cpp*

### Info_FindLargestKey

*char * Info_FindLargestKey(char * s)*

*Defined at line 359 of ./engine/common/infostring.cpp*

### IN_Init

*void IN_Init()*

*Defined at line 444 of ./engine/client/input.cpp*

 Defined in pm_math.cextern "C" float anglemod( float a );

===========IN_Init===========

### Host_InputFrame

*void Host_InputFrame()*

*Defined at line 641 of ./engine/client/input.cpp*

==================Host_InputFrame

Called every frame, even if not generating commands==================

### IN_Shutdown

*void IN_Shutdown()*

*Defined at line 427 of ./engine/client/input.cpp*

===========IN_Shutdown===========

### IN_MouseEvent

*void IN_MouseEvent()*

*Defined at line 359 of ./engine/client/input.cpp*

===========IN_MouseEvent===========

### IN_ActivateMouse

*void IN_ActivateMouse(qboolean force)*

*Defined at line 247 of ./engine/client/input.cpp*

===========IN_ActivateMouse

Called when the window gains focus or changes in some way===========

### IN_DeactivateMouse

*void IN_DeactivateMouse()*

*Defined at line 308 of ./engine/client/input.cpp*

===========IN_DeactivateMouse

Called when the window loses focus===========

### IN_MouseSavePos

*void IN_MouseSavePos()*

*Defined at line 152 of ./engine/client/input.cpp*

===========IN_MouseSavePos

Save mouse pos before state change e.g. changelevel===========

### IN_MouseRestorePos

*void IN_MouseRestorePos()*

*Defined at line 168 of ./engine/client/input.cpp*

===========IN_MouseRestorePos

Restore right position for background===========

### IN_ToggleClientMouse

*void IN_ToggleClientMouse(int newstate, int oldstate)*

*Defined at line 185 of ./engine/client/input.cpp*

===========IN_ToggleClientMouse

Called when key_dest is changed===========

### IN_SetCursor

*void IN_SetCursor(void * hCursor)*

*Defined at line 138 of ./engine/client/input.cpp*

### IN_CollectInputDevices

*uint IN_CollectInputDevices()*

*Defined at line 57 of ./engine/client/input.cpp*

================IN_CollectInputDevices

Returns a bit mask representing connected devices or, at least, enabled================

### IN_LockInputDevices

*void IN_LockInputDevices(qboolean lock)*

*Defined at line 87 of ./engine/client/input.cpp*

=================IN_LockInputDevices

tries to lock any possibilty to connect another input device afterplayer is connected to the server=================

### IN_EngineAppendMove

*void IN_EngineAppendMove(float frametime, void * cmd, qboolean active)*

*Defined at line 603 of ./engine/client/input.cpp*

================IN_EngineAppendMove

Called from cl_main.c after generating command in client================

### Touch_Draw

*void Touch_Draw()*

*Defined at line 1242 of ./engine/client/in_touch.cpp*

### Touch_SetClientOnly

*void Touch_SetClientOnly(qboolean state)*

*Defined at line 445 of ./engine/client/in_touch.cpp*

### Touch_RemoveButton

*void Touch_RemoveButton(const char * name)*

*Defined at line 495 of ./engine/client/in_touch.cpp*

### Touch_HideButtons

*void Touch_HideButtons(const char * name, unsigned char hide)*

*Defined at line 560 of ./engine/client/in_touch.cpp*

### Touch_AddClientButton

*void Touch_AddClientButton(const char * name, const char * texture, const char * command, float x1, float y1, float x2, float y2, byte * color, int round, float aspect, int flags)*

*Defined at line 713 of ./engine/client/in_touch.cpp*

void IN_TouchSetCommand( const char *name, const char *command );void IN_TouchSetTexture( const char *name, const char *texture );void IN_TouchSetColor( const char *name, byte *color );

### Touch_AddDefaultButton

*void Touch_AddDefaultButton(const char * name, const char * texturefile, const char * command, float x1, float y1, float x2, float y2, byte * color, int round, float aspect, int flags)*

*Defined at line 760 of ./engine/client/in_touch.cpp*

 Add default button from client

### Touch_WriteConfig

*void Touch_WriteConfig()*

*Defined at line 169 of ./engine/client/in_touch.cpp*

### Touch_Init

*void Touch_Init()*

*Defined at line 888 of ./engine/client/in_touch.cpp*

### Touch_Shutdown

*void Touch_Shutdown()*

*Defined at line 1882 of ./engine/client/in_touch.cpp*

### Touch_GetMove

*void Touch_GetMove(float * forward, float * side, float * yaw, float * pitch)*

*Defined at line 1840 of ./engine/client/in_touch.cpp*

### Touch_ResetDefaultButtons

*void Touch_ResetDefaultButtons()*

*Defined at line 779 of ./engine/client/in_touch.cpp*

 Client may remove all default buttons from engine

### IN_TouchEvent

*int IN_TouchEvent(touchEventType type, int fingerID, float x, float y, float dx, float dy)*

*Defined at line 1767 of ./engine/client/in_touch.cpp*

### Touch_KeyEvent

*void Touch_KeyEvent(int key, int down)*

*Defined at line 1849 of ./engine/client/in_touch.cpp*

### Joy_IsActive

*qboolean Joy_IsActive()*

*Defined at line 82 of ./engine/client/in_joy.cpp*

============Joy_IsActive============

### Joy_HatMotionEvent

*void Joy_HatMotionEvent(byte hat, byte value)*

*Defined at line 94 of ./engine/client/in_joy.cpp*

============Joy_HatMotionEvent

DPad events============

### Joy_AxisMotionEvent

*void Joy_AxisMotionEvent(byte axis, short value)*

*Defined at line 249 of ./engine/client/in_joy.cpp*

=============Joy_AxisMotionEvent

Axis events=============

### Joy_BallMotionEvent

*void Joy_BallMotionEvent(byte ball, short xrel, short yrel)*

*Defined at line 283 of ./engine/client/in_joy.cpp*

=============Joy_BallMotionEvent

Trackball events. UNDONE=============

### Joy_ButtonEvent

*void Joy_ButtonEvent(byte button, byte down)*

*Defined at line 296 of ./engine/client/in_joy.cpp*

=============Joy_ButtonEvent

Button events=============

### Joy_AddEvent

*void Joy_AddEvent()*

*Defined at line 334 of ./engine/client/in_joy.cpp*

=============Joy_RemoveEvent

Called when joystick is removed. For future expansion=============

### Joy_RemoveEvent

*void Joy_RemoveEvent()*

*Defined at line 321 of ./engine/client/in_joy.cpp*

=============Joy_RemoveEvent

Called when joystick is removed. For future expansion=============

### Joy_FinalizeMove

*void Joy_FinalizeMove(float * fw, float * side, float * dpitch, float * dyaw)*

*Defined at line 347 of ./engine/client/in_joy.cpp*

=============Joy_FinalizeMove

Append movement from axis. Called everyframe=============

### Joy_Init

*void Joy_Init()*

*Defined at line 393 of ./engine/client/in_joy.cpp*

=============Joy_Init

Main init procedure=============

### Joy_Shutdown

*void Joy_Shutdown()*

*Defined at line 438 of ./engine/client/in_joy.cpp*

===========Joy_Shutdown

Shutdown joystick code===========

### Joy_EnableTextInput

*void Joy_EnableTextInput(qboolean enable, qboolean force)*

### Con_ClearField

*void Con_ClearField(field_t * edit)*

*Defined at line 1444 of ./engine/client/console.cpp*

=============================================================================

EDIT FIELDS

=============================================================================

================Con_ClearField================

### Field_CharEvent

*void Field_CharEvent(field_t * edit, int ch)*

*Defined at line 1551 of ./engine/client/console.cpp*

==================Field_CharEvent==================

### Con_Clear_f

*void Con_Clear_f()*

*Defined at line 136 of ./engine/client/console.cpp*

================Con_Clear_f================

### Con_SetColor_f

*void Con_SetColor_f()*

*Defined at line 147 of ./engine/client/console.cpp*

================Con_SetColor_f================

### Con_ClearTyping

*void Con_ClearTyping()*

*Defined at line 189 of ./engine/client/console.cpp*

================Con_ClearTyping================

### Con_StringLength

*int Con_StringLength(const char * string)*

*Defined at line 206 of ./engine/client/console.cpp*

============Con_StringLength

skipped color prefixes============

### Con_MessageMode_f

*void Con_MessageMode_f()*

*Defined at line 235 of ./engine/client/console.cpp*

================Con_MessageMode_f================

### Con_MessageMode2_f

*void Con_MessageMode2_f()*

*Defined at line 249 of ./engine/client/console.cpp*

================Con_MessageMode2_f================

### Con_SetTimes_f

*void Con_SetTimes_f()*

*Defined at line 290 of ./engine/client/console.cpp*

================Con_SetTimes_f================

### Con_FixTimes

*void Con_FixTimes()*

*Defined at line 313 of ./engine/client/console.cpp*

================Con_FixTimes

Notifies the console code about the current time(and shifts back times of other entries when the timewent backwards)================

### Con_DeleteLine

*void Con_DeleteLine()*

*Defined at line 334 of ./engine/client/console.cpp*

================Con_DeleteLine

Deletes the first line from the console history.================

### Con_DeleteLastLine

*void Con_DeleteLastLine()*

*Defined at line 349 of ./engine/client/console.cpp*

================Con_DeleteLastLine

Deletes the last line from the console history.================

### Con_BytesLeft

*char * Con_BytesLeft(int length)*

*Defined at line 364 of ./engine/client/console.cpp*

================Con_BytesLeft

Checks if there is space for a line of the given length, and if yes, returns apointer to the start of such a space, and NULL otherwise.================

### Con_AddLine

*void Con_AddLine(const char * line, int length, qboolean newline)*

*Defined at line 408 of ./engine/client/console.cpp*

================Con_AddLine

Appends a given string as a new line to the console.================

### Con_CheckResize

*void Con_CheckResize()*

*Defined at line 454 of ./engine/client/console.cpp*

================Con_CheckResize

If the line width has changed, reformat the buffer.================

### Con_LoadFixedWidthFont

*qboolean Con_LoadFixedWidthFont(const char * fontname, cl_font_t * font)*

*Defined at line 540 of ./engine/client/console.cpp*

### Con_LoadVariableWidthFont

*qboolean Con_LoadVariableWidthFont(const char * fontname, cl_font_t * font)*

*Defined at line 574 of ./engine/client/console.cpp*

### Con_LoadConsoleFont

*void Con_LoadConsoleFont(int fontNumber, cl_font_t * font)*

*Defined at line 626 of ./engine/client/console.cpp*

================Con_LoadConsoleFont

INTERNAL RESOURCE================

### Con_LoadConchars

*void Con_LoadConchars()*

*Defined at line 661 of ./engine/client/console.cpp*

================Con_LoadConchars================

### Con_DrawCharToConback

*void Con_DrawCharToConback(int num, const byte * conchars, byte * dest)*

*Defined at line 824 of ./engine/client/console.cpp*

### Con_TextAdjustSize

*void Con_TextAdjustSize(int * x, int * y, int * w, int * h)*

*Defined at line 855 of ./engine/client/console.cpp*

====================Con_TextAdjustSize

draw charcters routine====================

### Con_DrawGenericChar

*int Con_DrawGenericChar(int x, int y, int number, rgba_t color)*

*Defined at line 878 of ./engine/client/console.cpp*

====================Con_DrawGenericChar

draw console single character====================

### Con_DrawGenericString

*int Con_DrawGenericString(int x, int y, const char * string, rgba_t setColor, qboolean forceColor, int hideChar)*

*Defined at line 1032 of ./engine/client/console.cpp*

==================Con_DrawString

Draws a multi-colored string, optionally forcingto a fixed color.==================

### Con_SaveHistory

*void Con_SaveHistory()*

*Defined at line 1134 of ./engine/client/console.cpp*

### Field_Paste

*void Field_Paste(field_t * edit)*

*Defined at line 1456 of ./engine/client/console.cpp*

================Field_Paste================

### Field_KeyDownEvent

*void Field_KeyDownEvent(field_t * edit, int key)*

*Defined at line 1480 of ./engine/client/console.cpp*

=================Field_KeyDownEvent

Performs the basic line editing functions for the console,in-game talk, and menu fields

Key events are used for non-printable characters, others are gotten from char events.=================

### Field_DrawInputLine

*void Field_DrawInputLine(int x, int y, field_t * edit)*

*Defined at line 1614 of ./engine/client/console.cpp*

==================Field_DrawInputLine==================

### Con_DrawInput

*void Con_DrawInput(int lines)*

*Defined at line 1874 of ./engine/client/console.cpp*

==============================================================================

DRAWING

==============================================================================

================Con_DrawInput

The input line scrolls horizontally if typing goes beyond the right edge================

### Con_DrawDebugLines

*int Con_DrawDebugLines()*

*Defined at line 1894 of ./engine/client/console.cpp*

================Con_DrawDebugLines

Custom debug messages================

### Con_DrawNotify

*void Con_DrawNotify()*

*Defined at line 1969 of ./engine/client/console.cpp*

================Con_DrawNotify

Draws the last few lines of output transparently over the game top================

### Con_DrawConsoleLine

*int Con_DrawConsoleLine(int y, int lineno)*

*Defined at line 2021 of ./engine/client/console.cpp*

================Con_DrawConsoleLine

Draws a line of the console; returns its height in lines.If alpha is 0, the line is not drawn, but still wrapped and its heightreturned.================

### Con_LastVisibleLine

*void Con_LastVisibleLine(int * lastline)*

*Defined at line 2042 of ./engine/client/console.cpp*

================Con_LastVisibleLine

Calculates the last visible line index and how much to showof it based on con.backscroll.================

### Con_DrawSolidConsole

*void Con_DrawSolidConsole(int lines)*

*Defined at line 2072 of ./engine/client/console.cpp*

================Con_DrawConsole

Draws the console with the solid background================

### CL_ScreenshotGetName

*qboolean CL_ScreenshotGetName(int lastnum, char * filename)*

*Defined at line 148 of ./engine/client/cl_cmds.cpp*

================== CL_ScreenshotGetName================== 

### CL_SnapshotGetName

*qboolean CL_SnapshotGetName(int lastnum, char * filename)*

*Defined at line 176 of ./engine/client/cl_cmds.cpp*

================== CL_SnapshotGetName================== 

### Log_PrintServerCvar

*void Log_PrintServerCvar(const char * var_name, const char * var_value, void * unused2, void * unused3)*

*Defined at line 135 of ./engine/server/sv_log.cpp*

### Delta_FindStruct

*delta_info_t * Delta_FindStruct(const char * name)*

*Defined at line 311 of ./engine/common/net_encode.cpp*

### Delta_FindStructByEncoder

*delta_info_t * Delta_FindStructByEncoder(const char * encoderName)*

*Defined at line 343 of ./engine/common/net_encode.cpp*

### Delta_FindStructByDelta

*delta_info_t * Delta_FindStructByDelta(const delta_t * pFields)*

*Defined at line 359 of ./engine/common/net_encode.cpp*

### Delta_CustomEncode

*void Delta_CustomEncode(delta_info_t * dt, const void * from, const void * to)*

*Defined at line 374 of ./engine/common/net_encode.cpp*

### Delta_FindFieldInfo

*delta_field_t * Delta_FindFieldInfo(const delta_field_t * pInfo, const char * fieldName)*

*Defined at line 390 of ./engine/common/net_encode.cpp*

### Delta_IndexForFieldInfo

*int Delta_IndexForFieldInfo(const delta_field_t * pInfo, const char * fieldName)*

*Defined at line 403 of ./engine/common/net_encode.cpp*

### Delta_AddField

*qboolean Delta_AddField(const char * pStructName, const char * pName, int flags, int bits, float mul, float post_mul)*

*Defined at line 418 of ./engine/common/net_encode.cpp*

### Delta_ParseField

*qboolean Delta_ParseField(char ** delta_script, const delta_field_t * pInfo, delta_t * pField, qboolean bPost)*

*Defined at line 558 of ./engine/common/net_encode.cpp*

### Delta_ParseTable

*void Delta_ParseTable(char ** delta_script, delta_info_t * dt, const char * encodeDll, const char * encodeFunc)*

*Defined at line 698 of ./engine/common/net_encode.cpp*

### Delta_ClampIntegerField

*int Delta_ClampIntegerField(delta_t * pField, int iValue, qboolean bSigned, int numbits)*

*Defined at line 897 of ./engine/common/net_encode.cpp*

=====================Delta_ClampIntegerField

prevent data to out of range=====================

### Delta_CompareField

*qboolean Delta_CompareField(delta_t * pField, void * from, void * to, float timebase)*

*Defined at line 922 of ./engine/common/net_encode.cpp*

=====================Delta_CompareField

compare fields by offsetsassume from and to is valid=====================

### Delta_WriteField

*qboolean Delta_WriteField(sizebuf_t * msg, delta_t * pField, void * from, void * to, float timebase)*

*Defined at line 1105 of ./engine/common/net_encode.cpp*

=====================Delta_WriteField

write fields by offsetsassume from and to is valid=====================

### Delta_ReadField

*qboolean Delta_ReadField(sizebuf_t * msg, delta_t * pField, void * from, void * to, float timebase)*

*Defined at line 1188 of ./engine/common/net_encode.cpp*

=====================Delta_ReadField

read fields by offsetsassume 'from' and 'to' is valid=====================

### monster_cine_scientist

*void monster_cine_scientist(entvars_t * pev)*

*Defined at line 93 of ./game/server/npc/npc_h_cine.cpp*

### monster_cine_panther

*void monster_cine_panther(entvars_t * pev)*

*Defined at line 94 of ./game/server/npc/npc_h_cine.cpp*

### monster_cine_barney

*void monster_cine_barney(entvars_t * pev)*

*Defined at line 95 of ./game/server/npc/npc_h_cine.cpp*

### monster_cine2_scientist

*void monster_cine2_scientist(entvars_t * pev)*

*Defined at line 96 of ./game/server/npc/npc_h_cine.cpp*

### monster_cine2_hvyweapons

*void monster_cine2_hvyweapons(entvars_t * pev)*

*Defined at line 97 of ./game/server/npc/npc_h_cine.cpp*

### monster_cine2_slave

*void monster_cine2_slave(entvars_t * pev)*

*Defined at line 98 of ./game/server/npc/npc_h_cine.cpp*

### monster_cine3_scientist

*void monster_cine3_scientist(entvars_t * pev)*

*Defined at line 99 of ./game/server/npc/npc_h_cine.cpp*

### monster_cine3_barney

*void monster_cine3_barney(entvars_t * pev)*

*Defined at line 100 of ./game/server/npc/npc_h_cine.cpp*

### cine_blood

*void cine_blood(entvars_t * pev)*

*Defined at line 193 of ./game/server/npc/npc_h_cine.cpp*

### CL_CmpStudioTextures

*qboolean CL_CmpStudioTextures(int numtexs, mstudiotexture_t * p1, mstudiotexture_t * p2)*

*Defined at line 44 of ./engine/client/cl_remap.cpp*

====================CL_CmpStudioTextures

return true if equal====================

### CL_CreateRawTextureFromPixels

*byte * CL_CreateRawTextureFromPixels(texture_t * tx, size_t * size, int topcolor, int bottomcolor)*

*Defined at line 68 of ./engine/client/cl_remap.cpp*

====================CL_CreateRawTextureFromPixels

Convert texture_t struct into mstudiotexture_t prototype====================

### CL_DuplicateTexture

*void CL_DuplicateTexture(mstudiotexture_t * ptexture, int topcolor, int bottomcolor)*

*Defined at line 101 of ./engine/client/cl_remap.cpp*

====================CL_DuplicateTexture

Dupliacte texture with remap pixels====================

### CL_UpdateStudioTexture

*void CL_UpdateStudioTexture(mstudiotexture_t * ptexture, int topcolor, int bottomcolor)*

*Defined at line 144 of ./engine/client/cl_remap.cpp*

====================CL_UpdateStudioTexture

Update texture top and bottom colors====================

### CL_UpdateAliasTexture

*void CL_UpdateAliasTexture(unsigned short * texture, int skinnum, int topcolor, int bottomcolor)*

*Defined at line 205 of ./engine/client/cl_remap.cpp*

====================CL_UpdateAliasTexture

Update texture top and bottom colors====================

### FracNoise

*void FracNoise(float * noise, int divs)*

*Defined at line 47 of ./rendersystem/r_beams.cpp*

 freq2 += step * 0.1; Fractal noise generator, power of 2 wavelength

### SineNoise

*void SineNoise(float * noise, int divs)*

*Defined at line 64 of ./rendersystem/r_beams.cpp*

### R_BeamComputePerpendicular

*void R_BeamComputePerpendicular(const vec3_t vecBeamDelta, vec3_t pPerp)*

*Defined at line 85 of ./rendersystem/r_beams.cpp*

==============================================================

BEAM MATHLIB

==============================================================

### R_BeamComputeNormal

*void R_BeamComputeNormal(const vec3_t vStartPos, const vec3_t vNextPos, vec3_t pNormal)*

*Defined at line 95 of ./rendersystem/r_beams.cpp*

### R_DrawSegs

*void R_DrawSegs(vec3_t source, vec3_t delta, float width, float scale, float freq, float speed, int segments, int flags)*

*Defined at line 193 of ./rendersystem/r_beams.cpp*

==============================================================

BEAM DRAW METHODS

==============================================================

================R_DrawSegs

general code for drawing beams================

### R_DrawTorus

*void R_DrawTorus(vec3_t source, vec3_t delta, float width, float scale, float freq, float speed, int segments)*

*Defined at line 375 of ./rendersystem/r_beams.cpp*

================R_DrawTorus

Draw beamtours================

### R_DrawDisk

*void R_DrawDisk(vec3_t source, vec3_t delta, float width, float scale, float freq, float speed, int segments)*

*Defined at line 464 of ./rendersystem/r_beams.cpp*

================R_DrawDisk

Draw beamdisk================

### R_DrawCylinder

*void R_DrawCylinder(vec3_t source, vec3_t delta, float width, float scale, float freq, float speed, int segments)*

*Defined at line 522 of ./rendersystem/r_beams.cpp*

================R_DrawCylinder

Draw beam cylinder================

### R_DrawBeamFollow

*void R_DrawBeamFollow(BEAM * pbeam, float frametime)*

*Defined at line 579 of ./rendersystem/r_beams.cpp*

==============R_DrawBeamFollow

drawi followed beam==============

### R_DrawRing

*void R_DrawRing(vec3_t source, vec3_t delta, float width, float amplitude, float freq, float speed, int segments)*

*Defined at line 729 of ./rendersystem/r_beams.cpp*

================R_DrawRing

Draw beamring================

### R_BeamComputePoint

*qboolean R_BeamComputePoint(int beamEnt, vec3_t pt)*

*Defined at line 851 of ./rendersystem/r_beams.cpp*

==============R_BeamComputePoint

compute attachment point for beam==============

### R_BeamRecomputeEndpoints

*qboolean R_BeamRecomputeEndpoints(BEAM * pbeam)*

*Defined at line 890 of ./rendersystem/r_beams.cpp*

==============R_BeamRecomputeEndpoints

Recomputes beam endpoints..==============

### R_BeamDraw

*void R_BeamDraw(BEAM * pbeam, float frametime)*

*Defined at line 943 of ./rendersystem/r_beams.cpp*

==============R_BeamDraw

Update beam vars and draw it==============

### R_BeamSetAttributes

*void R_BeamSetAttributes(BEAM * pbeam, float r, float g, float b, float framerate, int startFrame)*

*Defined at line 1132 of ./rendersystem/r_beams.cpp*

==============R_BeamSetAttributes

set beam attributes==============

### R_BeamSetup

*void R_BeamSetup(BEAM * pbeam, vec3_t start, vec3_t end, int modelIndex, float life, float width, float amplitude, float brightness, float speed)*

*Defined at line 1149 of ./rendersystem/r_beams.cpp*

==============R_BeamSetup

generic function. all beams must bepassed through this==============

### R_BeamDrawCustomEntity

*void R_BeamDrawCustomEntity(cl_entity_t * ent)*

*Defined at line 1189 of ./rendersystem/r_beams.cpp*

==============R_BeamDrawCustomEntity

initialize beam from server entity==============

### VGui_Startup

*void VGui_Startup(const char * clientlib, int width, int height)*

*Defined at line 226 of ./engine/client/vgui/vgui_draw.cpp*

 vgui_draw.c

================VGui_Startup

Load vgui_support library and call VGui_Startup================

### VGui_Shutdown

*void VGui_Shutdown()*

*Defined at line 347 of ./engine/client/vgui/vgui_draw.cpp*

================VGui_Shutdown

Unload vgui_support library and call VGui_Shutdown================

### VGui_Paint

*void VGui_Paint()*

*Defined at line 536 of ./engine/client/vgui/vgui_draw.cpp*

### VGui_RunFrame

*void VGui_RunFrame()*

*Defined at line 542 of ./engine/client/vgui/vgui_draw.cpp*

### VGui_KeyEvent

*void VGui_KeyEvent(int key, int down)*

*Defined at line 492 of ./engine/client/vgui/vgui_draw.cpp*

### VGui_MouseMove

*void VGui_MouseMove(int x, int y)*

*Defined at line 528 of ./engine/client/vgui/vgui_draw.cpp*

### VGui_IsActive

*qboolean VGui_IsActive()*

*Defined at line 197 of ./engine/client/vgui/vgui_draw.cpp*

### VGui_GetPanel

*void * VGui_GetPanel()*

*Defined at line 548 of ./engine/client/vgui/vgui_draw.cpp*

### IN_StartupMouse

*void IN_StartupMouse()*

*Defined at line 111 of ./engine/client/input.cpp*

===========IN_StartupMouse===========

### IN_ActivateCursor

*void IN_ActivateCursor()*

*Defined at line 128 of ./engine/client/input.cpp*

### IN_MouseMove

*void IN_MouseMove()*

*Defined at line 329 of ./engine/client/input.cpp*

================IN_MouseMove================

### IN_JoyAppendMove

*void IN_JoyAppendMove(usercmd_t * cmd, float forwardmove, float sidemove)*

*Defined at line 481 of ./engine/client/input.cpp*

### IN_CollectInput

*void IN_CollectInput(float * forward, float * side, float * pitch, float * yaw, qboolean includeMouse, qboolean includeSdlMouse)*

*Defined at line 555 of ./engine/client/input.cpp*

### CL_ExecuteMsgHooks

*void CL_ExecuteMsgHooks(int cmd, sizebuf_t * msg)*

*Defined at line 2802 of ./engine/client/cl_parse.cpp*

### CL_UserMsgStub

*int CL_UserMsgStub(const char * pszName, int iSize, void * pbuf)*

*Defined at line 35 of ./engine/client/cl_parse.cpp*

===============CL_UserMsgStub

Default stub for missed callbacks===============

### CL_ParseSoundPacket

*void CL_ParseSoundPacket(sizebuf_t * msg)*

*Defined at line 61 of ./engine/client/cl_parse.cpp*

==================CL_ParseSoundPacket

==================

### CL_ParseRestoreSoundPacket

*void CL_ParseRestoreSoundPacket(sizebuf_t * msg)*

*Defined at line 123 of ./engine/client/cl_parse.cpp*

==================CL_ParseRestoreSoundPacket

==================

### CL_ParseSignon

*void CL_ParseSignon(sizebuf_t * msg)*

*Defined at line 220 of ./engine/client/cl_parse.cpp*

==================CL_ParseSignon

==================

### CL_ParseMovevars

*void CL_ParseMovevars(sizebuf_t * msg)*

*Defined at line 241 of ./engine/client/cl_parse.cpp*

==================CL_ParseMovevars

==================

### CL_ParseParticles

*void CL_ParseParticles(sizebuf_t * msg)*

*Defined at line 268 of ./engine/client/cl_parse.cpp*

==================CL_ParseParticles

==================

### CL_ParseStaticEntity

*void CL_ParseStaticEntity(sizebuf_t * msg)*

*Defined at line 308 of ./engine/client/cl_parse.cpp*

==================CL_ParseStaticEntity

static client entity==================

### CL_ParseStaticDecal

*void CL_ParseStaticDecal(sizebuf_t * msg)*

*Defined at line 388 of ./engine/client/cl_parse.cpp*

==================CL_ParseStaticDecal

==================

### CL_ParseSoundFade

*void CL_ParseSoundFade(sizebuf_t * msg)*

*Defined at line 415 of ./engine/client/cl_parse.cpp*

==================CL_ParseSoundFade

==================

### CL_PlayerHasCustomization

*customization_t * CL_PlayerHasCustomization(int nPlayerNum, resourcetype_t type)*

*Defined at line 631 of ./engine/client/cl_parse.cpp*

### CL_RemoveCustomization

*void CL_RemoveCustomization(int nPlayerNum, customization_t * pRemove)*

*Defined at line 643 of ./engine/client/cl_parse.cpp*

### CL_ParseCustomization

*void CL_ParseCustomization(sizebuf_t * msg)*

*Defined at line 680 of ./engine/client/cl_parse.cpp*

==================CL_ParseCustomization

==================

### CL_ParseResourceRequest

*void CL_ParseResourceRequest(sizebuf_t * msg)*

*Defined at line 768 of ./engine/client/cl_parse.cpp*

==================CL_ParseResourceRequest

==================

### CL_CreateCustomizationList

*void CL_CreateCustomizationList()*

*Defined at line 814 of ./engine/client/cl_parse.cpp*

==================CL_CreateCustomizationList

loading custom decal for self==================

### CL_ParseFileTransferFailed

*void CL_ParseFileTransferFailed(sizebuf_t * msg)*

*Defined at line 838 of ./engine/client/cl_parse.cpp*

==================CL_ParseFileTransferFailed

==================

### CL_ParseServerData

*void CL_ParseServerData(sizebuf_t * msg)*

*Defined at line 858 of ./engine/client/cl_parse.cpp*

=====================================================================

  SERVER CONNECTING MESSAGES

=====================================================================

==================CL_ParseServerData==================

### CL_ParseClientData

*void CL_ParseClientData(sizebuf_t * msg)*

*Defined at line 1000 of ./engine/client/cl_parse.cpp*

===================CL_ParseClientData===================

### CL_ParseBaseline

*void CL_ParseBaseline(sizebuf_t * msg)*

*Defined at line 1161 of ./engine/client/cl_parse.cpp*

==================CL_ParseBaseline==================

### CL_ParseLightStyle

*void CL_ParseLightStyle(sizebuf_t * msg)*

*Defined at line 1202 of ./engine/client/cl_parse.cpp*

================CL_ParseLightStyle================

### CL_ParseSetAngle

*void CL_ParseSetAngle(sizebuf_t * msg)*

*Defined at line 1222 of ./engine/client/cl_parse.cpp*

================CL_ParseSetAngle

set the view angle to this absolute value================

### CL_ParseAddAngle

*void CL_ParseAddAngle(sizebuf_t * msg)*

*Defined at line 1236 of ./engine/client/cl_parse.cpp*

================CL_ParseAddAngle

add the view angle yaw================

### CL_ParseCrosshairAngle

*void CL_ParseCrosshairAngle(sizebuf_t * msg)*

*Defined at line 1265 of ./engine/client/cl_parse.cpp*

================CL_ParseCrosshairAngle

offset crosshair angles================

### CL_ParseRestore

*void CL_ParseRestore(sizebuf_t * msg)*

*Defined at line 1279 of ./engine/client/cl_parse.cpp*

================CL_ParseRestore

reading decals, etc.================

### CL_RegisterUserMessage

*void CL_RegisterUserMessage(sizebuf_t * msg)*

*Defined at line 1306 of ./engine/client/cl_parse.cpp*

================CL_RegisterUserMessage

register new user message or update existing================

### CL_UpdateUserinfo

*void CL_UpdateUserinfo(sizebuf_t * msg)*

*Defined at line 1365 of ./engine/client/cl_parse.cpp*

================CL_RegisterUserMessage

register new user message or update existing================

void CL_LegacyRegisterUserMessage( sizebuf_t *msg ){	char	*pszName;	int	svc_num, size;

	svc_num = MSG_ReadByte( msg );	size = MSG_ReadByte( msg );	pszName = MSG_ReadString( msg );

	// important stuff	if( size == 0xFF ) size = -1;	svc_num = bound( 0, svc_num, 255 );

	CL_LinkUserMessage( pszName, svc_num, size );}

================CL_UpdateUserinfo

collect userinfo from all players================

### CL_ParseResource

*void CL_ParseResource(sizebuf_t * msg)*

*Defined at line 1402 of ./engine/client/cl_parse.cpp*

==============CL_ParseResource

downloading and precache resource in-game==============

### CL_UpdateUserPings

*void CL_UpdateUserPings(sizebuf_t * msg)*

*Defined at line 1430 of ./engine/client/cl_parse.cpp*

================CL_UpdateUserPings

collect pings and packet lossage from clients================

### CL_SendConsistencyInfo

*void CL_SendConsistencyInfo(sizebuf_t * msg)*

*Defined at line 1450 of ./engine/client/cl_parse.cpp*

### CL_ParseConsistencyInfo

*void CL_ParseConsistencyInfo(sizebuf_t * msg)*

*Defined at line 1587 of ./engine/client/cl_parse.cpp*

### CL_ParseResourceList

*void CL_ParseResourceList(sizebuf_t * msg)*

*Defined at line 1652 of ./engine/client/cl_parse.cpp*

==============CL_ParseResourceList

==============

### CL_ParseVoiceInit

*void CL_ParseVoiceInit(sizebuf_t * msg)*

*Defined at line 1689 of ./engine/client/cl_parse.cpp*

==================CL_ParseVoiceInit

==================

### CL_ParseVoiceData

*void CL_ParseVoiceData(sizebuf_t * msg)*

*Defined at line 1700 of ./engine/client/cl_parse.cpp*

==================CL_ParseVoiceData

==================

### CL_ParseResLocation

*void CL_ParseResLocation(sizebuf_t * msg)*

*Defined at line 1711 of ./engine/client/cl_parse.cpp*

==================CL_ParseResLocation

==================

### CL_ParseHLTV

*void CL_ParseHLTV(sizebuf_t * msg)*

*Defined at line 1741 of ./engine/client/cl_parse.cpp*

==============CL_ParseHLTV

spectator message (hltv)sended from game.dll==============

### CL_ParseDirector

*void CL_ParseDirector(sizebuf_t * msg)*

*Defined at line 1776 of ./engine/client/cl_parse.cpp*

==============CL_ParseDirector

spectator message (director)sended from game.dll==============

### CL_ParseScreenShake

*void CL_ParseScreenShake(sizebuf_t * msg)*

*Defined at line 1793 of ./engine/client/cl_parse.cpp*

==============CL_ParseScreenShake

Set screen shake==============

### CL_ParseScreenFade

*void CL_ParseScreenFade(sizebuf_t * msg)*

*Defined at line 1809 of ./engine/client/cl_parse.cpp*

==============CL_ParseScreenFade

Set screen fade==============

### CL_ParseCvarValue

*void CL_ParseCvarValue(sizebuf_t * msg)*

*Defined at line 1862 of ./engine/client/cl_parse.cpp*

==============CL_ParseCvarValue

Find the client cvar valueand sent it back to the server==============

### CL_ParseCvarValue2

*void CL_ParseCvarValue2(sizebuf_t * msg)*

*Defined at line 1880 of ./engine/client/cl_parse.cpp*

==============CL_ParseCvarValue2

Find the client cvar valueand sent it back to the server==============

### CL_LegacyParseBaseline

*void CL_LegacyParseBaseline(sizebuf_t * msg)*

*Defined at line 2348 of ./engine/client/cl_parse.cpp*

==================CL_ParseBaseline==================

### CL_ParseLegacyServerData

*void CL_ParseLegacyServerData(sizebuf_t * msg)*

*Defined at line 2378 of ./engine/client/cl_parse.cpp*

==================CL_ParseServerData==================

### CL_LegacyParseStaticEntity

*void CL_LegacyParseStaticEntity(sizebuf_t * msg)*

*Defined at line 2512 of ./engine/client/cl_parse.cpp*

==================CL_ParseStaticEntity

static client entity==================

### CL_LegacyParseSoundPacket

*void CL_LegacyParseSoundPacket(sizebuf_t * msg, qboolean is_ambient)*

*Defined at line 2582 of ./engine/client/cl_parse.cpp*

### CL_LegacyPrecacheSound

*void CL_LegacyPrecacheSound(sizebuf_t * msg)*

*Defined at line 2651 of ./engine/client/cl_parse.cpp*

================CL_PrecacheSound

prceache sound from server================

### CL_LegacyPrecacheModel

*void CL_LegacyPrecacheModel(sizebuf_t * msg)*

*Defined at line 2668 of ./engine/client/cl_parse.cpp*

### CL_LegacyPrecacheEvent

*void CL_LegacyPrecacheEvent(sizebuf_t * msg)*

*Defined at line 2698 of ./engine/client/cl_parse.cpp*

### CL_LegacyUpdateUserinfo

*void CL_LegacyUpdateUserinfo(sizebuf_t * msg)*

*Defined at line 2714 of ./engine/client/cl_parse.cpp*

### CL_LegacyParseResourceList

*void CL_LegacyParseResourceList(sizebuf_t * msg)*

*Defined at line 2750 of ./engine/client/cl_parse.cpp*

==============CL_ParseResourceList

==============

### pfnHookClientNetsystemMsg

*void pfnHookClientNetsystemMsg(void (*)(void *) pfnHook)*

*Defined at line 2813 of ./engine/client/cl_parse.cpp*

### pfnHookClientMsg

*void pfnHookClientMsg(int cmd, void (*)(void *) pfnHook)*

*Defined at line 2819 of ./engine/client/cl_parse.cpp*

### pfnBeginClientCmd

*sizebuf_t * pfnBeginClientCmd(int msg)*

*Defined at line 2827 of ./engine/client/cl_parse.cpp*

### UI_TouchEdit_Precache

*void UI_TouchEdit_Precache()*

*Defined at line 104 of ./mainui/menus/TouchEdit.cpp*

=================UI_TouchEdit_Precache=================

### VGUI_EngineMalloc

*void * VGUI_EngineMalloc(size_t size)*

*Defined at line 52 of ./engine/client/vgui/vgui_draw.cpp*

void VGUI_HideCursor( void ){	host.mouse_visible = false;	SDL_HideCursor();}

void VGUI_ShowCursor( void ){	host.mouse_visible = true;	SDL_ShowCursor();}

### VGUI_IsInGame

*qboolean VGUI_IsInGame()*

*Defined at line 57 of ./engine/client/vgui/vgui_draw.cpp*

### VGUI_GetMousePos

*void VGUI_GetMousePos(int * _x, int * _y)*

*Defined at line 62 of ./engine/client/vgui/vgui_draw.cpp*

### VGUI_InitCursors

*void VGUI_InitCursors()*

*Defined at line 72 of ./engine/client/vgui/vgui_draw.cpp*

### VGUI_CursorSelect

*void VGUI_CursorSelect(enum VGUI_DefaultCursor cursor)*

*Defined at line 94 of ./engine/client/vgui/vgui_draw.cpp*

### VGUI_GetColor

*byte VGUI_GetColor(int i, int j)*

*Defined at line 137 of ./engine/client/vgui/vgui_draw.cpp*

### VGUI_SetVisible

*void VGUI_SetVisible(qboolean state)*

*Defined at line 144 of ./engine/client/vgui/vgui_draw.cpp*

 Define and initialize vgui API

### VGUI_UtfProcessChar

*int VGUI_UtfProcessChar(int in)*

*Defined at line 155 of ./engine/client/vgui/vgui_draw.cpp*

### VGui_FillAPIFromRef

*void VGui_FillAPIFromRef(vguiapi_t * to, const ref_interface_t * from)*

*Defined at line 202 of ./engine/client/vgui/vgui_draw.cpp*

### VGUI_InitKeyTranslationTable

*void VGUI_InitKeyTranslationTable()*

*Defined at line 360 of ./engine/client/vgui/vgui_draw.cpp*

### VGUI_MapKey

*enum VGUI_KeyCode VGUI_MapKey(int keyCode)*

*Defined at line 477 of ./engine/client/vgui/vgui_draw.cpp*

### Game_AddObjects

*void Game_AddObjects()*

*Defined at line 110 of ./game/client/hl/hl_objects.cpp*

=====================Game_AddObjects

Add game specific, client-side objects here=====================

### HUD_AddEntity

*int HUD_AddEntity(int type, struct cl_entity_s * ent, const char * modelname)*

*Defined at line 48 of ./game/client/entity.cpp*

========================HUD_AddEntity	Return 0 to filter entity from visible list for rendering        Called each frame to add entities to the draw list========================

### HUD_CreateEntities

*void HUD_CreateEntities()*

*Defined at line 508 of ./game/client/entity.cpp*

=========================HUD_CreateEntities

Gives us a chance to add additional entities to the render this frame=========================

### HUD_StudioEvent

*void HUD_StudioEvent(const struct mstudioevent_s * event, const struct cl_entity_s * entity)*

*Defined at line 542 of ./game/client/entity.cpp*

=========================HUD_StudioEvent

The entity's studio model description indicated an event wasfired during this frame, handle the event by it's tag ( e.g., muzzleflash, sound )=========================

### HUD_TxferLocalOverrides

*void HUD_TxferLocalOverrides(struct entity_state_s * state, const struct clientdata_s * client)*

*Defined at line 86 of ./game/client/entity.cpp*

=========================HUD_TxferLocalOverrides

The server sends us our origin with extra precision as part of the clientdata structure, not during the normalplayerstate update in entity_state_t.  In order for these overrides to eventually get to the appropriate playerstatestructure, we need to copy them into the state structure at this point.=========================

### HUD_ProcessPlayerState

*void HUD_ProcessPlayerState(struct entity_state_s * dst, const struct entity_state_s * src)*

*Defined at line 109 of ./game/client/entity.cpp*

=========================HUD_ProcessPlayerState

We have received entity_state_t for this player over the network.  We need to copy appropriate fields to theplayerstate structure=========================

### HUD_TxferPredictionData

*void HUD_TxferPredictionData(struct entity_state_s * ps, const struct entity_state_s * pps, struct clientdata_s * pcd, const struct clientdata_s * ppcd, struct weapon_data_s * wd, const struct weapon_data_s * pwd)*

*Defined at line 175 of ./game/client/entity.cpp*

=========================HUD_TxferPredictionData

Because we can predict an arbitrary number of frames before the server responds with an update, we need to be able to copy client side prediction data in from the state that the server ack'd receiving, which can be anywhere along the predicted frame path ( i.e., we could predict 20 frames into the future and the server ack's up through 10 of those frames, so we need to copy persistent client-side only state from the 10th predicted frame to the slot the server update is occupying.=========================

### HUD_TempEntUpdate

*void HUD_TempEntUpdate(double frametime, double client_time, double cl_gravity, struct tempent_s ** ppTempEntFree, struct tempent_s ** ppTempEntActive, int (*)(struct cl_entity_s *) Callback_AddVisibleEntity, void (*)(struct tempent_s *, float) Callback_TempEntPlaySound)*

*Defined at line 577 of ./game/client/entity.cpp*

=================CL_UpdateTEnts

Simulation and cleanup of temporary entities=================

### HUD_GetUserEntity

*struct cl_entity_s * HUD_GetUserEntity(int index)*

*Defined at line 944 of ./game/client/entity.cpp*

=================HUD_GetUserEntity

If you specify negative numbers for beam start and end point entities, then  the engine will call back into this function requesting a pointer to a cl_entity_t   object that describes the entity to attach the beam onto.

Indices must start at 1, not zero.=================

### monster_gman

*void monster_gman(entvars_t * pev)*

*Defined at line 55 of ./game/server/npc/npc_gman.cpp*

### cycler

*void cycler(entvars_t * pev)*

*Defined at line 74 of ./game/server/npc/npc_h_cycler.cpp*

### cycler_prdroid

*void cycler_prdroid(entvars_t * pev)*

*Defined at line 86 of ./game/server/npc/npc_h_cycler.cpp*

### cycler_sprite

*void cycler_sprite(entvars_t * pev)*

*Defined at line 235 of ./game/server/npc/npc_h_cycler.cpp*

### cycler_weapon

*void cycler_weapon(entvars_t * pev)*

*Defined at line 310 of ./game/server/npc/npc_h_cycler.cpp*

### cycler_wreckage

*void cycler_wreckage(entvars_t * pev)*

*Defined at line 390 of ./game/server/npc/npc_h_cycler.cpp*

### Sys_DebuggerPresent

*qboolean Sys_DebuggerPresent()*

*Defined at line 45 of ./engine/platform/linux/sys_linux.cpp*

### Sys_WaitForQuit

*void Sys_WaitForQuit()*

*Defined at line 354 of ./engine/common/system.cpp*

================Sys_WaitForQuit

wait for 'Esc' key will be hit================

### ConnectNetsystemLibraries

*void ConnectNetsystemLibraries()*

*Defined at line 50 of ./networksystem/networksystem.cpp*

### NetworksystemInit

*void NetworksystemInit()*

*Defined at line 56 of ./networksystem/networksystem.cpp*

### NetworksystemInit_Client

*void NetworksystemInit_Client()*

*Defined at line 70 of ./networksystem/networksystem.cpp*

### NetworksystemInit_Server

*void NetworksystemInit_Server()*

*Defined at line 76 of ./networksystem/networksystem.cpp*

### NetworksystemShutdown

*void NetworksystemShutdown()*

*Defined at line 63 of ./networksystem/networksystem.cpp*

### SV_ParseNetsysMessage

*void SV_ParseNetsysMessage(edict_t * e, void * msg)*

*Defined at line 243 of ./networksystem/networksystem.cpp*

 Parse a netsys message received from a client connected to the server 

### CL_ParseNetsysMessage

*void CL_ParseNetsysMessage(void * msg)*

*Defined at line 202 of ./networksystem/networksystem.cpp*

 Parse a netsys message received from the server

### IsComment

*int IsComment(const char * pText)*

*Defined at line 27 of ./engine/client/titles.cpp*

 the string "pText" is assumed to have all whitespace from both ends cut out

### IsStartOfText

*int IsStartOfText(const char * pText)*

*Defined at line 46 of ./engine/client/titles.cpp*

 the string "pText" is assumed to have all whitespace from both ends cut out

### IsEndOfText

*int IsEndOfText(const char * pText)*

*Defined at line 57 of ./engine/client/titles.cpp*

 the string "pText" is assumed to have all whitespace from both ends cut out

### IsWhiteSpace

*int IsWhiteSpace(char space)*

*Defined at line 67 of ./engine/client/titles.cpp*

### SkipSpace

*const char * SkipSpace(const char * pText)*

*Defined at line 74 of ./engine/client/titles.cpp*

### SkipText

*const char * SkipText(const char * pText)*

*Defined at line 86 of ./engine/client/titles.cpp*

### ParseFloats

*int ParseFloats(const char * pText, float * pFloat, int count)*

*Defined at line 98 of ./engine/client/titles.cpp*

### IsToken

*int IsToken(const char * pText, const char * pTokenName)*

*Defined at line 124 of ./engine/client/titles.cpp*

### ParseDirective

*int ParseDirective(const char * pText)*

*Defined at line 135 of ./engine/client/titles.cpp*

### monster_satchel

*void monster_satchel(entvars_t * pev)*

*Defined at line 65 of ./game/shared/hl1/weapon_satchel.cpp*

### weapon_satchel

*void weapon_satchel(entvars_t * pev)*

*Defined at line 188 of ./game/shared/hl1/weapon_satchel.cpp*

### weapon_tripmine

*void weapon_tripmine(entvars_t * pev)*

*Defined at line 355 of ./game/shared/hl1/weapon_tripmine.cpp*

### Key_Unbind_f

*void Key_Unbind_f()*

*Defined at line 340 of ./engine/client/keys.cpp*

===================Key_Unbind_f===================

### Key_Unbindall_f

*void Key_Unbindall_f()*

*Defined at line 366 of ./engine/client/keys.cpp*

===================Key_Unbindall_f===================

### Key_Reset_f

*void Key_Reset_f()*

*Defined at line 385 of ./engine/client/keys.cpp*

===================Key_Reset_f===================

### Key_Bind_f

*void Key_Bind_f()*

*Defined at line 407 of ./engine/client/keys.cpp*

===================Key_Bind_f===================

### Key_Bindlist_f

*void Key_Bindlist_f()*

*Defined at line 478 of ./engine/client/keys.cpp*

============Key_Bindlist_f

============

### Key_AddKeyCommands

*void Key_AddKeyCommands(int key, const char * kb, qboolean down)*

*Defined at line 524 of ./engine/client/keys.cpp*

===================Key_AddKeyCommands===================

### Key_IsAllowedAutoRepeat

*qboolean Key_IsAllowedAutoRepeat(int key)*

*Defined at line 570 of ./engine/client/keys.cpp*

===================Key_IsAllowedAutoRepeat

List of keys that allows auto-repeat===================

### weapon_crossbow

*void weapon_crossbow(entvars_t * pev)*

*Defined at line 259 of ./game/shared/hl1/weapon_crossbow.cpp*

### ammo_crossbow

*void ammo_crossbow(entvars_t * pev)*

*Defined at line 560 of ./game/shared/hl1/weapon_crossbow.cpp*

### COM_ExtractExtension

*const char * COM_ExtractExtension(const char * s)*

*Defined at line 563 of ./mainui/BaseMenu.cpp*

### UI_StartBackGroundMap

*_Bool UI_StartBackGroundMap()*

*Defined at line 580 of ./mainui/BaseMenu.cpp*

=================UI_StartBackGroundMap=================

### UI_Precache

*void UI_Precache()*

*Defined at line 939 of ./mainui/BaseMenu.cpp*

=================UI_Precache=================

### UI_ParseColor

*void UI_ParseColor(char *& pfile, unsigned int * outColor)*

*Defined at line 961 of ./mainui/BaseMenu.cpp*

### UI_ApplyCustomColors

*void UI_ApplyCustomColors()*

*Defined at line 976 of ./mainui/BaseMenu.cpp*

### UI_LoadBackgroundMapList

*void UI_LoadBackgroundMapList()*

*Defined at line 1033 of ./mainui/BaseMenu.cpp*

### UI_UpdateDialog_f

*void UI_UpdateDialog_f()*

*Defined at line 1175 of ./mainui/BaseMenu.cpp*

### Con_Reportf

*void Con_Reportf(const char * channel, const char * fmt)*

*Defined at line 318 of ./engine/common/sys_con.cpp*

### Con_DPrintf

*void Con_DPrintf(const char * channel, const char * fmt)*

*Defined at line 338 of ./engine/common/sys_con.cpp*

### Con_Printf

*void Con_Printf(const char * channel, const char * fmt)*

*Defined at line 360 of ./engine/common/sys_con.cpp*

### SDL_SoundCallback

*void SDL_SoundCallback(void * userdata, Uint8 * stream, int len)*

*Defined at line 38 of ./engine/platform/sdl/s_sdl.cpp*

static qboolean	snd_firsttime = true;static qboolean	primary_format_set;

### SNDDMA_GetDMAPos

*int SNDDMA_GetDMAPos()*

*Defined at line 140 of ./engine/platform/sdl/s_sdl.cpp*

==============SNDDMA_GetDMAPos

return the current sample position (in mono samples read)inside the recirculating dma buffer, so the mixing code will knowhow many sample are required to fill it up.===============

### WordSwapC

*T WordSwapC(T w)*

*Defined at line 22 of ./mainui/miniutl/minbase_endian.h*

------------------------------------- Basic swaps-------------------------------------

### DWordSwapC

*T DWordSwapC(T dw)*

*Defined at line 37 of ./mainui/miniutl/minbase_endian.h*

### QWordSwapC

*T QWordSwapC(T dw)*

*Defined at line 55 of ./mainui/miniutl/minbase_endian.h*

### LoadLittleDWord

*uint32 LoadLittleDWord(uint32 * base, unsigned int dwordIndex)*

*Defined at line 182 of ./mainui/miniutl/minbase_endian.h*

### StoreLittleDWord

*void StoreLittleDWord(uint32 * base, unsigned int dwordIndex, uint32 dword)*

*Defined at line 187 of ./mainui/miniutl/minbase_endian.h*

### GetCStringCharConversion

*class CUtlCharConversion * GetCStringCharConversion()*

*Defined at line 69 of ./mainui/miniutl/utlbuffer.cpp*

----------------------------------------------------------------------------- Character conversions for C strings-----------------------------------------------------------------------------

### GetNoEscCharConversion

*class CUtlCharConversion * GetNoEscCharConversion()*

*Defined at line 78 of ./mainui/miniutl/utlbuffer.cpp*

----------------------------------------------------------------------------- Character conversions for quoted strings, with no escape sequences-----------------------------------------------------------------------------

### lran1

*int lran1()*

*Defined at line 71 of ./engine/common/common.cpp*

### fran1

*float fran1()*

*Defined at line 105 of ./engine/common/common.cpp*

 fran1 -- return a random floating-point number on the interval [0,1]

### LZSS_BuildHash

*void LZSS_BuildHash(lzss_state_t * state, const byte * source)*

*Defined at line 219 of ./engine/common/common.cpp*

### LZSS_CompressNoAlloc

*byte * LZSS_CompressNoAlloc(lzss_state_t * state, byte * pInput, int input_length, byte * pOutputBuf, uint * pOutputSize)*

*Defined at line 252 of ./engine/common/common.cpp*

### COM_IsSingleChar

*int COM_IsSingleChar(char c)*

*Defined at line 452 of ./engine/common/common.cpp*

==============COM_IsSingleChar

interpert this character as single==============

### COM_IsWhiteSpace

*int COM_IsWhiteSpace(char space)*

*Defined at line 474 of ./engine/common/common.cpp*

==============COM_IsWhiteSpace

interpret symbol as whitespace==============

### COM_Nibble

*byte COM_Nibble(char c)*

*Defined at line 746 of ./engine/common/common.cpp*

==================COM_Nibble

Returns the 4 bit nibble for a hex character==================

### func_door

*void func_door(entvars_t * pev)*

*Defined at line 290 of ./game/server/func_door.cpp*

### func_water

*void func_water(entvars_t * pev)*

*Defined at line 294 of ./game/server/func_door.cpp*

### func_door_rotating

*void func_door_rotating(entvars_t * pev)*

*Defined at line 913 of ./game/server/func_door.cpp*

### momentary_door

*void momentary_door(entvars_t * pev)*

*Defined at line 1004 of ./game/server/func_door.cpp*

### V_CalcViewRect

*void V_CalcViewRect()*

*Defined at line 32 of ./engine/client/cl_view.cpp*

===============V_CalcViewRect

calc frame rectangle (Quake1 style)===============

### V_SetupViewModel

*void V_SetupViewModel()*

*Defined at line 82 of ./engine/client/cl_view.cpp*

===============V_SetupViewModel===============

### V_SetRefParams

*void V_SetRefParams(ref_params_t * fd)*

*Defined at line 112 of ./engine/client/cl_view.cpp*

===============V_SetRefParams===============

### V_RefApplyOverview

*void V_RefApplyOverview(ref_viewpass_t * rvp)*

*Defined at line 176 of ./engine/client/cl_view.cpp*

===============V_MergeOverviewRefdef

merge refdef with overview settings===============

### V_GetRefParams

*void V_GetRefParams(ref_params_t * fd, ref_viewpass_t * rvp)*

*Defined at line 228 of ./engine/client/cl_view.cpp*

=============V_GetRefParams=============

### R_DrawLeafNode

*void R_DrawLeafNode(float x, float y, float scale)*

*Defined at line 354 of ./engine/client/cl_view.cpp*

### R_DrawNodeConnection

*void R_DrawNodeConnection(float x, float y, float x2, float y2)*

*Defined at line 361 of ./engine/client/cl_view.cpp*

### R_ShowTree_r

*void R_ShowTree_r(mnode_t * node, float x, float y, float scale, int shownodes, mleaf_t * viewleaf)*

*Defined at line 369 of ./engine/client/cl_view.cpp*

### R_ShowTree

*void R_ShowTree()*

*Defined at line 416 of ./engine/client/cl_view.cpp*

### weapon_shotgun

*void weapon_shotgun(entvars_t * pev)*

*Defined at line 43 of ./game/shared/hl1/weapon_shotgun.cpp*

### ammo_buckshot

*void ammo_buckshot(entvars_t * pev)*

*Defined at line 392 of ./game/shared/hl1/weapon_shotgun.cpp*

### CL_ButtonBits

*int CL_ButtonBits(int )*

*Defined at line 901 of ./game/client/input.cpp*

============CL_ButtonBits

Returns appropriate button info for keyboard and mouse stateSet bResetState to 1 to clear old state info============

### CL_ResetButtonBits

*void CL_ResetButtonBits(int bits)*

*Defined at line 1016 of ./game/client/input.cpp*

============CL_ResetButtonBits

============

### HUD_SetCmdBits

*void HUD_SetCmdBits(int bits)*

### CL_UpdatePositions

*void CL_UpdatePositions(cl_entity_t * ent)*

*Defined at line 55 of ./engine/client/cl_frame.cpp*

=========================================================================

FRAME INTERPOLATION

=========================================================================

==================CL_UpdatePositions

Store another position into interpolation circular buffer==================

### CL_ResetPositions

*void CL_ResetPositions(cl_entity_t * ent)*

*Defined at line 74 of ./engine/client/cl_frame.cpp*

==================CL_ResetPositions

Interpolation init or reset after teleporting==================

### CL_EntityTeleported

*qboolean CL_EntityTeleported(cl_entity_t * ent)*

*Defined at line 96 of ./engine/client/cl_frame.cpp*

==================CL_EntityTeleported

check for instant movement in casewe don't want interpolate this==================

### CL_CompareTimestamps

*qboolean CL_CompareTimestamps(float t1, float t2)*

*Defined at line 117 of ./engine/client/cl_frame.cpp*

==================CL_CompareTimestamps

round-off floating errors==================

### CL_EntityIgnoreLerp

*qboolean CL_EntityIgnoreLerp(cl_entity_t * e)*

*Defined at line 132 of ./engine/client/cl_frame.cpp*

==================CL_EntityIgnoreLerp

some ents will be ignore lerping==================

### CL_EntityCustomLerp

*qboolean CL_EntityCustomLerp(cl_entity_t * e)*

*Defined at line 146 of ./engine/client/cl_frame.cpp*

==================CL_EntityCustomLerp

==================

### CL_ParametricMove

*qboolean CL_ParametricMove(cl_entity_t * ent)*

*Defined at line 168 of ./engine/client/cl_frame.cpp*

==================CL_ParametricMove

check for parametrical moved entities==================

### CL_UpdateLatchedVars

*void CL_UpdateLatchedVars(cl_entity_t * ent)*

*Defined at line 205 of ./engine/client/cl_frame.cpp*

====================CL_UpdateLatchedVars

====================

### CL_ProcessEntityUpdate

*void CL_ProcessEntityUpdate(cl_entity_t * ent)*

*Defined at line 300 of ./engine/client/cl_frame.cpp*

==================CL_ProcessEntityUpdate

apply changes since new frame received==================

### CL_FindInterpolationUpdates

*qboolean CL_FindInterpolationUpdates(cl_entity_t * ent, float targettime, position_history_t ** ph0, position_history_t ** ph1)*

*Defined at line 346 of ./engine/client/cl_frame.cpp*

==================CL_FindInterpolationUpdates

find two timestamps==================

### CL_PureOrigin

*void CL_PureOrigin(cl_entity_t * ent, float t, vec3_t outorigin, vec3_t outangles)*

*Defined at line 384 of ./engine/client/cl_frame.cpp*

==================CL_PureOrigin

non-local players interpolation==================

### CL_InterpolateModel

*int CL_InterpolateModel(cl_entity_t * e)*

*Defined at line 434 of ./engine/client/cl_frame.cpp*

==================CL_InterpolateModel

non-players interpolation==================

### CL_ResetLatchedState

*void CL_ResetLatchedState(int pnum, frame_t * frame, cl_entity_t * ent)*

*Defined at line 577 of ./engine/client/cl_frame.cpp*

=================CL_ResetLatchedState

reset latched state if this frame entity was teleportedor just EF_NOINTERP was set=================

### CL_FlushEntityPacket

*void CL_FlushEntityPacket(sizebuf_t * msg)*

*Defined at line 649 of ./engine/client/cl_frame.cpp*

=========================================================================

FRAME PARSING

=========================================================================

=================CL_FlushEntityPacket

Read and ignore whole entity packet.=================

### CL_DeltaEntity

*void CL_DeltaEntity(sizebuf_t * msg, frame_t * frame, int newnum, entity_state_t * old, qboolean has_update)*

*Defined at line 679 of ./engine/client/cl_frame.cpp*

=================CL_DeltaEntity

processing delta update=================

### CL_LinkCustomEntity

*void CL_LinkCustomEntity(cl_entity_t * ent, entity_state_t * state)*

*Defined at line 1009 of ./engine/client/cl_frame.cpp*

=============CL_LinkCustomEntity

Add server beam to draw list=============

### CL_LinkPlayers

*void CL_LinkPlayers(frame_t * frame)*

*Defined at line 1032 of ./engine/client/cl_frame.cpp*

=============CL_LinkPlayers

Create visible entities in the correct positionfor all current players=============

### CL_LinkPacketEntities

*void CL_LinkPacketEntities(frame_t * frame)*

*Defined at line 1113 of ./engine/client/cl_frame.cpp*

===============CL_LinkPacketEntities

===============

### R_SaveVideoMode

*void R_SaveVideoMode(int w, int h)*

*Defined at line 65 of ./engine/client/vid_common.cpp*

=================R_SaveVideoMode=================

### VID_GetModeString

*const char * VID_GetModeString(int vid_mode)*

*Defined at line 87 of ./engine/client/vid_common.cpp*

=================VID_GetModeString=================

### VID_StartupGamma

*void VID_StartupGamma()*

*Defined at line 39 of ./engine/client/vid_common.cpp*

=================VID_StartupGamma=================

### CL_InternetServers_f

*void CL_InternetServers_f()*

*Defined at line 1579 of ./engine/client/cl_main.cpp*

=================CL_InternetServers_f=================

### CL_CheckClientState

*void CL_CheckClientState()*

*Defined at line 182 of ./engine/client/cl_main.cpp*

===============CL_CheckClientState

finalize connection process and begin new framewith new cls.state===============

### CL_LerpPoint

*float CL_LerpPoint()*

*Defined at line 253 of ./engine/client/cl_main.cpp*

===============CL_LerpPoint

Determines the fraction between the last two messages that the objectsshould be put at.===============

### CL_DriftInterpolationAmount

*int CL_DriftInterpolationAmount(int goal)*

*Defined at line 308 of ./engine/client/cl_main.cpp*

===============CL_DriftInterpolationAmount

Drift interpolation value (this is used for server unlag system)===============

### CL_ComputeClientInterpolationAmount

*void CL_ComputeClientInterpolationAmount(usercmd_t * cmd)*

*Defined at line 336 of ./engine/client/cl_main.cpp*

===============CL_ComputeClientInterpolationAmount

Validate interpolation cvars, calc interpolation window===============

### CL_ComputePacketLoss

*void CL_ComputePacketLoss()*

*Defined at line 387 of ./engine/client/cl_main.cpp*

=================CL_ComputePacketLoss

=================

### CL_FindInterpolatedAddAngle

*void CL_FindInterpolatedAddAngle(float t, float * frac, pred_viewangle_t ** prev, pred_viewangle_t ** next)*

*Defined at line 432 of ./engine/client/cl_main.cpp*

### CL_ApplyAddAngle

*void CL_ApplyAddAngle()*

*Defined at line 474 of ./engine/client/cl_main.cpp*

### CL_ProcessShowTexturesCmds

*qboolean CL_ProcessShowTexturesCmds(usercmd_t * cmd)*

*Defined at line 510 of ./engine/client/cl_main.cpp*

=======================================================================

CLIENT MOVEMENT COMMUNICATION

=======================================================================

===============CL_ProcessShowTexturesCmds

navigate around texture atlas===============

### CL_ProcessOverviewCmds

*qboolean CL_ProcessOverviewCmds(usercmd_t * cmd)*

*Defined at line 539 of ./engine/client/cl_main.cpp*

===============CL_ProcessOverviewCmds

Transform user movement into overview adjust===============

### CL_UpdateClientData

*void CL_UpdateClientData()*

*Defined at line 591 of ./engine/client/cl_main.cpp*

=================CL_UpdateClientData

tell the client.dll about player origin, angles, fov, etc=================

### CL_CreateCmd

*void CL_CreateCmd()*

*Defined at line 618 of ./engine/client/cl_main.cpp*

=================CL_CreateCmd=================

### CL_WritePacket

*void CL_WritePacket()*

*Defined at line 717 of ./engine/client/cl_main.cpp*

===================CL_WritePacket

Create and send the command packet to the serverIncluding both the reliable commands and the usercmds===================

### CL_BeginUpload_f

*void CL_BeginUpload_f()*

*Defined at line 911 of ./engine/client/cl_main.cpp*

==================CL_BeginUpload_f==================

### CL_SendConnectPacket

*void CL_SendConnectPacket()*

*Defined at line 1008 of ./engine/client/cl_main.cpp*

=======================CL_SendConnectPacket

We have gotten a challenge from the server, so try andconnect.======================

### CL_CheckForResend

*void CL_CheckForResend()*

*Defined at line 1091 of ./engine/client/cl_main.cpp*

=================CL_CheckForResend

Resend a connect message if the last one has timed out=================

### CL_AddResource

*resource_t * CL_AddResource(resourcetype_t type, const char * name, int size, qboolean bFatalIfMissing, int index)*

*Defined at line 1178 of ./engine/client/cl_main.cpp*

### CL_CreateResourceList

*void CL_CreateResourceList()*

*Defined at line 1195 of ./engine/client/cl_main.cpp*

### CL_Connect_f

*void CL_Connect_f()*

*Defined at line 1237 of ./engine/client/cl_main.cpp*

================CL_Connect_f

================

### CL_Rcon_f

*void CL_Rcon_f()*

*Defined at line 1280 of ./engine/client/cl_main.cpp*

=====================CL_Rcon_f

Send the rest of the command line over asan unconnected command.=====================

### CL_SendDisconnectMessage

*void CL_SendDisconnectMessage()*

*Defined at line 1384 of ./engine/client/cl_main.cpp*

=====================CL_SendDisconnectMessage

Sends a disconnect message to the server=====================

### CL_Reconnect

*void CL_Reconnect(qboolean setup_netchan)*

*Defined at line 1429 of ./engine/client/cl_main.cpp*

=====================CL_Reconnect

build a request to reconnect client=====================

### CL_LocalServers_f

*void CL_LocalServers_f()*

*Defined at line 1557 of ./engine/client/cl_main.cpp*

=================CL_LocalServers_f=================

### CL_Reconnect_f

*void CL_Reconnect_f()*

*Defined at line 1612 of ./engine/client/cl_main.cpp*

=================CL_Reconnect_f

The server is changing levels=================

### CL_FixupColorStringsForInfoString

*void CL_FixupColorStringsForInfoString(const char * in, char * out)*

*Defined at line 1646 of ./engine/client/cl_main.cpp*

=================CL_FixupColorStringsForInfoString

all the keys and values must be ends with ^7=================

### CL_ParseStatusMessage

*void CL_ParseStatusMessage(netadr_s from, sizebuf_t * msg)*

*Defined at line 1710 of ./engine/client/cl_main.cpp*

=================CL_ParseStatusMessage

Handle a reply from a info=================

### CL_ParseNETInfoMessage

*void CL_ParseNETInfoMessage(netadr_s from, sizebuf_t * msg, const char * s)*

*Defined at line 1756 of ./engine/client/cl_main.cpp*

=================CL_ParseNETInfoMessage

Handle a reply from a netinfo=================

### CL_ProcessNetRequests

*void CL_ProcessNetRequests()*

*Defined at line 1811 of ./engine/client/cl_main.cpp*

=================CL_ProcessNetRequests

check for timeouts=================

### CL_IsFromConnectingServer

*qboolean CL_IsFromConnectingServer(netadr_s from)*

*Defined at line 1880 of ./engine/client/cl_main.cpp*

=================CL_IsFromConnectingServer

Used for connectionless packets, when netchan may not be ready.=================

### CL_ConnectionlessPacket

*void CL_ConnectionlessPacket(netadr_s from, sizebuf_t * msg)*

*Defined at line 1893 of ./engine/client/cl_main.cpp*

=================CL_ConnectionlessPacket

Responses to broadcasts, etc=================

### CL_GetMessage

*int CL_GetMessage(byte * data, size_t * length)*

*Defined at line 2186 of ./engine/client/cl_main.cpp*

====================CL_GetMessage

Handles recording and playback of demos, on top of NET_ code====================

### CL_ReadNetMessage

*void CL_ReadNetMessage()*

*Defined at line 2205 of ./engine/client/cl_main.cpp*

=================CL_ReadNetMessage=================

### CL_ReadPackets

*void CL_ReadPackets()*

*Defined at line 2286 of ./engine/client/cl_main.cpp*

=================CL_ReadPackets

Updates the local time and reads/handles messageson client net connection.=================

### CL_CleanFileName

*const char * CL_CleanFileName(const char * filename)*

*Defined at line 2350 of ./engine/client/cl_main.cpp*

====================CL_CleanFileName

Replace the displayed name for some resources====================

### CL_RegisterCustomization

*void CL_RegisterCustomization(resource_t * resource)*

*Defined at line 2367 of ./engine/client/cl_main.cpp*

====================CL_RegisterCustomization

register custom resource for player====================

### CL_SetInfo_f

*void CL_SetInfo_f()*

*Defined at line 2567 of ./engine/client/cl_main.cpp*

=============================================================================

==============CL_SetInfo_f==============

### CL_Physinfo_f

*void CL_Physinfo_f()*

*Defined at line 2607 of ./engine/client/cl_main.cpp*

==============CL_Physinfo_f==============

### CL_FullServerinfo_f

*void CL_FullServerinfo_f()*

*Defined at line 2764 of ./engine/client/cl_main.cpp*

==================CL_FullServerinfo_f

Sent by server when serverinfo changes==================

### CL_Escape_f

*void CL_Escape_f()*

*Defined at line 2782 of ./engine/client/cl_main.cpp*

=================CL_Escape_f

Escape to menu from game=================

### CL_InitLocal

*void CL_InitLocal()*

*Defined at line 2800 of ./engine/client/cl_main.cpp*

=================CL_InitLocal=================

### CL_AdjustClock

*void CL_AdjustClock()*

*Defined at line 2938 of ./engine/client/cl_main.cpp*

============================================================================

==================CL_AdjustClock

slowly adjuct client clockto smooth lag effect==================

### rotl32

*uint32 rotl32(uint32 x, int8 r)*

*Defined at line 24 of ./mainui/miniutl/generichash.cpp*

### rotl64

*uint64 rotl64(uint64 x, int8 r)*

*Defined at line 28 of ./mainui/miniutl/generichash.cpp*

### fmix64

*uint64 fmix64(uint64 k)*

*Defined at line 105 of ./mainui/miniutl/generichash.cpp*

### GetProcAddress

*void * GetProcAddress(void * hmod, const char * sym)*

*Defined at line 32 of ./public/appframework.cpp*

### _LoadLibraryA

*void * _LoadLibraryA(const char * lib)*

*Defined at line 83 of ./public/appframework.cpp*

### _FreeLibrary

*void _FreeLibrary(void * lib)*

*Defined at line 88 of ./public/appframework.cpp*

### S_ConvertLoopedPosition

*int S_ConvertLoopedPosition(wavdata_t * pSource, int samplePosition, qboolean use_loop)*

*Defined at line 222 of ./engine/client/s_utils.cpp*

----------------------------------------------------------------------------- Purpose: wrap the position wrt looping Input  : samplePosition - absolute position Output : int - looped position-----------------------------------------------------------------------------

### UI_CustomGame_Precache

*void UI_CustomGame_Precache()*

*Defined at line 189 of ./mainui/menus/CustomGame.cpp*

=================UI_CustomGame_Precache=================

### InitCrtLib

*void InitCrtLib()*

*Defined at line 60 of ./public/crtlib.cpp*

### Q_starcmp

*qboolean Q_starcmp(const char * pattern, const char * text)*

*Defined at line 613 of ./public/crtlib.cpp*

### CustomDecal_Validate

*qboolean CustomDecal_Validate(void * raw, int nFileSize)*

*Defined at line 20 of ./engine/common/custom.cpp*

### getbits

*uint getbits(mpg123_handle_t * fr, int number_of_bits)*

*Defined at line 54 of ./engine/common/soundlib/libmpg/getbits.h*

### frame_bitrate

*int frame_bitrate(mpg123_handle_t * fr)*

*Defined at line 71 of ./engine/common/soundlib/libmpg/parse.cpp*

### header_mono

*int header_mono(ulong newhead)*

*Defined at line 146 of ./engine/common/soundlib/libmpg/parse.cpp*

 just tell if the header is some mono.

### head_check

*int head_check(ulong head)*

*Defined at line 151 of ./engine/common/soundlib/libmpg/parse.cpp*

### head_compatible

*int head_compatible(ulong fred, ulong bret)*

*Defined at line 160 of ./engine/common/soundlib/libmpg/parse.cpp*

 true if the two headers will work with the same decoding routines

### bit_read_long

*ulong bit_read_long(byte * buf, int * offset)*

*Defined at line 166 of ./engine/common/soundlib/libmpg/parse.cpp*

 this is moderately sized buffers. Int offset is enough.

### bit_read_short

*word bit_read_short(byte * buf, int * offset)*

*Defined at line 174 of ./engine/common/soundlib/libmpg/parse.cpp*

### check_lame_tag

*int check_lame_tag(mpg123_handle_t * fr)*

*Defined at line 182 of ./engine/common/soundlib/libmpg/parse.cpp*

### do_readahead

*int do_readahead(mpg123_handle_t * fr, ulong newhead)*

*Defined at line 408 of ./engine/common/soundlib/libmpg/parse.cpp*

 first attempt of read ahead check to find the real first header; cannot believe what junk is out there!

### halfspeed_prepare

*void halfspeed_prepare(mpg123_handle_t * fr)*

*Defined at line 448 of ./engine/common/soundlib/libmpg/parse.cpp*

### halfspeed_do

*int halfspeed_do(mpg123_handle_t * fr)*

*Defined at line 455 of ./engine/common/soundlib/libmpg/parse.cpp*

 if this returns 1, the next frame is the repetition.

### guess_freeformat_framesize

*int guess_freeformat_framesize(mpg123_handle_t * fr, ulong oldhead)*

*Defined at line 488 of ./engine/common/soundlib/libmpg/parse.cpp*

 read ahead and find the next MPEG header, to guess framesize return value: success code PARSE_GOOD: found a valid frame size (stored in the handle).< 0: error codes, possibly from feeder buffer (NEED_MORE) PARSE_BAD: cannot get the framesize for some reason and shall silentry try the next possible header (if this is no free format stream after all...)

### decode_header

*int decode_header(mpg123_handle_t * fr, ulong newhead, int * freeformat_count)*

*Defined at line 527 of ./engine/common/soundlib/libmpg/parse.cpp*

 decode a header and write the information into the frame structure return values are compatible with those of read_frame, namely:  1: success  0: no valid header<0: some error you are required to do a head_check() before calling!

### forget_head_shift

*int forget_head_shift(mpg123_handle_t * fr, ulong * newheadp, int forget)*

*Defined at line 619 of ./engine/common/soundlib/libmpg/parse.cpp*

 advance a byte in stream to get next possible header and forget  buffered data if possible (for feed reader).

### parse_new_id3

*int parse_new_id3(mpg123_handle_t * fr, ulong first4bytes)*

*Defined at line 646 of ./engine/common/soundlib/libmpg/parse.cpp*

 trying to parse ID3v2.3 and ID3v2.4 tags... returns:  0: bad or just unparseable tag           1: good, (possibly) new tag info<0: reader error (may need more data feed, try again)

### handle_id3v2

*int handle_id3v2(mpg123_handle_t * fr, ulong newhead)*

*Defined at line 682 of ./engine/common/soundlib/libmpg/parse.cpp*

### skip_junk

*int skip_junk(mpg123_handle_t * fr, ulong * newheadp, long * headcount)*

*Defined at line 694 of ./engine/common/soundlib/libmpg/parse.cpp*

 watch out for junk/tags on beginning of stream by invalid header

### wetwork

*int wetwork(mpg123_handle_t * fr, ulong * newheadp)*

*Defined at line 771 of ./engine/common/soundlib/libmpg/parse.cpp*

 the newhead is bad, so let's check if it is something special, otherwise just resync.

### CSCR_LoadDefaultCVars

*struct scrvardef_t * CSCR_LoadDefaultCVars(const char * scriptfilename, int * count)*

*Defined at line 266 of ./mainui/CFGScript.cpp*

======================CSCR_LoadDefaultCVars

Register all cvars declared in config file and set default values======================

### CSCR_FreeList

*void CSCR_FreeList(struct scrvardef_t * list)*

*Defined at line 345 of ./mainui/CFGScript.cpp*

### SV_SetPlayer

*sv_client_t * SV_SetPlayer()*

*Defined at line 114 of ./engine/server/sv_cmds.cpp*

==================SV_SetPlayer

Sets sv_client and sv_player to the player with idnum Cmd_Argv(1)==================

### SV_ValidateMap

*qboolean SV_ValidateMap(const char * pMapName, qboolean check_spawn)*

*Defined at line 172 of ./engine/server/sv_cmds.cpp*

==================SV_ValidateMap

check map for typically errors==================

### SV_Map_f

*void SV_Map_f()*

*Defined at line 213 of ./engine/server/sv_cmds.cpp*

==================SV_Map_f

Goes directly to a given map without any savegame archiving.For development work==================

### SV_MapBackground_f

*void SV_MapBackground_f()*

*Defined at line 241 of ./engine/server/sv_cmds.cpp*

==================SV_MapBackground_f

Set background map (enable physics in menu)==================

### SV_NextMap_f

*void SV_NextMap_f()*

*Defined at line 281 of ./engine/server/sv_cmds.cpp*

==================SV_NextMap_f

Change map for next in alpha-bethical orderingFor development work==================

### SV_NewGame_f

*void SV_NewGame_f()*

*Defined at line 332 of ./engine/server/sv_cmds.cpp*

==============SV_NewGame_f

==============

### SV_HazardCourse_f

*void SV_HazardCourse_f()*

*Defined at line 349 of ./engine/server/sv_cmds.cpp*

==============SV_HazardCourse_f

==============

### SV_Load_f

*void SV_Load_f()*

*Defined at line 372 of ./engine/server/sv_cmds.cpp*

==============SV_Load_f

==============

### SV_QuickLoad_f

*void SV_QuickLoad_f()*

*Defined at line 392 of ./engine/server/sv_cmds.cpp*

==============SV_QuickLoad_f

==============

### SV_Save_f

*void SV_Save_f()*

*Defined at line 403 of ./engine/server/sv_cmds.cpp*

==============SV_Save_f

==============

### SV_QuickSave_f

*void SV_QuickSave_f()*

*Defined at line 425 of ./engine/server/sv_cmds.cpp*

==============SV_QuickSave_f

==============

### SV_DeleteSave_f

*void SV_DeleteSave_f()*

*Defined at line 436 of ./engine/server/sv_cmds.cpp*

==============SV_DeleteSave_f

==============

### SV_AutoSave_f

*void SV_AutoSave_f()*

*Defined at line 455 of ./engine/server/sv_cmds.cpp*

==============SV_AutoSave_f

==============

### SV_Restart_f

*void SV_Restart_f()*

*Defined at line 473 of ./engine/server/sv_cmds.cpp*

==================SV_Restart_f

restarts current level==================

### SV_Reload_f

*void SV_Reload_f()*

*Defined at line 488 of ./engine/server/sv_cmds.cpp*

==================SV_Reload_f

continue from latest savedgame==================

### SV_ChangeLevel_f

*void SV_ChangeLevel_f()*

*Defined at line 505 of ./engine/server/sv_cmds.cpp*

==================SV_ChangeLevel_f

classic change level==================

### SV_ChangeLevel2_f

*void SV_ChangeLevel2_f()*

*Defined at line 523 of ./engine/server/sv_cmds.cpp*

==================SV_ChangeLevel2_f

smooth change level==================

### SV_Kick_f

*void SV_Kick_f()*

*Defined at line 541 of ./engine/server/sv_cmds.cpp*

==================SV_Kick_f

Kick a user off of the server==================

### SV_EntPatch_f

*void SV_EntPatch_f()*

*Defined at line 603 of ./engine/server/sv_cmds.cpp*

==================SV_EntPatch_f==================

### SV_ConSay_f

*void SV_ConSay_f()*

*Defined at line 678 of ./engine/server/sv_cmds.cpp*

==================SV_ConSay_f==================

### SV_Heartbeat_f

*void SV_Heartbeat_f()*

*Defined at line 709 of ./engine/server/sv_cmds.cpp*

==================SV_Heartbeat_f==================

### SV_ServerInfo_f

*void SV_ServerInfo_f()*

*Defined at line 721 of ./engine/server/sv_cmds.cpp*

===========SV_ServerInfo_f

Examine or change the serverinfo string===========

### SV_LocalInfo_f

*void SV_LocalInfo_f()*

*Defined at line 765 of ./engine/server/sv_cmds.cpp*

===========SV_LocalInfo_f

Examine or change the localinfo string===========

### SV_ClientInfo_f

*void SV_ClientInfo_f()*

*Defined at line 797 of ./engine/server/sv_cmds.cpp*

===========SV_ClientInfo_f

Examine all a users info strings===========

### SV_ClientUserAgent_f

*void SV_ClientUserAgent_f()*

*Defined at line 823 of ./engine/server/sv_cmds.cpp*

===========SV_ClientUserAgent_f

Examine useragent strings===========

### SV_KillServer_f

*void SV_KillServer_f()*

*Defined at line 848 of ./engine/server/sv_cmds.cpp*

===============SV_KillServer_f

Kick everyone off, possibly in preparation for a new game===============

### SV_PlayersOnly_f

*void SV_PlayersOnly_f()*

*Defined at line 860 of ./engine/server/sv_cmds.cpp*

===============SV_PlayersOnly_f

disable plhysics but players===============

### SV_EdictUsage_f

*void SV_EdictUsage_f()*

*Defined at line 875 of ./engine/server/sv_cmds.cpp*

===============SV_EdictUsage_f

===============

### SV_EntityInfo_f

*void SV_EntityInfo_f()*

*Defined at line 897 of ./engine/server/sv_cmds.cpp*

===============SV_EntityInfo_f

===============

### EV_EjectBrass

*void EV_EjectBrass(float * origin, float * velocity, float rotation, int model, int soundtype)*

*Defined at line 138 of ./game/client/ev_common.cpp*

 Some of these are HL/TFC specific?

=================EV_EjectBrass

Bullet shell casings=================

### EV_GetGunPosition

*void EV_GetGunPosition(struct event_args_s * args, float * pos, float * origin)*

*Defined at line 104 of ./game/client/ev_common.cpp*

=================EV_GetGunPosition

Figure out the height of the gun=================

### EV_GetDefaultShellInfo

*void EV_GetDefaultShellInfo(struct event_args_s * args, float * origin, float * velocity, float * ShellVelocity, float * ShellOrigin, float * forward, float * right, float * up, float forwardScale, float upScale, float rightScale)*

*Defined at line 153 of ./game/client/ev_common.cpp*

=================EV_GetDefaultShellInfo

Determine where to eject shells from=================

### EV_IsLocal

*qboolean EV_IsLocal(int idx)*

*Defined at line 88 of ./game/client/ev_common.cpp*

=================EV_IsLocal

Is the entity == the local player=================

### EV_IsPlayer

*qboolean EV_IsPlayer(int idx)*

*Defined at line 73 of ./game/client/ev_common.cpp*

=================EV_IsPlayer

Is the entity's index in the player range?=================

### EV_CreateTracer

*void EV_CreateTracer(float * start, float * end)*

*Defined at line 61 of ./game/client/ev_common.cpp*

=================EV_CreateTracer

Creates a tracer effect=================

### GetEntity

*struct cl_entity_s * GetEntity(int idx)*

*Defined at line 37 of ./game/client/ev_common.cpp*

=================GetEntity

Return's the requested cl_entity_t=================

### GetViewEntity

*struct cl_entity_s * GetViewEntity()*

*Defined at line 49 of ./game/client/ev_common.cpp*

=================GetViewEntity

Return's the current weapon/view model=================

### EV_MuzzleFlash

*void EV_MuzzleFlash()*

*Defined at line 195 of ./game/client/ev_common.cpp*

=================EV_MuzzleFlash

Flag weapon/view model for muzzle flash=================

### EV_HLDM_GunshotDecalTrace

*void EV_HLDM_GunshotDecalTrace(pmtrace_t * pTrace, char * decalName)*

*Defined at line 260 of ./game/client/ev_hldm.cpp*

### EV_HLDM_DecalGunshot

*void EV_HLDM_DecalGunshot(pmtrace_t * pTrace, int iBulletType)*

*Defined at line 304 of ./game/client/ev_hldm.cpp*

### EV_HLDM_CheckTracer

*int EV_HLDM_CheckTracer(int idx, float * vecSrc, float * end, float * forward, float * right, int iBulletType, int iTracerFreq, int * tracerCount)*

*Defined at line 328 of ./game/client/ev_hldm.cpp*

### EV_HLDM_FireBullets

*void EV_HLDM_FireBullets(int idx, float * forward, float * right, float * up, int cShots, float * vecSrc, float * vecDirShooting, float flDistance, int iBulletType, int iTracerFreq, int * tracerCount, float flSpreadX, float flSpreadY)*

*Defined at line 378 of ./game/client/ev_hldm.cpp*

================FireBullets

Go to the trouble of combining multiple pellets into a single damage call.================

### V_PunchAxis

*void V_PunchAxis(int axis, float punch)*

*Defined at line 1574 of ./game/client/view.cpp*

=============V_PunchAxis

Client side punch effect=============

### EV_FireGlock1

*void EV_FireGlock1(struct event_args_s * args)*

*Defined at line 461 of ./game/client/ev_hldm.cpp*

 HLDM

======================	    GLOCK START======================

### EV_FireGlock2

*void EV_FireGlock2(struct event_args_s * args)*

*Defined at line 506 of ./game/client/ev_hldm.cpp*

### EV_FireShotGunSingle

*void EV_FireShotGunSingle(struct event_args_s * args)*

*Defined at line 613 of ./game/client/ev_hldm.cpp*

### EV_FireShotGunDouble

*void EV_FireShotGunDouble(struct event_args_s * args)*

*Defined at line 558 of ./game/client/ev_hldm.cpp*

======================	  SHOTGUN START======================

### EV_FireMP5

*void EV_FireMP5(struct event_args_s * args)*

*Defined at line 671 of ./game/client/ev_hldm.cpp*

======================	    MP5 START======================

### EV_FireMP52

*void EV_FireMP52(struct event_args_s * args)*

*Defined at line 732 of ./game/client/ev_hldm.cpp*

 We only predict the animation and sound The grenade is still launched from the server.

### EV_FirePython

*void EV_FirePython(struct event_args_s * args)*

*Defined at line 764 of ./game/client/ev_hldm.cpp*

======================	   PHYTON START 	     ( .357 )======================

### EV_FireGauss

*void EV_FireGauss(struct event_args_s * args)*

*Defined at line 857 of ./game/client/ev_hldm.cpp*

### EV_SpinGauss

*void EV_SpinGauss(struct event_args_s * args)*

*Defined at line 820 of ./game/client/ev_hldm.cpp*

### EV_Crowbar

*void EV_Crowbar(struct event_args_s * args)*

*Defined at line 1154 of ./game/client/ev_hldm.cpp*

Only predict the miss sounds, hit sounds are still played server side, so players don't get the wrong idea.

### EV_FireCrossbow

*void EV_FireCrossbow(struct event_args_s * args)*

*Defined at line 1307 of ./game/client/ev_hldm.cpp*

TODO: Fully predict the fliying bolt.

### EV_FireCrossbow2

*void EV_FireCrossbow2(struct event_args_s * args)*

*Defined at line 1217 of ./game/client/ev_hldm.cpp*

### EV_FireRpg

*void EV_FireRpg(struct event_args_s * args)*

*Defined at line 1350 of ./game/client/ev_hldm.cpp*

### EV_EgonFire

*void EV_EgonFire(struct event_args_s * args)*

*Defined at line 1429 of ./game/client/ev_hldm.cpp*

### EV_EgonStop

*void EV_EgonStop(struct event_args_s * args)*

*Defined at line 1525 of ./game/client/ev_hldm.cpp*

### EV_HornetGunFire

*void EV_HornetGunFire(struct event_args_s * args)*

*Defined at line 1590 of ./game/client/ev_hldm.cpp*

### EV_TripmineFire

*void EV_TripmineFire(struct event_args_s * args)*

*Defined at line 1642 of ./game/client/ev_hldm.cpp*

We only check if it's possible to put a trip mineand if it is, then we play the animation. Server still places it.

### EV_SnarkFire

*void EV_SnarkFire(struct event_args_s * args)*

*Defined at line 1696 of ./game/client/ev_hldm.cpp*

### EV_TrainPitchAdjust

*void EV_TrainPitchAdjust(struct event_args_s * args)*

*Defined at line 1732 of ./game/client/ev_hldm.cpp*

======================	   SQUEAK END======================

### EV_HLDM_PlayTextureSound

*float EV_HLDM_PlayTextureSound(int idx, pmtrace_t * ptr, float * vecSrc, float * vecEnd, int iBulletType)*

*Defined at line 91 of ./game/client/ev_hldm.cpp*

 play a strike sound based on the texture that was hit by the attack traceline.  VecSrc/VecEnd are the original traceline endpoints used by the attacker, iBulletType is the type of bullet that hit the texture. returns volume of strike instrument (crowbar) to play

### EV_HLDM_DamageDecal

*char * EV_HLDM_DamageDecal(physent_t * pe)*

*Defined at line 238 of ./game/client/ev_hldm.cpp*

### EV_StopPreviousGauss

*void EV_StopPreviousGauss(int idx)*

*Defined at line 848 of ./game/client/ev_hldm.cpp*

==============================EV_StopPreviousGauss

==============================

### EV_BoltCallback

*void EV_BoltCallback(struct tempent_s * ent, float frametime, float currenttime)*

*Defined at line 1211 of ./game/client/ev_hldm.cpp*

===================== EV_BoltCallback This function is used to correct the origin and angles  of the bolt, so it looks like it's stuck on the wall.=====================

### EV_EgonFlareCallback

*void EV_EgonFlareCallback(struct tempent_s * ent, float frametime, float currenttime)*

*Defined at line 1419 of ./game/client/ev_hldm.cpp*

### EV_TFC_IsAllyTeam

*int EV_TFC_IsAllyTeam(int iTeam1, int iTeam2)*

*Defined at line 1791 of ./game/client/ev_hldm.cpp*

### HUD_PostRunCmd

*void HUD_PostRunCmd(struct local_state_s * from, struct local_state_s * to, struct usercmd_s * cmd, int runfuncs, double time, unsigned int random_seed)*

*Defined at line 793 of ./game/client/hl/hl_weapons.cpp*

=====================HUD_PostRunCmd

Client calls this during prediction, after it has moved the player and updated any info changed into to->time is the current client clock based on predictioncmd is the command that caused the movement, etcrunfuncs is 1 if this is the first time we've predicted this command.  If so, sounds and effects should play, otherwise, they shouldbe ignored=====================

### COM_Log

*void COM_Log(const char * pszFile, const char * fmt)*

*Defined at line 44 of ./game/client/com_weapons.cpp*

====================COM_Log

Log debug messages to file ( appends )====================

### CL_IsDead

*int CL_IsDead()*

*Defined at line 888 of ./game/client/input.cpp*

============CL_IsDead

Returns 1 if health is <= 0============

### HUD_GetWeaponAnim

*int HUD_GetWeaponAnim()*

*Defined at line 102 of ./game/client/com_weapons.cpp*

=====================HUD_GetWeaponAnim

Retrieve current predicted weapon animation=====================

### HUD_SendWeaponAnim

*void HUD_SendWeaponAnim(int iAnim, int body, int force)*

*Defined at line 83 of ./game/client/com_weapons.cpp*

=====================HUD_SendWeaponAnim

Change weapon model animation=====================

### HUD_PlaySound

*void HUD_PlaySound(const char * sound, float volume)*

*Defined at line 114 of ./game/client/com_weapons.cpp*

=====================HUD_PlaySound

Play a sound, if we are seeing this command for the first time=====================

### HUD_PlaybackEvent

*void HUD_PlaybackEvent(int flags, const struct edict_s * pInvoker, unsigned short eventindex, float delay, float * origin, float * angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2)*

*Defined at line 129 of ./game/client/com_weapons.cpp*

=====================HUD_PlaybackEvent

Directly queue up an event on the client=====================

### HUD_SetMaxSpeed

*void HUD_SetMaxSpeed(const struct edict_s * ed, float speed)*

*Defined at line 150 of ./game/client/com_weapons.cpp*

=====================HUD_SetMaxSpeed

=====================

### stub_PrecacheModel

*int stub_PrecacheModel(const char * s)*

*Defined at line 271 of ./game/client/com_weapons.cpp*

======================stub_*

stub functions for such things as precaching.  So we don't have to modify weapons code that is compiled into both game and client .dlls.======================

### stub_PrecacheSound

*int stub_PrecacheSound(const char * s)*

*Defined at line 276 of ./game/client/com_weapons.cpp*

### stub_PrecacheEvent

*unsigned short stub_PrecacheEvent(int type, const char * s)*

*Defined at line 281 of ./game/client/com_weapons.cpp*

### stub_NameForFunction

*const char * stub_NameForFunction(void * function)*

*Defined at line 286 of ./game/client/com_weapons.cpp*

### stub_SetModel

*void stub_SetModel(struct edict_s * e, const char * m)*

*Defined at line 291 of ./game/client/com_weapons.cpp*

### CanAttack

*BOOL CanAttack(float attack_time, float curtime, BOOL isPredicted)*

*Defined at line 45 of ./game/shared/c_base_weapon.cpp*

### BaseCmd_CheckCvars

*void BaseCmd_CheckCvars(const char * key, const char * value, void * buffer, void * ptr)*

*Defined at line 232 of ./engine/common/base_cmd.cpp*

### weapon_egon

*void weapon_egon(entvars_t * pev)*

*Defined at line 52 of ./game/shared/hl1/weapon_egon.cpp*

### ammo_egonclip

*void ammo_egonclip(entvars_t * pev)*

*Defined at line 543 of ./game/shared/hl1/weapon_egon.cpp*

### weapon_rpg

*void weapon_rpg(entvars_t * pev)*

*Defined at line 40 of ./game/shared/hl1/weapon_rpg.cpp*

### ammo_rpgclip

*void ammo_rpgclip(entvars_t * pev)*

*Defined at line 594 of ./game/shared/hl1/weapon_rpg.cpp*

### item_airtank

*void item_airtank(entvars_t * pev)*

*Defined at line 41 of ./game/server/airtank.cpp*

### GetSpriteList

*client_sprite_t * GetSpriteList(client_sprite_t * pList, const char * psz, int iRes, int iCount)*

*Defined at line 1163 of ./game/client/ammo.cpp*

 =================================	GetSpriteList

Finds and returns the matching sprite name 'psz' and resolution 'iRes'in the given sprite list 'pList'iCount is the number of items in the pList================================= 

### __MsgFunc_CurWeapon

*int __MsgFunc_CurWeapon(const char * pszName, int iSize, void * pbuf)*

*Defined at line 229 of ./game/client/ammo.cpp*

### __MsgFunc_WeaponList

*int __MsgFunc_WeaponList(const char * pszName, int iSize, void * pbuf)*

*Defined at line 230 of ./game/client/ammo.cpp*

### __MsgFunc_AmmoX

*int __MsgFunc_AmmoX(const char * pszName, int iSize, void * pbuf)*

*Defined at line 231 of ./game/client/ammo.cpp*

### __MsgFunc_AmmoPickup

*int __MsgFunc_AmmoPickup(const char * pszName, int iSize, void * pbuf)*

*Defined at line 232 of ./game/client/ammo.cpp*

### __MsgFunc_WeapPickup

*int __MsgFunc_WeapPickup(const char * pszName, int iSize, void * pbuf)*

*Defined at line 233 of ./game/client/ammo.cpp*

### __MsgFunc_HideWeapon

*int __MsgFunc_HideWeapon(const char * pszName, int iSize, void * pbuf)*

*Defined at line 234 of ./game/client/ammo.cpp*

### __MsgFunc_ItemPickup

*int __MsgFunc_ItemPickup(const char * pszName, int iSize, void * pbuf)*

*Defined at line 235 of ./game/client/ammo.cpp*

### __CmdFunc_Slot1

*void __CmdFunc_Slot1()*

*Defined at line 237 of ./game/client/ammo.cpp*

### __CmdFunc_Slot2

*void __CmdFunc_Slot2()*

*Defined at line 238 of ./game/client/ammo.cpp*

### __CmdFunc_Slot3

*void __CmdFunc_Slot3()*

*Defined at line 239 of ./game/client/ammo.cpp*

### __CmdFunc_Slot4

*void __CmdFunc_Slot4()*

*Defined at line 240 of ./game/client/ammo.cpp*

### __CmdFunc_Slot5

*void __CmdFunc_Slot5()*

*Defined at line 241 of ./game/client/ammo.cpp*

### __CmdFunc_Slot6

*void __CmdFunc_Slot6()*

*Defined at line 242 of ./game/client/ammo.cpp*

### __CmdFunc_Slot7

*void __CmdFunc_Slot7()*

*Defined at line 243 of ./game/client/ammo.cpp*

### __CmdFunc_Slot8

*void __CmdFunc_Slot8()*

*Defined at line 244 of ./game/client/ammo.cpp*

### __CmdFunc_Slot9

*void __CmdFunc_Slot9()*

*Defined at line 245 of ./game/client/ammo.cpp*

### __CmdFunc_Slot10

*void __CmdFunc_Slot10()*

*Defined at line 246 of ./game/client/ammo.cpp*

### __CmdFunc_Close

*void __CmdFunc_Close()*

*Defined at line 247 of ./game/client/ammo.cpp*

### __CmdFunc_NextWeapon

*void __CmdFunc_NextWeapon()*

*Defined at line 248 of ./game/client/ammo.cpp*

### __CmdFunc_PrevWeapon

*void __CmdFunc_PrevWeapon()*

*Defined at line 249 of ./game/client/ammo.cpp*

### DrawBar

*int DrawBar(int x, int y, int width, int height, float f)*

*Defined at line 945 of ./game/client/ammo.cpp*

 Draws the ammo bar on the hud

### DrawAmmoBar

*void DrawAmmoBar(struct WEAPON * p, int x, int y, int width, int height)*

*Defined at line 974 of ./game/client/ammo.cpp*

### R_DecalUnlink

*void R_DecalUnlink(decal_t * pdecal)*

*Defined at line 65 of ./ref_gl/gl_decals.cpp*

 unlink pdecal from any surface it's attached to

### R_DecalAlloc

*decal_t * R_DecalAlloc(decal_t * pdecal)*

*Defined at line 102 of ./ref_gl/gl_decals.cpp*

 Just reuse next decal in list A decal that spans multiple surfaces will use multiple decal_t pool entries, as each surface needs it's own.

### R_GetDecalDimensions

*void R_GetDecalDimensions(int texture, int * width, int * height)*

*Defined at line 136 of ./ref_gl/gl_decals.cpp*

----------------------------------------------------------------------------- find decal image and grab size from it-----------------------------------------------------------------------------

### R_DecalComputeBasis

*void R_DecalComputeBasis(msurface_t * surf, int flags, vec3_t [3] textureSpaceBasis)*

*Defined at line 147 of ./ref_gl/gl_decals.cpp*

----------------------------------------------------------------------------- compute the decal basis based on surface normal-----------------------------------------------------------------------------

### R_SetupDecalTextureSpaceBasis

*void R_SetupDecalTextureSpaceBasis(decal_t * pDecal, msurface_t * surf, int texture, vec3_t [3] textureSpaceBasis, float [2] decalWorldScale)*

*Defined at line 183 of ./ref_gl/gl_decals.cpp*

### R_SetupDecalVertsForMSurface

*void R_SetupDecalVertsForMSurface(decal_t * pDecal, msurface_t * surf, vec3_t [3] textureSpaceBasis, float * verts)*

*Defined at line 203 of ./ref_gl/gl_decals.cpp*

 Build the initial list of vertices from the surface verts into the global array, 'verts'.

### R_SetupDecalClip

*void R_SetupDecalClip(decal_t * pDecal, msurface_t * surf, int texture, vec3_t [3] textureSpaceBasis, float [2] decalWorldScale)*

*Defined at line 218 of ./ref_gl/gl_decals.cpp*

 Figure out where the decal maps onto the surface.

### R_ClipInside

*int R_ClipInside(float * vert, int edge)*

*Defined at line 233 of ./ref_gl/gl_decals.cpp*

 Quick and dirty sutherland Hodgman clipper Clip polygon to decal in texture space JAY: This code is lame, change it later.  It does way too much work per frame It can be made to recursively call the clipping code and only copy the vertex list once

### R_ClipIntersect

*void R_ClipIntersect(float * one, float * two, float * out, int edge)*

*Defined at line 257 of ./ref_gl/gl_decals.cpp*

### SHClip

*int SHClip(float * vert, int vertCount, float * out, int edge)*

*Defined at line 309 of ./ref_gl/gl_decals.cpp*

### R_DoDecalSHClip

*float * R_DoDecalSHClip(float * pInVerts, decal_t * pDecal, int nStartVerts, int * pVertCount)*

*Defined at line 358 of ./ref_gl/gl_decals.cpp*

### R_DecalVertsClip

*float * R_DecalVertsClip(decal_t * pDecal, msurface_t * surf, int texture, int * pVertCount)*

*Defined at line 378 of ./ref_gl/gl_decals.cpp*

----------------------------------------------------------------------------- Generate clipped vertex list for decal pdecal projected onto polygon psurf-----------------------------------------------------------------------------

### R_DecalVertsLight

*void R_DecalVertsLight(float * v, msurface_t * surf, int vertCount)*

*Defined at line 393 of ./ref_gl/gl_decals.cpp*

 Generate lighting coordinates at each vertex for decal vertices v[] on surface psurf

### R_DecalIntersect

*decal_t * R_DecalIntersect(decalinfo_t * decalinfo, msurface_t * surf, int * pcount)*

*Defined at line 423 of ./ref_gl/gl_decals.cpp*

 Check for intersecting decals on this surface

### R_DecalCreatePoly

*glpoly_t * R_DecalCreatePoly(decalinfo_t * decalinfo, decal_t * pdecal, msurface_t * surf)*

*Defined at line 511 of ./ref_gl/gl_decals.cpp*

====================R_DecalCreatePoly

creates mesh for decal on first rendering====================

### R_AddDecalToSurface

*void R_AddDecalToSurface(decal_t * pdecal, msurface_t * surf, decalinfo_t * decalinfo)*

*Defined at line 546 of ./ref_gl/gl_decals.cpp*

 Add the decal to the surface's list of decals.

### R_DecalCreate

*void R_DecalCreate(decalinfo_t * decalinfo, msurface_t * surf, float x, float y)*

*Defined at line 576 of ./ref_gl/gl_decals.cpp*

### R_DecalSurface

*void R_DecalSurface(msurface_t * surf, decalinfo_t * decalinfo)*

*Defined at line 615 of ./ref_gl/gl_decals.cpp*

### R_DecalNodeSurfaces

*void R_DecalNodeSurfaces(model_t * model, mnode_t * node, decalinfo_t * decalinfo)*

*Defined at line 685 of ./ref_gl/gl_decals.cpp*

----------------------------------------------------------------------------- iterate over all surfaces on a node, looking for surfaces to decal-----------------------------------------------------------------------------

### R_DecalNode

*void R_DecalNode(model_t * model, mnode_t * node, decalinfo_t * decalinfo)*

*Defined at line 711 of ./ref_gl/gl_decals.cpp*

----------------------------------------------------------------------------- Recursive routine to find surface to apply a decal to.  World coordinates of  the decal are passed in r_recalpos like the rest of the engine.  This should  be called through R_DecalShoot()-----------------------------------------------------------------------------

### R_DecalUnProject

*qboolean R_DecalUnProject(decal_t * pdecal, decallist_t * entry)*

*Defined at line 1097 of ./ref_gl/gl_decals.cpp*

=============================================================

  DECALS SERIALIZATION

=============================================================

### DecalListAdd

*int DecalListAdd(decallist_t * pList, int count)*

*Defined at line 1119 of ./ref_gl/gl_decals.cpp*

----------------------------------------------------------------------------- Purpose:  Input  : *pList - 			count -  Output : static int-----------------------------------------------------------------------------

### DecalDepthCompare

*int DecalDepthCompare(const void * a, const void * b)*

*Defined at line 1142 of ./ref_gl/gl_decals.cpp*

### StringLessThan

*_Bool StringLessThan(const char *const & lhs, const char *const & rhs)*

*Defined at line 86 of ./mainui/miniutl/utlrbtree.h*

-------------------------------------

### CaselessStringLessThan

*_Bool CaselessStringLessThan(const char *const & lhs, const char *const & rhs)*

*Defined at line 87 of ./mainui/miniutl/utlrbtree.h*

### CaselessStringLessThanIgnoreSlashes

*_Bool CaselessStringLessThanIgnoreSlashes(const char *const & lhs, const char *const & rhs)*

*Defined at line 90 of ./mainui/miniutl/utlrbtree.h*

 Same as CaselessStringLessThan, but it ignores differences in / and .

### SetDefLessFunc

*void SetDefLessFunc(RBTREE_T & RBTree)*

*Defined at line 156 of ./mainui/miniutl/utlrbtree.h*

### FT_Error_String

*const char * FT_Error_String(FT_Error error_code)*

************************************************************************



:

   FT_Error_String

**<not a builtin command>** :   Retrieve the description of a valid FreeType error code.

**<not a builtin command>** :   error_code ::     A valid FreeType error code.



**return**:   A C~string or `NULL`, if any error occurred.



**note**:   FreeType has to be compiled with `FT_CONFIG_OPTION_ERROR_STRINGS` or   `FT_DEBUG_LEVEL_ERROR` to get meaningful descriptions.   'error_string' will be `NULL` otherwise.

   Module identification will be ignored:

   ```c     strcmp( FT_Error_String(  FT_Err_Unknown_File_Format ),             FT_Error_String( BDF_Err_Unknown_File_Format ) ) == 0;   ```

### FT_Init_FreeType

*FT_Error FT_Init_FreeType(FT_Library * alibrary)*

************************************************************************



:

   FT_Init_FreeType

**<not a builtin command>** :   Initialize a new FreeType library object.  The set of modules that are   registered by this function is determined at build time.

**<not a builtin command>** :   alibrary ::     A handle to a new library object.



**return**:   FreeType error code.  0~means success.



**note**:   In case you want to provide your own memory allocating routines, use**<not a builtin command>** _New_Library instead, followed by a call to **<not a builtin command>** _Add_Default_Modules   (or a series of calls to **<not a builtin command>** _Add_Module) and**<not a builtin command>** _Set_Default_Properties.

   See the documentation of **<not a builtin command>** _Library and **<not a builtin command>** _Face for multi-threading   issues.

   If you need reference-counting (cf. **<not a builtin command>** _Reference_Library), use**<not a builtin command>** _New_Library and **<not a builtin command>** _Done_Library.

   If compilation option `FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES` is   set, this function reads the `FREETYPE_PROPERTIES` environment   variable to control driver properties.  See section **<not a builtin command>**  for   more.

### FT_Done_FreeType

*FT_Error FT_Done_FreeType(FT_Library library)*

************************************************************************



:

   FT_Done_FreeType

**<not a builtin command>** :   Destroy a given FreeType library object and all of its children,   including resources, drivers, faces, sizes, etc.

**<not a builtin command>** :   library ::     A handle to the target library object.



**return**:   FreeType error code.  0~means success.

### FT_New_Face

*FT_Error FT_New_Face(FT_Library library, const char * filepathname, FT_Long face_index, FT_Face * aface)*

************************************************************************



:

   FT_New_Face

**<not a builtin command>** :   Call **<not a builtin command>** _Open_Face to open a font by its pathname.

**<not a builtin command>** :   library ::     A handle to the library resource.

**<not a builtin command>** :   pathname ::     A path to the font file.

   face_index ::     See **<not a builtin command>** _Open_Face for a detailed description of this parameter.

**<not a builtin command>** :   aface ::     A handle to a new face object.  If `face_index` is greater than or     equal to zero, it must be non-`NULL`.



**return**:   FreeType error code.  0~means success.



**note**:   Use **<not a builtin command>** _Done_Face to destroy the created **<not a builtin command>** _Face object (along with   its slot and sizes).

### FT_New_Memory_Face

*FT_Error FT_New_Memory_Face(FT_Library library, const FT_Byte * file_base, FT_Long file_size, FT_Long face_index, FT_Face * aface)*

************************************************************************



:

   FT_New_Memory_Face

**<not a builtin command>** :   Call **<not a builtin command>** _Open_Face to open a font that has been loaded into memory.

**<not a builtin command>** :   library ::     A handle to the library resource.

**<not a builtin command>** :   file_base ::     A pointer to the beginning of the font data.

   file_size ::     The size of the memory chunk used by the font data.

   face_index ::     See **<not a builtin command>** _Open_Face for a detailed description of this parameter.

**<not a builtin command>** :   aface ::     A handle to a new face object.  If `face_index` is greater than or     equal to zero, it must be non-`NULL`.



**return**:   FreeType error code.  0~means success.



**note**:   You must not deallocate the memory before calling **<not a builtin command>** _Done_Face.

### FT_Open_Face

*FT_Error FT_Open_Face(FT_Library library, const FT_Open_Args * args, FT_Long face_index, FT_Face * aface)*

************************************************************************



:

   FT_Open_Face

**<not a builtin command>** :   Create a face object from a given resource described by **<not a builtin command>** _Open_Args.

**<not a builtin command>** :   library ::     A handle to the library resource.

**<not a builtin command>** :   args ::     A pointer to an `FT_Open_Args` structure that must be filled by the     caller.

   face_index ::     This field holds two different values.  Bits 0-15 are the index of     the face in the font file (starting with value~0).  Set it to~0 if     there is only one face in the font file.

     [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation     fonts only, specifying the named instance index for the current face     index (starting with value~1; value~0 makes FreeType ignore named     instances).  For non-variation fonts, bits 16-30 are ignored.     Assuming that you want to access the third named instance in face~4,     `face_index` should be set to 0x00030004.  If you want to access     face~4 without variation handling, simply set `face_index` to     value~4.

     `FT_Open_Face` and its siblings can be used to quickly check whether     the font format of a given font resource is supported by FreeType.     In general, if the `face_index` argument is negative, the function's     return value is~0 if the font format is recognized, or non-zero     otherwise.  The function allocates a more or less empty face handle     in `*aface` (if `aface` isn't `NULL`); the only two useful fields in     this special case are `face->num_faces` and `face->style_flags`.     For any negative value of `face_index`, `face->num_faces` gives the     number of faces within the font file.  For the negative value     '-(N+1)' (with 'N' a non-negative 16-bit value), bits 16-30 in     `face->style_flags` give the number of named instances in face 'N'     if we have a variation font (or zero otherwise).  After examination,     the returned **<not a builtin command>** _Face structure should be deallocated with a call to**<not a builtin command>** _Done_Face.

**<not a builtin command>** :   aface ::     A handle to a new face object.  If `face_index` is greater than or     equal to zero, it must be non-`NULL`.



**return**:   FreeType error code.  0~means success.



**note**:   Unlike FreeType 1.x, this function automatically creates a glyph slot   for the face object that can be accessed directly through   `face->glyph`.

   Each new face object created with this function also owns a default**<not a builtin command>** _Size object, accessible as `face->size`.

   One **<not a builtin command>** _Library instance can have multiple face objects, this is,**<not a builtin command>** _Open_Face and its siblings can be called multiple times using the   same `library` argument.

   See the discussion of reference counters in the description of**<not a builtin command>** _Reference_Face.

**<not a builtin command>** :   To loop over all faces, use code similar to the following snippet   (omitting the error handling).

   ```     ...     FT_Face  face;     FT_Long  i, num_faces;

     error = FT_Open_Face( library, args, -1, &face );     if ( error ) { ... }

     num_faces = face->num_faces;     FT_Done_Face( face );

     for ( i = 0; i < num_faces; i++ )     {       ...       error = FT_Open_Face( library, args, i, &face );       ...       FT_Done_Face( face );       ...     }   ```

   To loop over all valid values for `face_index`, use something similar   to the following snippet, again without error handling.  The code   accesses all faces immediately (thus only a single call of   `FT_Open_Face` within the do-loop), with and without named instances.

   ```     ...     FT_Face  face;

     FT_Long  num_faces     = 0;     FT_Long  num_instances = 0;

     FT_Long  face_idx     = 0;     FT_Long  instance_idx = 0;

     do     {       FT_Long  id = ( instance_idx << 16 ) + face_idx;

       error = FT_Open_Face( library, args, id, &face );       if ( error ) { ... }

       num_faces     = face->num_faces;       num_instances = face->style_flags >> 16;

       ...

       FT_Done_Face( face );

       if ( instance_idx < num_instances )         instance_idx++;       else       {         face_idx++;         instance_idx = 0;       }

     } while ( face_idx < num_faces )   ```

### FT_Attach_File

*FT_Error FT_Attach_File(FT_Face face, const char * filepathname)*

************************************************************************



:

   FT_Attach_File

**<not a builtin command>** :   Call **<not a builtin command>** _Attach_Stream to attach a file.

**<not a builtin command>** :   face ::     The target face object.

**<not a builtin command>** :   filepathname ::     The pathname.



**return**:   FreeType error code.  0~means success.

### FT_Attach_Stream

*FT_Error FT_Attach_Stream(FT_Face face, FT_Open_Args * parameters)*

************************************************************************



:

   FT_Attach_Stream

**<not a builtin command>** :   'Attach' data to a face object.  Normally, this is used to read   additional information for the face object.  For example, you can   attach an AFM file that comes with a Type~1 font to get the kerning   values and other metrics.

**<not a builtin command>** :   face ::     The target face object.

**<not a builtin command>** :   parameters ::     A pointer to **<not a builtin command>** _Open_Args that must be filled by the caller.



**return**:   FreeType error code.  0~means success.



**note**:   The meaning of the 'attach' (i.e., what really happens when the new   file is read) is not fixed by FreeType itself.  It really depends on   the font format (and thus the font driver).

   Client applications are expected to know what they are doing when   invoking this function.  Most drivers simply do not implement file or   stream attachments.

### FT_Reference_Face

*FT_Error FT_Reference_Face(FT_Face face)*

************************************************************************



:

   FT_Reference_Face

**<not a builtin command>** :   A counter gets initialized to~1 at the time an **<not a builtin command>** _Face structure is   created.  This function increments the counter.  **<not a builtin command>** _Done_Face then   only destroys a face if the counter is~1, otherwise it simply   decrements the counter.

   This function helps in managing life-cycles of structures that   reference **<not a builtin command>** _Face objects.

**<not a builtin command>** :   face ::     A handle to a target face object.



**return**:   FreeType error code.  0~means success.



**since**:   2.4.2

### FT_Done_Face

*FT_Error FT_Done_Face(FT_Face face)*

************************************************************************



:

   FT_Done_Face

**<not a builtin command>** :   Discard a given face object, as well as all of its child slots and   sizes.

**<not a builtin command>** :   face ::     A handle to a target face object.



**return**:   FreeType error code.  0~means success.



**note**:   See the discussion of reference counters in the description of**<not a builtin command>** _Reference_Face.

### FT_Select_Size

*FT_Error FT_Select_Size(FT_Face face, FT_Int strike_index)*

************************************************************************



:

   FT_Select_Size

**<not a builtin command>** :   Select a bitmap strike.  To be more precise, this function sets the   scaling factors of the active **<not a builtin command>** _Size object in a face so that   bitmaps from this particular strike are taken by **<not a builtin command>** _Load_Glyph and   friends.

**<not a builtin command>** :   face ::     A handle to a target face object.

**<not a builtin command>** :   strike_index ::     The index of the bitmap strike in the `available_sizes` field of**<not a builtin command>** _FaceRec structure.



**return**:   FreeType error code.  0~means success.



**note**:   For bitmaps embedded in outline fonts it is common that only a subset   of the available glyphs at a given ppem value is available.  FreeType   silently uses outlines if there is no bitmap for a given glyph index.

   For GX and OpenType variation fonts, a bitmap strike makes sense only   if the default instance is active (this is, no glyph variation takes   place); otherwise, FreeType simply ignores bitmap strikes.  The same   is true for all named instances that are different from the default   instance.

   Don't use this function if you are using the FreeType cache API.

### FT_Request_Size

*FT_Error FT_Request_Size(FT_Face face, FT_Size_Request req)*

************************************************************************



:

   FT_Request_Size

**<not a builtin command>** :   Resize the scale of the active **<not a builtin command>** _Size object in a face.

**<not a builtin command>** :   face ::     A handle to a target face object.

**<not a builtin command>** :   req ::     A pointer to a **<not a builtin command>** _Size_RequestRec.



**return**:   FreeType error code.  0~means success.



**note**:   Although drivers may select the bitmap strike matching the request,   you should not rely on this if you intend to select a particular   bitmap strike.  Use **<not a builtin command>** _Select_Size instead in that case.

   The relation between the requested size and the resulting glyph size   is dependent entirely on how the size is defined in the source face.   The font designer chooses the final size of each glyph relative to   this size.  For more information refer to   'https://www.freetype.org/freetype2/docs/glyphs/glyphs-2.html'.

   Contrary to **<not a builtin command>** _Set_Char_Size, this function doesn't have special code   to normalize zero-valued widths, heights, or resolutions (which lead   to errors in most cases).

   Don't use this function if you are using the FreeType cache API.

### FT_Set_Char_Size

*FT_Error FT_Set_Char_Size(FT_Face face, FT_F26Dot6 char_width, FT_F26Dot6 char_height, FT_UInt horz_resolution, FT_UInt vert_resolution)*

************************************************************************



:

   FT_Set_Char_Size

**<not a builtin command>** :   Call **<not a builtin command>** _Request_Size to request the nominal size (in points).

**<not a builtin command>** :   face ::     A handle to a target face object.

**<not a builtin command>** :   char_width ::     The nominal width, in 26.6 fractional points.

   char_height ::     The nominal height, in 26.6 fractional points.

   horz_resolution ::     The horizontal resolution in dpi.

   vert_resolution ::     The vertical resolution in dpi.



**return**:   FreeType error code.  0~means success.



**note**:   While this function allows fractional points as input values, the   resulting ppem value for the given resolution is always rounded to the   nearest integer.

   If either the character width or height is zero, it is set equal to   the other value.

   If either the horizontal or vertical resolution is zero, it is set   equal to the other value.

   A character width or height smaller than 1pt is set to 1pt; if both   resolution values are zero, they are set to 72dpi.

   Don't use this function if you are using the FreeType cache API.

### FT_Set_Pixel_Sizes

*FT_Error FT_Set_Pixel_Sizes(FT_Face face, FT_UInt pixel_width, FT_UInt pixel_height)*

************************************************************************



:

   FT_Set_Pixel_Sizes

**<not a builtin command>** :   Call **<not a builtin command>** _Request_Size to request the nominal size (in pixels).

**<not a builtin command>** :   face ::     A handle to the target face object.

**<not a builtin command>** :   pixel_width ::     The nominal width, in pixels.

   pixel_height ::     The nominal height, in pixels.



**return**:   FreeType error code.  0~means success.



**note**:   You should not rely on the resulting glyphs matching or being   constrained to this pixel size.  Refer to **<not a builtin command>** _Request_Size to   understand how requested sizes relate to actual sizes.

   Don't use this function if you are using the FreeType cache API.

### FT_Load_Glyph

*FT_Error FT_Load_Glyph(FT_Face face, FT_UInt glyph_index, FT_Int32 load_flags)*

************************************************************************



:

   FT_Load_Glyph

**<not a builtin command>** :   Load a glyph into the glyph slot of a face object.

**<not a builtin command>** :   face ::     A handle to the target face object where the glyph is loaded.

**<not a builtin command>** :   glyph_index ::     The index of the glyph in the font file.  For CID-keyed fonts     (either in PS or in CFF format) this argument specifies the CID     value.

   load_flags ::     A flag indicating what to load for this glyph.  The **<not a builtin command>** _LOAD_XXX     constants can be used to control the glyph loading process (e.g.,     whether the outline should be scaled, whether to load bitmaps or     not, whether to hint the outline, etc).



**return**:   FreeType error code.  0~means success.



**note**:   The loaded glyph may be transformed.  See **<not a builtin command>** _Set_Transform for the   details.

   For subsetted CID-keyed fonts, `FT_Err_Invalid_Argument` is returned   for invalid CID values (this is, for CID values that don't have a   corresponding glyph in the font).  See the discussion of the**<not a builtin command>** _FACE_FLAG_CID_KEYED flag for more details.

   If you receive `FT_Err_Glyph_Too_Big`, try getting the glyph outline   at EM size, then scale it manually and fill it as a graphics   operation.

### FT_Load_Char

*FT_Error FT_Load_Char(FT_Face face, FT_ULong char_code, FT_Int32 load_flags)*

************************************************************************



:

   FT_Load_Char

**<not a builtin command>** :   Load a glyph into the glyph slot of a face object, accessed by its   character code.

**<not a builtin command>** :   face ::     A handle to a target face object where the glyph is loaded.

**<not a builtin command>** :   char_code ::     The glyph's character code, according to the current charmap used in     the face.

   load_flags ::     A flag indicating what to load for this glyph.  The **<not a builtin command>** _LOAD_XXX     constants can be used to control the glyph loading process (e.g.,     whether the outline should be scaled, whether to load bitmaps or     not, whether to hint the outline, etc).



**return**:   FreeType error code.  0~means success.



**note**:   This function simply calls **<not a builtin command>** _Get_Char_Index and **<not a builtin command>** _Load_Glyph.

   Many fonts contain glyphs that can't be loaded by this function since   its glyph indices are not listed in any of the font's charmaps.

   If no active cmap is set up (i.e., `face->charmap` is zero), the call   to **<not a builtin command>** _Get_Char_Index is omitted, and the function behaves identically   to **<not a builtin command>** _Load_Glyph.

### FT_Set_Transform

*void FT_Set_Transform(FT_Face face, FT_Matrix * matrix, FT_Vector * delta)*

************************************************************************



:

   FT_Set_Transform

**<not a builtin command>** :   Set the transformation that is applied to glyph images when they are   loaded into a glyph slot through **<not a builtin command>** _Load_Glyph.

**<not a builtin command>** :   face ::     A handle to the source face object.

**<not a builtin command>** :   matrix ::     A pointer to the transformation's 2x2 matrix.  Use `NULL` for the     identity matrix.   delta ::     A pointer to the translation vector.  Use `NULL` for the null vector.



**note**:   The transformation is only applied to scalable image formats after the   glyph has been loaded.  It means that hinting is unaltered by the   transformation and is performed on the character size given in the   last call to **<not a builtin command>** _Set_Char_Size or **<not a builtin command>** _Set_Pixel_Sizes.

   Note that this also transforms the `face.glyph.advance` field, but   **not** the values in `face.glyph.metrics`.

### FT_Render_Glyph

*FT_Error FT_Render_Glyph(FT_GlyphSlot slot, FT_Render_Mode render_mode)*

************************************************************************



:

   FT_Render_Glyph

**<not a builtin command>** :   Convert a given glyph image to a bitmap.  It does so by inspecting the   glyph image format, finding the relevant renderer, and invoking it.

**<not a builtin command>** :   slot ::     A handle to the glyph slot containing the image to convert.

**<not a builtin command>** :   render_mode ::     The render mode used to render the glyph image into a bitmap.  See**<not a builtin command>** _Render_Mode for a list of possible values.

     If **<not a builtin command>** _RENDER_MODE_NORMAL is used, a previous call of **<not a builtin command>** _Load_Glyph     with flag **<not a builtin command>** _LOAD_COLOR makes FT_Render_Glyph provide a default     blending of colored glyph layers associated with the current glyph     slot (provided the font contains such layers) instead of rendering     the glyph slot's outline.  This is an experimental feature; see**<not a builtin command>** _LOAD_COLOR for more information.



**return**:   FreeType error code.  0~means success.



**note**:   To get meaningful results, font scaling values must be set with   functions like **<not a builtin command>** _Set_Char_Size before calling `FT_Render_Glyph`.

   When FreeType outputs a bitmap of a glyph, it really outputs an alpha   coverage map.  If a pixel is completely covered by a filled-in   outline, the bitmap contains 0xFF at that pixel, meaning that   0xFF/0xFF fraction of that pixel is covered, meaning the pixel is 100%   black (or 0% bright).  If a pixel is only 50% covered (value 0x80),   the pixel is made 50% black (50% bright or a middle shade of grey).   0% covered means 0% black (100% bright or white).

   On high-DPI screens like on smartphones and tablets, the pixels are so   small that their chance of being completely covered and therefore   completely black are fairly good.  On the low-DPI screens, however,   the situation is different.  The pixels are too large for most of the   details of a glyph and shades of gray are the norm rather than the   exception.

   This is relevant because all our screens have a second problem: they   are not linear.  1~+~1 is not~2.  Twice the value does not result in   twice the brightness.  When a pixel is only 50% covered, the coverage   map says 50% black, and this translates to a pixel value of 128 when   you use 8~bits per channel (0-255).  However, this does not translate   to 50% brightness for that pixel on our sRGB and gamma~2.2 screens.   Due to their non-linearity, they dwell longer in the darks and only a   pixel value of about 186 results in 50% brightness -- 128 ends up too   dark on both bright and dark backgrounds.  The net result is that dark   text looks burnt-out, pixely and blotchy on bright background, bright   text too frail on dark backgrounds, and colored text on colored   background (for example, red on green) seems to have dark halos or   'dirt' around it.  The situation is especially ugly for diagonal stems   like in 'w' glyph shapes where the quality of FreeType's anti-aliasing   depends on the correct display of grays.  On high-DPI screens where   smaller, fully black pixels reign supreme, this doesn't matter, but on   our low-DPI screens with all the gray shades, it does.  0% and 100%   brightness are the same things in linear and non-linear space, just   all the shades in-between aren't.

   The blending function for placing text over a background is

   ```     dst = alpha * src + (1 - alpha) * dst    ,   ```

   which is known as the OVER operator.

   To correctly composite an antialiased pixel of a glyph onto a surface,

   1. take the foreground and background colors (e.g., in sRGB space)      and apply gamma to get them in a linear space,

   2. use OVER to blend the two linear colors using the glyph pixel      as the alpha value (remember, the glyph bitmap is an alpha coverage      bitmap), and

   3. apply inverse gamma to the blended pixel and write it back to      the image.

   Internal testing at Adobe found that a target inverse gamma of~1.8 for   step~3 gives good results across a wide range of displays with an sRGB   gamma curve or a similar one.

   This process can cost performance.  There is an approximation that   does not need to know about the background color; see   https://bel.fi/alankila/lcd/ and   https://bel.fi/alankila/lcd/alpcor.html for details.

   **ATTENTION**: Linear blending is even more important when dealing   with subpixel-rendered glyphs to prevent color-fringing!  A   subpixel-rendered glyph must first be filtered with a filter that   gives equal weight to the three color primaries and does not exceed a   sum of 0x100, see section **<not a builtin command>** _rendering.  Then the only difference to   gray linear blending is that subpixel-rendered linear blending is done   3~times per pixel: red foreground subpixel to red background subpixel   and so on for green and blue.

### FT_Get_Kerning

*FT_Error FT_Get_Kerning(FT_Face face, FT_UInt left_glyph, FT_UInt right_glyph, FT_UInt kern_mode, FT_Vector * akerning)*

************************************************************************



:

   FT_Get_Kerning

**<not a builtin command>** :   Return the kerning vector between two glyphs of the same face.

**<not a builtin command>** :   face ::     A handle to a source face object.

   left_glyph ::     The index of the left glyph in the kern pair.

   right_glyph ::     The index of the right glyph in the kern pair.

   kern_mode ::     See **<not a builtin command>** _Kerning_Mode for more information.  Determines the scale and     dimension of the returned kerning vector.

**<not a builtin command>** :   akerning ::     The kerning vector.  This is either in font units, fractional pixels     (26.6 format), or pixels for scalable formats, and in pixels for     fixed-sizes formats.



**return**:   FreeType error code.  0~means success.



**note**:   Only horizontal layouts (left-to-right & right-to-left) are supported   by this method.  Other layouts, or more sophisticated kernings, are   out of the scope of this API function -- they can be implemented   through format-specific interfaces.

   Kerning for OpenType fonts implemented in a 'GPOS' table is not   supported; use **<not a builtin command>** _HAS_KERNING to find out whether a font has data   that can be extracted with `FT_Get_Kerning`.

### FT_Get_Track_Kerning

*FT_Error FT_Get_Track_Kerning(FT_Face face, FT_Fixed point_size, FT_Int degree, FT_Fixed * akerning)*

************************************************************************



:

   FT_Get_Track_Kerning

**<not a builtin command>** :   Return the track kerning for a given face object at a given size.

**<not a builtin command>** :   face ::     A handle to a source face object.

   point_size ::     The point size in 16.16 fractional points.

   degree ::     The degree of tightness.  Increasingly negative values represent     tighter track kerning, while increasingly positive values represent     looser track kerning.  Value zero means no track kerning.

**<not a builtin command>** :   akerning ::     The kerning in 16.16 fractional points, to be uniformly applied     between all glyphs.



**return**:   FreeType error code.  0~means success.



**note**:   Currently, only the Type~1 font driver supports track kerning, using   data from AFM files (if attached with **<not a builtin command>** _Attach_File or**<not a builtin command>** _Attach_Stream).

   Only very few AFM files come with track kerning data; please refer to   Adobe's AFM specification for more details.

### FT_Get_Glyph_Name

*FT_Error FT_Get_Glyph_Name(FT_Face face, FT_UInt glyph_index, FT_Pointer buffer, FT_UInt buffer_max)*

************************************************************************



:

   FT_Get_Glyph_Name

**<not a builtin command>** :   Retrieve the ASCII name of a given glyph in a face.  This only works   for those faces where **<not a builtin command>** _HAS_GLYPH_NAMES(face) returns~1.

**<not a builtin command>** :   face ::     A handle to a source face object.

   glyph_index ::     The glyph index.

   buffer_max ::     The maximum number of bytes available in the buffer.

**<not a builtin command>** :   buffer ::     A pointer to a target buffer where the name is copied to.



**return**:   FreeType error code.  0~means success.



**note**:   An error is returned if the face doesn't provide glyph names or if the   glyph index is invalid.  In all cases of failure, the first byte of   `buffer` is set to~0 to indicate an empty name.

   The glyph name is truncated to fit within the buffer if it is too   long.  The returned string is always zero-terminated.

   Be aware that FreeType reorders glyph indices internally so that glyph   index~0 always corresponds to the 'missing glyph' (called '.notdef').

   This function always returns an error if the config macro   `FT_CONFIG_OPTION_NO_GLYPH_NAMES` is not defined in `ftoption.h`.

### FT_Get_Postscript_Name

*const char * FT_Get_Postscript_Name(FT_Face face)*

************************************************************************



:

   FT_Get_Postscript_Name

**<not a builtin command>** :   Retrieve the ASCII PostScript name of a given face, if available.   This only works with PostScript, TrueType, and OpenType fonts.

**<not a builtin command>** :   face ::     A handle to the source face object.



**return**:   A pointer to the face's PostScript name.  `NULL` if unavailable.



**note**:   The returned pointer is owned by the face and is destroyed with it.

   For variation fonts, this string changes if you select a different   instance, and you have to call `FT_Get_PostScript_Name` again to   retrieve it.  FreeType follows Adobe TechNote #5902, 'Generating   PostScript Names for Fonts Using OpenType Font Variations'.

     https://download.macromedia.com/pub/developer/opentype/tech-notes/5902.AdobePSNameGeneration.html

   [Since 2.9] Special PostScript names for named instances are only   returned if the named instance is set with **<not a builtin command>** _Set_Named_Instance (and   the font has corresponding entries in its 'fvar' table).  If**<not a builtin command>** _IS_VARIATION returns true, the algorithmically derived PostScript   name is provided, not looking up special entries for named instances.

### FT_Select_Charmap

*FT_Error FT_Select_Charmap(FT_Face face, FT_Encoding encoding)*

************************************************************************



:

   FT_Select_Charmap

**<not a builtin command>** :   Select a given charmap by its encoding tag (as listed in   `freetype.h`).

**<not a builtin command>** :   face ::     A handle to the source face object.

**<not a builtin command>** :   encoding ::     A handle to the selected encoding.



**return**:   FreeType error code.  0~means success.



**note**:   This function returns an error if no charmap in the face corresponds   to the encoding queried here.

   Because many fonts contain more than a single cmap for Unicode   encoding, this function has some special code to select the one that   covers Unicode best ('best' in the sense that a UCS-4 cmap is   preferred to a UCS-2 cmap).  It is thus preferable to **<not a builtin command>** _Set_Charmap   in this case.

### FT_Set_Charmap

*FT_Error FT_Set_Charmap(FT_Face face, FT_CharMap charmap)*

************************************************************************



:

   FT_Set_Charmap

**<not a builtin command>** :   Select a given charmap for character code to glyph index mapping.

**<not a builtin command>** :   face ::     A handle to the source face object.

**<not a builtin command>** :   charmap ::     A handle to the selected charmap.



**return**:   FreeType error code.  0~means success.



**note**:   This function returns an error if the charmap is not part of the face   (i.e., if it is not listed in the `face->charmaps` table).

   It also fails if an OpenType type~14 charmap is selected (which   doesn't map character codes to glyph indices at all).

### FT_Get_Charmap_Index

*FT_Int FT_Get_Charmap_Index(FT_CharMap charmap)*

************************************************************************



:

   FT_Get_Charmap_Index

**<not a builtin command>** :   Retrieve index of a given charmap.

**<not a builtin command>** :   charmap ::     A handle to a charmap.



**return**:   The index into the array of character maps within the face to which   `charmap` belongs.  If an error occurs, -1 is returned.



### FT_Get_Char_Index

*FT_UInt FT_Get_Char_Index(FT_Face face, FT_ULong charcode)*

************************************************************************



:

   FT_Get_Char_Index

**<not a builtin command>** :   Return the glyph index of a given character code.  This function uses   the currently selected charmap to do the mapping.

**<not a builtin command>** :   face ::     A handle to the source face object.

   charcode ::     The character code.



**return**:   The glyph index.  0~means 'undefined character code'.



**note**:   If you use FreeType to manipulate the contents of font files directly,   be aware that the glyph index returned by this function doesn't always   correspond to the internal indices used within the file.  This is done   to ensure that value~0 always corresponds to the 'missing glyph'.  If   the first glyph is not named '.notdef', then for Type~1 and Type~42   fonts, '.notdef' will be moved into the glyph ID~0 position, and   whatever was there will be moved to the position '.notdef' had.  For   Type~1 fonts, if there is no '.notdef' glyph at all, then one will be   created at index~0 and whatever was there will be moved to the last   index -- Type~42 fonts are considered invalid under this condition.

### FT_Get_First_Char

*FT_ULong FT_Get_First_Char(FT_Face face, FT_UInt * agindex)*

************************************************************************



:

   FT_Get_First_Char

**<not a builtin command>** :   Return the first character code in the current charmap of a given   face, together with its corresponding glyph index.

**<not a builtin command>** :   face ::     A handle to the source face object.

**<not a builtin command>** :   agindex ::     Glyph index of first character code.  0~if charmap is empty.



**return**:   The charmap's first character code.



**note**:   You should use this function together with **<not a builtin command>** _Get_Next_Char to parse   all character codes available in a given charmap.  The code should   look like this:

   ```     FT_ULong  charcode;     FT_UInt   gindex;

     charcode = FT_Get_First_Char( face, &gindex );     while ( gindex != 0 )     {       ... do something with (charcode,gindex) pair ...

       charcode = FT_Get_Next_Char( face, charcode, &gindex );     }   ```

   Be aware that character codes can have values up to 0xFFFFFFFF; this   might happen for non-Unicode or malformed cmaps.  However, even with   regular Unicode encoding, so-called 'last resort fonts' (using SFNT   cmap format 13, see function **<not a builtin command>** _Get_CMap_Format) normally have   entries for all Unicode characters up to 0x1FFFFF, which can cause *a   lot* of iterations.

   Note that `*agindex` is set to~0 if the charmap is empty.  The result   itself can be~0 in two cases: if the charmap is empty or if the   value~0 is the first valid character code.

### FT_Get_Next_Char

*FT_ULong FT_Get_Next_Char(FT_Face face, FT_ULong char_code, FT_UInt * agindex)*

************************************************************************



:

   FT_Get_Next_Char

**<not a builtin command>** :   Return the next character code in the current charmap of a given face   following the value `char_code`, as well as the corresponding glyph   index.

**<not a builtin command>** :   face ::     A handle to the source face object.

   char_code ::     The starting character code.

**<not a builtin command>** :   agindex ::     Glyph index of next character code.  0~if charmap is empty.



**return**:   The charmap's next character code.



**note**:   You should use this function with **<not a builtin command>** _Get_First_Char to walk over all   character codes available in a given charmap.  See the note for that   function for a simple code example.

   Note that `*agindex` is set to~0 when there are no more codes in the   charmap.

### FT_Face_Properties

*FT_Error FT_Face_Properties(FT_Face face, FT_UInt num_properties, FT_Parameter * properties)*

************************************************************************



:

   FT_Face_Properties

**<not a builtin command>** :   Set or override certain (library or module-wide) properties on a   face-by-face basis.  Useful for finer-grained control and avoiding   locks on shared structures (threads can modify their own faces as they   see fit).

   Contrary to **<not a builtin command>** _Property_Set, this function uses **<not a builtin command>** _Parameter so that   you can pass multiple properties to the target face in one call.  Note   that only a subset of the available properties can be controlled.

   * **<not a builtin command>** _PARAM_TAG_STEM_DARKENING (stem darkening, corresponding to the     property `no-stem-darkening` provided by the 'autofit', 'cff',     'type1', and 't1cid' modules; see **<not a builtin command>** -stem-darkening).

   * **<not a builtin command>** _PARAM_TAG_LCD_FILTER_WEIGHTS (LCD filter weights, corresponding     to function **<not a builtin command>** _Library_SetLcdFilterWeights).

   * **<not a builtin command>** _PARAM_TAG_RANDOM_SEED (seed value for the CFF, Type~1, and CID     'random' operator, corresponding to the `random-seed` property     provided by the 'cff', 'type1', and 't1cid' modules; see**<not a builtin command>** -seed).

   Pass `NULL` as `data` in **<not a builtin command>** _Parameter for a given tag to reset the   option and use the library or module default again.

**<not a builtin command>** :   face ::     A handle to the source face object.

   num_properties ::     The number of properties that follow.

   properties ::     A handle to an **<not a builtin command>** _Parameter array with `num_properties` elements.



**return**:   FreeType error code.  0~means success.

**<not a builtin command>** :   Here is an example that sets three properties.  You must define   `FT_CONFIG_OPTION_SUBPIXEL_RENDERING` to make the LCD filter examples   work.

   ```     FT_Parameter         property1;     FT_Bool              darken_stems = 1;

     FT_Parameter         property2;     FT_LcdFiveTapFilter  custom_weight =                            { 0x11, 0x44, 0x56, 0x44, 0x11 };

     FT_Parameter         property3;     FT_Int32             random_seed = 314159265;

     FT_Parameter         properties[3] = { property1,                                            property2,                                            property3 };

     property1.tag  = FT_PARAM_TAG_STEM_DARKENING;     property1.data = &darken_stems;

     property2.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;     property2.data = custom_weight;

     property3.tag  = FT_PARAM_TAG_RANDOM_SEED;     property3.data = &random_seed;

     FT_Face_Properties( face, 3, properties );   ```

   The next example resets a single property to its default value.

   ```     FT_Parameter  property;

     property.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;     property.data = NULL;

     FT_Face_Properties( face, 1, &property );   ```



**since**:   2.8



### FT_Get_Name_Index

*FT_UInt FT_Get_Name_Index(FT_Face face, const FT_String * glyph_name)*

************************************************************************



:

   FT_Get_Name_Index

**<not a builtin command>** :   Return the glyph index of a given glyph name.

**<not a builtin command>** :   face ::     A handle to the source face object.

   glyph_name ::     The glyph name.



**return**:   The glyph index.  0~means 'undefined character code'.

### FT_Get_SubGlyph_Info

*FT_Error FT_Get_SubGlyph_Info(FT_GlyphSlot glyph, FT_UInt sub_index, FT_Int * p_index, FT_UInt * p_flags, FT_Int * p_arg1, FT_Int * p_arg2, FT_Matrix * p_transform)*

************************************************************************



:

   FT_Get_SubGlyph_Info

**<not a builtin command>** :   Retrieve a description of a given subglyph.  Only use it if   `glyph->format` is **<not a builtin command>** _GLYPH_FORMAT_COMPOSITE; an error is returned   otherwise.

**<not a builtin command>** :   glyph ::     The source glyph slot.

   sub_index ::     The index of the subglyph.  Must be less than     `glyph->num_subglyphs`.

**<not a builtin command>** :   p_index ::     The glyph index of the subglyph.

   p_flags ::     The subglyph flags, see **<not a builtin command>** _SUBGLYPH_FLAG_XXX.

   p_arg1 ::     The subglyph's first argument (if any).

   p_arg2 ::     The subglyph's second argument (if any).

   p_transform ::     The subglyph transformation (if any).



**return**:   FreeType error code.  0~means success.



**note**:   The values of `*p_arg1`, `*p_arg2`, and `*p_transform` must be   interpreted depending on the flags returned in `*p_flags`.  See the   OpenType specification for details.

     https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description



### FT_Get_Color_Glyph_Layer

*FT_Bool FT_Get_Color_Glyph_Layer(FT_Face face, FT_UInt base_glyph, FT_UInt * aglyph_index, FT_UInt * acolor_index, FT_LayerIterator * iterator)*

************************************************************************



:

   FT_Get_Color_Glyph_Layer

**<not a builtin command>** :   This is an interface to the 'COLR' table in OpenType fonts to   iteratively retrieve the colored glyph layers associated with the   current glyph slot.

     https://docs.microsoft.com/en-us/typography/opentype/spec/colr

   The glyph layer data for a given glyph index, if present, provides an   alternative, multi-colour glyph representation: Instead of rendering   the outline or bitmap with the given glyph index, glyphs with the   indices and colors returned by this function are rendered layer by   layer.

   The returned elements are ordered in the z~direction from bottom to   top; the 'n'th element should be rendered with the associated palette   color and blended on top of the already rendered layers (elements 0,   1, ..., n-1).

**<not a builtin command>** :   face ::     A handle to the parent face object.

   base_glyph ::     The glyph index the colored glyph layers are associated with.

**<not a builtin command>** :   iterator ::     An **<not a builtin command>** _LayerIterator object.  For the first call you should set     `iterator->p` to `NULL`.  For all following calls, simply use the     same object again.

**<not a builtin command>** :   aglyph_index ::     The glyph index of the current layer.

   acolor_index ::     The color index into the font face's color palette of the current     layer.  The value 0xFFFF is special; it doesn't reference a palette     entry but indicates that the text foreground color should be used     instead (to be set up by the application outside of FreeType).

     The color palette can be retrieved with **<not a builtin command>** _Palette_Select.



**return**:   Value~1 if everything is OK.  If there are no more layers (or if there   are no layers at all), value~0 gets returned.  In case of an error,   value~0 is returned also.



**note**:   This function is necessary if you want to handle glyph layers by   yourself.  In particular, functions that operate with **<not a builtin command>** _GlyphRec   objects (like **<not a builtin command>** _Get_Glyph or **<not a builtin command>** _Glyph_To_Bitmap) don't have access   to this information.

   Note that **<not a builtin command>** _Render_Glyph is able to handle colored glyph layers   automatically if the **<not a builtin command>** _LOAD_COLOR flag is passed to a previous call   to **<not a builtin command>** _Load_Glyph.  [This is an experimental feature.]

**<not a builtin command>** :   ```     FT_Color*         palette;     FT_LayerIterator  iterator;

     FT_Bool  have_layers;     FT_UInt  layer_glyph_index;     FT_UInt  layer_color_index;

     error = FT_Palette_Select( face, palette_index, &palette );     if ( error )       palette = NULL;

     iterator.p  = NULL;     have_layers = FT_Get_Color_Glyph_Layer( face,                                             glyph_index,&layer_glyph_index,&layer_color_index,&iterator );

     if ( palette && have_layers )     {       do       {         FT_Color  layer_color;

         if ( layer_color_index == 0xFFFF )           layer_color = text_foreground_color;         else           layer_color = palette[layer_color_index];

         // Load and render glyph `layer_glyph_index', then         // blend resulting pixmap (using color `layer_color')         // with previously created pixmaps.

       } while ( FT_Get_Color_Glyph_Layer( face,                                           glyph_index,&layer_glyph_index,&layer_color_index,&iterator ) );     }   ```

### FT_Get_FSType_Flags

*FT_UShort FT_Get_FSType_Flags(FT_Face face)*

************************************************************************



:

   FT_Get_FSType_Flags

**<not a builtin command>** :   Return the `fsType` flags for a font.

**<not a builtin command>** :   face ::     A handle to the source face object.



**return**:   The `fsType` flags, see **<not a builtin command>** _FSTYPE_XXX.



**note**:   Use this function rather than directly reading the `fs_type` field in   the **<not a builtin command>** _FontInfoRec structure, which is only guaranteed to return the   correct results for Type~1 fonts.



**since**:   2.3.8

### FT_Face_GetCharVariantIndex

*FT_UInt FT_Face_GetCharVariantIndex(FT_Face face, FT_ULong charcode, FT_ULong variantSelector)*

************************************************************************



:

   FT_Face_GetCharVariantIndex

**<not a builtin command>** :   Return the glyph index of a given character code as modified by the   variation selector.

**<not a builtin command>** :   face ::     A handle to the source face object.

   charcode ::     The character code point in Unicode.

   variantSelector ::     The Unicode code point of the variation selector.



**return**:   The glyph index.  0~means either 'undefined character code', or   'undefined selector code', or 'no variation selector cmap subtable',   or 'current CharMap is not Unicode'.



**note**:   If you use FreeType to manipulate the contents of font files directly,   be aware that the glyph index returned by this function doesn't always   correspond to the internal indices used within the file.  This is done   to ensure that value~0 always corresponds to the 'missing glyph'.

   This function is only meaningful if     a) the font has a variation selector cmap sub table, and     b) the current charmap has a Unicode encoding.



**since**:   2.3.6

### FT_Face_GetCharVariantIsDefault

*FT_Int FT_Face_GetCharVariantIsDefault(FT_Face face, FT_ULong charcode, FT_ULong variantSelector)*

************************************************************************



:

   FT_Face_GetCharVariantIsDefault

**<not a builtin command>** :   Check whether this variation of this Unicode character is the one to   be found in the charmap.

**<not a builtin command>** :   face ::     A handle to the source face object.

   charcode ::     The character codepoint in Unicode.

   variantSelector ::     The Unicode codepoint of the variation selector.



**return**:   1~if found in the standard (Unicode) cmap, 0~if found in the variation   selector cmap, or -1 if it is not a variation.



**note**:   This function is only meaningful if the font has a variation selector   cmap subtable.



**since**:   2.3.6

### FT_Face_GetVariantSelectors

*FT_UInt32 * FT_Face_GetVariantSelectors(FT_Face face)*

************************************************************************



:

   FT_Face_GetVariantSelectors

**<not a builtin command>** :   Return a zero-terminated list of Unicode variation selectors found in   the font.

**<not a builtin command>** :   face ::     A handle to the source face object.



**return**:   A pointer to an array of selector code points, or `NULL` if there is   no valid variation selector cmap subtable.



**note**:   The last item in the array is~0; the array is owned by the **<not a builtin command>** _Face   object but can be overwritten or released on the next call to a   FreeType function.



**since**:   2.3.6

### FT_Face_GetVariantsOfChar

*FT_UInt32 * FT_Face_GetVariantsOfChar(FT_Face face, FT_ULong charcode)*

************************************************************************



:

   FT_Face_GetVariantsOfChar

**<not a builtin command>** :   Return a zero-terminated list of Unicode variation selectors found for   the specified character code.

**<not a builtin command>** :   face ::     A handle to the source face object.

   charcode ::     The character codepoint in Unicode.



**return**:   A pointer to an array of variation selector code points that are   active for the given character, or `NULL` if the corresponding list is   empty.



**note**:   The last item in the array is~0; the array is owned by the **<not a builtin command>** _Face   object but can be overwritten or released on the next call to a   FreeType function.



**since**:   2.3.6

### FT_Face_GetCharsOfVariant

*FT_UInt32 * FT_Face_GetCharsOfVariant(FT_Face face, FT_ULong variantSelector)*

************************************************************************



:

   FT_Face_GetCharsOfVariant

**<not a builtin command>** :   Return a zero-terminated list of Unicode character codes found for the   specified variation selector.

**<not a builtin command>** :   face ::     A handle to the source face object.

   variantSelector ::     The variation selector code point in Unicode.



**return**:   A list of all the code points that are specified by this selector   (both default and non-default codes are returned) or `NULL` if there   is no valid cmap or the variation selector is invalid.



**note**:   The last item in the array is~0; the array is owned by the **<not a builtin command>** _Face   object but can be overwritten or released on the next call to a   FreeType function.



**since**:   2.3.6

### FT_MulDiv

*FT_Long FT_MulDiv(FT_Long a, FT_Long b, FT_Long c)*

************************************************************************



:

   FT_MulDiv

**<not a builtin command>** :   Compute `(a*b)/c` with maximum accuracy, using a 64-bit intermediate   integer whenever necessary.

   This function isn't necessarily as fast as some processor-specific   operations, but is at least completely portable.

**<not a builtin command>** :   a ::     The first multiplier.

   b ::     The second multiplier.

   c ::     The divisor.



**return**:   The result of `(a*b)/c`.  This function never traps when trying to   divide by zero; it simply returns 'MaxInt' or 'MinInt' depending on   the signs of `a` and `b`.

### FT_MulFix

*FT_Long FT_MulFix(FT_Long a, FT_Long b)*

************************************************************************



:

   FT_MulFix

**<not a builtin command>** :   Compute `(a*b)/0x10000` with maximum accuracy.  Its main use is to   multiply a given value by a 16.16 fixed-point factor.

**<not a builtin command>** :   a ::     The first multiplier.

   b ::     The second multiplier.  Use a 16.16 factor here whenever possible     (see note below).



**return**:   The result of `(a*b)/0x10000`.



**note**:   This function has been optimized for the case where the absolute value   of `a` is less than 2048, and `b` is a 16.16 scaling factor.  As this   happens mainly when scaling from notional units to fractional pixels   in FreeType, it resulted in noticeable speed improvements between   versions 2.x and 1.x.

   As a conclusion, always try to place a 16.16 factor as the _second_   argument of this function; this can make a great difference.

### FT_DivFix

*FT_Long FT_DivFix(FT_Long a, FT_Long b)*

************************************************************************



:

   FT_DivFix

**<not a builtin command>** :   Compute `(a*0x10000)/b` with maximum accuracy.  Its main use is to   divide a given value by a 16.16 fixed-point factor.

**<not a builtin command>** :   a ::     The numerator.

   b ::     The denominator.  Use a 16.16 factor here.



**return**:   The result of `(a*0x10000)/b`.

### FT_RoundFix

*FT_Fixed FT_RoundFix(FT_Fixed a)*

************************************************************************



:

   FT_RoundFix

**<not a builtin command>** :   Round a 16.16 fixed number.

**<not a builtin command>** :   a ::     The number to be rounded.



**return**:   `a` rounded to the nearest 16.16 fixed integer, halfway cases away   from zero.



**note**:   The function uses wrap-around arithmetic.

### FT_CeilFix

*FT_Fixed FT_CeilFix(FT_Fixed a)*

************************************************************************



:

   FT_CeilFix

**<not a builtin command>** :   Compute the smallest following integer of a 16.16 fixed number.

**<not a builtin command>** :   a ::     The number for which the ceiling function is to be computed.



**return**:   `a` rounded towards plus infinity.



**note**:   The function uses wrap-around arithmetic.

### FT_FloorFix

*FT_Fixed FT_FloorFix(FT_Fixed a)*

************************************************************************



:

   FT_FloorFix

**<not a builtin command>** :   Compute the largest previous integer of a 16.16 fixed number.

**<not a builtin command>** :   a ::     The number for which the floor function is to be computed.



**return**:   `a` rounded towards minus infinity.

### FT_Vector_Transform

*void FT_Vector_Transform(FT_Vector * vector, const FT_Matrix * matrix)*

************************************************************************



:

   FT_Vector_Transform

**<not a builtin command>** :   Transform a single vector through a 2x2 matrix.

**<not a builtin command>** :   vector ::     The target vector to transform.

**<not a builtin command>** :   matrix ::     A pointer to the source 2x2 matrix.



**note**:   The result is undefined if either `vector` or `matrix` is invalid.

### FT_Library_Version

*void FT_Library_Version(FT_Library library, FT_Int * amajor, FT_Int * aminor, FT_Int * apatch)*

************************************************************************



:

   FT_Library_Version

**<not a builtin command>** :   Return the version of the FreeType library being used.  This is useful   when dynamically linking to the library, since one cannot use the   macros **<not a builtin command>** _MAJOR, **<not a builtin command>** _MINOR, and **<not a builtin command>** _PATCH.

**<not a builtin command>** :   library ::     A source library handle.

**<not a builtin command>** :   amajor ::     The major version number.

   aminor ::     The minor version number.

   apatch ::     The patch version number.



**note**:   The reason why this function takes a `library` argument is because   certain programs implement library initialization in a custom way that   doesn't use **<not a builtin command>** _Init_FreeType.

   In such cases, the library version might not be available before the   library object has been created.

### FT_Face_CheckTrueTypePatents

*FT_Bool FT_Face_CheckTrueTypePatents(FT_Face face)*

************************************************************************



:

   FT_Face_CheckTrueTypePatents

**<not a builtin command>** :   Deprecated, does nothing.

**<not a builtin command>** :   face ::     A face handle.



**return**:   Always returns false.



**note**:   Since May 2010, TrueType hinting is no longer patented.



**since**:   2.3.5

### FT_Face_SetUnpatentedHinting

*FT_Bool FT_Face_SetUnpatentedHinting(FT_Face face, FT_Bool value)*

************************************************************************



:

   FT_Face_SetUnpatentedHinting

**<not a builtin command>** :   Deprecated, does nothing.

**<not a builtin command>** :   face ::     A face handle.

   value ::     New boolean setting.



**return**:   Always returns false.



**note**:   Since May 2010, TrueType hinting is no longer patented.



**since**:   2.3.5

### UI_GameOptions_Precache

*void UI_GameOptions_Precache()*

*Defined at line 292 of ./mainui/menus/GameOptions.cpp*

=================UI_GameOptions_Precache=================

### UI_UpdateUserinfo

*void UI_UpdateUserinfo()*

*Defined at line 377 of ./engine/client/cl_gameui.cpp*

### UI_DrawLogo

*void UI_DrawLogo(const char * filename, float x, float y, float width, float height)*

*Defined at line 293 of ./engine/client/cl_gameui.cpp*

### UI_GetLogoWidth

*int UI_GetLogoWidth()*

*Defined at line 362 of ./engine/client/cl_gameui.cpp*

### UI_GetLogoHeight

*int UI_GetLogoHeight()*

*Defined at line 367 of ./engine/client/cl_gameui.cpp*

### UI_GetLogoLength

*float UI_GetLogoLength()*

*Defined at line 372 of ./engine/client/cl_gameui.cpp*

### UI_ConvertGameInfo

*void UI_ConvertGameInfo(GAMEINFO * out, gameinfo_t * in)*

*Defined at line 400 of ./engine/client/cl_gameui.cpp*

### PIC_Scissor

*qboolean PIC_Scissor(float * x, float * y, float * width, float * height, float * u0, float * v0, float * u1, float * v1)*

*Defined at line 422 of ./engine/client/cl_gameui.cpp*

### PIC_DrawGeneric

*void PIC_DrawGeneric(float x, float y, float width, float height, const wrect_t * prc)*

*Defined at line 477 of ./engine/client/cl_gameui.cpp*

====================PIC_DrawGeneric

draw hudsprite routine====================

### pfnPIC_Load

*HIMAGE pfnPIC_Load(const char * szPicName, const byte * image_buf, int image_size, int flags)*

*Defined at line 532 of ./engine/client/cl_gameui.cpp*

===============================================================================	MainUI Builtin Functions

===============================================================================

=========pfnPIC_Load

=========

### pfnPIC_Width

*int pfnPIC_Width(HIMAGE hPic)*

*Defined at line 558 of ./engine/client/cl_gameui.cpp*

=========pfnPIC_Width

=========

### pfnPIC_Height

*int pfnPIC_Height(HIMAGE hPic)*

*Defined at line 573 of ./engine/client/cl_gameui.cpp*

=========pfnPIC_Height

=========

### pfnPIC_EnableScissor

*void pfnPIC_EnableScissor(int x, int y, int width, int height)*

*Defined at line 652 of ./engine/client/cl_gameui.cpp*

=========pfnPIC_EnableScissor

=========

### pfnPIC_DisableScissor

*void pfnPIC_DisableScissor()*

*Defined at line 673 of ./engine/client/cl_gameui.cpp*

=========pfnPIC_DisableScissor

=========

### pfnFillRGBA

*void pfnFillRGBA(int x, int y, int width, int height, int r, int g, int b, int a)*

*Defined at line 688 of ./engine/client/cl_gameui.cpp*

=============pfnFillRGBA

=============

### pfnClientCmd

*void pfnClientCmd(int exec_now, const char * szCmdString)*

*Defined at line 706 of ./engine/client/cl_gameui.cpp*

=============pfnClientCmd

=============

### pfnPlaySound

*void pfnPlaySound(const char * szSound)*

*Defined at line 724 of ./engine/client/cl_gameui.cpp*

=============pfnPlaySound

=============

### pfnDrawCharacter

*void pfnDrawCharacter(int ix, int iy, int iwidth, int iheight, int ch, int ulRGBA, HIMAGE hFont)*

*Defined at line 737 of ./engine/client/cl_gameui.cpp*

=============pfnDrawCharacter

quakefont draw character=============

### UI_DrawConsoleString

*int UI_DrawConsoleString(int x, int y, const char * string)*

*Defined at line 782 of ./engine/client/cl_gameui.cpp*

=============UI_DrawConsoleString

drawing string like a console string =============

### UI_DrawSetTextColor

*void UI_DrawSetTextColor(int r, int g, int b, int alpha)*

*Defined at line 800 of ./engine/client/cl_gameui.cpp*

=============pfnDrawSetTextColor

set color for anything=============

### pfnGetPlayerModel

*cl_entity_t * pfnGetPlayerModel()*

*Defined at line 816 of ./engine/client/cl_gameui.cpp*

====================pfnGetPlayerModel

for drawing playermodel previews====================

### pfnSetPlayerModel

*void pfnSetPlayerModel(cl_entity_t * ent, const char * path)*

*Defined at line 828 of ./engine/client/cl_gameui.cpp*

====================pfnSetPlayerModel

for drawing playermodel previews====================

### pfnClearScene

*void pfnClearScene()*

*Defined at line 841 of ./engine/client/cl_gameui.cpp*

====================pfnClearScene

for drawing playermodel previews====================

### pfnRenderScene

*void pfnRenderScene(const ref_viewpass_t * rvp)*

*Defined at line 854 of ./engine/client/cl_gameui.cpp*

====================pfnRenderScene

for drawing playermodel previews====================

### pfnAddEntity

*int pfnAddEntity(int entityType, cl_entity_t * ent)*

*Defined at line 880 of ./engine/client/cl_gameui.cpp*

====================pfnAddEntity

adding player model into visible list====================

### pfnClientJoin

*void pfnClientJoin(netadr_s adr)*

*Defined at line 894 of ./engine/client/cl_gameui.cpp*

====================pfnClientJoin

send client connect====================

### pfnKeyGetOverstrikeMode

*int pfnKeyGetOverstrikeMode()*

*Defined at line 906 of ./engine/client/cl_gameui.cpp*

====================pfnKeyGetOverstrikeMode

get global key overstrike state====================

### pfnKeySetOverstrikeMode

*void pfnKeySetOverstrikeMode(int fActive)*

*Defined at line 918 of ./engine/client/cl_gameui.cpp*

====================pfnKeySetOverstrikeMode

set global key overstrike mode====================

### pfnKeyGetState

*void * pfnKeyGetState(const char * name)*

*Defined at line 930 of ./engine/client/cl_gameui.cpp*

====================pfnKeyGetState

returns kbutton struct if found====================

### pfnMemAlloc

*void * pfnMemAlloc(size_t cb, const char * filename, const int fileline)*

*Defined at line 943 of ./engine/client/cl_gameui.cpp*

=========pfnMemAlloc

=========

### pfnMemFree

*void pfnMemFree(void * mem, const char * filename, const int fileline)*

*Defined at line 954 of ./engine/client/cl_gameui.cpp*

=========pfnMemFree

=========

### pfnGetGameInfo

*int pfnGetGameInfo(GAMEINFO * pgameinfo)*

*Defined at line 965 of ./engine/client/cl_gameui.cpp*

=========pfnGetGameInfo

=========

### pfnGetGamesList

*GAMEINFO ** pfnGetGamesList(int * numGames)*

*Defined at line 979 of ./engine/client/cl_gameui.cpp*

=========pfnGetGamesList

=========

### pfnGetFilesList

*char ** pfnGetFilesList(const char * pattern, int * numFiles, int gamedironly)*

*Defined at line 992 of ./engine/client/cl_gameui.cpp*

=========pfnGetFilesList

release prev search on a next call=========

### pfnGetClipboardData

*char * pfnGetClipboardData()*

*Defined at line 1016 of ./engine/client/cl_gameui.cpp*

=========pfnGetClipboardData

pointer must be released in call place=========

### pfnCheckGameDll

*int pfnCheckGameDll()*

*Defined at line 1027 of ./engine/client/cl_gameui.cpp*

=========pfnCheckGameDll

=========

### pfnChangeInstance

*void pfnChangeInstance(const char * newInstance, const char * szFinalMessage)*

*Defined at line 1059 of ./engine/client/cl_gameui.cpp*

=========pfnChangeInstance

=========

### pfnHostEndGame

*void pfnHostEndGame(const char * szFinalMessage)*

*Defined at line 1073 of ./engine/client/cl_gameui.cpp*

=========pfnHostEndGame

=========

### pfnStartBackgroundTrack

*void pfnStartBackgroundTrack(const char * introTrack, const char * mainTrack)*

*Defined at line 1085 of ./engine/client/cl_gameui.cpp*

=========pfnStartBackgroundTrack

=========

### GL_ProcessTexture

*void GL_ProcessTexture(int texnum, float gamma, int topColor, int bottomColor)*

*Defined at line 1090 of ./engine/client/cl_gameui.cpp*

### UI_ShellExecute

*void UI_ShellExecute(const char * path, const char * parms, int shouldExit)*

*Defined at line 1101 of ./engine/client/cl_gameui.cpp*

=================UI_ShellExecute=================

### pfnEnableTextInput

*void pfnEnableTextInput(int enable)*

*Defined at line 1198 of ./engine/client/cl_gameui.cpp*

### pfnGetRenderers

*int pfnGetRenderers(unsigned int num, char * shortName, size_t size1, char * readableName, size_t size2)*

*Defined at line 1203 of ./engine/client/cl_gameui.cpp*

### __MsgFunc_StatusIcon

*int __MsgFunc_StatusIcon(const char * pszName, int iSize, void * pbuf)*

*Defined at line 30 of ./game/client/status_icons.cpp*

### scripted_sequence

*void scripted_sequence(entvars_t * pev)*

*Defined at line 118 of ./game/server/ai/ai_scripted.cpp*

### aiscripted_sequence

*void aiscripted_sequence(entvars_t * pev)*

*Defined at line 122 of ./game/server/ai/ai_scripted.cpp*

### ScriptEntityCancel

*void ScriptEntityCancel(edict_t * pentCine)*

*Defined at line 651 of ./game/server/ai/ai_scripted.cpp*

### scripted_sentence

*void scripted_sentence(entvars_t * pev)*

*Defined at line 941 of ./game/server/ai/ai_scripted.cpp*

### monster_furniture

*void monster_furniture(entvars_t * pev)*

*Defined at line 1163 of ./game/server/ai/ai_scripted.cpp*

### SX_Profiling_f

*void SX_Profiling_f()*

*Defined at line 858 of ./engine/client/s_dsp.cpp*

### SX_ReloadRoomFX

*void SX_ReloadRoomFX()*

*Defined at line 165 of ./engine/client/s_dsp.cpp*

============SX_ReloadRoomFX

============

### DLY_Free

*void DLY_Free(int idelay)*

*Defined at line 228 of ./engine/client/s_dsp.cpp*

===========DLY_Free

Free memory allocated for DSP===========

### DLY_Init

*int DLY_Init(int idelay, float delay)*

*Defined at line 264 of ./engine/client/s_dsp.cpp*

===========DLY_Init

Initialize dly===========

### DLY_MovePointer

*void DLY_MovePointer(dly_t * dly)*

*Defined at line 300 of ./engine/client/s_dsp.cpp*

============DLY_MovePointer

Checks overflow and moves pointer============

### DLY_CheckNewStereoDelayVal

*void DLY_CheckNewStereoDelayVal()*

*Defined at line 316 of ./engine/client/s_dsp.cpp*

=============DLY_CheckNewStereoDelayVal

Update stereo processor settings if we are in new room=============

### DLY_DoStereoDelay

*void DLY_DoStereoDelay(int count)*

*Defined at line 366 of ./engine/client/s_dsp.cpp*

=============DLY_DoStereoDelay

Do stereo processing=============

### DLY_CheckNewDelayVal

*void DLY_CheckNewDelayVal()*

*Defined at line 431 of ./engine/client/s_dsp.cpp*

=============DLY_CheckNewDelayVal

Update delay processor settings if we are in new room=============

### DLY_DoDelay

*void DLY_DoDelay(int count)*

*Defined at line 478 of ./engine/client/s_dsp.cpp*

=============DLY_DoDelay

Do delay processing=============

### RVB_SetUpDly

*void RVB_SetUpDly(int pos, float delay, int kmod)*

*Defined at line 529 of ./engine/client/s_dsp.cpp*

===========RVB_SetUpDly

Set up dly for reverb===========

### RVB_CheckNewReverbVal

*void RVB_CheckNewReverbVal()*

*Defined at line 565 of ./engine/client/s_dsp.cpp*

===========RVB_CheckNewReverbVal

Update reverb settings if we are in new room===========

### RVB_DoReverbForOneDly

*int RVB_DoReverbForOneDly(dly_t * dly, const int vlr, const portable_samplepair_t * samplepair)*

*Defined at line 597 of ./engine/client/s_dsp.cpp*

===========RVB_DoReverbForOneDly

Do reverberation for one dly===========

### RVB_DoReverb

*void RVB_DoReverb(int count)*

*Defined at line 671 of ./engine/client/s_dsp.cpp*

===========RVB_DoReverb

Do reverberation processing===========

### RVB_DoAMod

*void RVB_DoAMod(int count)*

*Defined at line 702 of ./engine/client/s_dsp.cpp*

===========RVB_DoAMod

Do amplification modulation processing===========

### weapon_gauss

*void weapon_gauss(entvars_t * pev)*

*Defined at line 45 of ./game/shared/hl1/weapon_gauss.cpp*

### ammo_gaussclip

*void ammo_gaussclip(entvars_t * pev)*

*Defined at line 632 of ./game/shared/hl1/weapon_gauss.cpp*

### __MsgFunc_TextMsg

*int __MsgFunc_TextMsg(const char * pszName, int iSize, void * pbuf)*

*Defined at line 29 of ./game/client/text_message.cpp*

### StripEndNewlineFromString

*void StripEndNewlineFromString(char * str)*

*Defined at line 130 of ./game/client/text_message.cpp*

### ConvertCRtoNL

*char * ConvertCRtoNL(char * str)*

*Defined at line 139 of ./game/client/text_message.cpp*

 converts all '**<not a builtin command>** ' characters to '**<not a builtin command>** ', so that the engine can deal with the properly returns a pointer to str

### soundent

*void soundent(entvars_t * pev)*

*Defined at line 22 of ./game/server/soundent.cpp*

### path_corner

*void path_corner(entvars_t * pev)*

*Defined at line 41 of ./game/server/pathcorner.cpp*

### path_track

*void path_track(entvars_t * pev)*

*Defined at line 129 of ./game/server/pathcorner.cpp*

### monster_barney

*void monster_barney(entvars_t * pev)*

*Defined at line 91 of ./game/server/npc/npc_barney.cpp*

### IsFacing

*BOOL IsFacing(entvars_t * pevTest, const class Vector & reference)*

*Defined at line 476 of ./game/server/npc/npc_barney.cpp*

### monster_barney_dead

*void monster_barney_dead(entvars_t * pev)*

*Defined at line 802 of ./game/server/npc/npc_barney.cpp*

### GlobalXProf

*class CXProf & GlobalXProf()*

*Defined at line 65 of ./public/xprof.cpp*

### KB_ConvertString

*int KB_ConvertString(char * in, char ** ppout)*

*Defined at line 147 of ./game/client/input.cpp*

============KB_ConvertString

Removes references to +use and replaces them with the keyname in the output string.  If a binding is unfound, then the original text is retained.NOTE:  Only works for text with +word in it.============

### __MsgFunc_ShowMenu

*int __MsgFunc_ShowMenu(const char * pszName, int iSize, void * pbuf)*

*Defined at line 33 of ./game/client/menu.cpp*

### UI_VidOptions_Precache

*void UI_VidOptions_Precache()*

*Defined at line 237 of ./mainui/menus/VideoOptions.cpp*

=================CMenuVidOptions::Precache=================

### info_bigmomma

*void info_bigmomma(entvars_t * pev)*

*Defined at line 55 of ./game/server/npc/npc_bigmomma.cpp*

### bmortar

*void bmortar(entvars_t * pev)*

*Defined at line 118 of ./game/server/npc/npc_bigmomma.cpp*

### VecCheckSplatToss

*Vector VecCheckSplatToss(entvars_t * pev, const class Vector & vecSpot1, Vector vecSpot2, float maxHeight)*

*Defined at line 1026 of ./game/server/npc/npc_bigmomma.cpp*

### MortarSpray

*void MortarSpray(const class Vector & position, const class Vector & direction, int spriteModel, int count)*

*Defined at line 1073 of ./game/server/npc/npc_bigmomma.cpp*

 ---------------------------------

 Mortar

 ---------------------------------

### monster_bigmomma

*void monster_bigmomma(entvars_t * pev)*

*Defined at line 310 of ./game/server/npc/npc_bigmomma.cpp*

### R_ClearScreen

*void R_ClearScreen()*

*Defined at line 22 of ./rendersystem/r_context.cpp*

### R_GetTextureOriginalBuffer

*const byte * R_GetTextureOriginalBuffer(unsigned int idx)*

*Defined at line 28 of ./rendersystem/r_context.cpp*

### CL_FillRGBA

*void CL_FillRGBA(float _x, float _y, float _w, float _h, int r, int g, int b, int a)*

*Defined at line 44 of ./rendersystem/r_context.cpp*

=============CL_FillRGBA

=============

### CL_FillRGBABlend

*void CL_FillRGBABlend(float _x, float _y, float _w, float _h, int r, int g, int b, int a)*

*Defined at line 70 of ./rendersystem/r_context.cpp*

=============pfnFillRGBABlend

=============

### Mod_BrushUnloadTextures

*void Mod_BrushUnloadTextures(model_t * mod)*

*Defined at line 90 of ./rendersystem/r_context.cpp*

### Mod_UnloadTextures

*void Mod_UnloadTextures(model_t * mod)*

*Defined at line 105 of ./rendersystem/r_context.cpp*

### Mod_ProcessRenderData

*qboolean Mod_ProcessRenderData(model_t * mod, qboolean create, const byte * buf)*

*Defined at line 129 of ./rendersystem/r_context.cpp*

### GL_RefGetParm

*int GL_RefGetParm(int parm, int arg)*

*Defined at line 162 of ./rendersystem/r_context.cpp*

### R_GetDetailScaleForTexture

*void R_GetDetailScaleForTexture(int texture, float * xScale, float * yScale)*

*Defined at line 244 of ./rendersystem/r_context.cpp*

### R_GetExtraParmsForTexture

*void R_GetExtraParmsForTexture(int texture, byte * red, byte * green, byte * blue, byte * density)*

*Defined at line 252 of ./rendersystem/r_context.cpp*

### R_SetCurrentEntity

*void R_SetCurrentEntity(cl_entity_t * ent)*

*Defined at line 263 of ./rendersystem/r_context.cpp*

### R_SetCurrentModel

*void R_SetCurrentModel(model_t * mod)*

*Defined at line 274 of ./rendersystem/r_context.cpp*

### R_GetFrameTime

*float R_GetFrameTime()*

*Defined at line 279 of ./rendersystem/r_context.cpp*

### GL_TextureName

*const char * GL_TextureName(unsigned int texnum)*

*Defined at line 284 of ./rendersystem/r_context.cpp*

### GL_TextureData

*const byte * GL_TextureData(unsigned int texnum)*

*Defined at line 289 of ./rendersystem/r_context.cpp*

### R_ProcessEntData

*void R_ProcessEntData(qboolean allocate)*

*Defined at line 298 of ./rendersystem/r_context.cpp*

### R_GetConfigName

*const char * R_GetConfigName()*

*Defined at line 311 of ./rendersystem/r_context.cpp*

### GetRefAPI

*int GetRefAPI(int version, ref_interface_t * funcs, ref_api_t * engfuncs, ref_globals_t * globals)*

*Defined at line 462 of ./rendersystem/r_context.cpp*

### GetRefHumanReadableName

*void GetRefHumanReadableName(char * out, size_t size)*

*Defined at line 475 of ./rendersystem/r_context.cpp*

### PM_HullForBox

*hull_t * PM_HullForBox(const vec3_t mins, const vec3_t maxs)*

*Defined at line 100 of ./engine/common/pm_trace.cpp*

===================PM_HullForBox

To keep everything totally uniform, bounding boxes are turned into smallBSP trees instead of being compared directly.===================

### PM_HullForStudio

*hull_t * PM_HullForStudio(physent_t * pe, playermove_t * pmove, int * numhitboxes)*

*Defined at line 186 of ./engine/common/pm_trace.cpp*

==================PM_HullForStudio

generate multiple hulls as hitboxes==================

### RES_ExpectString

*_Bool RES_ExpectString(char ** data, const char * expect, _Bool skip)*

*Defined at line 525 of ./mainui/controls/ItemsHolder.cpp*

### FreeFile

*_Bool FreeFile(byte * pfile, const _Bool retval)*

*Defined at line 550 of ./mainui/controls/ItemsHolder.cpp*

### aligned_pointer

*void * aligned_pointer(void * base, uint alignment)*

*Defined at line 19 of ./engine/common/soundlib/libmpg/frame.cpp*

### frame_default_parm

*void frame_default_parm(mpg123_parm_t * mp)*

*Defined at line 34 of ./engine/common/soundlib/libmpg/frame.cpp*

### frame_fixed_reset

*void frame_fixed_reset(mpg123_handle_t * fr)*

*Defined at line 58 of ./engine/common/soundlib/libmpg/frame.cpp*

 reset everythign except dynamic memory.

### frame_decode_buffers_reset

*void frame_decode_buffers_reset(mpg123_handle_t * fr)*

*Defined at line 173 of ./engine/common/soundlib/libmpg/frame.cpp*

### frame_free_toc

*void frame_free_toc(mpg123_handle_t * fr)*

*Defined at line 323 of ./engine/common/soundlib/libmpg/frame.cpp*

### frame_free_buffers

*void frame_free_buffers(mpg123_handle_t * fr)*

*Defined at line 359 of ./engine/common/soundlib/libmpg/frame.cpp*

### mpg123_framedata

*int mpg123_framedata(mpg123_handle_t * mh, ulong * header, byte ** bodydata, size_t * bodybytes)*

*Defined at line 395 of ./engine/common/soundlib/libmpg/frame.cpp*

### frame_fuzzy_find

*mpg_off_t frame_fuzzy_find(mpg123_handle_t * fr, mpg_off_t want_frame, mpg_off_t * get_frame)*

*Defined at line 420 of ./engine/common/soundlib/libmpg/frame.cpp*

 Fuzzy frame offset searching (guessing). When we don't have an accurate position, we may use an inaccurate one. Possibilities:	- use approximate positions from Xing TOC (not yet parsed)	- guess wildly from mean framesize and offset of first frame / beginning of file.

### frame_ins2outs

*mpg_off_t frame_ins2outs(mpg123_handle_t * fr, mpg_off_t ins)*

*Defined at line 514 of ./engine/common/soundlib/libmpg/frame.cpp*

### ignoreframe

*mpg_off_t ignoreframe(mpg123_handle_t * fr)*

*Defined at line 623 of ./engine/common/soundlib/libmpg/frame.cpp*

 compute the needed frame to ignore from, for getting accurate/consistent output for intended firstframe.

### get_rva

*int get_rva(mpg123_handle_t * fr, double * peak, double * gain)*

*Defined at line 697 of ./engine/common/soundlib/libmpg/frame.cpp*

### VID_RestoreScreenResolution

*void VID_RestoreScreenResolution()*

*Defined at line 492 of ./engine/platform/sdl/vid_sdl.cpp*

 window management

### VID_CreateWindow

*qboolean VID_CreateWindow(int width, int height, qboolean fullscreen)*

*Defined at line 527 of ./engine/platform/sdl/vid_sdl.cpp*

=================VID_CreateWindow=================

### VID_DestroyWindow

*void VID_DestroyWindow()*

*Defined at line 691 of ./engine/platform/sdl/vid_sdl.cpp*

=================VID_DestroyWindow=================

### GL_CreateContext

*qboolean GL_CreateContext()*

*Defined at line 425 of ./engine/platform/sdl/vid_sdl.cpp*

=================GL_CreateContext=================

### GL_UpdateContext

*qboolean GL_UpdateContext()*

*Defined at line 441 of ./engine/platform/sdl/vid_sdl.cpp*

=================GL_UpdateContext=================

### GL_DeleteContext

*qboolean GL_DeleteContext()*

*Defined at line 409 of ./engine/platform/sdl/vid_sdl.cpp*

=================GL_DeleteContext

always return false=================

### GL_SetupAttributes

*void GL_SetupAttributes()*

*Defined at line 713 of ./engine/platform/sdl/vid_sdl.cpp*

==================GL_SetupAttributes==================

### R_InitVideoModes

*void R_InitVideoModes()*

*Defined at line 237 of ./engine/platform/sdl/vid_sdl.cpp*

### R_FreeVideoModes

*void R_FreeVideoModes()*

*Defined at line 285 of ./engine/platform/sdl/vid_sdl.cpp*

### VID_SetScreenResolution

*qboolean VID_SetScreenResolution(int width, int height)*

*Defined at line 452 of ./engine/platform/sdl/vid_sdl.cpp*

### monster_zombie

*void monster_zombie(entvars_t * pev)*

*Defined at line 66 of ./game/server/npc/npc_zombie.cpp*

### VID_WriteOverviewScript

*void VID_WriteOverviewScript()*

*Defined at line 236 of ./engine/client/cl_scrn.cpp*

===============VID_WriteOverviewScript

Create overview script file===============

### SCR_DrawPlaque

*void SCR_DrawPlaque()*

*Defined at line 326 of ./engine/client/cl_scrn.cpp*

================SCR_DrawPlaque================

### SCR_LoadFixedWidthFont

*qboolean SCR_LoadFixedWidthFont(const char * fontname)*

*Defined at line 525 of ./engine/client/cl_scrn.cpp*

### SCR_LoadVariableWidthFont

*qboolean SCR_LoadVariableWidthFont(const char * fontname)*

*Defined at line 554 of ./engine/client/cl_scrn.cpp*

### SCR_SizeUp_f

*void SCR_SizeUp_f()*

*Defined at line 703 of ./engine/client/cl_scrn.cpp*

=================SCR_SizeUp_f

Keybinding command=================

### SCR_SizeDown_f

*void SCR_SizeDown_f()*

*Defined at line 716 of ./engine/client/cl_scrn.cpp*

=================SCR_SizeDown_f

Keybinding command=================

### pfnEngineGetParm

*int pfnEngineGetParm(int parm, int arg)*

*Defined at line 55 of ./engine/client/ref_common.cpp*

### pfnGetWorld

*world_static_t * pfnGetWorld()*

*Defined at line 60 of ./engine/client/ref_common.cpp*

### pfnStudioEvent

*void pfnStudioEvent(const mstudioevent_t * event, const cl_entity_t * e)*

*Defined at line 65 of ./engine/client/ref_common.cpp*

### pfnGetEfragsFreeList

*efrag_t * pfnGetEfragsFreeList()*

*Defined at line 70 of ./engine/client/ref_common.cpp*

### pfnSetEfragsFreeList

*void pfnSetEfragsFreeList(efrag_t * list)*

*Defined at line 75 of ./engine/client/ref_common.cpp*

### pfnGetDefaultSprite

*model_t * pfnGetDefaultSprite(enum ref_defaultsprite_e spr)*

*Defined at line 80 of ./engine/client/ref_common.cpp*

### pfnMod_Extradata

*void * pfnMod_Extradata(int type, model_t * m)*

*Defined at line 91 of ./engine/client/ref_common.cpp*

### pfnMod_GetCurrentLoadingModel

*model_t * pfnMod_GetCurrentLoadingModel()*

*Defined at line 105 of ./engine/client/ref_common.cpp*

### pfnMod_SetCurrentLoadingModel

*void pfnMod_SetCurrentLoadingModel(model_t * m)*

*Defined at line 110 of ./engine/client/ref_common.cpp*

### pfnGetPredictedOrigin

*void pfnGetPredictedOrigin(vec3_t v)*

*Defined at line 115 of ./engine/client/ref_common.cpp*

### pfnCL_GetPaletteColor

*color24 * pfnCL_GetPaletteColor(int color)*

*Defined at line 120 of ./engine/client/ref_common.cpp*

### pfnCL_GetScreenInfo

*void pfnCL_GetScreenInfo(int * width, int * height)*

*Defined at line 125 of ./engine/client/ref_common.cpp*

### pfnSetLocalLightLevel

*void pfnSetLocalLightLevel(int level)*

*Defined at line 131 of ./engine/client/ref_common.cpp*

### pfnPlayerInfo

*player_info_t * pfnPlayerInfo(int index)*

*Defined at line 142 of ./engine/client/ref_common.cpp*

===============pfnPlayerInfo

===============

### R_StudioGetPlayerState

*entity_state_t * R_StudioGetPlayerState(int index)*

*Defined at line 159 of ./engine/client/ref_common.cpp*

===============pfnGetPlayerState

===============

### pfnGetStudioModelInterface

*int pfnGetStudioModelInterface(int version, struct r_studio_interface_s ** ppinterface, struct engine_studio_api_s * pstudio)*

*Defined at line 167 of ./engine/client/ref_common.cpp*

### pfnImage_GetPool

*byte * pfnImage_GetPool()*

*Defined at line 174 of ./engine/client/ref_common.cpp*

### pfnImage_GetPFDesc

*const bpc_desc_t * pfnImage_GetPFDesc(int idx)*

*Defined at line 179 of ./engine/client/ref_common.cpp*

### pfnDrawNormalTriangles

*void pfnDrawNormalTriangles()*

*Defined at line 184 of ./engine/client/ref_common.cpp*

### pfnDrawTransparentTriangles

*void pfnDrawTransparentTriangles()*

*Defined at line 189 of ./engine/client/ref_common.cpp*

### pfnRefGetScreenFade

*screenfade_t * pfnRefGetScreenFade()*

*Defined at line 194 of ./engine/client/ref_common.cpp*

### R_DoResetGamma

*qboolean R_DoResetGamma()*

*Defined at line 206 of ./engine/client/ref_common.cpp*

===============R_DoResetGammagamma will be reset forsome type of screenshots===============

### R_Init_Video_

*qboolean R_Init_Video_(const int type)*

*Defined at line 218 of ./engine/client/ref_common.cpp*

### R_UnloadProgs

*void R_UnloadProgs()*

*Defined at line 383 of ./engine/client/ref_common.cpp*

### CL_FillTriAPIFromRef

*void CL_FillTriAPIFromRef(triangleapi_t * dst, const ref_interface_t * src)*

*Defined at line 402 of ./engine/client/ref_common.cpp*

### R_LoadProgs

*qboolean R_LoadProgs(const char * name)*

*Defined at line 426 of ./engine/client/ref_common.cpp*

### R_GetRendererName

*void R_GetRendererName(char * dest, size_t size, const char * opt)*

*Defined at line 501 of ./engine/client/ref_common.cpp*

### R_LoadRenderer

*qboolean R_LoadRenderer(const char * refopt)*

*Defined at line 522 of ./engine/client/ref_common.cpp*

### SetWidthAndHeightFromCommandLine

*void SetWidthAndHeightFromCommandLine()*

*Defined at line 540 of ./engine/client/ref_common.cpp*

### SetFullscreenModeFromCommandLine

*void SetFullscreenModeFromCommandLine()*

*Defined at line 556 of ./engine/client/ref_common.cpp*

### R_CollectRendererNames

*void R_CollectRendererNames()*

*Defined at line 570 of ./engine/client/ref_common.cpp*

### SetColor

*void SetColor(FILE * fs, unsigned char r, unsigned char g, unsigned char b)*

*Defined at line 140 of ./engine/common/logsystem/logsystem.cpp*

### GetChan

*log_channel_t GetChan(LoggingChannel_t chan)*

*Defined at line 148 of ./engine/common/logsystem/logsystem.cpp*

### Master_Shutdown

*void Master_Shutdown()*

*Defined at line 714 of ./engine/server/sv_main.cpp*

=================Master_Shutdown

Informs all masters that this server is going down=================

### SV_HasActivePlayers

*qboolean SV_HasActivePlayers()*

*Defined at line 136 of ./engine/server/sv_main.cpp*

============================================================================

================SV_HasActivePlayers

returns true if server have spawned players================

### SV_CheckCmdTimes

*void SV_CheckCmdTimes()*

*Defined at line 224 of ./engine/server/sv_main.cpp*

=================SV_CheckCmdTimes=================

### SV_ReadPackets

*void SV_ReadPackets()*

*Defined at line 350 of ./engine/server/sv_main.cpp*

=================SV_ReadPackets=================

### SV_CheckTimeouts

*void SV_CheckTimeouts()*

*Defined at line 468 of ./engine/server/sv_main.cpp*

==================SV_CheckTimeouts

If a packet has not been received from a client for timeout->valueseconds, drop the conneciton.  Server frames are used instead ofrealtime to avoid dropping the local client while debugging.

When a client is normally dropped, the sv_client_t goes into a zombie statefor a few seconds to make sure any final reliable message gets resentif necessary==================

### SV_RunGameFrame

*qboolean SV_RunGameFrame()*

*Defined at line 573 of ./engine/server/sv_main.cpp*

=================SV_RunGameFrame=================

### monster_human_assassin

*void monster_human_assassin(entvars_t * pev)*

*Defined at line 107 of ./game/server/npc/npc_hassassin.cpp*

### list_add__

*void list_add__(hullnode_t * _new, hullnode_t * prev, hullnode_t * next)*

*Defined at line 42 of ./engine/client/mod_dbghulls.cpp*

### list_add

*void list_add(hullnode_t * newobj, hullnode_t * head)*

*Defined at line 51 of ./engine/client/mod_dbghulls.cpp*

 add the new entry after the give list entry

### list_add_tail

*void list_add_tail(hullnode_t * newobj, hullnode_t * head)*

*Defined at line 57 of ./engine/client/mod_dbghulls.cpp*

 add the new entry before the given list entry (list is circular)

### list_del

*void list_del(hullnode_t * entry)*

*Defined at line 62 of ./engine/client/mod_dbghulls.cpp*

### winding_alloc

*winding_t * winding_alloc(uint numpoints)*

*Defined at line 68 of ./engine/client/mod_dbghulls.cpp*

### free_winding

*void free_winding(winding_t * w)*

*Defined at line 73 of ./engine/client/mod_dbghulls.cpp*

### winding_copy

*winding_t * winding_copy(winding_t * w)*

*Defined at line 82 of ./engine/client/mod_dbghulls.cpp*

### winding_reverse

*void winding_reverse(winding_t * w)*

*Defined at line 92 of ./engine/client/mod_dbghulls.cpp*

### winding_shrink

*winding_t * winding_shrink(winding_t * w)*

*Defined at line 111 of ./engine/client/mod_dbghulls.cpp*

 winding_shrink

 Takes an over-allocated winding and allocates a new winding with just the required number of points. The input winding is freed.

### winding_for_plane

*winding_t * winding_for_plane(const mplane_t * p)*

*Defined at line 125 of ./engine/client/mod_dbghulls.cpp*

====================winding_for_plane====================

### CalcSides

*void CalcSides(const winding_t * in, const mplane_t * split, int * sides, vec_t * dists, int [3] counts, vec_t epsilon)*

*Defined at line 193 of ./engine/client/mod_dbghulls.cpp*

 =========================== Helper for for the clipping functions  (winding_clip, winding_split) ===========================

### PushToPlaneAxis

*void PushToPlaneAxis(vec_t * v, const mplane_t * p)*

*Defined at line 240 of ./engine/client/mod_dbghulls.cpp*

### winding_clip

*winding_t * winding_clip(winding_t * in, const mplane_t * split, qboolean keepon, int side, vec_t epsilon)*

*Defined at line 257 of ./engine/client/mod_dbghulls.cpp*

==================winding_clip

Clips the winding to the plane, returning the new winding on 'side'.Frees the input winding.If keepon is true, an exactly on-plane winding will be saved, otherwise  it will be clipped away.==================

### winding_split

*void winding_split(winding_t * in, const mplane_t * split, winding_t ** pfront, winding_t ** pback)*

*Defined at line 361 of ./engine/client/mod_dbghulls.cpp*

==================winding_split

Splits a winding by a plane, producing one or two windings.  Theoriginal winding is not damaged or freed.  If only on one side, thereturned winding will be the input winding.  If on both sides, twonew windings will be created.==================

### push_node

*void push_node(mclipnode_t * node, int side)*

*Defined at line 475 of ./engine/client/mod_dbghulls.cpp*

### pop_node

*void pop_node()*

*Defined at line 485 of ./engine/client/mod_dbghulls.cpp*

### free_hull_polys

*void free_hull_polys(hullnode_t * hull_polys)*

*Defined at line 492 of ./engine/client/mod_dbghulls.cpp*

### hull_windings_r

*void hull_windings_r(hull_t * hull, mclipnode_t * node, hullnode_t * polys, hull_model_t * model)*

*Defined at line 549 of ./engine/client/mod_dbghulls.cpp*

### do_hull_recursion

*void do_hull_recursion(hull_t * hull, mclipnode_t * node, int side, hullnode_t * polys, hull_model_t * model)*

*Defined at line 505 of ./engine/client/mod_dbghulls.cpp*

### remove_paired_polys

*void remove_paired_polys(hull_model_t * model)*

*Defined at line 630 of ./engine/client/mod_dbghulls.cpp*

### make_hull_windings

*void make_hull_windings(hull_t * hull, hull_model_t * model)*

*Defined at line 645 of ./engine/client/mod_dbghulls.cpp*

### GL_DebugOutput

*void GL_DebugOutput(GLuint source, GLuint type, GLuint id, GLuint severity, GLint length, const GLcharARB * message, GLvoid * userParam)*

*Defined at line 257 of ./ref_gl/gl_opengl.cpp*

========================DebugCallback

For ARB_debug_output========================

### GL_GetProcAddress

*void * GL_GetProcAddress(const char * name)*

*Defined at line 387 of ./ref_gl/gl_opengl.cpp*

==============GL_GetProcAddress

defined just for nanogl/glwes, so it don't link to SDL2 directly, nor use dlsym==============

### GL_SetDefaultTexState

*void GL_SetDefaultTexState()*

*Defined at line 397 of ./ref_gl/gl_opengl.cpp*

===============GL_SetDefaultTexState===============

### GL_SetDefaultState

*void GL_SetDefaultState()*

*Defined at line 418 of ./ref_gl/gl_opengl.cpp*

===============GL_SetDefaultState===============

### GL_SetDefaults

*void GL_SetDefaults()*

*Defined at line 433 of ./ref_gl/gl_opengl.cpp*

===============GL_SetDefaults===============

### R_RenderInfo_f

*void R_RenderInfo_f()*

*Defined at line 478 of ./ref_gl/gl_opengl.cpp*

=================R_RenderInfo_f=================

### GL_InitExtensionsBigGL

*void GL_InitExtensionsBigGL()*

*Defined at line 588 of ./ref_gl/gl_opengl.cpp*

### GL_InitCommands

*void GL_InitCommands()*

*Defined at line 773 of ./ref_gl/gl_opengl.cpp*

=================GL_InitCommands=================

### R_CheckVBO

*void R_CheckVBO()*

*Defined at line 839 of ./ref_gl/gl_opengl.cpp*

===============R_CheckVBO

register VBO cvars and get default value===============

### GL_RemoveCommands

*void GL_RemoveCommands()*

*Defined at line 881 of ./ref_gl/gl_opengl.cpp*

=================GL_RemoveCommands=================

### nanoGL_Init

*int nanoGL_Init()*

### wes_init

*void wes_init(const char * gles2)*

### DrawRoute

*void DrawRoute(entvars_t * pev, struct WayPoint_t * m_Route, int m_iRouteIndex, int r, int g, int b)*

*Defined at line 727 of ./game/server/ai/ai_monsters.cpp*

### pfnDrawCharacter

*int pfnDrawCharacter(int x, int y, int number, int r, int g, int b)*

### IN_TouchCheckCoords

*void IN_TouchCheckCoords(float * x1, float * y1, float * x2, float * y2)*

*Defined at line 1067 of ./engine/client/in_touch.cpp*

### IN_TouchEditClear

*void IN_TouchEditClear()*

*Defined at line 1353 of ./engine/client/in_touch.cpp*

 clear move and selection state

### Touch_InitConfig

*void Touch_InitConfig()*

*Defined at line 992 of ./engine/client/in_touch.cpp*

int pfnGetScreenInfo( SCREENINFO *pscrinfo );

### Touch_ExportConfig_f

*void Touch_ExportConfig_f()*

*Defined at line 261 of ./engine/client/in_touch.cpp*

### Touch_GenetateCode_f

*void Touch_GenetateCode_f()*

*Defined at line 356 of ./engine/client/in_touch.cpp*

### Touch_RoundAll_f

*void Touch_RoundAll_f()*

*Defined at line 392 of ./engine/client/in_touch.cpp*

### Touch_ListButtons_f

*void Touch_ListButtons_f()*

*Defined at line 401 of ./engine/client/in_touch.cpp*

### Touch_Stroke_f

*void Touch_Stroke_f()*

*Defined at line 419 of ./engine/client/in_touch.cpp*

### Touch_FindButton

*touch_button_t * Touch_FindButton(touchbuttonlist_t * list, const char * name)*

*Defined at line 425 of ./engine/client/in_touch.cpp*

### Touch_FindFirst

*touch_button_t * Touch_FindFirst(touchbuttonlist_t * list, const char * name)*

*Defined at line 435 of ./engine/client/in_touch.cpp*

### Touch_SetClientOnly_f

*void Touch_SetClientOnly_f()*

*Defined at line 469 of ./engine/client/in_touch.cpp*

### Touch_RemoveButtonFromList

*void Touch_RemoveButtonFromList(touchbuttonlist_t * list, const char * name)*

*Defined at line 474 of ./engine/client/in_touch.cpp*

### IN_TouchRemoveButton_f

*void IN_TouchRemoveButton_f()*

*Defined at line 500 of ./engine/client/in_touch.cpp*

### Touch_ClearList

*void Touch_ClearList(touchbuttonlist_t * list)*

*Defined at line 505 of ./engine/client/in_touch.cpp*

### Touch_RemoveAll_f

*void Touch_RemoveAll_f()*

*Defined at line 516 of ./engine/client/in_touch.cpp*

### Touch_SetColor

*void Touch_SetColor(touchbuttonlist_t * list, const char * name, byte * color)*

*Defined at line 522 of ./engine/client/in_touch.cpp*

### Touch_SetTexture

*void Touch_SetTexture(touchbuttonlist_t * list, const char * name, const char * texture)*

*Defined at line 532 of ./engine/client/in_touch.cpp*

### Touch_SetCommand

*void Touch_SetCommand(touchbuttonlist_t * list, const char * name, const char * command)*

*Defined at line 541 of ./engine/client/in_touch.cpp*

### Touch_ToggleSelection_f

*void Touch_ToggleSelection_f()*

*Defined at line 577 of ./engine/client/in_touch.cpp*

### Touch_Hide_f

*void Touch_Hide_f()*

*Defined at line 583 of ./engine/client/in_touch.cpp*

### Touch_Show_f

*void Touch_Show_f()*

*Defined at line 588 of ./engine/client/in_touch.cpp*

### Touch_FadeButtons

*void Touch_FadeButtons(touchbuttonlist_t * list, const char * name, float speed, float end, float start)*

*Defined at line 593 of ./engine/client/in_touch.cpp*

### Touch_Fade_f

*void Touch_Fade_f()*

*Defined at line 607 of ./engine/client/in_touch.cpp*

### Touch_SetColor_f

*void Touch_SetColor_f()*

*Defined at line 617 of ./engine/client/in_touch.cpp*

### Touch_SetTexture_f

*void Touch_SetTexture_f()*

*Defined at line 629 of ./engine/client/in_touch.cpp*

### Touch_SetFlags_f

*void Touch_SetFlags_f()*

*Defined at line 639 of ./engine/client/in_touch.cpp*

### Touch_SetCommand_f

*void Touch_SetCommand_f()*

*Defined at line 651 of ./engine/client/in_touch.cpp*

### Touch_ReloadConfig_f

*void Touch_ReloadConfig_f()*

*Defined at line 660 of ./engine/client/in_touch.cpp*

### Touch_AddButton

*touch_button_t * Touch_AddButton(touchbuttonlist_t * list, const char * name, const char * texture, const char * command, float x1, float y1, float x2, float y2, byte * color)*

*Defined at line 673 of ./engine/client/in_touch.cpp*

### Touch_LoadDefaults_f

*void Touch_LoadDefaults_f()*

*Defined at line 730 of ./engine/client/in_touch.cpp*

### Touch_AddButton_f

*void Touch_AddButton_f()*

*Defined at line 783 of ./engine/client/in_touch.cpp*

### Touch_EnableEdit_f

*void Touch_EnableEdit_f()*

*Defined at line 832 of ./engine/client/in_touch.cpp*

### Touch_DisableEdit_f

*void Touch_DisableEdit_f()*

*Defined at line 841 of ./engine/client/in_touch.cpp*

### Touch_DeleteProfile_f

*void Touch_DeleteProfile_f()*

*Defined at line 859 of ./engine/client/in_touch.cpp*

### Touch_InitEditor

*void Touch_InitEditor()*

*Defined at line 871 of ./engine/client/in_touch.cpp*

### Touch_IsVisible

*qboolean Touch_IsVisible(touch_button_t * button)*

*Defined at line 1015 of ./engine/client/in_touch.cpp*

### Touch_DrawTexture

*void Touch_DrawTexture(float x1, float y1, float x2, float y2, int texture, byte r, byte g, byte b, byte a)*

*Defined at line 1044 of ./engine/client/in_touch.cpp*

### Touch_DrawCharacter

*float Touch_DrawCharacter(float x, float y, int number, float size)*

*Defined at line 1091 of ./engine/client/in_touch.cpp*

### Touch_DrawText

*float Touch_DrawText(float x1, float y1, float x2, float y2, const char * s, byte * color, float size)*

*Defined at line 1118 of ./engine/client/in_touch.cpp*

### Touch_DrawButtons

*void Touch_DrawButtons(touchbuttonlist_t * list)*

*Defined at line 1155 of ./engine/client/in_touch.cpp*

### Touch_EditMove

*void Touch_EditMove(touchEventType type, int fingerID, float x, float y, float dx, float dy)*

*Defined at line 1371 of ./engine/client/in_touch.cpp*

### Touch_Motion

*void Touch_Motion(touchEventType type, int fingerID, float x, float y, float dx, float dy)*

*Defined at line 1429 of ./engine/client/in_touch.cpp*

### Touch_ButtonPress

*qboolean Touch_ButtonPress(touchbuttonlist_t * list, touchEventType type, int fingerID, float x, float y, float dx, float dy)*

*Defined at line 1502 of ./engine/client/in_touch.cpp*

### Touch_ButtonEdit

*qboolean Touch_ButtonEdit(touchEventType type, int fingerID, float x, float y, float dx, float dy)*

*Defined at line 1682 of ./engine/client/in_touch.cpp*

### Touch_ControlsEvent

*int Touch_ControlsEvent(touchEventType type, int fingerID, float x, float y, float dx, float dy)*

*Defined at line 1750 of ./engine/client/in_touch.cpp*

### Mod_AddToStudioCache

*void Mod_AddToStudioCache(float frame, int sequence, vec3_t angles, vec3_t origin, vec3_t size, byte * pcontroller, byte * pblending, model_t * model, hull_t * hull, int numhitboxes)*

*Defined at line 119 of ./engine/common/mod_studio.cpp*

====================AddToStudioCache====================

### Mod_CheckStudioCache

*mstudiocache_t * Mod_CheckStudioCache(model_t * model, float frame, int sequence, vec3_t angles, vec3_t origin, vec3_t size, byte * controller, byte * blending)*

*Defined at line 156 of ./engine/common/mod_studio.cpp*

====================CheckStudioCache====================

### Mod_SetStudioHullPlane

*void Mod_SetStudioHullPlane(int planenum, int bone, int axis, float offset, const vec3_t size)*

*Defined at line 207 of ./engine/common/mod_studio.cpp*

===============================================================================

	STUDIO MODELS TRACING

===============================================================================

====================SetStudioHullPlane====================

### Mod_StudioCalcBoneAdj

*void Mod_StudioCalcBoneAdj(float * adj, const byte * pcontroller)*

*Defined at line 308 of ./engine/common/mod_studio.cpp*

===============================================================================

	STUDIO MODELS SETUP BONES

===============================================================================

====================StudioCalcBoneAdj

====================

### Mod_StudioCalcRotations

*void Mod_StudioCalcRotations(int [] boneused, int numbones, const byte * pcontroller, float [][3] pos, vec4_t * q, mstudioseqdesc_t * pseqdesc, mstudioanim_t * panim, float f)*

*Defined at line 360 of ./engine/common/mod_studio.cpp*

====================StudioCalcRotations

====================

### SV_StudioSetupBones

*void SV_StudioSetupBones(model_t * pModel, float frame, int sequence, const vec3_t angles, const vec3_t origin, const byte * pcontroller, const byte * pblending, int iBone, const edict_t * pEdict)*

*Defined at line 648 of ./engine/common/mod_studio.cpp*

====================StudioSetupBones

NOTE: pEdict is unused====================

### Mod_StudioBoundVertex

*void Mod_StudioBoundVertex(vec3_t mins, vec3_t maxs, int * numverts, const vec3_t vertex)*

*Defined at line 826 of ./engine/common/mod_studio.cpp*

====================StudioBoundVertex====================

### Mod_StudioAccumulateBoneVerts

*void Mod_StudioAccumulateBoneVerts(vec3_t mins, vec3_t maxs, int * numverts, vec3_t bone_mins, vec3_t bone_maxs, int * numbones)*

*Defined at line 840 of ./engine/common/mod_studio.cpp*

====================StudioAccumulateBoneVerts====================

### Mod_StudioBodyVariations

*int Mod_StudioBodyVariations(model_t * mod)*

*Defined at line 988 of ./engine/common/mod_studio.cpp*

================Mod_StudioBodyVariations

calc studio body variations================

### R_StudioLoadHeader

*studiohdr_t * R_StudioLoadHeader(model_t * mod, const void * buffer)*

*Defined at line 1012 of ./engine/common/mod_studio.cpp*

=================R_StudioLoadHeader=================

### monster_tentacle

*void monster_tentacle(entvars_t * pev)*

*Defined at line 113 of ./game/server/npc/npc_tentacle.cpp*

### monster_tentaclemaw

*void monster_tentaclemaw(entvars_t * pev)*

*Defined at line 997 of ./game/server/npc/npc_tentacle.cpp*

### SV_CopyEdictToPhysEnt

*qboolean SV_CopyEdictToPhysEnt(physent_t * pe, edict_t * ed)*

*Defined at line 62 of ./engine/server/sv_pmove.cpp*

### SV_ShouldUnlagForPlayer

*qboolean SV_ShouldUnlagForPlayer(sv_client_t * cl)*

*Defined at line 156 of ./engine/server/sv_pmove.cpp*

### SV_AddLinksToPmove

*void SV_AddLinksToPmove(areanode_t * node, const vec3_t pmove_mins, const vec3_t pmove_maxs)*

*Defined at line 210 of ./engine/server/sv_pmove.cpp*

====================SV_AddLinksToPmove

collect solid entities====================

### SV_AddLaddersToPmove

*void SV_AddLaddersToPmove(areanode_t * node, const vec3_t pmove_mins, const vec3_t pmove_maxs)*

*Defined at line 302 of ./engine/server/sv_pmove.cpp*

====================SV_AddLaddersToPmove====================

### pfnParticle

*void pfnParticle(const float * origin, int color, float life, int zpos, int zvel)*

*Defined at line 344 of ./engine/server/sv_pmove.cpp*

### SV_TestLine

*int SV_TestLine(const vec3_t start, const vec3_t end, int flags)*

*Defined at line 365 of ./engine/server/sv_pmove.cpp*

### pfnTestPlayerPosition

*int pfnTestPlayerPosition(float * pos, pmtrace_t * ptrace)*

*Defined at line 370 of ./engine/server/sv_pmove.cpp*

### pfnStuckTouch

*void pfnStuckTouch(int hitent, pmtrace_t * tr)*

*Defined at line 375 of ./engine/server/sv_pmove.cpp*

### pfnPointContents

*int pfnPointContents(float * p, int * truecontents)*

*Defined at line 394 of ./engine/server/sv_pmove.cpp*

### pfnTruePointContents

*int pfnTruePointContents(float * p)*

*Defined at line 406 of ./engine/server/sv_pmove.cpp*

### pfnHullPointContents

*int pfnHullPointContents(struct hull_s * hull, int num, float * p)*

*Defined at line 411 of ./engine/server/sv_pmove.cpp*

### pfnPlayerTrace

*pmtrace_s pfnPlayerTrace(float * start, float * end, int traceFlags, int ignore_pe)*

*Defined at line 416 of ./engine/server/sv_pmove.cpp*

### pfnTraceLine

*pmtrace_t * pfnTraceLine(float * start, float * end, int flags, int usehull, int ignore_pe)*

*Defined at line 421 of ./engine/server/sv_pmove.cpp*

### pfnHullForBsp

*hull_t * pfnHullForBsp(physent_t * pe, float * offset)*

*Defined at line 444 of ./engine/server/sv_pmove.cpp*

### pfnTraceModel

*float pfnTraceModel(physent_t * pe, float * start, float * end, trace_t * trace)*

*Defined at line 449 of ./engine/server/sv_pmove.cpp*

### pfnTraceTexture

*const char * pfnTraceTexture(int ground, float * vstart, float * vend)*

*Defined at line 495 of ./engine/server/sv_pmove.cpp*

### pfnPlaySound

*void pfnPlaySound(int channel, const char * sample, float volume, float attenuation, int fFlags, int pitch)*

*Defined at line 506 of ./engine/server/sv_pmove.cpp*

### pfnPlaybackEventFull

*void pfnPlaybackEventFull(int flags, int clientindex, word eventindex, float delay, float * origin, float * angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2)*

*Defined at line 516 of ./engine/server/sv_pmove.cpp*

### pfnPlayerTraceEx

*pmtrace_s pfnPlayerTraceEx(float * start, float * end, int traceFlags, pfnIgnore pmFilter)*

*Defined at line 534 of ./engine/server/sv_pmove.cpp*

### pfnTestPlayerPositionEx

*int pfnTestPlayerPositionEx(float * pos, pmtrace_t * ptrace, pfnIgnore pmFilter)*

*Defined at line 539 of ./engine/server/sv_pmove.cpp*

### pfnTraceLineEx

*pmtrace_t * pfnTraceLineEx(float * start, float * end, int flags, int usehull, pfnIgnore pmFilter)*

*Defined at line 544 of ./engine/server/sv_pmove.cpp*

### pfnTraceSurface

*struct msurface_s * pfnTraceSurface(int ground, float * vstart, float * vend)*

*Defined at line 567 of ./engine/server/sv_pmove.cpp*

### PM_CheckMovingGround

*void PM_CheckMovingGround(edict_t * ent, float frametime)*

*Defined at line 642 of ./engine/server/sv_pmove.cpp*

### SV_SetupPMove

*void SV_SetupPMove(playermove_t * pmove, sv_client_t * cl, usercmd_t * ucmd, const char * physinfo)*

*Defined at line 663 of ./engine/server/sv_pmove.cpp*

### SV_FinishPMove

*void SV_FinishPMove(playermove_t * pmove, sv_client_t * cl)*

*Defined at line 743 of ./engine/server/sv_pmove.cpp*

### SV_FindEntInPack

*entity_state_t * SV_FindEntInPack(int index, client_frame_t * frame)*

*Defined at line 810 of ./engine/server/sv_pmove.cpp*

### SV_UnlagCheckTeleport

*qboolean SV_UnlagCheckTeleport(vec3_t old_pos, vec3_t new_pos)*

*Defined at line 825 of ./engine/server/sv_pmove.cpp*

### SV_SetupMoveInterpolant

*void SV_SetupMoveInterpolant(sv_client_t * cl)*

*Defined at line 837 of ./engine/server/sv_pmove.cpp*

### SV_RestoreMoveInterpolant

*void SV_RestoreMoveInterpolant(sv_client_t * cl)*

*Defined at line 987 of ./engine/server/sv_pmove.cpp*

### env_global

*void env_global(entvars_t * pev)*

*Defined at line 54 of ./game/server/func_button.cpp*

### func_button

*void func_button(entvars_t * pev)*

*Defined at line 317 of ./game/server/func_button.cpp*

### DoSpark

*void DoSpark(entvars_t * pev, const class Vector & location)*

*Defined at line 465 of ./game/server/func_button.cpp*

 Makes flagged buttons spark when turned off

### func_rot_button

*void func_rot_button(entvars_t * pev)*

*Defined at line 725 of ./game/server/func_button.cpp*

### momentary_rot_button

*void momentary_rot_button(entvars_t * pev)*

*Defined at line 838 of ./game/server/func_button.cpp*

### env_spark

*void env_spark(entvars_t * pev)*

*Defined at line 1060 of ./game/server/func_button.cpp*

### env_debris

*void env_debris(entvars_t * pev)*

*Defined at line 1061 of ./game/server/func_button.cpp*

### button_target

*void button_target(entvars_t * pev)*

*Defined at line 1148 of ./game/server/func_button.cpp*

### CAM_Init

*void CAM_Init()*

*Defined at line 495 of ./game/client/in_camera.cpp*

### CAM_ClearStates

*void CAM_ClearStates()*

*Defined at line 532 of ./game/client/in_camera.cpp*

### CAM_StartMouseMove

*void CAM_StartMouseMove()*

*Defined at line 561 of ./game/client/in_camera.cpp*

### CAM_EndMouseMove

*void CAM_EndMouseMove()*

*Defined at line 598 of ./game/client/in_camera.cpp*

the key has been released for camera movementtell the engine that mouse camera movement is off

### CL_KeyState

*float CL_KeyState(kbutton_t * key)*

*Defined at line 673 of ./game/client/input.cpp*

===============CL_KeyState

Returns 0.25 if a key was pressed and released during the frame,0.5 if it was pressed and held0 if held then released, and1.0 if held for the entire time===============

### CAM_Think

*void CAM_Think()*

*Defined at line 143 of ./game/client/in_camera.cpp*

 From in_camera.cpp 

### CL_IsThirdPerson

*int CL_IsThirdPerson()*

*Defined at line 643 of ./game/client/in_camera.cpp*

### CL_CameraOffset

*void CL_CameraOffset(float * ofs)*

*Defined at line 648 of ./game/client/in_camera.cpp*

### CAM_ToThirdPerson

*void CAM_ToThirdPerson()*

*Defined at line 459 of ./game/client/in_camera.cpp*

-------------------------------------------------- Prototypes

### CAM_StartDistance

*void CAM_StartDistance()*

*Defined at line 608 of ./game/client/in_camera.cpp*

----------------------------------------------------------routines to start the process of moving the cam in or out using the mouse----------------------------------------------------------

### CAM_EndDistance

*void CAM_EndDistance()*

*Defined at line 636 of ./game/client/in_camera.cpp*

the key has been released for camera movementtell the engine that mouse camera movement is off

### MoveToward

*float MoveToward(float cur, float goal, float maxspeed)*

*Defined at line 90 of ./game/client/in_camera.cpp*

-------------------------------------------------- Local Functions

### SV_ClipMoveToEntity

* SV_ClipMoveToEntity(edict_t * ent, Vector start, Vector mins, Vector maxs, Vector end)*

### KeyDown

*void KeyDown(kbutton_t * b)*

*Defined at line 305 of ./game/client/input.cpp*

============KeyDown============

### KeyUp

*void KeyUp(kbutton_t * b)*

*Defined at line 339 of ./game/client/input.cpp*

============KeyUp============

### CAM_PitchUpDown

*void CAM_PitchUpDown()*

*Defined at line 399 of ./game/client/in_camera.cpp*

### CAM_PitchUpUp

*void CAM_PitchUpUp()*

*Defined at line 404 of ./game/client/in_camera.cpp*

### CAM_PitchDownDown

*void CAM_PitchDownDown()*

*Defined at line 409 of ./game/client/in_camera.cpp*

### CAM_PitchDownUp

*void CAM_PitchDownUp()*

*Defined at line 414 of ./game/client/in_camera.cpp*

### CAM_YawLeftDown

*void CAM_YawLeftDown()*

*Defined at line 419 of ./game/client/in_camera.cpp*

### CAM_YawLeftUp

*void CAM_YawLeftUp()*

*Defined at line 424 of ./game/client/in_camera.cpp*

### CAM_YawRightDown

*void CAM_YawRightDown()*

*Defined at line 429 of ./game/client/in_camera.cpp*

### CAM_YawRightUp

*void CAM_YawRightUp()*

*Defined at line 434 of ./game/client/in_camera.cpp*

### CAM_InDown

*void CAM_InDown()*

*Defined at line 439 of ./game/client/in_camera.cpp*

### CAM_InUp

*void CAM_InUp()*

*Defined at line 444 of ./game/client/in_camera.cpp*

### CAM_OutDown

*void CAM_OutDown()*

*Defined at line 449 of ./game/client/in_camera.cpp*

### CAM_OutUp

*void CAM_OutUp()*

*Defined at line 454 of ./game/client/in_camera.cpp*

### CAM_ToggleSnapto

*void CAM_ToggleSnapto()*

*Defined at line 490 of ./game/client/in_camera.cpp*

### SDLash_KeyEvent

*void SDLash_KeyEvent(SDL_KeyboardEvent key)*

*Defined at line 36 of ./engine/platform/sdl/events.cpp*

=============SDLash_KeyEvent

=============

### SDLash_MouseEvent

*void SDLash_MouseEvent(SDL_MouseButtonEvent button)*

*Defined at line 158 of ./engine/platform/sdl/events.cpp*

=============SDLash_MouseEvent

=============

### SDLash_InputEvent

*void SDLash_InputEvent(SDL_TextInputEvent input)*

*Defined at line 178 of ./engine/platform/sdl/events.cpp*

=============SDLash_InputEvent

=============

### SDLash_EventFilter

*void SDLash_EventFilter(SDL_Event * event)*

*Defined at line 203 of ./engine/platform/sdl/events.cpp*

=============SDLash_EventFilter

=============

### fix_coord

*uint fix_coord(vec_t in, uint width)*

*Defined at line 38 of ./engine/common/pm_surface.cpp*

==============fix_coord

converts the reletive tex coords to absolute==============

### PM_SampleMiptex

*int PM_SampleMiptex(const msurface_t * surf, const vec3_t point)*

*Defined at line 51 of ./engine/common/pm_surface.cpp*

=============SampleMiptex

fence texture testing=============

### PM_TestLine_r

*int PM_TestLine_r(model_t * mod, mnode_t * node, vec_t p1f, vec_t p2f, const vec3_t start, const vec3_t stop, linetrace_t * trace)*

*Defined at line 240 of ./engine/common/pm_surface.cpp*

==================PM_TestLine_r

optimized trace for light gathering==================

### ListResponse

*void ListResponse(struct net_response_s * response)*

 Dispatchers

### ServerResponse

*void ServerResponse(struct net_response_s * response)*

### PingResponse

*void PingResponse(struct net_response_s * response)*

### RulesResponse

*void RulesResponse(struct net_response_s * response)*

### PlayersResponse

*void PlayersResponse(struct net_response_s * response)*

### ServersInit

*void ServersInit()*

### ServersShutdown

*void ServersShutdown()*

### ServersThink

*void ServersThink(double time)*

### ServersCancel

*void ServersCancel()*

### ServersList

*void ServersList()*

 Get list and get server info from each

### BroadcastServersList

*void BroadcastServersList(int clearpending)*

 Query for IP / IPX LAN servers

### ServerPing

*void ServerPing(int server)*

### ServerRules

*void ServerRules(int server)*

### ServerPlayers

*void ServerPlayers(int server)*

### ServersGetCount

*int ServersGetCount()*

### ServersGetInfo

*const char * ServersGetInfo(int server)*

### ServersIsQuerying

*int ServersIsQuerying()*

### SortServers

*void SortServers(const char * fieldname)*

### Demo_WriteBuffer

*void Demo_WriteBuffer(int type, int size, unsigned char * buffer)*

*Defined at line 42 of ./game/client/demo.cpp*

=====================Demo_WriteBuffer

Write some data to the demo stream=====================

### ShutdownInput

*void ShutdownInput()*

*Defined at line 1128 of ./game/client/input.cpp*

============ShutdownInput============

### __MsgFunc_Logo

*int __MsgFunc_Logo(const char * pszName, int iSize, void * pbuf)*

*Defined at line 44 of ./game/client/hud.cpp*

DECLARE_MESSAGE( m_Logo, Logo )

### __MsgFunc_ResetHUD

*int __MsgFunc_ResetHUD(const char * pszName, int iSize, void * pbuf)*

*Defined at line 50 of ./game/client/hud.cpp*

DECLARE_MESSAGE( m_Logo, Logo )

### __MsgFunc_InitHUD

*int __MsgFunc_InitHUD(const char * pszName, int iSize, void * pbuf)*

*Defined at line 55 of ./game/client/hud.cpp*

### __MsgFunc_ViewMode

*int __MsgFunc_ViewMode(const char * pszName, int iSize, void * pbuf)*

*Defined at line 61 of ./game/client/hud.cpp*

### __MsgFunc_SetFOV

*int __MsgFunc_SetFOV(const char * pszName, int iSize, void * pbuf)*

*Defined at line 67 of ./game/client/hud.cpp*

### __MsgFunc_Concuss

*int __MsgFunc_Concuss(const char * pszName, int iSize, void * pbuf)*

*Defined at line 72 of ./game/client/hud.cpp*

### __MsgFunc_GameMode

*int __MsgFunc_GameMode(const char * pszName, int iSize, void * pbuf)*

*Defined at line 77 of ./game/client/hud.cpp*

### __CmdFunc_OpenCommandMenu

*void __CmdFunc_OpenCommandMenu()*

*Defined at line 83 of ./game/client/hud.cpp*

 TFFree Command Menu

### __CmdFunc_InputPlayerSpecial

*void __CmdFunc_InputPlayerSpecial()*

*Defined at line 88 of ./game/client/hud.cpp*

 TFC "special" command

 needs capture by hud/vgui also

### __CmdFunc_CloseCommandMenu

*void __CmdFunc_CloseCommandMenu()*

*Defined at line 92 of ./game/client/hud.cpp*

### __CmdFunc_ForceCloseCommandMenu

*void __CmdFunc_ForceCloseCommandMenu()*

*Defined at line 96 of ./game/client/hud.cpp*

### __CmdFunc_ToggleServerBrowser

*void __CmdFunc_ToggleServerBrowser()*

*Defined at line 100 of ./game/client/hud.cpp*

### __MsgFunc_ValClass

*int __MsgFunc_ValClass(const char * pszName, int iSize, void * pbuf)*

*Defined at line 105 of ./game/client/hud.cpp*

 TFFree Command Menu Message Handlers

### __MsgFunc_TeamNames

*int __MsgFunc_TeamNames(const char * pszName, int iSize, void * pbuf)*

*Defined at line 110 of ./game/client/hud.cpp*

### __MsgFunc_Feign

*int __MsgFunc_Feign(const char * pszName, int iSize, void * pbuf)*

*Defined at line 115 of ./game/client/hud.cpp*

### __MsgFunc_Detpack

*int __MsgFunc_Detpack(const char * pszName, int iSize, void * pbuf)*

*Defined at line 120 of ./game/client/hud.cpp*

### __MsgFunc_VGUIMenu

*int __MsgFunc_VGUIMenu(const char * pszName, int iSize, void * pbuf)*

*Defined at line 125 of ./game/client/hud.cpp*

### __MsgFunc_BuildSt

*int __MsgFunc_BuildSt(const char * pszName, int iSize, void * pbuf)*

*Defined at line 130 of ./game/client/hud.cpp*

### __MsgFunc_RandomPC

*int __MsgFunc_RandomPC(const char * pszName, int iSize, void * pbuf)*

*Defined at line 135 of ./game/client/hud.cpp*

### __MsgFunc_ServerName

*int __MsgFunc_ServerName(const char * pszName, int iSize, void * pbuf)*

*Defined at line 140 of ./game/client/hud.cpp*

### __MsgFunc_Spectator

*int __MsgFunc_Spectator(const char * pszName, int iSize, void * pbuf)*

*Defined at line 145 of ./game/client/hud.cpp*

### __MsgFunc_AllowSpec

*int __MsgFunc_AllowSpec(const char * pszName, int iSize, void * pbuf)*

*Defined at line 150 of ./game/client/hud.cpp*

### HUD_IsGame

*int HUD_IsGame(const char * game)*

*Defined at line 479 of ./game/client/hud.cpp*

=================HUD_IsGame

=================

### Image_SetPalette

*void Image_SetPalette(const byte * pal, uint * d_table)*

*Defined at line 278 of ./engine/common/imagelib/img_utils.cpp*

### Image_ConvertPalTo24bit

*void Image_ConvertPalTo24bit(rgbdata_t * pic)*

*Defined at line 330 of ./engine/common/imagelib/img_utils.cpp*

### Image_Resample32LerpLine

*void Image_Resample32LerpLine(const byte * in, byte * out, int inwidth, int outwidth)*

*Defined at line 652 of ./engine/common/imagelib/img_utils.cpp*

### Image_Resample24LerpLine

*void Image_Resample24LerpLine(const byte * in, byte * out, int inwidth, int outwidth)*

*Defined at line 685 of ./engine/common/imagelib/img_utils.cpp*

### Image_Resample32Lerp

*void Image_Resample32Lerp(const void * indata, int inwidth, int inheight, void * outdata, int outwidth, int outheight)*

*Defined at line 718 of ./engine/common/imagelib/img_utils.cpp*

### Image_Resample32Nolerp

*void Image_Resample32Nolerp(const void * indata, int inwidth, int inheight, void * outdata, int outwidth, int outheight)*

*Defined at line 826 of ./engine/common/imagelib/img_utils.cpp*

### Image_Resample24Lerp

*void Image_Resample24Lerp(const void * indata, int inwidth, int inheight, void * outdata, int outwidth, int outheight)*

*Defined at line 865 of ./engine/common/imagelib/img_utils.cpp*

### Image_Resample24Nolerp

*void Image_Resample24Nolerp(const void * indata, int inwidth, int inheight, void * outdata, int outwidth, int outheight)*

*Defined at line 966 of ./engine/common/imagelib/img_utils.cpp*

### Image_Resample8Nolerp

*void Image_Resample8Nolerp(const void * indata, int inwidth, int inheight, void * outdata, int outwidth, int outheight)*

*Defined at line 1032 of ./engine/common/imagelib/img_utils.cpp*

### Image_CreateLumaInternal

*byte * Image_CreateLumaInternal(byte * fin, int width, int height, int type, int flags)*

*Defined at line 1172 of ./engine/common/imagelib/img_utils.cpp*

### Image_Decompress

*qboolean Image_Decompress(const byte * data)*

*Defined at line 1229 of ./engine/common/imagelib/img_utils.cpp*

=============Image_Decompress

force to unpack any image to 32-bit buffer=============

### Image_DecompressInternal

*rgbdata_t * Image_DecompressInternal(rgbdata_t * pic)*

*Defined at line 1297 of ./engine/common/imagelib/img_utils.cpp*

### Image_LightGamma

*rgbdata_t * Image_LightGamma(rgbdata_t * pic)*

*Defined at line 1320 of ./engine/common/imagelib/img_utils.cpp*

### Image_RemapInternal

*qboolean Image_RemapInternal(rgbdata_t * pic, int topColor, int bottomColor)*

*Defined at line 1338 of ./engine/common/imagelib/img_utils.cpp*

### Image_ApplyFilter

*void Image_ApplyFilter(rgbdata_t * pic, float factor)*

*Defined at line 1380 of ./engine/common/imagelib/img_utils.cpp*

================== Image_ApplyFilter

Applies a 5 x 5 filtering matrix to the texture, then runs it through a simulated OpenGL texture environment blend with the original data to derive a new texture.  Freaky, funky, and *f--king* *fantastic*.  You can do reasonable enough "fake bumpmapping" with this baby... 

Filtering algorithm from http://www.student.kuleuven.ac.be/~m0216922/CG/filtering.html All credit due ================== 

### UI_Touch_Precache

*void UI_Touch_Precache()*

*Defined at line 32 of ./mainui/menus/Touch.cpp*

=================UI_Touch_Precache=================

### AlertMessage

*void AlertMessage(ALERT_TYPE atype, const char * szFmt)*

*Defined at line 93 of ./game/client/hl/hl_weapons.cpp*

======================AlertMessage

Print debug messages to console======================

### HUD_PrepEntity

*void HUD_PrepEntity(class CBaseEntity * pEntity, class CBasePlayer * pWeaponOwner)*

*Defined at line 127 of ./game/client/hl/hl_weapons.cpp*

=====================HUD_PrepEntity

Links the raw entity to an entvars_s holder.  If a player is passed in as the owner, thenwe set up the m_pPlayer field.=====================

### UTIL_ParticleBox

*void UTIL_ParticleBox(class CBasePlayer * player, float * mins, float * maxs, float life, unsigned char r, unsigned char g, unsigned char b)*

*Defined at line 255 of ./game/client/hl/hl_weapons.cpp*

=====================UTIL_ParticleBox

For debugging, draw a box around a player made out of particles=====================

### UTIL_ParticleBoxes

*void UTIL_ParticleBoxes()*

*Defined at line 276 of ./game/client/hl/hl_weapons.cpp*

=====================UTIL_ParticleBoxes

For debugging, draw boxes for other collidable players=====================

### UTIL_ParticleLine

*void UTIL_ParticleLine(class CBasePlayer * player, float * start, float * end, float life, unsigned char r, unsigned char g, unsigned char b)*

*Defined at line 317 of ./game/client/hl/hl_weapons.cpp*

=====================UTIL_ParticleLine

For debugging, draw a line made out of particles=====================

### HUD_InitClientWeapons

*void HUD_InitClientWeapons()*

*Defined at line 329 of ./game/client/hl/hl_weapons.cpp*

=====================HUD_InitClientWeapons

Set up weapons, player and functions needed to run weapons code client-side.=====================

### HUD_GetLastOrg

*void HUD_GetLastOrg(float * org)*

*Defined at line 387 of ./game/client/hl/hl_weapons.cpp*

=====================HUD_GetLastOrg

Retruns the last position that we stored for egon beam endpoint.=====================

### HUD_SetLastOrg

*void HUD_SetLastOrg()*

*Defined at line 405 of ./game/client/hl/hl_weapons.cpp*

=====================HUD_SetLastOrg

Remember our exact predicted origin so we can draw the egon to the right position.=====================

### HUD_WeaponsPostThink

*void HUD_WeaponsPostThink(struct local_state_s * from, struct local_state_s * to, usercmd_t * cmd, double time, unsigned int random_seed)*

*Defined at line 423 of ./game/client/hl/hl_weapons.cpp*

=====================HUD_WeaponsPostThink

Run Weapon firing code on client=====================

### GL_TargetToString

*const char * GL_TargetToString(GLenum target)*

*Defined at line 44 of ./ref_gl/gl_image.cpp*

=================GL_TargetToString=================

### GL_UpdateTextureParams

*void GL_UpdateTextureParams(int iTexture)*

*Defined at line 247 of ./ref_gl/gl_image.cpp*

=================GL_UpdateTextureParams=================

### GL_CalcTextureSamples

*int GL_CalcTextureSamples(int flags)*

*Defined at line 333 of ./ref_gl/gl_image.cpp*

================GL_CalcTextureSamples================

### GL_CalcImageSize

*size_t GL_CalcImageSize(pixformat_t format, int width, int height, int depth)*

*Defined at line 345 of ./ref_gl/gl_image.cpp*

==================GL_CalcImageSize==================

### GL_CalcTextureSize

*size_t GL_CalcTextureSize(GLenum format, int width, int height, int depth)*

*Defined at line 383 of ./ref_gl/gl_image.cpp*

==================GL_CalcTextureSize==================

### GL_CalcMipmapCount

*int GL_CalcMipmapCount(gl_texture_t * tex, qboolean haveBuffer)*

*Defined at line 484 of ./ref_gl/gl_image.cpp*

### GL_SetTextureDimensions

*void GL_SetTextureDimensions(gl_texture_t * tex, int width, int height, int depth)*

*Defined at line 515 of ./ref_gl/gl_image.cpp*

================GL_SetTextureDimensions================

### GL_SetTextureTarget

*void GL_SetTextureTarget(gl_texture_t * tex, rgbdata_t * pic)*

*Defined at line 604 of ./ref_gl/gl_image.cpp*

===============GL_SetTextureTarget===============

### GL_SetTextureFormat

*void GL_SetTextureFormat(gl_texture_t * tex, pixformat_t format, int channelMask)*

*Defined at line 656 of ./ref_gl/gl_image.cpp*

===============GL_SetTextureFormat===============

### GL_BuildMipMap

*void GL_BuildMipMap(byte * in, int srcWidth, int srcHeight, int srcDepth, int flags)*

*Defined at line 917 of ./ref_gl/gl_image.cpp*

=================GL_BuildMipMap

Operates in place, quartering the size of the texture=================

### GL_TextureImageRAW

*void GL_TextureImageRAW(gl_texture_t * tex, GLint side, GLint level, GLint width, GLint height, GLint depth, GLint type, const void * data)*

*Defined at line 1001 of ./ref_gl/gl_image.cpp*

### GL_TextureImageDXT

*void GL_TextureImageDXT(gl_texture_t * tex, GLint side, GLint level, GLint width, GLint height, GLint depth, size_t size, const void * data)*

*Defined at line 1040 of ./ref_gl/gl_image.cpp*

### GL_CheckTexImageError

*void GL_CheckTexImageError(gl_texture_t * tex)*

*Defined at line 1078 of ./ref_gl/gl_image.cpp*

===============GL_CheckTexImageError

show GL-errors on load images===============

### GL_UploadTexture

*qboolean GL_UploadTexture(gl_texture_t * tex, rgbdata_t * pic)*

*Defined at line 1096 of ./ref_gl/gl_image.cpp*

===============GL_UploadTexture

upload texture into video memory===============

### GL_ProcessImage

*void GL_ProcessImage(gl_texture_t * tex, rgbdata_t * pic)*

*Defined at line 1233 of ./ref_gl/gl_image.cpp*

===============GL_ProcessImage

do specified actions on pixels===============

### GL_TextureForName

*gl_texture_t * GL_TextureForName(const char * name)*

*Defined at line 1320 of ./ref_gl/gl_image.cpp*

================GL_TextureForName================

### GL_AllocTexture

*gl_texture_t * GL_AllocTexture(const char * name, texFlags_t flags)*

*Defined at line 1342 of ./ref_gl/gl_image.cpp*

================GL_AllocTexture================

### GL_DeleteTexture

*void GL_DeleteTexture(gl_texture_t * tex)*

*Defined at line 1380 of ./ref_gl/gl_image.cpp*

================GL_DeleteTexture================

### GL_FakeImage

*rgbdata_t * GL_FakeImage(int width, int height, int depth, int flags)*

*Defined at line 1891 of ./ref_gl/gl_image.cpp*

==============================================================================

INTERNAL TEXTURES

==============================================================================

==================GL_FakeImage==================

### GL_CreateInternalTextures

*void GL_CreateInternalTextures()*

*Defined at line 1942 of ./ref_gl/gl_image.cpp*

==================GL_CreateInternalTextures==================

### PlatSpawnInsideTrigger

*void PlatSpawnInsideTrigger(entvars_t * pevPlatform)*

*Defined at line 322 of ./game/server/plats.cpp*

### func_plat

*void func_plat(entvars_t * pev)*

*Defined at line 231 of ./game/server/plats.cpp*

### func_platrot

*void func_platrot(entvars_t * pev)*

*Defined at line 514 of ./game/server/plats.cpp*

### func_train

*void func_train(entvars_t * pev)*

*Defined at line 624 of ./game/server/plats.cpp*

### func_tracktrain

*void func_tracktrain(entvars_t * pev)*

*Defined at line 915 of ./game/server/plats.cpp*

### Fix

*float Fix(float angle)*

*Defined at line 1030 of ./game/server/plats.cpp*

### FixupAngles

*void FixupAngles(class Vector & v)*

*Defined at line 1040 of ./game/server/plats.cpp*

### func_traincontrols

*void func_traincontrols(entvars_t * pev)*

*Defined at line 1528 of ./game/server/plats.cpp*

### func_trackchange

*void func_trackchange(entvars_t * pev)*

*Defined at line 1630 of ./game/server/plats.cpp*

### func_trackautochange

*void func_trackautochange(entvars_t * pev)*

*Defined at line 1972 of ./game/server/plats.cpp*

### func_guntarget

*void func_guntarget(entvars_t * pev)*

*Defined at line 2082 of ./game/server/plats.cpp*

### pfnSPR_DrawHoles

*void pfnSPR_DrawHoles(int frame, int x, int y, const wrect_t * prc)*

*Defined at line 1475 of ./engine/client/cl_game.cpp*

=========pfnSPR_DrawHoles

=========

### CL_CreatePlaylist

*void CL_CreatePlaylist(const char * filename)*

*Defined at line 179 of ./engine/client/cl_game.cpp*

====================CL_CreatePlaylist

Create a default valve playlist====================

### CL_InitCDAudio

*void CL_InitCDAudio(const char * filename)*

*Defined at line 225 of ./engine/client/cl_game.cpp*

====================CL_InitCDAudio

Initialize CD playlist====================

### CL_AdjustXPos

*int CL_AdjustXPos(float x, int width, int totalWidth)*

*Defined at line 282 of ./engine/client/cl_game.cpp*

=============CL_AdjustXPos

adjust text by x pos=============

### CL_AdjustYPos

*int CL_AdjustYPos(float y, int height)*

*Defined at line 313 of ./engine/client/cl_game.cpp*

=============CL_AdjustYPos

adjust text by y pos=============

### SPR_AdjustSize

*void SPR_AdjustSize(float * x, float * y, float * w, float * h)*

*Defined at line 386 of ./engine/client/cl_game.cpp*

====================SPR_AdjustSize

draw hudsprite routine====================

### SPR_Scissor

*qboolean SPR_Scissor(float * x, float * y, float * width, float * height, float * u0, float * v0, float * u1, float * v1)*

*Defined at line 426 of ./engine/client/cl_game.cpp*

### SPR_DrawGeneric

*void SPR_DrawGeneric(int frame, float x, float y, float width, float height, const wrect_t * prc)*

*Defined at line 482 of ./engine/client/cl_game.cpp*

====================SPR_DrawGeneric

draw hudsprite routine====================

### CL_DrawScreenFade

*void CL_DrawScreenFade()*

*Defined at line 605 of ./engine/client/cl_game.cpp*

=============CL_DrawScreenFade

fill screen with specfied colorcan be modulated=============

### CL_InitTitles

*void CL_InitTitles(const char * filename)*

*Defined at line 656 of ./engine/client/cl_game.cpp*

====================CL_InitTitles

parse all messages that declared in titles.txtand hold them into permament memory pool ====================

### CL_SoundFromIndex

*const char * CL_SoundFromIndex(int index)*

*Defined at line 829 of ./engine/client/cl_game.cpp*

====================CL_SoundFromIndex

return soundname from index====================

### SPR_EnableScissor

*void SPR_EnableScissor(int x, int y, int width, int height)*

*Defined at line 860 of ./engine/client/cl_game.cpp*

=========SPR_EnableScissor

=========

### SPR_DisableScissor

*void SPR_DisableScissor()*

*Defined at line 881 of ./engine/client/cl_game.cpp*

=========SPR_DisableScissor

=========

### CL_DrawCrosshair

*void CL_DrawCrosshair()*

*Defined at line 897 of ./engine/client/cl_game.cpp*

====================CL_DrawCrosshair

Render crosshair====================

### CL_DrawLoading

*void CL_DrawLoading(float percent)*

*Defined at line 951 of ./engine/client/cl_game.cpp*

=============CL_DrawLoading

draw loading progress bar=============

### CL_DrawPause

*void CL_DrawPause()*

*Defined at line 999 of ./engine/client/cl_game.cpp*

=============CL_DrawPause

draw pause sign=============

### CL_ClearUserMessage

*void CL_ClearUserMessage(char * pszName, int svc_num)*

*Defined at line 1059 of ./engine/client/cl_game.cpp*

### CL_LoadHudSprite

*qboolean CL_LoadHudSprite(const char * szSpriteName, model_t * m_pSprite, uint type, uint texFlags)*

*Defined at line 1204 of ./engine/client/cl_game.cpp*

=============CL_LoadHudSprite

upload sprite frames=============

### CL_LoadSpriteModel

*model_t * CL_LoadSpriteModel(const char * filename, uint type, uint texFlags)*

*Defined at line 1268 of ./engine/client/cl_game.cpp*

=============CL_LoadSpriteModel

some sprite models is exist only at client: HUD sprites,tent sprites or overview images=============

### CL_GetSpritePointer

*const model_t * CL_GetSpritePointer(HSPRITE hSprite)*

*Defined at line 1372 of ./engine/client/cl_game.cpp*

=============CL_GetSpritePointer

=============

### pfnSPR_Frames

*int pfnSPR_Frames(HSPRITE hPic)*

*Defined at line 1403 of ./engine/client/cl_game.cpp*

=========pfnSPR_Frames

=========

### pfnSPR_Height

*int pfnSPR_Height(HSPRITE hPic, int frame)*

*Defined at line 1418 of ./engine/client/cl_game.cpp*

=========pfnSPR_Height

=========

### pfnSPR_Width

*int pfnSPR_Width(HSPRITE hPic, int frame)*

*Defined at line 1433 of ./engine/client/cl_game.cpp*

=========pfnSPR_Width

=========

### pfnSPR_Set

*void pfnSPR_Set(HSPRITE hPic, int r, int g, int b)*

*Defined at line 1448 of ./engine/client/cl_game.cpp*

=========pfnSPR_Set

=========

### pfnSPR_Draw

*void pfnSPR_Draw(int frame, int x, int y, const wrect_t * prc)*

*Defined at line 1463 of ./engine/client/cl_game.cpp*

=========pfnSPR_Draw

=========

### pfnSPR_DrawAdditive

*void pfnSPR_DrawAdditive(int frame, int x, int y, const wrect_t * prc)*

*Defined at line 1500 of ./engine/client/cl_game.cpp*

=========pfnSPR_DrawAdditive

=========

### pfnSPR_GetList

*client_sprite_t * pfnSPR_GetList(char * psz, int * piCount)*

*Defined at line 1525 of ./engine/client/cl_game.cpp*

=========pfnSPR_GetList

for parsing half-life scripts - hud.txt etc=========

### pfnSetCrosshair

*void pfnSetCrosshair(HSPRITE hspr, wrect_s rc, int r, int g, int b)*

*Defined at line 1694 of ./engine/client/cl_game.cpp*

=============pfnSetCrosshair

setup crosshair=============

### pfnHookUserMsg

*int pfnHookUserMsg(const char * pszName, pfnUserMsgHook pfn)*

*Defined at line 1710 of ./engine/client/cl_game.cpp*

=============pfnHookUserMsg

=============

### pfnServerCmd

*int pfnServerCmd(const char * szCmdString)*

*Defined at line 1744 of ./engine/client/cl_game.cpp*

=============pfnServerCmd

=============

### pfnClientCmd

*int pfnClientCmd(const char * szCmdString)*

*Defined at line 1764 of ./engine/client/cl_game.cpp*

=============pfnClientCmd

=============

### pfnGetPlayerInfo

*void pfnGetPlayerInfo(int ent_num, hud_player_info_t * pinfo)*

*Defined at line 1789 of ./engine/client/cl_game.cpp*

=============pfnGetPlayerInfo

=============

### pfnPlaySoundByName

*void pfnPlaySoundByName(const char * szSound, float volume)*

*Defined at line 1819 of ./engine/client/cl_game.cpp*

=============pfnPlaySoundByName

=============

### pfnPlaySoundByIndex

*void pfnPlaySoundByIndex(int iSound, float volume)*

*Defined at line 1831 of ./engine/client/cl_game.cpp*

=============pfnPlaySoundByIndex

=============

### pfnDrawCharacter

*int pfnDrawCharacter(int x, int y, int number, int r, int g, int b)*

*Defined at line 1877 of ./engine/client/cl_game.cpp*

=============pfnDrawCharacter

returns drawed chachter width (in real screen pixels)=============

### pfnConsolePrint

*void pfnConsolePrint(const char * string)*

*Defined at line 1961 of ./engine/client/cl_game.cpp*

=============pfnConsolePrint

prints directly into console (can skip notify)=============

### pfnCenterPrint

*void pfnCenterPrint(const char * string)*

*Defined at line 1974 of ./engine/client/cl_game.cpp*

=============pfnCenterPrint

holds and fade message at center of screenlike trigger_multiple message in q1=============

### pfnGetWindowCenterX

*int pfnGetWindowCenterX()*

*Defined at line 1985 of ./engine/client/cl_game.cpp*

=========GetWindowCenterX

=========

### pfnGetWindowCenterY

*int pfnGetWindowCenterY()*

*Defined at line 2010 of ./engine/client/cl_game.cpp*

=========GetWindowCenterY

=========

### pfnGetViewAngles

*void pfnGetViewAngles(float * angles)*

*Defined at line 2036 of ./engine/client/cl_game.cpp*

=============pfnGetViewAngles

return interpolated angles from previous frame=============

### pfnSetViewAngles

*void pfnSetViewAngles(float * angles)*

*Defined at line 2048 of ./engine/client/cl_game.cpp*

=============pfnSetViewAngles

return interpolated angles from previous frame=============

### pfnPhysInfo_ValueForKey

*const char * pfnPhysInfo_ValueForKey(const char * key)*

*Defined at line 2059 of ./engine/client/cl_game.cpp*

=============pfnPhysInfo_ValueForKey

=============

### pfnServerInfo_ValueForKey

*const char * pfnServerInfo_ValueForKey(const char * key)*

*Defined at line 2070 of ./engine/client/cl_game.cpp*

=============pfnServerInfo_ValueForKey

=============

### pfnGetClientMaxspeed

*float pfnGetClientMaxspeed()*

*Defined at line 2082 of ./engine/client/cl_game.cpp*

=============pfnGetClientMaxspeed

value that come from server=============

### pfnIsNoClipping

*int pfnIsNoClipping()*

*Defined at line 2093 of ./engine/client/cl_game.cpp*

=============pfnIsNoClipping

=============

### pfnGetClientTime

*float pfnGetClientTime()*

*Defined at line 2115 of ./engine/client/cl_game.cpp*

=============pfnGetClientTime

=============

### pfnCalcShake

*void pfnCalcShake()*

*Defined at line 2126 of ./engine/client/cl_game.cpp*

=============pfnCalcShake

=============

### pfnApplyShake

*void pfnApplyShake(float * origin, float * angles, float factor)*

*Defined at line 2188 of ./engine/client/cl_game.cpp*

=============pfnApplyShake

=============

### pfnIsSpectateOnly

*int pfnIsSpectateOnly()*

*Defined at line 2200 of ./engine/client/cl_game.cpp*

=============pfnIsSpectateOnly

=============

### pfnPointContents

*int pfnPointContents(const float * p, int * truecontents)*

*Defined at line 2211 of ./engine/client/cl_game.cpp*

=============pfnPointContents

=============

### pfnTraceLine

*pmtrace_t * pfnTraceLine(float * start, float * end, int flags, int usehull, int ignore_pe)*

*Defined at line 2229 of ./engine/client/cl_game.cpp*

=============pfnTraceLine

=============

### pfnPlaySoundByNameAtLocation

*void pfnPlaySoundByNameAtLocation(char * szSound, float volume, float * origin)*

*Defined at line 2252 of ./engine/client/cl_game.cpp*

### pfnPrecacheEvent

*word pfnPrecacheEvent(int type, const char * psz)*

*Defined at line 2264 of ./engine/client/cl_game.cpp*

=============pfnPrecacheEvent

=============

### pfnHookEvent

*void pfnHookEvent(const char * filename, pfnEventHook pfn)*

*Defined at line 2275 of ./engine/client/cl_game.cpp*

=============pfnHookEvent

=============

### pfnKillEvents

*void pfnKillEvents(int entnum, const char * eventname)*

*Defined at line 2310 of ./engine/client/cl_game.cpp*

=============pfnKillEvent

=============

### pfnPlaySound

*void pfnPlaySound(int ent, float * org, int chan, const char * samp, float vol, float attn, int flags, int pitch)*

*Defined at line 2344 of ./engine/client/cl_game.cpp*

=============pfnPlaySound

=============

### pfnIsLocal

*int pfnIsLocal(int playernum)*

*Defined at line 2392 of ./engine/client/cl_game.cpp*

=============pfnIsLocal

=============

### pfnLocalPlayerDucking

*int pfnLocalPlayerDucking()*

*Defined at line 2405 of ./engine/client/cl_game.cpp*

=============pfnLocalPlayerDucking

=============

### pfnLocalPlayerViewheight

*void pfnLocalPlayerViewheight(float * view_ofs)*

*Defined at line 2416 of ./engine/client/cl_game.cpp*

=============pfnLocalPlayerViewheight

=============

### pfnLocalPlayerBounds

*void pfnLocalPlayerBounds(int hull, float * mins, float * maxs)*

*Defined at line 2427 of ./engine/client/cl_game.cpp*

=============pfnLocalPlayerBounds

=============

### pfnGetVisent

*physent_t * pfnGetVisent(int idx)*

*Defined at line 2474 of ./engine/client/cl_game.cpp*

=============pfnGetVisent

=============

### pfnTraceTexture

*const char * pfnTraceTexture(int ground, float * vstart, float * vend)*

*Defined at line 2526 of ./engine/client/cl_game.cpp*

=============pfnTraceTexture

=============

### pfnStopAllSounds

*void pfnStopAllSounds(int ent, int entchannel)*

*Defined at line 2571 of ./engine/client/cl_game.cpp*

=============pfnStopAllSounds

=============

### pfnGetGameDirectory

*const char * pfnGetGameDirectory()*

*Defined at line 2613 of ./engine/client/cl_game.cpp*

=============pfnGetGameDirectory

=============

### Key_LookupBinding

*const char * Key_LookupBinding(const char * pBinding)*

*Defined at line 2627 of ./engine/client/cl_game.cpp*

=============Key_LookupBinding

=============

### pfnGetLevelName

*const char * pfnGetLevelName()*

*Defined at line 2638 of ./engine/client/cl_game.cpp*

=============pfnGetLevelName

=============

### pfnSetScreenFade

*void pfnSetScreenFade(struct screenfade_s * fade)*

*Defined at line 2666 of ./engine/client/cl_game.cpp*

=============pfnSetScreenFade

=============

### pfnLoadMapSprite

*model_t * pfnLoadMapSprite(const char * filename)*

*Defined at line 2677 of ./engine/client/cl_game.cpp*

=============pfnLoadMapSprite

=============

### PlayerInfo_ValueForKey

*const char * PlayerInfo_ValueForKey(int playerNum, const char * key)*

*Defined at line 2688 of ./engine/client/cl_game.cpp*

=============PlayerInfo_ValueForKey

=============

### PlayerInfo_SetValueForKey

*void PlayerInfo_SetValueForKey(const char * key, const char * value)*

*Defined at line 2706 of ./engine/client/cl_game.cpp*

=============PlayerInfo_SetValueForKey

=============

### pfnGetPlayerUniqueID

*qboolean pfnGetPlayerUniqueID(int iPlayer, char [16] playerID)*

*Defined at line 2732 of ./engine/client/cl_game.cpp*

=============pfnGetPlayerUniqueID

=============

### pfnGetTrackerIDForPlayer

*int pfnGetTrackerIDForPlayer(int playerSlot)*

*Defined at line 2752 of ./engine/client/cl_game.cpp*

=============pfnGetTrackerIDForPlayer

obsolete, unused=============

### pfnGetPlayerForTrackerID

*int pfnGetPlayerForTrackerID(int trackerID)*

*Defined at line 2764 of ./engine/client/cl_game.cpp*

=============pfnGetPlayerForTrackerID

obsolete, unused=============

### pfnServerCmdUnreliable

*int pfnServerCmdUnreliable(char * szCmdString)*

*Defined at line 2775 of ./engine/client/cl_game.cpp*

=============pfnServerCmdUnreliable

=============

### pfnGetMousePos

*void pfnGetMousePos(struct tagPOINT * ppt)*

*Defined at line 2792 of ./engine/client/cl_game.cpp*

=============pfnGetMousePos

=============

### pfnSetMouseEnable

*void pfnSetMouseEnable(qboolean fEnable)*

*Defined at line 2807 of ./engine/client/cl_game.cpp*

=============pfnSetMouseEnable

legacy of dinput code=============

### pfnGetClientOldTime

*float pfnGetClientOldTime()*

*Defined at line 2818 of ./engine/client/cl_game.cpp*

=============pfnGetServerTime

=============

### pfnGetGravity

*float pfnGetGravity()*

*Defined at line 2829 of ./engine/client/cl_game.cpp*

=============pfnGetGravity

=============

### pfnEnableTexSort

*void pfnEnableTexSort(int enable)*

*Defined at line 2841 of ./engine/client/cl_game.cpp*

=============pfnEnableTexSort

TODO: implement=============

### pfnSetLightmapColor

*void pfnSetLightmapColor(float red, float green, float blue)*

*Defined at line 2852 of ./engine/client/cl_game.cpp*

=============pfnSetLightmapColor

TODO: implement=============

### pfnSetLightmapScale

*void pfnSetLightmapScale(float scale)*

*Defined at line 2863 of ./engine/client/cl_game.cpp*

=============pfnSetLightmapScale

TODO: implement=============

### pfnSPR_DrawGeneric

*void pfnSPR_DrawGeneric(int frame, int x, int y, const wrect_t * prc, int blendsrc, int blenddst, int width, int height)*

*Defined at line 2873 of ./engine/client/cl_game.cpp*

=============pfnSPR_DrawGeneric

=============

### LocalPlayerInfo_ValueForKey

*const char * LocalPlayerInfo_ValueForKey(const char * key)*

*Defined at line 2888 of ./engine/client/cl_game.cpp*

=============LocalPlayerInfo_ValueForKey

=============

### pfnVGUI2DrawCharacter

*int pfnVGUI2DrawCharacter(int x, int y, int number, unsigned int font)*

*Defined at line 2899 of ./engine/client/cl_game.cpp*

=============pfnVGUI2DrawCharacter

=============

### pfnVGUI2DrawCharacterAdditive

*int pfnVGUI2DrawCharacterAdditive(int x, int y, int ch, int r, int g, int b, unsigned int font)*

*Defined at line 2926 of ./engine/client/cl_game.cpp*

=============pfnVGUI2DrawCharacterAdditive

=============

### pfnDrawString

*int pfnDrawString(int x, int y, const char * str, int r, int g, int b)*

*Defined at line 2940 of ./engine/client/cl_game.cpp*

=============pfnDrawString

=============

### pfnDrawStringReverse

*int pfnDrawStringReverse(int x, int y, const char * str, int r, int g, int b)*

*Defined at line 2959 of ./engine/client/cl_game.cpp*

=============pfnDrawStringReverse

=============

### GetCareerGameInterface

*void * GetCareerGameInterface()*

*Defined at line 2975 of ./engine/client/cl_game.cpp*

=============GetCareerGameInterface

=============

### pfnPlaySoundVoiceByName

*void pfnPlaySoundVoiceByName(char * filename, float volume, int pitch)*

*Defined at line 2987 of ./engine/client/cl_game.cpp*

=============pfnPlaySoundVoiceByName

=============

### pfnMP3_InitStream

*void pfnMP3_InitStream(char * filename, int looping)*

*Defined at line 3000 of ./engine/client/cl_game.cpp*

=============pfnMP3_InitStream

=============

### pfnPlaySoundByNameAtPitch

*void pfnPlaySoundByNameAtPitch(char * filename, float volume, int pitch)*

*Defined at line 3024 of ./engine/client/cl_game.cpp*

=============pfnPlaySoundByNameAtPitch

=============

### CL_FillRGBABlend

*void CL_FillRGBABlend(int x, int y, int w, int h, int r, int g, int b, int a)*

*Defined at line 3036 of ./engine/client/cl_game.cpp*

=============pfnFillRGBABlend

=============

### pfnGetAppID

*int pfnGetAppID()*

*Defined at line 3075 of ./engine/client/cl_game.cpp*

=============pfnGetAppID

=============

### pfnVguiWrap2_GetMouseDelta

*void pfnVguiWrap2_GetMouseDelta(int * x, int * y)*

*Defined at line 3087 of ./engine/client/cl_game.cpp*

=============pfnVguiWrap2_GetMouseDelta

TODO: implement=============

### pfnParseFile

*char * pfnParseFile(char * data, char * token)*

*Defined at line 3098 of ./engine/client/cl_game.cpp*

=============pfnParseFile

handle colon separately=============

### Demo_IsRecording

*int Demo_IsRecording()*

*Defined at line 3284 of ./engine/client/cl_game.cpp*

=================DemoApi implementation

=================

=================Demo_IsRecording

=================

### Demo_IsPlayingback

*int Demo_IsPlayingback()*

*Defined at line 3295 of ./engine/client/cl_game.cpp*

=================Demo_IsPlayingback

=================

### Demo_IsTimeDemo

*int Demo_IsTimeDemo()*

*Defined at line 3306 of ./engine/client/cl_game.cpp*

=================Demo_IsTimeDemo

=================

### Demo_WriteBuffer

*void Demo_WriteBuffer(int size, byte * buffer)*

*Defined at line 3317 of ./engine/client/cl_game.cpp*

=================Demo_WriteBuffer

=================

### NetAPI_InitNetworking

*void NetAPI_InitNetworking()*

*Defined at line 3334 of ./engine/client/cl_game.cpp*

=================NetworkApi implementation

=================

=================NetAPI_InitNetworking

=================

### NetAPI_Status

*void NetAPI_Status(net_status_t * status)*

*Defined at line 3345 of ./engine/client/cl_game.cpp*

=================NetAPI_InitNetworking

=================

### NetAPI_SendRequest

*void NetAPI_SendRequest(int context, int request, int flags, double timeout, netadr_t * remote_address, net_api_response_func_t response)*

*Defined at line 3373 of ./engine/client/cl_game.cpp*

=================NetAPI_SendRequest

=================

### NetAPI_CancelRequest

*void NetAPI_CancelRequest(int context)*

*Defined at line 3451 of ./engine/client/cl_game.cpp*

=================NetAPI_CancelRequest

=================

### NetAPI_AdrToString

*char * NetAPI_AdrToString(netadr_t * a)*

*Defined at line 3515 of ./engine/client/cl_game.cpp*

=================NetAPI_AdrToString

=================

### NetAPI_CompareAdr

*int NetAPI_CompareAdr(netadr_t * a, netadr_t * b)*

*Defined at line 3526 of ./engine/client/cl_game.cpp*

=================NetAPI_CompareAdr

=================

### NetAPI_StringToAdr

*int NetAPI_StringToAdr(char * s, netadr_t * a)*

*Defined at line 3537 of ./engine/client/cl_game.cpp*

=================NetAPI_StringToAdr

=================

### NetAPI_ValueForKey

*const char * NetAPI_ValueForKey(const char * s, const char * key)*

*Defined at line 3548 of ./engine/client/cl_game.cpp*

=================NetAPI_ValueForKey

=================

### NetAPI_RemoveKey

*void NetAPI_RemoveKey(char * s, const char * key)*

*Defined at line 3559 of ./engine/client/cl_game.cpp*

=================NetAPI_RemoveKey

=================

### NetAPI_SetValueForKey

*void NetAPI_SetValueForKey(char * s, const char * key, const char * value, int maxsize)*

*Defined at line 3570 of ./engine/client/cl_game.cpp*

=================NetAPI_SetValueForKey

=================

### Voice_StartVoiceTweakMode

*int Voice_StartVoiceTweakMode()*

*Defined at line 3590 of ./engine/client/cl_game.cpp*

=================IVoiceTweak implementation

TODO: implement=================

=================Voice_StartVoiceTweakMode

=================

### Voice_EndVoiceTweakMode

*void Voice_EndVoiceTweakMode()*

*Defined at line 3601 of ./engine/client/cl_game.cpp*

=================Voice_EndVoiceTweakMode

=================

### Voice_SetControlFloat

*void Voice_SetControlFloat(VoiceTweakControl iControl, float value)*

*Defined at line 3611 of ./engine/client/cl_game.cpp*

=================Voice_SetControlFloat

=================

### Voice_GetControlFloat

*float Voice_GetControlFloat(VoiceTweakControl iControl)*

*Defined at line 3621 of ./engine/client/cl_game.cpp*

=================Voice_GetControlFloat

=================

### VGui_ViewportPaintBackground

*void VGui_ViewportPaintBackground(int [4] extents)*

*Defined at line 3626 of ./engine/client/cl_game.cpp*

### Demo_ReadBuffer

*void Demo_ReadBuffer(int size, unsigned char * buffer)*

*Defined at line 62 of ./game/client/demo.cpp*

=====================Demo_ReadBuffer

Engine wants us to parse some data from the demo stream=====================

### xen_plantlight

*void xen_plantlight(entvars_t * pev)*

*Defined at line 78 of ./game/server/xen.cpp*

### xen_hair

*void xen_hair(entvars_t * pev)*

*Defined at line 176 of ./game/server/xen.cpp*

### xen_ttrigger

*void xen_ttrigger(entvars_t * pev)*

*Defined at line 217 of ./game/server/xen.cpp*

### xen_tree

*void xen_tree(entvars_t * pev)*

*Defined at line 265 of ./game/server/xen.cpp*

### xen_spore_small

*void xen_spore_small(entvars_t * pev)*

*Defined at line 460 of ./game/server/xen.cpp*

### xen_spore_medium

*void xen_spore_medium(entvars_t * pev)*

*Defined at line 461 of ./game/server/xen.cpp*

### xen_spore_large

*void xen_spore_large(entvars_t * pev)*

*Defined at line 462 of ./game/server/xen.cpp*

### xen_hull

*void xen_hull(entvars_t * pev)*

*Defined at line 463 of ./game/server/xen.cpp*

### UI_VidModes_Precache

*void UI_VidModes_Precache()*

*Defined at line 370 of ./mainui/menus/VideoModes.cpp*

=================UI_VidModes_Precache=================

### S_TransferPaintBuffer

*void S_TransferPaintBuffer(int endtime)*

*Defined at line 61 of ./engine/client/s_mix.cpp*

===================S_TransferPaintBuffer

===================

### MIX_ActivatePaintbuffer

*void MIX_ActivatePaintbuffer(int ipaintbuffer)*

*Defined at line 114 of ./engine/client/s_mix.cpp*

=============================================================================== Mix buffer (paintbuffer) management routines=============================================================================== Activate a paintbuffer.  All active paintbuffers are mixed in parallel within  MIX_MixChannelsToPaintbuffer, according to flags

### MIX_DeactivatePaintbuffer

*void MIX_DeactivatePaintbuffer(int ipaintbuffer)*

*Defined at line 121 of ./engine/client/s_mix.cpp*

 don't mix into this paintbuffer

### MIX_SetCurrentPaintbuffer

*void MIX_SetCurrentPaintbuffer(int ipaintbuffer)*

*Defined at line 127 of ./engine/client/s_mix.cpp*

### MIX_GetCurrentPaintbufferIndex

*int MIX_GetCurrentPaintbufferIndex()*

*Defined at line 134 of ./engine/client/s_mix.cpp*

### MIX_GetCurrentPaintbufferPtr

*paintbuffer_t * MIX_GetCurrentPaintbufferPtr()*

*Defined at line 146 of ./engine/client/s_mix.cpp*

### MIX_DeactivateAllPaintbuffers

*void MIX_DeactivateAllPaintbuffers()*

*Defined at line 155 of ./engine/client/s_mix.cpp*

 Don't mix into any paintbuffers

### MIX_ResetPaintbufferFilterCounters

*void MIX_ResetPaintbufferFilterCounters()*

*Defined at line 164 of ./engine/client/s_mix.cpp*

 set upsampling filter indexes back to 0

### MIX_ResetPaintbufferFilterCounter

*void MIX_ResetPaintbufferFilterCounter(int ipaintbuffer)*

*Defined at line 172 of ./engine/client/s_mix.cpp*

### MIX_GetPFrontFromIPaint

*portable_samplepair_t * MIX_GetPFrontFromIPaint(int ipaintbuffer)*

*Defined at line 179 of ./engine/client/s_mix.cpp*

 return pointer to front paintbuffer pbuf, given index

### MIX_GetPPaintFromIPaint

*paintbuffer_t * MIX_GetPPaintFromIPaint(int ipaint)*

*Defined at line 185 of ./engine/client/s_mix.cpp*

### S_PaintMonoFrom8

*void S_PaintMonoFrom8(portable_samplepair_t * pbuf, int * volume, byte * pData, int outCount)*

*Defined at line 217 of ./engine/client/s_mix.cpp*

===============================================================================

CHANNEL MIXING

===============================================================================

### S_PaintStereoFrom8

*void S_PaintStereoFrom8(portable_samplepair_t * pbuf, int * volume, byte * pData, int outCount)*

*Defined at line 233 of ./engine/client/s_mix.cpp*

### S_PaintMonoFrom16

*void S_PaintMonoFrom16(portable_samplepair_t * pbuf, int * volume, short * pData, int outCount)*

*Defined at line 253 of ./engine/client/s_mix.cpp*

### S_PaintStereoFrom16

*void S_PaintStereoFrom16(portable_samplepair_t * pbuf, int * volume, short * pData, int outCount)*

*Defined at line 268 of ./engine/client/s_mix.cpp*

### S_Mix8MonoTimeCompress

*void S_Mix8MonoTimeCompress(portable_samplepair_t * pbuf, int * volume, byte * pData, int inputOffset, uint rateScale, int outCount, int timecompress)*

*Defined at line 289 of ./engine/client/s_mix.cpp*

### S_Mix8Mono

*void S_Mix8Mono(portable_samplepair_t * pbuf, int * volume, byte * pData, int inputOffset, uint rateScale, int outCount, int timecompress)*

*Defined at line 293 of ./engine/client/s_mix.cpp*

### S_Mix8Stereo

*void S_Mix8Stereo(portable_samplepair_t * pbuf, int * volume, byte * pData, int inputOffset, uint rateScale, int outCount)*

*Defined at line 325 of ./engine/client/s_mix.cpp*

### S_Mix16Mono

*void S_Mix16Mono(portable_samplepair_t * pbuf, int * volume, short * pData, int inputOffset, uint rateScale, int outCount)*

*Defined at line 351 of ./engine/client/s_mix.cpp*

### S_Mix16Stereo

*void S_Mix16Stereo(portable_samplepair_t * pbuf, int * volume, short * pData, int inputOffset, uint rateScale, int outCount)*

*Defined at line 373 of ./engine/client/s_mix.cpp*

### S_MixChannel

*void S_MixChannel(channel_t * pChannel, void * pData, int outputOffset, int inputOffset, uint fracRate, int outCount, int timecompress)*

*Defined at line 395 of ./engine/client/s_mix.cpp*

### S_ShouldContinueMixing

*qboolean S_ShouldContinueMixing(channel_t * ch)*

*Defined at line 512 of ./engine/client/s_mix.cpp*

### MIX_MixChannelsToPaintbuffer

*void MIX_MixChannelsToPaintbuffer(int endtime, int rate, int outputRate)*

*Defined at line 533 of ./engine/client/s_mix.cpp*

 Mix all channels into active paintbuffers until paintbuffer is full or 'endtime' is reached. endtime: time in 44khz samples to mix rate: ignore samples which are not natively at this rate (for multipass mixing/filtering) if rate == SOUND_ALL_RATES then mix all samples this pass flags: if SOUND_MIX_DRY, then mix only samples with channel flagged as 'dry' outputRate: target mix rate for all samples.  Note, if outputRate = SOUND_DMA_SPEED, then this routine will fill the paintbuffer to endtime.  Otherwise, fewer samples are mixed. if( endtime - paintedtime ) is not aligned on boundaries of 4,  we'll miss data if outputRate < SOUND_DMA_SPEED!

### S_GetNextpFilter

*portable_samplepair_t * S_GetNextpFilter(int i, portable_samplepair_t * pbuffer, portable_samplepair_t * pfiltermem)*

*Defined at line 643 of ./engine/client/s_mix.cpp*

 pass in index -1...count+2, return pointer to source sample in either paintbuffer or delay buffer

### S_Interpolate2xCubic

*void S_Interpolate2xCubic(portable_samplepair_t * pbuffer, portable_samplepair_t * pfiltermem, int cfltmem, int count)*

*Defined at line 661 of ./engine/client/s_mix.cpp*

 pass forward over passed in buffer and cubic interpolate all odd samples pbuffer: buffer to filter (in place) prevfilter:  filter memory. NOTE: this must match the filtertype ie: filtercubic[] for FILTERTYPE_CUBIC if NULL then perform no filtering. count: how many samples to upsample. will become count*2 samples in buffer, in place.

### S_Interpolate2xLinear

*void S_Interpolate2xLinear(portable_samplepair_t * pbuffer, portable_samplepair_t * pfiltermem, int cfltmem, int count)*

*Defined at line 754 of ./engine/client/s_mix.cpp*

 pass forward over passed in buffer and linearly interpolate all odd samples pbuffer: buffer to filter (in place) prevfilter:  filter memory. NOTE: this must match the filtertype ie: filterlinear[] for FILTERTYPE_LINEAR if NULL then perform no filtering. count: how many samples to upsample. will become count*2 samples in buffer, in place.

### S_MixBufferUpsample2x

*void S_MixBufferUpsample2x(int count, portable_samplepair_t * pbuffer, portable_samplepair_t * pfiltermem, int cfltmem, int filtertype)*

*Defined at line 783 of ./engine/client/s_mix.cpp*

 upsample by 2x, optionally using interpolation count: how many samples to upsample. will become count*2 samples in buffer, in place. pbuffer: buffer to upsample into (in place) pfiltermem:  filter memory. NOTE: this must match the filtertype ie: filterlinear[] for FILTERTYPE_LINEAR if NULL then perform no filtering. cfltmem: max number of sample pairs filter can use filtertype: FILTERTYPE_NONE, _LINEAR, _CUBIC etc.  Must match prevfilter.

### MIX_MixPaintbuffers

*void MIX_MixPaintbuffers(int ibuf1, int ibuf2, int ibuf3, int count, float fgain)*

*Defined at line 836 of ./engine/client/s_mix.cpp*

 mixes pbuf1 + pbuf2 into pbuf3, count samples fgain is output gain 0-1.0 NOTE: pbuf3 may equal pbuf1 or pbuf2!

### MIX_CompressPaintbuffer

*void MIX_CompressPaintbuffer(int ipaint, int count)*

*Defined at line 869 of ./engine/client/s_mix.cpp*

### S_MixUpsample

*void S_MixUpsample(int sampleCount, int filtertype)*

*Defined at line 885 of ./engine/client/s_mix.cpp*

### MIX_MixStreamBuffer

*void MIX_MixStreamBuffer(int end)*

*Defined at line 898 of ./engine/client/s_mix.cpp*

### MIX_MixRawSamplesBuffer

*void MIX_MixRawSamplesBuffer(int end)*

*Defined at line 929 of ./engine/client/s_mix.cpp*

### MIX_UpsampleAllPaintbuffers

*void MIX_UpsampleAllPaintbuffers(int end, int count)*

*Defined at line 966 of ./engine/client/s_mix.cpp*

 upsample and mix sounds into final 44khz versions of: IROOMBUFFER, IFACINGBUFFER, IFACINGAWAY dsp fx are then applied to these buffers by the caller. caller also remixes all into final IPAINTBUFFER output.

### __MsgFunc_Geiger

*int __MsgFunc_Geiger(const char * pszName, int iSize, void * pbuf)*

*Defined at line 29 of ./game/client/geiger.cpp*

### KB_Find

*struct kbutton_s * KB_Find(const char * name)*

*Defined at line 223 of ./game/client/input.cpp*

============KB_Find

Allows the engine to get a kbutton_t directly ( so it can check +mlook state, etc ) for saving out to .cfg files============

### CL_CreateMove

*void CL_CreateMove(float frametime, struct usercmd_s * cmd, int active)*

*Defined at line 779 of ./game/client/input.cpp*

================CL_CreateMove

Send the intended movement message to the serverif active == 1 then we are 1) not playing back demos ( where our commands are ignored ) and2 ) we have finished signing on to server================

### HUD_Shutdown

*void HUD_Shutdown()*

*Defined at line 1134 of ./game/client/input.cpp*

### HUD_Key_Event

*int HUD_Key_Event(int eventcode, int keynum, const char * pszCurrentBinding)*

*Defined at line 381 of ./game/client/input.cpp*

============HUD_Key_Event

Return 1 to allow engine to process the key, otherwise, act on it as needed============

### IN_Move

*void IN_Move(float frametime, usercmd_t * cmd)*

*Defined at line 29 of ./game/client/input_mouse.cpp*

### KB_Add

*void KB_Add(const char * name, kbutton_t * pkb)*

*Defined at line 244 of ./game/client/input.cpp*

============KB_Add

Add a kbutton_t * to the list of pointers the engine can retrieve via KB_Find============

### KB_Init

*void KB_Init()*

*Defined at line 271 of ./game/client/input.cpp*

============KB_Init

Add kbutton_t definitions that the engine can query if needed============

### KB_Shutdown

*void KB_Shutdown()*

*Defined at line 287 of ./game/client/input.cpp*

============KB_Shutdown

Clear kblist============

### IN_BreakDown

*void IN_BreakDown()*

*Defined at line 386 of ./game/client/input.cpp*

### IN_BreakUp

*void IN_BreakUp()*

*Defined at line 391 of ./game/client/input.cpp*

### IN_KLookDown

*void IN_KLookDown()*

*Defined at line 396 of ./game/client/input.cpp*

### IN_KLookUp

*void IN_KLookUp()*

*Defined at line 401 of ./game/client/input.cpp*

### IN_JLookDown

*void IN_JLookDown()*

*Defined at line 406 of ./game/client/input.cpp*

### IN_JLookUp

*void IN_JLookUp()*

*Defined at line 411 of ./game/client/input.cpp*

### IN_MLookDown

*void IN_MLookDown()*

*Defined at line 416 of ./game/client/input.cpp*

### IN_UpDown

*void IN_UpDown()*

*Defined at line 421 of ./game/client/input.cpp*

### IN_UpUp

*void IN_UpUp()*

*Defined at line 426 of ./game/client/input.cpp*

### IN_DownDown

*void IN_DownDown()*

*Defined at line 431 of ./game/client/input.cpp*

### IN_DownUp

*void IN_DownUp()*

*Defined at line 436 of ./game/client/input.cpp*

### IN_LeftDown

*void IN_LeftDown()*

*Defined at line 441 of ./game/client/input.cpp*

### IN_LeftUp

*void IN_LeftUp()*

*Defined at line 446 of ./game/client/input.cpp*

### IN_RightDown

*void IN_RightDown()*

*Defined at line 451 of ./game/client/input.cpp*

### IN_RightUp

*void IN_RightUp()*

*Defined at line 456 of ./game/client/input.cpp*

### IN_ForwardDown

*void IN_ForwardDown()*

*Defined at line 461 of ./game/client/input.cpp*

### IN_ForwardUp

*void IN_ForwardUp()*

*Defined at line 467 of ./game/client/input.cpp*

### IN_BackDown

*void IN_BackDown()*

*Defined at line 473 of ./game/client/input.cpp*

### IN_BackUp

*void IN_BackUp()*

*Defined at line 479 of ./game/client/input.cpp*

### IN_LookupDown

*void IN_LookupDown()*

*Defined at line 485 of ./game/client/input.cpp*

### IN_LookupUp

*void IN_LookupUp()*

*Defined at line 490 of ./game/client/input.cpp*

### IN_LookdownDown

*void IN_LookdownDown()*

*Defined at line 495 of ./game/client/input.cpp*

### IN_LookdownUp

*void IN_LookdownUp()*

*Defined at line 500 of ./game/client/input.cpp*

### IN_MoveleftDown

*void IN_MoveleftDown()*

*Defined at line 505 of ./game/client/input.cpp*

### IN_MoveleftUp

*void IN_MoveleftUp()*

*Defined at line 511 of ./game/client/input.cpp*

### IN_MoverightDown

*void IN_MoverightDown()*

*Defined at line 517 of ./game/client/input.cpp*

### IN_MoverightUp

*void IN_MoverightUp()*

*Defined at line 523 of ./game/client/input.cpp*

### IN_SpeedDown

*void IN_SpeedDown()*

*Defined at line 529 of ./game/client/input.cpp*

### IN_SpeedUp

*void IN_SpeedUp()*

*Defined at line 534 of ./game/client/input.cpp*

### IN_StrafeDown

*void IN_StrafeDown()*

*Defined at line 539 of ./game/client/input.cpp*

### IN_StrafeUp

*void IN_StrafeUp()*

*Defined at line 544 of ./game/client/input.cpp*

### IN_Attack2Down

*void IN_Attack2Down()*

*Defined at line 552 of ./game/client/input.cpp*

### IN_Attack2Up

*void IN_Attack2Up()*

*Defined at line 559 of ./game/client/input.cpp*

### IN_UseDown

*void IN_UseDown()*

*Defined at line 564 of ./game/client/input.cpp*

### IN_UseUp

*void IN_UseUp()*

*Defined at line 569 of ./game/client/input.cpp*

### IN_JumpDown

*void IN_JumpDown()*

*Defined at line 573 of ./game/client/input.cpp*

### IN_JumpUp

*void IN_JumpUp()*

*Defined at line 579 of ./game/client/input.cpp*

### IN_DuckDown

*void IN_DuckDown()*

*Defined at line 584 of ./game/client/input.cpp*

### IN_DuckUp

*void IN_DuckUp()*

*Defined at line 590 of ./game/client/input.cpp*

### IN_ReloadDown

*void IN_ReloadDown()*

*Defined at line 595 of ./game/client/input.cpp*

### IN_ReloadUp

*void IN_ReloadUp()*

*Defined at line 600 of ./game/client/input.cpp*

### IN_Alt1Down

*void IN_Alt1Down()*

*Defined at line 605 of ./game/client/input.cpp*

### IN_Alt1Up

*void IN_Alt1Up()*

*Defined at line 610 of ./game/client/input.cpp*

### IN_GraphDown

*void IN_GraphDown()*

*Defined at line 615 of ./game/client/input.cpp*

### IN_GraphUp

*void IN_GraphUp()*

*Defined at line 620 of ./game/client/input.cpp*

### IN_AttackDown

*void IN_AttackDown()*

*Defined at line 625 of ./game/client/input.cpp*

### IN_AttackUp

*void IN_AttackUp()*

*Defined at line 631 of ./game/client/input.cpp*

### IN_Cancel

*void IN_Cancel()*

*Defined at line 638 of ./game/client/input.cpp*

 Special handling

### IN_Impulse

*void IN_Impulse()*

*Defined at line 643 of ./game/client/input.cpp*

### IN_ScoreDown

*void IN_ScoreDown()*

*Defined at line 648 of ./game/client/input.cpp*

### IN_ScoreUp

*void IN_ScoreUp()*

*Defined at line 653 of ./game/client/input.cpp*

### IN_MLookUp

*void IN_MLookUp()*

*Defined at line 658 of ./game/client/input.cpp*

### CL_AdjustAngles

*void CL_AdjustAngles(float frametime, float * viewangles)*

*Defined at line 726 of ./game/client/input.cpp*

================CL_AdjustAngles

Moves the local angle positions================

### InitInput

*void InitInput()*

*Defined at line 1041 of ./game/client/input.cpp*

============InitInput============

### SV_InitBoxHull

*void SV_InitBoxHull()*

*Defined at line 55 of ./engine/server/sv_world.cpp*

===================SV_InitBoxHull

Set up the planes and clipnodes so that the six floats of a bounding boxcan just be stored out and get a proper hull_t structure.===================

### SV_StudioPlayerBlend

*void SV_StudioPlayerBlend(mstudioseqdesc_t * pseqdesc, int * pBlend, float * pPitch)*

*Defined at line 87 of ./engine/server/sv_world.cpp*

====================StudioPlayerBlend

====================

### SV_CheckSphereIntersection

*qboolean SV_CheckSphereIntersection(edict_t * ent, const vec3_t start, const vec3_t end)*

*Defined at line 118 of ./engine/server/sv_world.cpp*

====================SV_CheckSphereIntersection

check clients only====================

### SV_HullForBox

*hull_t * SV_HullForBox(const vec3_t mins, const vec3_t maxs)*

*Defined at line 161 of ./engine/server/sv_world.cpp*

===================SV_HullForBox

To keep everything totally uniform, bounding boxes are turned into smallBSP trees instead of being compared directly.===================

### SV_HullAutoSelect

*hull_t * SV_HullAutoSelect(model_t * model, const vec3_t mins, const vec3_t maxs, const vec3_t size, vec3_t offset)*

*Defined at line 180 of ./engine/server/sv_world.cpp*

==================SV_HullAutoSelect

select the apropriate hull automatically==================

### SV_HullForBsp

*hull_t * SV_HullForBsp(edict_t * ent, const vec3_t mins, const vec3_t maxs, vec3_t offset)*

*Defined at line 220 of ./engine/server/sv_world.cpp*

==================SV_HullForBsp

forcing to select BSP hull==================

### SV_HullForEntity

*hull_t * SV_HullForEntity(edict_t * ent, vec3_t mins, vec3_t maxs, vec3_t offset)*

*Defined at line 292 of ./engine/server/sv_world.cpp*

================SV_HullForEntity

Returns a hull that can be used for testing or clipping an object of mins/maxssize.Offset is filled in to contain the adjustment that must be added to thetesting object's origin to get a point to use with the returned hull.================

### SV_HullForStudioModel

*hull_t * SV_HullForStudioModel(edict_t * ent, vec3_t mins, vec3_t maxs, vec3_t offset, int * numhitboxes)*

*Defined at line 325 of ./engine/server/sv_world.cpp*

====================SV_HullForStudioModel

====================

### SV_CreateAreaNode

*areanode_t * SV_CreateAreaNode(int depth, vec3_t mins, vec3_t maxs)*

*Defined at line 419 of ./engine/server/sv_world.cpp*

===============SV_CreateAreaNode

builds a uniformly subdivided tree for the given world size===============

### SV_FindTouchedLeafs

*void SV_FindTouchedLeafs(edict_t * ent, mnode_t * node, int * headnode)*

*Defined at line 590 of ./engine/server/sv_world.cpp*

===============SV_FindTouchedLeafs

===============

### SV_WaterLinks

*void SV_WaterLinks(const vec3_t origin, int * pCont, areanode_t * node)*

*Defined at line 707 of ./engine/server/sv_world.cpp*

===============================================================================

POINT TESTING IN HULLS

===============================================================================

### SV_PortalCSG

*void SV_PortalCSG(edict_t * portal, const vec3_t trace_mins, const vec3_t trace_maxs, const vec3_t start, const vec3_t end, trace_t * trace)*

*Defined at line 1001 of ./engine/server/sv_world.cpp*

==================SV_PortalCSG

a portal is flush with a world surface behind it. this causes problems. namely that we can't pass through the portal planeif the bsp behind it prevents out origin from getting through. so if the trace was clipped and ended infront of the portal,continue the trace to the edges of the portal cutout instead.==================

### SV_ClipToEntity

*qboolean SV_ClipToEntity(edict_t * touch, moveclip_t * clip)*

*Defined at line 1141 of ./engine/server/sv_world.cpp*

====================SV_ClipToEntity

generic clip function====================

### SV_ClipToLinks

*void SV_ClipToLinks(areanode_t * node, moveclip_t * clip)*

*Defined at line 1245 of ./engine/server/sv_world.cpp*

====================SV_ClipToLinks

Mins and maxs enclose the entire area swept by the move====================

### SV_ClipToPortals

*void SV_ClipToPortals(areanode_t * node, moveclip_t * clip)*

*Defined at line 1277 of ./engine/server/sv_world.cpp*

====================SV_ClipToPortals

Mins and maxs enclose the entire area swept by the move====================

### SV_ClipToWorldBrush

*void SV_ClipToWorldBrush(areanode_t * node, moveclip_t * clip)*

*Defined at line 1309 of ./engine/server/sv_world.cpp*

====================SV_ClipToWorldBrush

Mins and maxs enclose the entire area swept by the move====================

### SV_RecursiveLightPoint

*qboolean SV_RecursiveLightPoint(model_t * model, mnode_t * node, const vec3_t start, const vec3_t end)*

*Defined at line 1559 of ./engine/server/sv_world.cpp*

=================SV_RecursiveLightPoint=================

### EntSelectSpawnPoint

*edict_t * EntSelectSpawnPoint(class CBaseEntity * pPlayer)*

*Defined at line 2662 of ./game/server/player.cpp*

============EntSelectSpawnPoint

Returns the entity to spawn at

USES AND SETS GLOBAL g_pLastSpawn============

### _internal_isspace

*_Bool _internal_isspace(char c)*

*Defined at line 18 of ./public/keyvalues.cpp*

### R_ClearScreen

*void R_ClearScreen()*

*Defined at line 22 of ./ref_gl/gl_context.cpp*

### R_GetTextureOriginalBuffer

*const byte * R_GetTextureOriginalBuffer(unsigned int idx)*

*Defined at line 28 of ./ref_gl/gl_context.cpp*

### CL_FillRGBA

*void CL_FillRGBA(float _x, float _y, float _w, float _h, int r, int g, int b, int a)*

*Defined at line 44 of ./ref_gl/gl_context.cpp*

=============CL_FillRGBA

=============

### CL_FillRGBABlend

*void CL_FillRGBABlend(float _x, float _y, float _w, float _h, int r, int g, int b, int a)*

*Defined at line 70 of ./ref_gl/gl_context.cpp*

=============pfnFillRGBABlend

=============

### GL_RefGetParm

*int GL_RefGetParm(int parm, int arg)*

*Defined at line 162 of ./ref_gl/gl_context.cpp*

### R_GetDetailScaleForTexture

*void R_GetDetailScaleForTexture(int texture, float * xScale, float * yScale)*

*Defined at line 244 of ./ref_gl/gl_context.cpp*

### R_GetExtraParmsForTexture

*void R_GetExtraParmsForTexture(int texture, byte * red, byte * green, byte * blue, byte * density)*

*Defined at line 252 of ./ref_gl/gl_context.cpp*

### R_SetCurrentEntity

*void R_SetCurrentEntity(cl_entity_t * ent)*

*Defined at line 263 of ./ref_gl/gl_context.cpp*

### R_SetCurrentModel

*void R_SetCurrentModel(model_t * mod)*

*Defined at line 274 of ./ref_gl/gl_context.cpp*

### R_GetFrameTime

*float R_GetFrameTime()*

*Defined at line 279 of ./ref_gl/gl_context.cpp*

### GL_TextureName

*const char * GL_TextureName(unsigned int texnum)*

*Defined at line 284 of ./ref_gl/gl_context.cpp*

### R_GetConfigName

*const char * R_GetConfigName()*

*Defined at line 311 of ./ref_gl/gl_context.cpp*

### UtlMemory_CalcNewAllocationCount

*int UtlMemory_CalcNewAllocationCount(int nAllocationCount, int nGrowSize, int nNewSize, int nBytesItem)*

*Defined at line 182 of ./mainui/miniutl/utlmemory.cpp*

----------------------------------------------------------------------------- Grows the memory-----------------------------------------------------------------------------

### monster_alien_controller

*void monster_alien_controller(entvars_t * pev)*

*Defined at line 105 of ./game/server/ai/ai_controller.cpp*

### Intersect

*Vector Intersect(Vector vecSrc, Vector vecDst, Vector vecMove, float flSpeed)*

*Defined at line 547 of ./game/server/ai/ai_controller.cpp*

### controller_head_ball

*void controller_head_ball(entvars_t * pev)*

*Defined at line 1121 of ./game/server/ai/ai_controller.cpp*

### controller_energy_ball

*void controller_energy_ball(entvars_t * pev)*

*Defined at line 1304 of ./game/server/ai/ai_controller.cpp*

### BloomFilter_Process

*bloomfilter_t BloomFilter_Process(const char * buffer, int size)*

*Defined at line 38 of ./engine/common/identification.cpp*

### BloomFilter_ProcessStr

*bloomfilter_t BloomFilter_ProcessStr(const char * buffer)*

*Defined at line 58 of ./engine/common/identification.cpp*

### BloomFilter_Weight

*uint BloomFilter_Weight(bloomfilter_t value)*

*Defined at line 63 of ./engine/common/identification.cpp*

### BloomFilter_ContainsString

*qboolean BloomFilter_ContainsString(bloomfilter_t filter, const char * str)*

*Defined at line 80 of ./engine/common/identification.cpp*

### ID_ProcessFile

*qboolean ID_ProcessFile(bloomfilter_t * value, const char * path)*

*Defined at line 294 of ./engine/common/identification.cpp*

### ID_BloomFilter_f

*void ID_BloomFilter_f()*

*Defined at line 99 of ./engine/common/identification.cpp*

### ID_VerifyHEX

*qboolean ID_VerifyHEX(const char * hex)*

*Defined at line 114 of ./engine/common/identification.cpp*

### ID_VerifyHEX_f

*void ID_VerifyHEX_f()*

*Defined at line 156 of ./engine/common/identification.cpp*

### ID_ProcessCPUInfo

*qboolean ID_ProcessCPUInfo(bloomfilter_t * value)*

*Defined at line 166 of ./engine/common/identification.cpp*

### ID_ValidateNetDevice

*qboolean ID_ValidateNetDevice(const char * dev)*

*Defined at line 202 of ./engine/common/identification.cpp*

### ID_ProcessNetDevices

*int ID_ProcessNetDevices(bloomfilter_t * value)*

*Defined at line 230 of ./engine/common/identification.cpp*

### ID_CheckNetDevices

*int ID_CheckNetDevices(bloomfilter_t value)*

*Defined at line 254 of ./engine/common/identification.cpp*

### ID_TestCPUInfo_f

*void ID_TestCPUInfo_f()*

*Defined at line 282 of ./engine/common/identification.cpp*

### ID_ProcessFiles

*int ID_ProcessFiles(bloomfilter_t * value, const char * prefix, const char * postfix)*

*Defined at line 321 of ./engine/common/identification.cpp*

### ID_CheckFiles

*int ID_CheckFiles(bloomfilter_t value, const char * prefix, const char * postfix)*

*Defined at line 341 of ./engine/common/identification.cpp*

### ID_GenerateRawId

*bloomfilter_t ID_GenerateRawId()*

*Defined at line 490 of ./engine/common/identification.cpp*

### ID_CheckRawId

*uint ID_CheckRawId(bloomfilter_t filter)*

*Defined at line 523 of ./engine/common/identification.cpp*

### ID_Check

*void ID_Check()*

*Defined at line 567 of ./engine/common/identification.cpp*

### SetObjectCollisionBox

*void SetObjectCollisionBox(entvars_t * pev)*

*Defined at line 171 of ./game/shared/c_base_entity.cpp*

 Initialize absmin & absmax to the appropriate box

### weapon_handgrenade

*void weapon_handgrenade(entvars_t * pev)*

*Defined at line 38 of ./game/shared/hl1/weapon_frag.cpp*

### R_DecalUnlink

*void R_DecalUnlink(decal_t * pdecal)*

*Defined at line 65 of ./rendersystem/r_decals.cpp*

 unlink pdecal from any surface it's attached to

### R_DecalAlloc

*decal_t * R_DecalAlloc(decal_t * pdecal)*

*Defined at line 102 of ./rendersystem/r_decals.cpp*

 Just reuse next decal in list A decal that spans multiple surfaces will use multiple decal_t pool entries, as each surface needs it's own.

### R_GetDecalDimensions

*void R_GetDecalDimensions(int texture, int * width, int * height)*

*Defined at line 136 of ./rendersystem/r_decals.cpp*

----------------------------------------------------------------------------- find decal image and grab size from it-----------------------------------------------------------------------------

### SHClip

*int SHClip(float * vert, int vertCount, float * out, int edge)*

*Defined at line 309 of ./rendersystem/r_decals.cpp*

### R_DecalVertsLight

*void R_DecalVertsLight(float * v, msurface_t * surf, int vertCount)*

*Defined at line 393 of ./rendersystem/r_decals.cpp*

 Generate lighting coordinates at each vertex for decal vertices v[] on surface psurf

### R_DecalIntersect

*decal_t * R_DecalIntersect(decalinfo_t * decalinfo, msurface_t * surf, int * pcount)*

*Defined at line 423 of ./rendersystem/r_decals.cpp*

 Check for intersecting decals on this surface

### R_AddDecalToSurface

*void R_AddDecalToSurface(decal_t * pdecal, msurface_t * surf, decalinfo_t * decalinfo)*

*Defined at line 546 of ./rendersystem/r_decals.cpp*

 Add the decal to the surface's list of decals.

### R_DecalCreate

*void R_DecalCreate(decalinfo_t * decalinfo, msurface_t * surf, float x, float y)*

*Defined at line 576 of ./rendersystem/r_decals.cpp*

### R_DecalNodeSurfaces

*void R_DecalNodeSurfaces(model_t * model, mnode_t * node, decalinfo_t * decalinfo)*

*Defined at line 685 of ./rendersystem/r_decals.cpp*

----------------------------------------------------------------------------- iterate over all surfaces on a node, looking for surfaces to decal-----------------------------------------------------------------------------

### R_DecalNode

*void R_DecalNode(model_t * model, mnode_t * node, decalinfo_t * decalinfo)*

*Defined at line 711 of ./rendersystem/r_decals.cpp*

----------------------------------------------------------------------------- Recursive routine to find surface to apply a decal to.  World coordinates of  the decal are passed in r_recalpos like the rest of the engine.  This should  be called through R_DecalShoot()-----------------------------------------------------------------------------

### R_DecalUnProject

*qboolean R_DecalUnProject(decal_t * pdecal, decallist_t * entry)*

*Defined at line 1097 of ./rendersystem/r_decals.cpp*

=============================================================

  DECALS SERIALIZATION

=============================================================

### DecalListAdd

*int DecalListAdd(decallist_t * pList, int count)*

*Defined at line 1119 of ./rendersystem/r_decals.cpp*

----------------------------------------------------------------------------- Purpose:  Input  : *pList - 			count -  Output : static int-----------------------------------------------------------------------------

### DecalDepthCompare

*int DecalDepthCompare(const void * a, const void * b)*

*Defined at line 1142 of ./rendersystem/r_decals.cpp*

### UI_GamePad_Precache

*void UI_GamePad_Precache()*

*Defined at line 282 of ./mainui/menus/Gamepad.cpp*

=================CMenuGamePad::Precache=================

### SV_AngularMove

*void SV_AngularMove(edict_t * ent, float frametime, float friction)*

*Defined at line 303 of ./engine/server/sv_phys.cpp*

=============SV_AngularMove

may use friction for smooth stopping=============

### SV_LinearMove

*void SV_LinearMove(edict_t * ent, float frametime, float friction)*

*Defined at line 337 of ./engine/server/sv_phys.cpp*

=============SV_LinearMove

use friction for smooth stopping=============

### SV_RecursiveWaterLevel

*float SV_RecursiveWaterLevel(vec3_t origin, float out, float in, int count)*

*Defined at line 371 of ./engine/server/sv_phys.cpp*

=============SV_RecursiveWaterLevel

recursively recalculating the middle=============

### SV_Submerged

*float SV_Submerged(edict_t * ent)*

*Defined at line 393 of ./engine/server/sv_phys.cpp*

=============SV_Submerged

determine how deep the entity is=============

### SV_CheckMover

*qboolean SV_CheckMover(edict_t * ent)*

*Defined at line 493 of ./engine/server/sv_phys.cpp*

=============SV_CheckMover

test thing (applies the friction to pushables while standing on moving platform)=============

### SV_ClipVelocity

*int SV_ClipVelocity(vec3_t in, vec3_t normal, vec3_t out, float overbounce)*

*Defined at line 516 of ./engine/server/sv_phys.cpp*

==================SV_ClipVelocity

Slide off of the impacting object==================

### SV_FlyMove

*int SV_FlyMove(edict_t * ent, float time, trace_t * steptrace)*

*Defined at line 559 of ./engine/server/sv_phys.cpp*

===============================================================================

	FLYING MOVEMENT CODE

===============================================================================

============SV_FlyMove

The basic solid body movement clip that slides along multiple planessteptrace - if not NULL, the trace results of any vertical wall hit will be storedReturns the clipflags if the velocity was modified (hit something solid)1 = floor2 = wall / step4 = dead stop============

### SV_AddGravity

*void SV_AddGravity(edict_t * ent)*

*Defined at line 703 of ./engine/server/sv_phys.cpp*

============SV_AddGravity

============

### SV_AddHalfGravity

*void SV_AddHalfGravity(edict_t * ent, float timestep)*

*Defined at line 726 of ./engine/server/sv_phys.cpp*

============SV_AddHalfGravity

============

### SV_AllowPushRotate

*qboolean SV_AllowPushRotate(edict_t * ent)*

*Defined at line 757 of ./engine/server/sv_phys.cpp*

===============================================================================

PUSHMOVE

===============================================================================

============SV_AllowPushRotate

Allows to change entity yaw?============

### SV_PushEntity

* SV_PushEntity(edict_t * ent, const vec3_t lpush, const vec3_t apush, int * blocked, float flDamage)*

*Defined at line 782 of ./engine/server/sv_phys.cpp*

============SV_PushEntity

Does not change the entities velocity at all============

### SV_CanBlock

*qboolean SV_CanBlock(edict_t * ent)*

*Defined at line 866 of ./engine/server/sv_phys.cpp*

============SV_CanBlock

allow entity to block pusher?============

### SV_PushMove

*edict_t * SV_PushMove(edict_t * pusher, float movetime)*

*Defined at line 888 of ./engine/server/sv_phys.cpp*

============SV_PushMove

============

### SV_PushRotate

*edict_t * SV_PushRotate(edict_t * pusher, float movetime)*

*Defined at line 1005 of ./engine/server/sv_phys.cpp*

============SV_PushRotate

============

### SV_Physics_Pusher

*void SV_Physics_Pusher(edict_t * ent)*

*Defined at line 1143 of ./engine/server/sv_phys.cpp*

================SV_Physics_Pusher

================

### SV_Physics_Follow

*void SV_Physics_Follow(edict_t * ent)*

*Defined at line 1217 of ./engine/server/sv_phys.cpp*

============================================================================

=============SV_Physics_Follow

just copy angles and origin of parent=============

### SV_Physics_Compound

*void SV_Physics_Compound(edict_t * ent)*

*Defined at line 1245 of ./engine/server/sv_phys.cpp*

=============SV_Physics_Compound

a glue two entities together=============

### SV_Physics_Noclip

*void SV_Physics_Noclip(edict_t * ent)*

*Defined at line 1325 of ./engine/server/sv_phys.cpp*

=============SV_PhysicsNoclip

A moving object that doesn't obey physics=============

### SV_CheckWaterTransition

*void SV_CheckWaterTransition(edict_t * ent)*

*Defined at line 1352 of ./engine/server/sv_phys.cpp*

==============================================================================

TOSS / BOUNCE

==============================================================================

=============SV_CheckWaterTransition

=============

### SV_Physics_Toss

*void SV_Physics_Toss(edict_t * ent)*

*Defined at line 1425 of ./engine/server/sv_phys.cpp*

=============SV_Physics_Toss

Toss, bounce, and fly movement.  When onground, do nothing.=============

### SV_Physics_Step

*void SV_Physics_Step(edict_t * ent)*

*Defined at line 1571 of ./engine/server/sv_phys.cpp*

===============================================================================

STEPPING MOVEMENT

===============================================================================

=============SV_Physics_Step

Monsters freefall when they don't have a ground entity, otherwiseall movement is done with discrete steps.

This is also used for objects that have become still on the ground, butwill fall if the floor is pulled out from under them.=============

### SV_Physics_None

*void SV_Physics_None(edict_t * ent)*

*Defined at line 1703 of ./engine/server/sv_phys.cpp*

=============SV_PhysicsNone

Non moving objects can only think=============

### SV_Physics_Entity

*void SV_Physics_Entity(edict_t * ent)*

*Defined at line 1709 of ./engine/server/sv_phys.cpp*

============================================================================

### SV_GetServerTime

*double SV_GetServerTime()*

*Defined at line 1826 of ./engine/server/sv_phys.cpp*

================SV_GetServerTime

Inplementation for new physics interface================

### SV_GetFrameTime

*double SV_GetFrameTime()*

*Defined at line 1838 of ./engine/server/sv_phys.cpp*

================SV_GetFrameTime

Inplementation for new physics interface================

### SV_GetHeadNode

*areanode_t * SV_GetHeadNode()*

*Defined at line 1850 of ./engine/server/sv_phys.cpp*

================SV_GetHeadNode

Inplementation for new physics interface================

### SV_ServerState

*int SV_ServerState()*

*Defined at line 1862 of ./engine/server/sv_phys.cpp*

================SV_ServerState

Inplementation for new physics interface================

### SV_UpdateFogSettings

*void SV_UpdateFogSettings(unsigned int packed_fog)*

*Defined at line 1922 of ./engine/server/sv_phys.cpp*

### pfnGetFilesList

*char ** pfnGetFilesList(const char * pattern, int * numFiles, int gamedironly)*

*Defined at line 1934 of ./engine/server/sv_phys.cpp*

=========pfnGetFilesList

=========

### pfnMem_Alloc

*void * pfnMem_Alloc(size_t cb, const char * filename, const int fileline)*

*Defined at line 1952 of ./engine/server/sv_phys.cpp*

### pfnMem_Free

*void pfnMem_Free(void * mem, const char * filename, const int fileline)*

*Defined at line 1957 of ./engine/server/sv_phys.cpp*

### pfnPointContents

*int pfnPointContents(const float * pos, int groupmask)*

*Defined at line 1969 of ./engine/server/sv_phys.cpp*

=============pfnPointContents

=============

### pfnLoadImagePixels

*const byte * pfnLoadImagePixels(const char * filename, int * width, int * height)*

*Defined at line 1983 of ./engine/server/sv_phys.cpp*

### pfnGetModelName

*const char * pfnGetModelName(int modelindex)*

*Defined at line 1999 of ./engine/server/sv_phys.cpp*

### GL_TextureData

*const byte * GL_TextureData(unsigned int texnum)*

*Defined at line 2006 of ./engine/server/sv_phys.cpp*

### UI_Zoo_Precache

*void UI_Zoo_Precache()*

*Defined at line 156 of ./mainui/menus/Zoo.cpp*

### SV_RemoveID

*void SV_RemoveID(const char * id)*

*Defined at line 44 of ./engine/server/sv_filter.cpp*

### SV_RemoveIP

*void SV_RemoveIP(uint ip, uint mask)*

*Defined at line 70 of ./engine/server/sv_filter.cpp*

### SV_BanID_f

*void SV_BanID_f()*

*Defined at line 153 of ./engine/server/sv_filter.cpp*

### SV_ListID_f

*void SV_ListID_f()*

*Defined at line 227 of ./engine/server/sv_filter.cpp*

### SV_RemoveID_f

*void SV_RemoveID_f()*

*Defined at line 246 of ./engine/server/sv_filter.cpp*

### SV_WriteID_f

*void SV_WriteID_f()*

*Defined at line 269 of ./engine/server/sv_filter.cpp*

### StringToIP

*qboolean StringToIP(const char * str, const char * maskstr, uint * outip, uint * outmask)*

*Defined at line 292 of ./engine/server/sv_filter.cpp*

### SV_AddIP_f

*void SV_AddIP_f()*

*Defined at line 344 of ./engine/server/sv_filter.cpp*

### SV_ListIP_f

*void SV_ListIP_f()*

*Defined at line 372 of ./engine/server/sv_filter.cpp*

### SV_RemoveIP_f

*void SV_RemoveIP_f()*

*Defined at line 391 of ./engine/server/sv_filter.cpp*

### SV_WriteIP_f

*void SV_WriteIP_f()*

*Defined at line 404 of ./engine/server/sv_filter.cpp*

### monster_rat

*void monster_rat(entvars_t * pev)*

*Defined at line 38 of ./game/server/npc/npc_rat.cpp*

### create_decoder

*void * create_decoder(int * error)*

*Defined at line 19 of ./engine/common/soundlib/libmpg/libmpg.cpp*

### feed_mpeg_header

*int feed_mpeg_header(void * mpg, const byte * data, long bufsize, long streamsize, wavinfo_t * sc)*

*Defined at line 42 of ./engine/common/soundlib/libmpg/libmpg.cpp*

### feed_mpeg_stream

*int feed_mpeg_stream(void * mpg, const byte * data, long bufsize, byte * outbuf, size_t * outsize)*

*Defined at line 70 of ./engine/common/soundlib/libmpg/libmpg.cpp*

### open_mpeg_stream

*int open_mpeg_stream(void * mpg, void * file, pfread f_read, pfseek f_seek, wavinfo_t * sc)*

*Defined at line 83 of ./engine/common/soundlib/libmpg/libmpg.cpp*

### read_mpeg_stream

*int read_mpeg_stream(void * mpg, byte * outbuf, size_t * outsize)*

*Defined at line 109 of ./engine/common/soundlib/libmpg/libmpg.cpp*

### get_stream_pos

*int get_stream_pos(void * mpg)*

*Defined at line 120 of ./engine/common/soundlib/libmpg/libmpg.cpp*

### set_stream_pos

*int set_stream_pos(void * mpg, int curpos)*

*Defined at line 125 of ./engine/common/soundlib/libmpg/libmpg.cpp*

### close_decoder

*void close_decoder(void * mpg)*

*Defined at line 130 of ./engine/common/soundlib/libmpg/libmpg.cpp*

### Mod_LoadLump

*void Mod_LoadLump(const byte * in, mlumpinfo_t * info, mlumpstat_t * stat, int flags)*

*Defined at line 222 of ./engine/common/mod_bmodel.cpp*

===============================================================================

			MAP PROCESSING

===============================================================================

=================Mod_LoadLump

generic loader=================

### Mod_ArrayUsage

*int Mod_ArrayUsage(const char * szItem, int items, int maxitems, int itemsize)*

*Defined at line 358 of ./engine/common/mod_bmodel.cpp*

================Mod_ArrayUsage================

### Mod_GlobUsage

*int Mod_GlobUsage(const char * szItem, int itemstorage, int maxstorage)*

*Defined at line 380 of ./engine/common/mod_bmodel.cpp*

================Mod_GlobUsage================

### Mod_DecompressPVS

*byte * Mod_DecompressPVS(const byte * in, int visbytes)*

*Defined at line 454 of ./engine/common/mod_bmodel.cpp*

===============================================================================

			COMMON ROUTINES

===============================================================================

===================Mod_DecompressPVS===================

### Mod_FatPVS_RecursiveBSPNode

*void Mod_FatPVS_RecursiveBSPNode(const vec3_t org, float radius, byte * visbuffer, int visbytes, mnode_t * node)*

*Defined at line 552 of ./engine/common/mod_bmodel.cpp*

==================Mod_FatPVS_RecursiveBSPNode

==================

### Mod_BoxLeafnums_r

*void Mod_BoxLeafnums_r(leaflist_t * ll, mnode_t * node)*

*Defined at line 621 of ./engine/common/mod_bmodel.cpp*

======================================================================

LEAF LISTING

======================================================================

### Mod_BoxLeafnums

*int Mod_BoxLeafnums(const vec3_t mins, const vec3_t maxs, int * list, int listsize, int * topnode)*

*Defined at line 671 of ./engine/common/mod_bmodel.cpp*

==================Mod_BoxLeafnums==================

### Mod_FindModelOrigin

*void Mod_FindModelOrigin(const char * entities, const char * modelname, vec3_t origin)*

*Defined at line 772 of ./engine/common/mod_bmodel.cpp*

=================Mod_FindModelOrigin

routine to detect bmodels with origin-brush=================

### Mod_CheckWaterAlphaSupport

*qboolean Mod_CheckWaterAlphaSupport(dbspmodel_t * bmod)*

*Defined at line 834 of ./engine/common/mod_bmodel.cpp*

==================Mod_CheckWaterAlphaSupport

converted maps potential may don'tsupport water transparency==================

### Mod_GetFaceContents

*int Mod_GetFaceContents(const char * name)*

*Defined at line 894 of ./engine/common/mod_bmodel.cpp*

==================Mod_GetFaceContents

determine face contents by name==================

### Mod_GetVertexByNumber

*mvertex_t * Mod_GetVertexByNumber(model_t * mod, int surfedge)*

*Defined at line 921 of ./engine/common/mod_bmodel.cpp*

==================Mod_GetFaceContents

determine face contents by name==================

### Mod_MakeNormalAxial

*void Mod_MakeNormalAxial(vec3_t normal)*

*Defined at line 947 of ./engine/common/mod_bmodel.cpp*

==================Mod_MakeNormalAxial

remove jitter from near-axial normals==================

### Mod_LightMatrixFromTexMatrix

*void Mod_LightMatrixFromTexMatrix(const mtexinfo_t * tx, float [2][4] lmvecs)*

*Defined at line 973 of ./engine/common/mod_bmodel.cpp*

==================Mod_LightMatrixFromTexMatrix

compute lightmap matrix based on texture matrix==================

### Mod_CalcSurfaceExtents

*void Mod_CalcSurfaceExtents(msurface_t * surf)*

*Defined at line 1021 of ./engine/common/mod_bmodel.cpp*

=================Mod_CalcSurfaceExtents

Fills in surf->texturemins[] and surf->extents[]=================

### Mod_CalcSurfaceBounds

*void Mod_CalcSurfaceBounds(msurface_t * surf)*

*Defined at line 1102 of ./engine/common/mod_bmodel.cpp*

=================Mod_CalcSurfaceBounds

fills in surf->mins and surf->maxs=================

### Mod_CreateFaceBevels

*void Mod_CreateFaceBevels(msurface_t * surf)*

*Defined at line 1129 of ./engine/common/mod_bmodel.cpp*

=================Mod_CreateFaceBevels=================

### Mod_SetParent

*void Mod_SetParent(mnode_t * node, mnode_t * parent)*

*Defined at line 1189 of ./engine/common/mod_bmodel.cpp*

=================Mod_SetParent=================

### CountClipNodes_r

*void CountClipNodes_r(mclipnode_t * src, hull_t * hull, int nodenum)*

*Defined at line 1203 of ./engine/common/mod_bmodel.cpp*

==================CountClipNodes_r==================

### CountClipNodes32_r

*void CountClipNodes32_r(dclipnode32_t * src, hull_t * hull, int nodenum)*

*Defined at line 1221 of ./engine/common/mod_bmodel.cpp*

==================CountClipNodes32_r==================

### RemapClipNodes_r

*int RemapClipNodes_r(dclipnode32_t * srcnodes, hull_t * hull, int nodenum)*

*Defined at line 1239 of ./engine/common/mod_bmodel.cpp*

==================RemapClipNodes_r==================

### Mod_MakeHull0

*void Mod_MakeHull0()*

*Defined at line 1273 of ./engine/common/mod_bmodel.cpp*

=================Mod_MakeHull0

Duplicate the drawing hull structure as a clipping hull=================

### Mod_SetupHull

*void Mod_SetupHull(dbspmodel_t * bmod, model_t * mod, byte * mempool, int headnode, int hullnum)*

*Defined at line 1308 of ./engine/common/mod_bmodel.cpp*

=================Mod_SetupHull=================

### Mod_LoadColoredLighting

*qboolean Mod_LoadColoredLighting(dbspmodel_t * bmod)*

*Defined at line 1362 of ./engine/common/mod_bmodel.cpp*

=================Mod_LoadColoredLighting=================

### Mod_LoadDeluxemap

*void Mod_LoadDeluxemap(dbspmodel_t * bmod)*

*Defined at line 1414 of ./engine/common/mod_bmodel.cpp*

=================Mod_LoadDeluxemap=================

### Mod_SetupSubmodels

*void Mod_SetupSubmodels(dbspmodel_t * bmod)*

*Defined at line 1469 of ./engine/common/mod_bmodel.cpp*

=================Mod_SetupSubmodels

duplicate the basic informationfor embedded submodels=================

### Mod_LoadSubmodels

*void Mod_LoadSubmodels(dbspmodel_t * bmod)*

*Defined at line 1574 of ./engine/common/mod_bmodel.cpp*

===============================================================================

			MAP LOADING

===============================================================================

=================Mod_LoadSubmodels=================

### Mod_LoadEntities

*void Mod_LoadEntities(dbspmodel_t * bmod)*

*Defined at line 1632 of ./engine/common/mod_bmodel.cpp*

=================Mod_LoadEntities=================

### Mod_LoadPlanes

*void Mod_LoadPlanes(dbspmodel_t * bmod)*

*Defined at line 1747 of ./engine/common/mod_bmodel.cpp*

=================Mod_LoadPlanes=================

### Mod_LoadVertexes

*void Mod_LoadVertexes(dbspmodel_t * bmod)*

*Defined at line 1781 of ./engine/common/mod_bmodel.cpp*

=================Mod_LoadVertexes=================

### Mod_LoadEdges

*void Mod_LoadEdges(dbspmodel_t * bmod)*

*Defined at line 1817 of ./engine/common/mod_bmodel.cpp*

=================Mod_LoadEdges=================

### Mod_LoadSurfEdges

*void Mod_LoadSurfEdges(dbspmodel_t * bmod)*

*Defined at line 1852 of ./engine/common/mod_bmodel.cpp*

=================Mod_LoadSurfEdges=================

### Mod_LoadMarkSurfaces

*void Mod_LoadMarkSurfaces(dbspmodel_t * bmod)*

*Defined at line 1864 of ./engine/common/mod_bmodel.cpp*

=================Mod_LoadMarkSurfaces=================

### Mod_LoadTextures

*void Mod_LoadTextures(dbspmodel_t * bmod)*

*Defined at line 1901 of ./engine/common/mod_bmodel.cpp*

=================Mod_LoadTextures=================

### Mod_LoadTexInfo

*void Mod_LoadTexInfo(dbspmodel_t * bmod)*

*Defined at line 2204 of ./engine/common/mod_bmodel.cpp*

=================Mod_LoadTexInfo=================

### Mod_LoadSurfaces

*void Mod_LoadSurfaces(dbspmodel_t * bmod)*

*Defined at line 2251 of ./engine/common/mod_bmodel.cpp*

=================Mod_LoadSurfaces=================

### Mod_LoadNodes

*void Mod_LoadNodes(dbspmodel_t * bmod)*

*Defined at line 2405 of ./engine/common/mod_bmodel.cpp*

=================Mod_LoadNodes=================

### Mod_LoadLeafs

*void Mod_LoadLeafs(dbspmodel_t * bmod)*

*Defined at line 2470 of ./engine/common/mod_bmodel.cpp*

=================Mod_LoadLeafs=================

### Mod_LoadClipnodes

*void Mod_LoadClipnodes(dbspmodel_t * bmod)*

*Defined at line 2572 of ./engine/common/mod_bmodel.cpp*

=================Mod_LoadClipnodes=================

### Mod_LoadVisibility

*void Mod_LoadVisibility(dbspmodel_t * bmod)*

*Defined at line 2618 of ./engine/common/mod_bmodel.cpp*

=================Mod_LoadVisibility=================

### Mod_LoadLightVecs

*void Mod_LoadLightVecs(dbspmodel_t * bmod)*

*Defined at line 2629 of ./engine/common/mod_bmodel.cpp*

=================Mod_LoadLightVecs=================

### Mod_LoadShadowmap

*void Mod_LoadShadowmap(dbspmodel_t * bmod)*

*Defined at line 2648 of ./engine/common/mod_bmodel.cpp*

=================Mod_LoadShadowmap=================

### Mod_LoadLighting

*void Mod_LoadLighting(dbspmodel_t * bmod)*

*Defined at line 2666 of ./engine/common/mod_bmodel.cpp*

=================Mod_LoadLighting=================

### Mod_LoadBmodelLumps

*qboolean Mod_LoadBmodelLumps(const byte * mod_base, qboolean isworld)*

*Defined at line 2744 of ./engine/common/mod_bmodel.cpp*

=================Mod_LoadBmodelLumps

loading and processing bmodel=================

### ToggleInactiveInternalCb

*void ToggleInactiveInternalCb(class CMenuBaseItem * pSelf, void * pExtra)*

*Defined at line 221 of ./mainui/controls/YesNoMessageBox.cpp*

==============CMenuYesNoMessageBox::ToggleInactiveCb==============

### UI_ShowMessageBox_f

*void UI_ShowMessageBox_f()*

*Defined at line 264 of ./mainui/controls/YesNoMessageBox.cpp*

### UI_PlayerIntroduceDialog_Show

*void UI_PlayerIntroduceDialog_Show(class CMenuBaseWindow * pCaller)*

*Defined at line 104 of ./mainui/menus/PlayerIntroduceDialog.cpp*

 Don't expose class, just few functions

### FontMatch

*FcPattern * FontMatch(const char * type, FcType vtype, const void * value)*

*Defined at line 50 of ./mainui/font/FreeTypeFont.cpp*

 Find a matching font where **<not a builtin command>**  (one of FC_*) is equal to **<not a builtin command>** . For a list of types, see http://fontconfig.org/fontconfig-devel/x19.html#AEN27. The variable arguments are a list of triples, just like the first three arguments, and must be NULL terminated.

 For example,   FontMatchString(FC_FILE, FcTypeString, "/usr/share/fonts/myfont.ttf", NULL);

 Ripped from skia source code

### Sys_FindExecutable

*qboolean Sys_FindExecutable(const char * baseName, char * buf, size_t size)*

*Defined at line 23 of ./engine/platform/posix/sys_posix.cpp*

### monster_ichthyosaur

*void monster_ichthyosaur(entvars_t * pev)*

*Defined at line 124 of ./game/server/npc/npc_ichthyosaur.cpp*

### Mem_CheckFilename

*const char * Mem_CheckFilename(const char * filename)*

*Defined at line 109 of ./public/mem.cpp*

### Mem_FreeBlock

*void Mem_FreeBlock(memheader_t * mem, const char * filename, int fileline)*

*Defined at line 127 of ./public/mem.cpp*

### Mem_CheckAlloc

*qboolean Mem_CheckAlloc(mempool_t * pool, void * data)*

*Defined at line 254 of ./public/mem.cpp*

### Mem_CheckHeaderSentinels

*void Mem_CheckHeaderSentinels(void * data, const char * filename, int fileline)*

*Defined at line 288 of ./public/mem.cpp*

### cgltf_parse

*cgltf_result cgltf_parse(const cgltf_options * options, const void * data, cgltf_size size, cgltf_data ** out_data)*

*Defined at line 833 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_file

*cgltf_result cgltf_parse_file(const cgltf_options * options, const char * path, cgltf_data ** out_data)*

*Defined at line 965 of ./thirdparty/cgltf/cgltf.h*

### cgltf_load_buffers

*cgltf_result cgltf_load_buffers(const cgltf_options * options, cgltf_data * data, const char * gltf_path)*

*Defined at line 1128 of ./thirdparty/cgltf/cgltf.h*

### cgltf_load_buffer_base64

*cgltf_result cgltf_load_buffer_base64(const cgltf_options * options, cgltf_size size, const char * base64, void ** out_data)*

*Defined at line 1042 of ./thirdparty/cgltf/cgltf.h*

### cgltf_decode_uri

*void cgltf_decode_uri(char * uri)*

*Defined at line 1098 of ./thirdparty/cgltf/cgltf.h*

### cgltf_validate

*cgltf_result cgltf_validate(cgltf_data * data)*

*Defined at line 1235 of ./thirdparty/cgltf/cgltf.h*

### cgltf_free

*void cgltf_free(cgltf_data * data)*

*Defined at line 1469 of ./thirdparty/cgltf/cgltf.h*

### cgltf_node_transform_local

*void cgltf_node_transform_local(const cgltf_node * node, cgltf_float * out_matrix)*

*Defined at line 1639 of ./thirdparty/cgltf/cgltf.h*

### cgltf_node_transform_world

*void cgltf_node_transform_world(const cgltf_node * node, cgltf_float * out_matrix)*

*Defined at line 1684 of ./thirdparty/cgltf/cgltf.h*

### cgltf_accessor_read_float

*cgltf_bool cgltf_accessor_read_float(const cgltf_accessor * accessor, cgltf_size index, cgltf_float * out, cgltf_size element_size)*

*Defined at line 1826 of ./thirdparty/cgltf/cgltf.h*

### cgltf_accessor_read_uint

*cgltf_bool cgltf_accessor_read_uint(const cgltf_accessor * accessor, cgltf_size index, cgltf_uint * out, cgltf_size element_size)*

*Defined at line 1951 of ./thirdparty/cgltf/cgltf.h*

### cgltf_accessor_read_index

*cgltf_size cgltf_accessor_read_index(const cgltf_accessor * accessor, cgltf_size index)*

*Defined at line 1972 of ./thirdparty/cgltf/cgltf.h*

### cgltf_num_components

*cgltf_size cgltf_num_components(cgltf_type type)*

*Defined at line 4457 of ./thirdparty/cgltf/cgltf.h*

### cgltf_accessor_unpack_floats

*cgltf_size cgltf_accessor_unpack_floats(const cgltf_accessor * accessor, cgltf_float * out, cgltf_size float_count)*

*Defined at line 1847 of ./thirdparty/cgltf/cgltf.h*

### cgltf_copy_extras_json

*cgltf_result cgltf_copy_extras_json(const cgltf_data * data, const cgltf_extras * extras, char * dest, cgltf_size * dest_size)*

*Defined at line 1441 of ./thirdparty/cgltf/cgltf.h*

### jsmn_init

*void jsmn_init(jsmn_parser * parser)*

*Defined at line 5226 of ./thirdparty/cgltf/cgltf.h*

 Creates a new parser based over a given  buffer with an array of tokens available.

### jsmn_parse

*int jsmn_parse(jsmn_parser * parser, const char * js, size_t len, jsmntok_t * tokens, size_t num_tokens)*

*Defined at line 5068 of ./thirdparty/cgltf/cgltf.h*

 Parse JSON string and fill tokens.

### cgltf_default_alloc

*void * cgltf_default_alloc(void * user, cgltf_size size)*

*Defined at line 739 of ./thirdparty/cgltf/cgltf.h*

### cgltf_default_free

*void cgltf_default_free(void * user, void * ptr)*

*Defined at line 745 of ./thirdparty/cgltf/cgltf.h*

### cgltf_calloc

*void * cgltf_calloc(cgltf_options * options, size_t element_size, cgltf_size count)*

*Defined at line 751 of ./thirdparty/cgltf/cgltf.h*

### cgltf_default_file_read

*cgltf_result cgltf_default_file_read(const struct cgltf_memory_options * memory_options, const struct cgltf_file_options * file_options, const char * path, cgltf_size * size, void ** data)*

*Defined at line 766 of ./thirdparty/cgltf/cgltf.h*

### cgltf_default_file_release

*void cgltf_default_file_release(const struct cgltf_memory_options * memory_options, const struct cgltf_file_options * file_options, void * data)*

*Defined at line 824 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json

*cgltf_result cgltf_parse_json(cgltf_options * options, const uint8_t * json_chunk, cgltf_size size, cgltf_data ** out_data)*

*Defined at line 4664 of ./thirdparty/cgltf/cgltf.h*

### cgltf_combine_paths

*void cgltf_combine_paths(char * path, const char * base, const char * uri)*

*Defined at line 996 of ./thirdparty/cgltf/cgltf.h*

### cgltf_load_buffer_file

*cgltf_result cgltf_load_buffer_file(const cgltf_options * options, cgltf_size size, const char * uri, const char * gltf_path, void ** out_data)*

*Defined at line 1015 of ./thirdparty/cgltf/cgltf.h*

### cgltf_unhex

*int cgltf_unhex(char ch)*

*Defined at line 1089 of ./thirdparty/cgltf/cgltf.h*

### cgltf_calc_size

*cgltf_size cgltf_calc_size(cgltf_type type, cgltf_component_type component_type)*

*Defined at line 4497 of ./thirdparty/cgltf/cgltf.h*

### cgltf_calc_index_bound

*cgltf_size cgltf_calc_index_bound(cgltf_buffer_view * buffer_view, cgltf_size offset, cgltf_component_type component_type, cgltf_size count)*

*Defined at line 1197 of ./thirdparty/cgltf/cgltf.h*

### cgltf_component_read_index

*cgltf_size cgltf_component_read_index(const void * in, cgltf_component_type component_type)*

*Defined at line 1719 of ./thirdparty/cgltf/cgltf.h*

### cgltf_component_read_float

*cgltf_float cgltf_component_read_float(const void * in, cgltf_component_type component_type, cgltf_bool normalized)*

*Defined at line 1740 of ./thirdparty/cgltf/cgltf.h*

### cgltf_component_size

*cgltf_size cgltf_component_size(cgltf_component_type component_type)*

*Defined at line 4479 of ./thirdparty/cgltf/cgltf.h*

### cgltf_element_read_float

*cgltf_bool cgltf_element_read_float(const uint8_t * element, cgltf_type type, cgltf_component_type component_type, cgltf_bool normalized, cgltf_float * out, cgltf_size element_size)*

*Defined at line 1770 of ./thirdparty/cgltf/cgltf.h*

### cgltf_component_read_uint

*cgltf_uint cgltf_component_read_uint(const void * in, cgltf_component_type component_type)*

*Defined at line 1903 of ./thirdparty/cgltf/cgltf.h*

### cgltf_element_read_uint

*cgltf_bool cgltf_element_read_uint(const uint8_t * element, cgltf_type type, cgltf_component_type component_type, cgltf_uint * out, cgltf_size element_size)*

*Defined at line 1927 of ./thirdparty/cgltf/cgltf.h*

### cgltf_json_strcmp

*int cgltf_json_strcmp(const jsmntok_t * tok, const uint8_t * json_chunk, const char * str)*

*Defined at line 2004 of ./thirdparty/cgltf/cgltf.h*

### cgltf_json_to_int

*int cgltf_json_to_int(const jsmntok_t * tok, const uint8_t * json_chunk)*

*Defined at line 2012 of ./thirdparty/cgltf/cgltf.h*

### cgltf_json_to_float

*cgltf_float cgltf_json_to_float(const jsmntok_t * tok, const uint8_t * json_chunk)*

*Defined at line 2022 of ./thirdparty/cgltf/cgltf.h*

### cgltf_json_to_bool

*cgltf_bool cgltf_json_to_bool(const jsmntok_t * tok, const uint8_t * json_chunk)*

*Defined at line 2032 of ./thirdparty/cgltf/cgltf.h*

### cgltf_skip_json

*int cgltf_skip_json(const jsmntok_t * tokens, int i)*

*Defined at line 2038 of ./thirdparty/cgltf/cgltf.h*

### cgltf_fill_float_array

*void cgltf_fill_float_array(float * out_array, int size, float value)*

*Defined at line 2068 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_float_array

*int cgltf_parse_json_float_array(const jsmntok_t * tokens, int i, const uint8_t * json_chunk, float * out_array, int size)*

*Defined at line 2076 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_string

*int cgltf_parse_json_string(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, char ** out_string)*

*Defined at line 2093 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_array

*int cgltf_parse_json_array(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, size_t element_size, void ** out_array, cgltf_size * out_size)*

*Defined at line 2112 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_string_array

*int cgltf_parse_json_string_array(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, char *** out_array, cgltf_size * out_size)*

*Defined at line 2134 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_attribute_type

*void cgltf_parse_attribute_type(const char * name, cgltf_attribute_type * out_type, int * out_index)*

*Defined at line 2154 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_attribute_list

*int cgltf_parse_json_attribute_list(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_attribute ** out_attributes, cgltf_size * out_attributes_count)*

*Defined at line 2198 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_extras

*int cgltf_parse_json_extras(const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_extras * out_extras)*

*Defined at line 2235 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_draco_mesh_compression

*int cgltf_parse_json_draco_mesh_compression(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_draco_mesh_compression * out_draco_mesh_compression)*

*Defined at line 2244 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_primitive

*int cgltf_parse_json_primitive(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_primitive * out_prim)*

*Defined at line 2270 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_mesh

*int cgltf_parse_json_mesh(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_mesh * out_mesh)*

*Defined at line 2371 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_meshes

*int cgltf_parse_json_meshes(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_data * out_data)*

*Defined at line 2463 of ./thirdparty/cgltf/cgltf.h*

### cgltf_json_to_component_type

*cgltf_component_type cgltf_json_to_component_type(const jsmntok_t * tok, const uint8_t * json_chunk)*

*Defined at line 2482 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_accessor_sparse

*int cgltf_parse_json_accessor_sparse(const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_accessor_sparse * out_sparse)*

*Defined at line 2505 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_accessor

*int cgltf_parse_json_accessor(const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_accessor * out_accessor)*

*Defined at line 2624 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_texture_transform

*int cgltf_parse_json_texture_transform(const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_texture_transform * out_texture_transform)*

*Defined at line 2739 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_texture_view

*int cgltf_parse_json_texture_view(const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_texture_view * out_texture_view)*

*Defined at line 2784 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_pbr_metallic_roughness

*int cgltf_parse_json_pbr_metallic_roughness(const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_pbr_metallic_roughness * out_pbr)*

*Defined at line 2869 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_pbr_specular_glossiness

*int cgltf_parse_json_pbr_specular_glossiness(const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_pbr_specular_glossiness * out_pbr)*

*Defined at line 2926 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_clearcoat

*int cgltf_parse_json_clearcoat(const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_clearcoat * out_clearcoat)*

*Defined at line 2972 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_image

*int cgltf_parse_json_image(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_image * out_image)*

*Defined at line 3020 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_sampler

*int cgltf_parse_json_sampler(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_sampler * out_sampler)*

*Defined at line 3067 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_texture

*int cgltf_parse_json_texture(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_texture * out_texture)*

*Defined at line 3129 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_material

*int cgltf_parse_json_material(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_material * out_material)*

*Defined at line 3174 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_accessors

*int cgltf_parse_json_accessors(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_data * out_data)*

*Defined at line 3310 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_materials

*int cgltf_parse_json_materials(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_data * out_data)*

*Defined at line 3329 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_images

*int cgltf_parse_json_images(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_data * out_data)*

*Defined at line 3348 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_textures

*int cgltf_parse_json_textures(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_data * out_data)*

*Defined at line 3367 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_samplers

*int cgltf_parse_json_samplers(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_data * out_data)*

*Defined at line 3386 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_buffer_view

*int cgltf_parse_json_buffer_view(const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_buffer_view * out_buffer_view)*

*Defined at line 3405 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_buffer_views

*int cgltf_parse_json_buffer_views(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_data * out_data)*

*Defined at line 3480 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_buffer

*int cgltf_parse_json_buffer(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_buffer * out_buffer)*

*Defined at line 3499 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_buffers

*int cgltf_parse_json_buffers(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_data * out_data)*

*Defined at line 3539 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_skin

*int cgltf_parse_json_skin(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_skin * out_skin)*

*Defined at line 3558 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_skins

*int cgltf_parse_json_skins(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_data * out_data)*

*Defined at line 3619 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_camera

*int cgltf_parse_json_camera(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_camera * out_camera)*

*Defined at line 3638 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_cameras

*int cgltf_parse_json_cameras(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_data * out_data)*

*Defined at line 3792 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_light

*int cgltf_parse_json_light(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_light * out_light)*

*Defined at line 3811 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_lights

*int cgltf_parse_json_lights(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_data * out_data)*

*Defined at line 3909 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_node

*int cgltf_parse_json_node(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_node * out_node)*

*Defined at line 3928 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_nodes

*int cgltf_parse_json_nodes(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_data * out_data)*

*Defined at line 4090 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_scene

*int cgltf_parse_json_scene(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_scene * out_scene)*

*Defined at line 4109 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_scenes

*int cgltf_parse_json_scenes(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_data * out_data)*

*Defined at line 4156 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_animation_sampler

*int cgltf_parse_json_animation_sampler(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_animation_sampler * out_sampler)*

*Defined at line 4175 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_animation_channel

*int cgltf_parse_json_animation_channel(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_animation_channel * out_channel)*

*Defined at line 4234 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_animation

*int cgltf_parse_json_animation(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_animation * out_animation)*

*Defined at line 4321 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_animations

*int cgltf_parse_json_animations(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_data * out_data)*

*Defined at line 4388 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_asset

*int cgltf_parse_json_asset(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_asset * out_asset)*

*Defined at line 4407 of ./thirdparty/cgltf/cgltf.h*

### cgltf_fixup_pointers

*int cgltf_fixup_pointers(cgltf_data * out_data)*

*Defined at line 4743 of ./thirdparty/cgltf/cgltf.h*

### cgltf_parse_json_root

*int cgltf_parse_json_root(cgltf_options * options, const jsmntok_t * tokens, int i, const uint8_t * json_chunk, cgltf_data * out_data)*

*Defined at line 4513 of ./thirdparty/cgltf/cgltf.h*

### jsmn_alloc_token

*jsmntok_t * jsmn_alloc_token(jsmn_parser * parser, jsmntok_t * tokens, size_t num_tokens)*

*Defined at line 4923 of ./thirdparty/cgltf/cgltf.h*

 Allocates a fresh unused token from the token pull.

### jsmn_fill_token

*void jsmn_fill_token(jsmntok_t * token, jsmntype_t type, int start, int end)*

*Defined at line 4941 of ./thirdparty/cgltf/cgltf.h*

 Fills token type and boundaries.

### jsmn_parse_primitive

*int jsmn_parse_primitive(jsmn_parser * parser, const char * js, size_t len, jsmntok_t * tokens, size_t num_tokens)*

*Defined at line 4952 of ./thirdparty/cgltf/cgltf.h*

 Fills next available token with JSON primitive.

### jsmn_parse_string

*int jsmn_parse_string(jsmn_parser * parser, const char * js, size_t len, jsmntok_t * tokens, size_t num_tokens)*

*Defined at line 5001 of ./thirdparty/cgltf/cgltf.h*

 Fills next token with JSON string.

### MD5Transform

*void MD5Transform(uint [4] buf, const uint [16] in)*

*Defined at line 348 of ./public/crclib.cpp*

=================MD5Transform

The core of the MD5 algorithm, this alters an existing MD5 hash toreflect the addition of 16 longwords of new data.  MD5Update blocksthe data and converts bytes into longwords for this routine.=================

### CSCR_ExpectString

*_Bool CSCR_ExpectString(struct parserstate_t * ps, const char * pExpect, _Bool skip, _Bool error)*

*Defined at line 42 of ./mainui/CFGScript.cpp*

===================CSCR_ExpectString

Return true if next token is pExpext and skip it===================

### CSCR_ParseType

*cvartype_t CSCR_ParseType(struct parserstate_t * ps)*

*Defined at line 68 of ./mainui/CFGScript.cpp*

===================CSCR_ParseType

Determine script variable type===================

### CSCR_ParseSingleCvar

*_Bool CSCR_ParseSingleCvar(struct parserstate_t * ps, struct scrvardef_t * result)*

*Defined at line 89 of ./mainui/CFGScript.cpp*

=========================CSCR_ParseSingleCvar=========================

### CSCR_ParseHeader

*_Bool CSCR_ParseHeader(struct parserstate_t * ps)*

*Defined at line 227 of ./mainui/CFGScript.cpp*

======================CSCR_ParseHeader

Check version and seek to first cvar name======================

### SV_GetEntvarsDescirption

*TYPEDESCRIPTION * SV_GetEntvarsDescirption(int number)*

*Defined at line 94 of ./engine/server/sv_game.cpp*

=============SV_GetEntvarsDescription

entavrs table for FindEntityByString=============

### SV_ConvertTrace

*void SV_ConvertTrace(TraceResult * dst, trace_t * src)*

*Defined at line 245 of ./engine/server/sv_game.cpp*

=============SV_ConvertTrace

convert trace_t to TraceResult=============

### SV_CheckClientVisiblity

*qboolean SV_CheckClientVisiblity(sv_client_t * cl, const byte * mask)*

*Defined at line 271 of ./engine/server/sv_game.cpp*

=============SV_CheckClientVisiblity

Check visibility through client camera, portal camera, etc=============

### SV_Multicast

*int SV_Multicast(int dest, const vec3_t origin, const edict_t * ent, qboolean usermessage, qboolean filter)*

*Defined at line 324 of ./engine/server/sv_game.cpp*

=================SV_Multicast

Sends the contents of sv.multicast to a subset of the clients,then clears sv.multicast.

MSG_INIT	write message into signon bufferMSG_ONE	send to one client (ent can't be NULL)MSG_ALL	same as broadcast (origin can be NULL)MSG_PVS	send to clients potentially visible from orgMSG_PHS	send to clients potentially audible from org=================

### SV_GetReliableDatagram

*sizebuf_t * SV_GetReliableDatagram()*

*Defined at line 441 of ./engine/server/sv_game.cpp*

=======================SV_GetReliableDatagram

Get shared reliable buffer=======================

### SV_ReadEntityScript

*char * SV_ReadEntityScript(const char * filename, int * flags)*

*Defined at line 815 of ./engine/server/sv_game.cpp*

==============SV_ReadEntityScript

pfnMapIsValid use this==============

### SV_GetEntityClass

*LINK_ENTITY_FUNC SV_GetEntityClass(const char * pszClassName)*

*Defined at line 1065 of ./engine/server/sv_game.cpp*

==============SV_GetEntityClass

get pointer for entity class==============

### SV_IsValidCmd

*qboolean SV_IsValidCmd(const char * pCmd)*

*Defined at line 1215 of ./engine/server/sv_game.cpp*

==============SV_IsValidCmd

command validation==============

### pfnSetModel

*void pfnSetModel(edict_t * e, const char * m)*

*Defined at line 1294 of ./engine/server/sv_game.cpp*

=================pfnSetModel

=================

### pfnModelFrames

*int pfnModelFrames(int modelIndex)*

*Defined at line 1387 of ./engine/server/sv_game.cpp*

=================pfnModelFrames

=================

### pfnSetSize

*void pfnSetSize(edict_t * e, const float * rgflMin, const float * rgflMax)*

*Defined at line 1402 of ./engine/server/sv_game.cpp*

=================pfnSetSize

=================

### pfnChangeLevel

*void pfnChangeLevel(const char * level, const char * landmark)*

*Defined at line 1416 of ./engine/server/sv_game.cpp*

=================pfnChangeLevel

=================

### pfnGetSpawnParms

*void pfnGetSpawnParms(edict_t * ent)*

*Defined at line 1455 of ./engine/server/sv_game.cpp*

=================pfnGetSpawnParms

OBSOLETE, UNUSED=================

### pfnSaveSpawnParms

*void pfnSaveSpawnParms(edict_t * ent)*

*Defined at line 1466 of ./engine/server/sv_game.cpp*

=================pfnSaveSpawnParms

OBSOLETE, UNUSED=================

### pfnVecToYaw

*float pfnVecToYaw(const float * rgflVector)*

*Defined at line 1476 of ./engine/server/sv_game.cpp*

=================pfnVecToYaw

=================

### pfnMoveToOrigin

*void pfnMoveToOrigin(edict_t * ent, const float * pflGoal, float dist, int iMoveType)*

*Defined at line 1487 of ./engine/server/sv_game.cpp*

=================pfnMoveToOrigin

=================

### pfnChangeYaw

*void pfnChangeYaw(edict_t * ent)*

*Defined at line 1501 of ./engine/server/sv_game.cpp*

==============pfnChangeYaw

==============

### pfnChangePitch

*void pfnChangePitch(edict_t * ent)*

*Defined at line 1515 of ./engine/server/sv_game.cpp*

==============pfnChangePitch

==============

### pfnGetEntityIllum

*int pfnGetEntityIllum(edict_t * pEnt)*

*Defined at line 1610 of ./engine/server/sv_game.cpp*

==============pfnGetEntityIllum

returns averaged lightvalue for entity==============

### pfnFindEntityInSphere

*edict_t * pfnFindEntityInSphere(edict_t * pStartEdict, const float * org, float flRadius)*

*Defined at line 1625 of ./engine/server/sv_game.cpp*

=================pfnFindEntityInSphere

find the entity in sphere=================

### SV_CheckClientPVS

*int SV_CheckClientPVS(int check, qboolean bMergePVS)*

*Defined at line 1675 of ./engine/server/sv_game.cpp*

=================SV_CheckClientPVS

build the new client PVS=================

### pfnFindClientInPVS

*edict_t * pfnFindClientInPVS(edict_t * pEdict)*

*Defined at line 1740 of ./engine/server/sv_game.cpp*

=================pfnFindClientInPVS

=================

### pfnEntitiesInPVS

*edict_t * pfnEntitiesInPVS(edict_t * pview)*

*Defined at line 1799 of ./engine/server/sv_game.cpp*

=================pfnEntitiesInPVS

=================

### pfnMakeVectors

*void pfnMakeVectors(const float * rgflVector)*

*Defined at line 1839 of ./engine/server/sv_game.cpp*

==============pfnMakeVectors

==============

### pfnCreateNamedEntity

*edict_t * pfnCreateNamedEntity(string_t className)*

*Defined at line 1872 of ./engine/server/sv_game.cpp*

==============pfnCreateNamedEntity

==============

### pfnMakeStatic

*void pfnMakeStatic(edict_t * ent)*

*Defined at line 1884 of ./engine/server/sv_game.cpp*

=============pfnMakeStatic

move entity to client=============

### pfnEntIsOnFloor

*int pfnEntIsOnFloor(edict_t * e)*

*Defined at line 1910 of ./engine/server/sv_game.cpp*

=============pfnEntIsOnFloor

legacy builtin=============

### pfnDropToFloor

*int pfnDropToFloor(edict_t * e)*

*Defined at line 1924 of ./engine/server/sv_game.cpp*

===============pfnDropToFloor

===============

### pfnWalkMove

*int pfnWalkMove(edict_t * ent, float yaw, float dist, int iMode)*

*Defined at line 1959 of ./engine/server/sv_game.cpp*

===============pfnWalkMove

===============

### pfnSetOrigin

*void pfnSetOrigin(edict_t * e, const float * rgflOrigin)*

*Defined at line 1990 of ./engine/server/sv_game.cpp*

=================pfnSetOrigin

=================

### pfnEmitAmbientSound

*void pfnEmitAmbientSound(edict_t * ent, float * pos, const char * sample, float vol, float attn, int flags, int pitch)*

*Defined at line 2149 of ./engine/server/sv_game.cpp*

=================pfnEmitAmbientSound

=================

### pfnTraceLine

*void pfnTraceLine(const float * v1, const float * v2, int fNoMonsters, edict_t * pentToSkip, TraceResult * ptr)*

*Defined at line 2187 of ./engine/server/sv_game.cpp*

=================pfnTraceLine

=================

### pfnTraceToss

*void pfnTraceToss(edict_t * pent, edict_t * pentToIgnore, TraceResult * ptr)*

*Defined at line 2203 of ./engine/server/sv_game.cpp*

=================pfnTraceToss

=================

### pfnTraceHull

*void pfnTraceHull(const float * v1, const float * v2, int fNoMonsters, int hullNumber, edict_t * pentToSkip, TraceResult * ptr)*

*Defined at line 2220 of ./engine/server/sv_game.cpp*

=================pfnTraceHull

=================

### pfnTraceMonsterHull

*int pfnTraceMonsterHull(edict_t * pEdict, const float * v1, const float * v2, int fNoMonsters, edict_t * pentToSkip, TraceResult * ptr)*

*Defined at line 2237 of ./engine/server/sv_game.cpp*

=============pfnTraceMonsterHull

=============

### pfnTraceModel

*void pfnTraceModel(const float * v1, const float * v2, int hullNumber, edict_t * pent, TraceResult * ptr)*

*Defined at line 2260 of ./engine/server/sv_game.cpp*

=============pfnTraceModel

=============

### pfnTraceTexture

*const char * pfnTraceTexture(edict_t * pTextureEntity, const float * v1, const float * v2)*

*Defined at line 2309 of ./engine/server/sv_game.cpp*

=============pfnTraceTexture

returns texture basename=============

### pfnTraceSphere

*void pfnTraceSphere(const float * v1, const float * v2, int fNoMonsters, float radius, edict_t * pentToSkip, TraceResult * ptr)*

*Defined at line 2324 of ./engine/server/sv_game.cpp*

=============pfnTraceSphere

OBSOLETE, UNUSED=============

### pfnGetAimVector

*void pfnGetAimVector(edict_t * ent, float speed, float * rgflReturn)*

*Defined at line 2335 of ./engine/server/sv_game.cpp*

=============pfnGetAimVector

NOTE: speed is unused=============

### pfnServerCommand

*void pfnServerCommand(const char * str)*

*Defined at line 2408 of ./engine/server/sv_game.cpp*

=========pfnServerCommand

=========

### pfnServerExecute

*void pfnServerExecute()*

*Defined at line 2421 of ./engine/server/sv_game.cpp*

=========pfnServerExecute

=========

### pfnClientCommand

*void pfnClientCommand(edict_t * pEdict, char * szFmt)*

*Defined at line 2448 of ./engine/server/sv_game.cpp*

=========pfnClientCommand

=========

### pfnParticleEffect

*void pfnParticleEffect(const float * org, const float * dir, float color, float count)*

*Defined at line 2485 of ./engine/server/sv_game.cpp*

=================pfnParticleEffect

Make sure the event gets sent to all clients=================

### pfnLightStyle

*void pfnLightStyle(int style, const char * val)*

*Defined at line 2511 of ./engine/server/sv_game.cpp*

===============pfnLightStyle

===============

### pfnMessageBegin

*void pfnMessageBegin(int msg_dest, int msg_num, const float * pOrigin, edict_t * ed)*

*Defined at line 2550 of ./engine/server/sv_game.cpp*

=============pfnMessageBegin

=============

### pfnMessageEnd

*void pfnMessageEnd()*

*Defined at line 2615 of ./engine/server/sv_game.cpp*

=============pfnMessageEnd

=============

### pfnWriteByte

*void pfnWriteByte(int iValue)*

*Defined at line 2713 of ./engine/server/sv_game.cpp*

=============pfnWriteByte

=============

### pfnWriteChar

*void pfnWriteChar(int iValue)*

*Defined at line 2726 of ./engine/server/sv_game.cpp*

=============pfnWriteChar

=============

### pfnWriteShort

*void pfnWriteShort(int iValue)*

*Defined at line 2738 of ./engine/server/sv_game.cpp*

=============pfnWriteShort

=============

### pfnWriteLong

*void pfnWriteLong(int iValue)*

*Defined at line 2750 of ./engine/server/sv_game.cpp*

=============pfnWriteLong

=============

### pfnWriteAngle

*void pfnWriteAngle(float flValue)*

*Defined at line 2763 of ./engine/server/sv_game.cpp*

=============pfnWriteAngle

this is low-res angle=============

### pfnWriteCoord

*void pfnWriteCoord(float flValue)*

*Defined at line 2777 of ./engine/server/sv_game.cpp*

=============pfnWriteCoord

=============

### pfnWriteString

*void pfnWriteString(const char * src)*

*Defined at line 2801 of ./engine/server/sv_game.cpp*

=============pfnWriteString

=============

### pfnWriteEntity

*void pfnWriteEntity(int iValue)*

*Defined at line 2864 of ./engine/server/sv_game.cpp*

=============pfnWriteEntity

=============

### pfnAlertMessage

*void pfnAlertMessage(ALERT_TYPE type, char * szFmt)*

*Defined at line 2879 of ./engine/server/sv_game.cpp*

=============pfnAlertMessage

=============

### pfnEngineFprintf

*void pfnEngineFprintf(FILE * pfile, char * szFmt)*

*Defined at line 2933 of ./engine/server/sv_game.cpp*

=============pfnEngineFprintf

OBSOLETE, UNUSED=============

### pfnBuildSoundMsg

*void pfnBuildSoundMsg(edict_t * pSource, int chan, const char * samp, float fvol, float attn, int fFlags, int pitch, int msg_dest, int msg_type, const float * pOrigin, edict_t * pSend)*

*Defined at line 2944 of ./engine/server/sv_game.cpp*

=============pfnBuildSoundMsg

Customizable sound message=============

### pfnPvAllocEntPrivateData

*void * pfnPvAllocEntPrivateData(edict_t * pEdict, long cb)*

*Defined at line 2957 of ./engine/server/sv_game.cpp*

=============pfnPvAllocEntPrivateData

=============

### pfnPvEntPrivateData

*void * pfnPvEntPrivateData(edict_t * pEdict)*

*Defined at line 2979 of ./engine/server/sv_game.cpp*

=============pfnPvEntPrivateData

we already have copy of this function in 'enginecallback.h' :-)=============

### SV_AllocStringPool

*void SV_AllocStringPool()*

*Defined at line 3068 of ./engine/server/sv_game.cpp*

==================SV_AllocStringPool

alloc string pool on 32bit platformsalloc string array near the server library on 64bit platforms if possiblealloc string array somewhere if not (MAKE_STRING will not work. Always call ALLOC_STRING instead, or crash)this case need patched game dll with MAKE_STRING checking ptrdiff size==================

### SV_FreeStringPool

*void SV_FreeStringPool()*

*Defined at line 3148 of ./engine/server/sv_game.cpp*

### pfnGetVarsOfEnt

*entvars_t * pfnGetVarsOfEnt(edict_t * pEdict)*

*Defined at line 3273 of ./engine/server/sv_game.cpp*

=============pfnGetVarsOfEnt

=============

### pfnPEntityOfEntOffset

*edict_t * pfnPEntityOfEntOffset(int iEntOffset)*

*Defined at line 3286 of ./engine/server/sv_game.cpp*

=============pfnPEntityOfEntOffset

=============

### pfnEntOffsetOfPEntity

*int pfnEntOffsetOfPEntity(const edict_t * pEdict)*

*Defined at line 3297 of ./engine/server/sv_game.cpp*

=============pfnEntOffsetOfPEntity

=============

### pfnFindEntityByVars

*edict_t * pfnFindEntityByVars(entvars_t * pvars)*

*Defined at line 3353 of ./engine/server/sv_game.cpp*

=============pfnFindEntityByVars

debug thing=============

### pfnGetModelPtr

*void * pfnGetModelPtr(edict_t * pEdict)*

*Defined at line 3380 of ./engine/server/sv_game.cpp*

=============pfnGetModelPtr

returns pointer to a studiomodel=============

### pfnRegUserMsg

*int pfnRegUserMsg(const char * pszName, int iSize)*

*Defined at line 3411 of ./engine/server/sv_game.cpp*

=============pfnRegUserMsg

=============

### pfnAnimationAutomove

*void pfnAnimationAutomove(const edict_t * pEdict, float flTime)*

*Defined at line 3469 of ./engine/server/sv_game.cpp*

=============pfnAnimationAutomove

OBSOLETE, UNUSED=============

### pfnGetBonePosition

*void pfnGetBonePosition(const edict_t * pEdict, int iBone, float * rgflOrigin, float * rgflAngles)*

*Defined at line 3479 of ./engine/server/sv_game.cpp*

=============pfnGetBonePosition

=============

### pfnFunctionFromName

*void * pfnFunctionFromName(const char * pName)*

*Defined at line 3492 of ./engine/server/sv_game.cpp*

=============pfnFunctionFromName

=============

### pfnNameForFunction

*const char * pfnNameForFunction(void * function)*

*Defined at line 3503 of ./engine/server/sv_game.cpp*

=============pfnNameForFunction

=============

### pfnClientPrintf

*void pfnClientPrintf(edict_t * pEdict, PRINT_TYPE ptype, const char * szMsg)*

*Defined at line 3514 of ./engine/server/sv_game.cpp*

=============pfnClientPrintf

=============

### pfnServerPrint

*void pfnServerPrint(const char * szMsg)*

*Defined at line 3547 of ./engine/server/sv_game.cpp*

=============pfnServerPrint

print to the server console=============

### pfnGetAttachment

*void pfnGetAttachment(const edict_t * pEdict, int iAttachment, float * rgflOrigin, float * rgflAngles)*

*Defined at line 3560 of ./engine/server/sv_game.cpp*

=============pfnGetAttachment

=============

### pfnCrosshairAngle

*void pfnCrosshairAngle(const edict_t * pClient, float pitch, float yaw)*

*Defined at line 3573 of ./engine/server/sv_game.cpp*

=============pfnCrosshairAngle

=============

### pfnSetView

*void pfnSetView(const edict_t * pClient, const edict_t * pViewent)*

*Defined at line 3600 of ./engine/server/sv_game.cpp*

=============pfnSetView

=============

### pfnStaticDecal

*void pfnStaticDecal(const float * origin, int decalIndex, int entityIndex, int modelIndex)*

*Defined at line 3636 of ./engine/server/sv_game.cpp*

=============pfnStaticDecal

=============

### pfnIsDedicatedServer

*int pfnIsDedicatedServer()*

*Defined at line 3647 of ./engine/server/sv_game.cpp*

=============pfnIsDedicatedServer

=============

### pfnGetPlayerWONId

*uint pfnGetPlayerWONId(edict_t * e)*

*Defined at line 3659 of ./engine/server/sv_game.cpp*

=============pfnGetPlayerWONId

OBSOLETE, UNUSED=============

### pfnFadeClientVolume

*void pfnFadeClientVolume(const edict_t * pEdict, int fadePercent, int fadeOutSeconds, int holdTime, int fadeInSeconds)*

*Defined at line 3686 of ./engine/server/sv_game.cpp*

=============pfnFadeClientVolume

=============

### pfnSetClientMaxspeed

*void pfnSetClientMaxspeed(const edict_t * pEdict, float fNewMaxspeed)*

*Defined at line 3710 of ./engine/server/sv_game.cpp*

=============pfnSetClientMaxspeed

fakeclients can be changed speed to=============

### pfnRunPlayerMove

*void pfnRunPlayerMove(edict_t * pClient, const float * viewangles, float fmove, float smove, float upmove, word buttons, byte impulse, byte msec)*

*Defined at line 3729 of ./engine/server/sv_game.cpp*

=============pfnRunPlayerMove

=============

### pfnGetInfoKeyBuffer

*char * pfnGetInfoKeyBuffer(edict_t * e)*

*Defined at line 3790 of ./engine/server/sv_game.cpp*

=============pfnGetInfoKeyBuffer

=============

### pfnSetValueForKey

*void pfnSetValueForKey(char * infobuffer, char * key, char * value)*

*Defined at line 3815 of ./engine/server/sv_game.cpp*

=============pfnSetValueForKey

=============

### pfnSetClientKeyValue

*void pfnSetClientKeyValue(int clientIndex, char * infobuffer, char * key, char * value)*

*Defined at line 3830 of ./engine/server/sv_game.cpp*

=============pfnSetClientKeyValue

=============

### pfnGetPhysicsKeyValue

*const char * pfnGetPhysicsKeyValue(const edict_t * pClient, const char * key)*

*Defined at line 3859 of ./engine/server/sv_game.cpp*

=============pfnGetPhysicsKeyValue

=============

### pfnSetPhysicsKeyValue

*void pfnSetPhysicsKeyValue(const edict_t * pClient, const char * key, const char * value)*

*Defined at line 3879 of ./engine/server/sv_game.cpp*

=============pfnSetPhysicsKeyValue

=============

### pfnGetPhysicsInfoString

*const char * pfnGetPhysicsInfoString(const edict_t * pClient)*

*Defined at line 3899 of ./engine/server/sv_game.cpp*

=============pfnGetPhysicsInfoString

=============

### pfnPrecacheEvent

*word pfnPrecacheEvent(int type, const char * psz)*

*Defined at line 3921 of ./engine/server/sv_game.cpp*

=============pfnPrecacheEvent

register or returns already registered event ida type of event is ignored at this moment=============

### pfnCheckVisibility

*int pfnCheckVisibility(const edict_t * ent, byte * pset)*

*Defined at line 4234 of ./engine/server/sv_game.cpp*

=============pfnCheckVisibility

=============

### pfnCanSkipPlayer

*int pfnCanSkipPlayer(const edict_t * player)*

*Defined at line 4286 of ./engine/server/sv_game.cpp*

=============pfnCanSkipPlayer

=============

### pfnSetGroupMask

*void pfnSetGroupMask(int mask, int op)*

*Defined at line 4317 of ./engine/server/sv_game.cpp*

=============pfnSetGroupMask

=============

### pfnCreateInstancedBaseline

*int pfnCreateInstancedBaseline(int classname, struct entity_state_s * baseline)*

*Defined at line 4329 of ./engine/server/sv_game.cpp*

=============pfnCreateInstancedBaseline

=============

### pfnEndSection

*void pfnEndSection(const char * pszSection)*

*Defined at line 4348 of ./engine/server/sv_game.cpp*

=============pfnEndSection

=============

### pfnGetPlayerUserId

*int pfnGetPlayerUserId(edict_t * e)*

*Defined at line 4361 of ./engine/server/sv_game.cpp*

=============pfnGetPlayerUserId

=============

### pfnGetPlayerStats

*void pfnGetPlayerStats(const edict_t * pClient, int * ping, int * packet_loss)*

*Defined at line 4376 of ./engine/server/sv_game.cpp*

=============pfnGetPlayerStats

=============

### pfnForceUnmodified

*void pfnForceUnmodified(FORCE_TYPE type, float * mins, float * maxs, const char * filename)*

*Defined at line 4396 of ./engine/server/sv_game.cpp*

=============pfnForceUnmodified

=============

### pfnVoice_GetClientListening

*qboolean pfnVoice_GetClientListening(int iReceiver, int iSender)*

*Defined at line 4443 of ./engine/server/sv_game.cpp*

=============pfnVoice_GetClientListening

=============

### pfnVoice_SetClientListening

*qboolean pfnVoice_SetClientListening(int iReceiver, int iSender, qboolean bListen)*

*Defined at line 4460 of ./engine/server/sv_game.cpp*

=============pfnVoice_SetClientListening

=============

### pfnGetPlayerAuthId

*const char * pfnGetPlayerAuthId(edict_t * e)*

*Defined at line 4483 of ./engine/server/sv_game.cpp*

=============pfnGetPlayerAuthId

These function must returns cd-key hashed valuebut Xash3D currently doesn't have any security checksreturn nullstring for now=============

### pfnQueryClientCvarValue

*void pfnQueryClientCvarValue(const edict_t * player, const char * cvarName)*

*Defined at line 4495 of ./engine/server/sv_game.cpp*

=============pfnQueryClientCvarValue

request client cvar value=============

### pfnQueryClientCvarValue2

*void pfnQueryClientCvarValue2(const edict_t * player, const char * cvarName, int requestID)*

*Defined at line 4522 of ./engine/server/sv_game.cpp*

=============pfnQueryClientCvarValue2

request client cvar value (bugfixed)=============

### pfnEngineStub

*void pfnEngineStub()*

*Defined at line 4550 of ./engine/server/sv_game.cpp*

=============pfnEngineStub

extended iface stubs=============

### SV_ParseEdict

*qboolean SV_ParseEdict(char ** pfile, edict_t * ent)*

*Defined at line 4725 of ./engine/server/sv_game.cpp*

====================SV_ParseEdict

Parses an edict out of the given string, returning the new positioned should be a properly initialized empty edict.====================

### SV_LoadFromFile

*void SV_LoadFromFile(const char * mapname, char * entities)*

*Defined at line 4883 of ./engine/server/sv_game.cpp*

================SV_LoadFromFile

The entities are directly placed in the array, rather than allocated withED_Alloc, because otherwise an error loading the map would have entitynumber references out of order.

Creates a server's entity / program execution context byparsing textual entity definitions out of an ent file.================

### UI_TouchButtons_Precache

*void UI_TouchButtons_Precache()*

*Defined at line 541 of ./mainui/menus/TouchButtons.cpp*

=================UI_TouchButtons_Precache=================

### StripLength

*int StripLength(int starttri, int startv)*

*Defined at line 95 of ./ref_gl/gl_alias.cpp*

================StripLength================

### FanLength

*int FanLength(int starttri, int startv)*

*Defined at line 161 of ./ref_gl/gl_alias.cpp*

===========FanLength===========

### R_AliasDrawAbsBBox

*void R_AliasDrawAbsBBox(cl_entity_t * e, const vec3_t absmin, const vec3_t absmax)*

*Defined at line 1261 of ./ref_gl/gl_alias.cpp*

===============R_StudioDrawAbsBBox

===============

### R_AliasDrawLightTrace

*void R_AliasDrawLightTrace(cl_entity_t * e)*

*Defined at line 1297 of ./ref_gl/gl_alias.cpp*

### R_AliasSetupTimings

*void R_AliasSetupTimings()*

*Defined at line 1338 of ./ref_gl/gl_alias.cpp*

================R_AliasSetupTimings

init current time for a given model================

### __MsgFunc_SecAmmoVal

*int __MsgFunc_SecAmmoVal(const char * pszName, int iSize, void * pbuf)*

*Defined at line 27 of ./game/client/ammo_secondary.cpp*

### __MsgFunc_SecAmmoIcon

*int __MsgFunc_SecAmmoIcon(const char * pszName, int iSize, void * pbuf)*

*Defined at line 28 of ./game/client/ammo_secondary.cpp*

### func_breakable

*void func_breakable(entvars_t * pev)*

*Defined at line 126 of ./game/server/func_break.cpp*

### func_pushable

*void func_pushable(entvars_t * pev)*

*Defined at line 811 of ./game/server/func_break.cpp*

### monster_turret

*void monster_turret(entvars_t * pev)*

*Defined at line 206 of ./game/server/npc/npc_turret.cpp*

### monster_miniturret

*void monster_miniturret(entvars_t * pev)*

*Defined at line 207 of ./game/server/npc/npc_turret.cpp*

### monster_sentry

*void monster_sentry(entvars_t * pev)*

*Defined at line 1147 of ./game/server/npc/npc_turret.cpp*

### FEntIsVisible

*BOOL FEntIsVisible(entvars_t * pev, entvars_t * pevTarget)*

*Defined at line 467 of ./game/server/subs.cpp*

=============FEntIsVisible

returns TRUE if the passed entity is visible to caller, even if not infront ()=============

### info_null

*void info_null(entvars_t * pev)*

*Defined at line 48 of ./game/server/subs.cpp*

### info_player_deathmatch

*void info_player_deathmatch(entvars_t * pev)*

*Defined at line 60 of ./game/server/subs.cpp*

### info_player_start

*void info_player_start(entvars_t * pev)*

*Defined at line 61 of ./game/server/subs.cpp*

### info_landmark

*void info_landmark(entvars_t * pev)*

*Defined at line 62 of ./game/server/subs.cpp*

### DelayedUse

*void DelayedUse(entvars_t * pev)*

*Defined at line 132 of ./game/server/subs.cpp*

### grenade

*void grenade(entvars_t * pev)*

*Defined at line 34 of ./game/server/ggrenade.cpp*

### UI_ConnectionProgress_f

*void UI_ConnectionProgress_f()*

*Defined at line 405 of ./mainui/menus/ConnectionProgress.cpp*

### initnet

*void initnet(byte * thepic, int len, int sample)*

*Defined at line 68 of ./engine/common/imagelib/img_quant.cpp*

### unbiasnet

*void unbiasnet()*

*Defined at line 86 of ./engine/common/imagelib/img_quant.cpp*

 Unbias network to give byte values 0..255 and record position i to prepare for sort

### inxbuild

*void inxbuild()*

*Defined at line 106 of ./engine/common/imagelib/img_quant.cpp*

 Insertion sort of network and building of netindex[0..255] (to do after unbias)

### inxsearch

*int inxsearch(int r, int g, int b)*

*Defined at line 165 of ./engine/common/imagelib/img_quant.cpp*

 Search for BGR values 0..255 (after net is unbiased) and return colour index

### contest

*int contest(int r, int g, int b)*

*Defined at line 246 of ./engine/common/imagelib/img_quant.cpp*

 Search for biased BGR values

### altersingle

*void altersingle(int alpha, int i, int r, int g, int b)*

*Defined at line 301 of ./engine/common/imagelib/img_quant.cpp*

 Move neuron i towards biased (b,g,r) by factor alpha

### alterneigh

*void alterneigh(int rad, int i, int r, int g, int b)*

*Defined at line 314 of ./engine/common/imagelib/img_quant.cpp*

 Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in radpower[|i-j|]

### learn

*void learn()*

*Defined at line 357 of ./engine/common/imagelib/img_quant.cpp*

 Main Learning Loop

### MaxAmmoCarry

*int MaxAmmoCarry(int iszName)*

*Defined at line 81 of ./game/server/weapons.cpp*

========================================================= MaxAmmoCarry - pass in a name and this function will tell you the maximum amount of that type of ammunition that a  player can carry.=========================================================

### UTIL_PrecacheOtherWeapon

*void UTIL_PrecacheOtherWeapon(const char * szClassname)*

*Defined at line 252 of ./game/server/weapons.cpp*

 Precaches the weapon and queues the weapon info for sending to clients

### W_Precache

*void W_Precache()*

*Defined at line 289 of ./game/server/weapons.cpp*

 called by worldspawn

### weaponbox

*void weaponbox(entvars_t * pev)*

*Defined at line 462 of ./game/server/weapons.cpp*

### IsAmmoForExhaustibleWeapon

*const char * IsAmmoForExhaustibleWeapon(const char * ammoName, int & weaponId)*

*Defined at line 540 of ./game/server/weapons.cpp*

### UI_SaveLoad_Precache

*void UI_SaveLoad_Precache()*

*Defined at line 76 of ./mainui/menus/SaveLoad.cpp*

=================UI_SaveLoad_Precache=================

### monster_barnacle

*void monster_barnacle(entvars_t * pev)*

*Defined at line 69 of ./game/server/npc/npc_barnacle.cpp*

### R_SpriteLoadFrame

*const dframetype_t * R_SpriteLoadFrame(model_t * mod, const void * pin, mspriteframe_t ** ppframe, int num)*

*Defined at line 54 of ./ref_gl/gl_sprite.cpp*

====================R_SpriteLoadFrame

upload a single frame====================

### R_SpriteLoadGroup

*const dframetype_t * R_SpriteLoadGroup(model_t * mod, const void * pin, mspriteframe_t ** ppframe, int framenum)*

*Defined at line 101 of ./ref_gl/gl_sprite.cpp*

====================R_SpriteLoadGroup

upload a group frames====================

### R_GetSpriteFrameInterpolant

*float R_GetSpriteFrameInterpolant(cl_entity_t * ent, mspriteframe_t ** oldframe, mspriteframe_t ** curframe)*

*Defined at line 468 of ./ref_gl/gl_sprite.cpp*

================R_GetSpriteFrameInterpolant

NOTE: we using prevblending[0] and [1] for holds intervalbetween frames where are we lerping================

### R_CullSpriteModel

*qboolean R_CullSpriteModel(cl_entity_t * e, vec3_t origin)*

*Defined at line 634 of ./ref_gl/gl_sprite.cpp*

================R_CullSpriteModel

Cull sprite model by bbox================

### R_SpriteGlowBlend

*float R_SpriteGlowBlend(vec3_t origin, int rendermode, int renderfx, float * pscale)*

*Defined at line 664 of ./ref_gl/gl_sprite.cpp*

================R_GlowSightDistance

Set sprite brightness factor================

### R_SpriteOccluded

*qboolean R_SpriteOccluded(cl_entity_t * e, vec3_t origin, float * pscale)*

*Defined at line 698 of ./ref_gl/gl_sprite.cpp*

================R_SpriteOccluded

Do occlusion test for glow-sprites================

### R_DrawSpriteQuad

*void R_DrawSpriteQuad(mspriteframe_t * frame, vec3_t org, vec3_t v_right, vec3_t v_up, float scale)*

*Defined at line 732 of ./ref_gl/gl_sprite.cpp*

=================R_DrawSpriteQuad=================

### R_SpriteHasLightmap

*qboolean R_SpriteHasLightmap(cl_entity_t * e, int texFormat)*

*Defined at line 758 of ./ref_gl/gl_sprite.cpp*

### R_SpriteAllowLerping

*qboolean R_SpriteAllowLerping(cl_entity_t * e, msprite_t * psprite)*

*Defined at line 790 of ./ref_gl/gl_sprite.cpp*

=================R_SpriteAllowLerping=================

### SV_GetFragmentSize

*int SV_GetFragmentSize(void * pcl, fragsize_t mode)*

*Defined at line 90 of ./engine/server/sv_client.cpp*

### SV_FailDownload

*void SV_FailDownload(sv_client_t * cl, const char * filename)*

*Defined at line 163 of ./engine/server/sv_client.cpp*

================SV_FailDownload

for some reasons file can't be downloadedtell the client about this problem================

### SV_CheckChallenge

*int SV_CheckChallenge(netadr_s from, int challenge)*

*Defined at line 179 of ./engine/server/sv_client.cpp*

================SV_CheckChallenge

Make sure connecting client is not spoofing================

### SV_CheckIPRestrictions

*int SV_CheckIPRestrictions(netadr_s from)*

*Defined at line 219 of ./engine/server/sv_client.cpp*

================SV_CheckIPRestrictions

Determine if client is outside appropriate address range================

### SV_FindEmptySlot

*int SV_FindEmptySlot(netadr_s from, int * pslot, sv_client_t ** ppClient)*

*Defined at line 237 of ./engine/server/sv_client.cpp*

================SV_FindEmptySlot

Get slot # and set client_t pointer for player, if possibleWe don't do this search on a "reconnect, we just reuse the slot================

### SV_ConnectClient

*void SV_ConnectClient(netadr_s from)*

*Defined at line 263 of ./engine/server/sv_client.cpp*

==================SV_ConnectClient

A connection request that did not come from the master==================

### SV_BeginRedirect

*void SV_BeginRedirect(netadr_s adr, int target, char * buffer, int buffersize, void (*) flush)*

*Defined at line 611 of ./engine/server/sv_client.cpp*

==============================================================================

SVC COMMAND REDIRECT

==============================================================================

### SV_FlushRedirect

*void SV_FlushRedirect(netadr_s adr, int dest, char * buf)*

*Defined at line 624 of ./engine/server/sv_client.cpp*

### SV_TestBandWidth

*void SV_TestBandWidth(netadr_s from)*

*Defined at line 752 of ./engine/server/sv_client.cpp*

================SV_TestBandWidth

================

### SV_Ack

*void SV_Ack(netadr_s from)*

*Defined at line 804 of ./engine/server/sv_client.cpp*

================SV_Ack

================

### SV_Info

*void SV_Info(netadr_s from)*

*Defined at line 817 of ./engine/server/sv_client.cpp*

================SV_Info

Responds with short info for broadcast scansThe second parameter should be the current protocol version number.================

### SV_BuildNetAnswer

*void SV_BuildNetAnswer(netadr_s from)*

*Defined at line 860 of ./engine/server/sv_client.cpp*

================SV_BuildNetAnswer

Responds with long info for local and broadcast requests================

### SV_Ping

*void SV_Ping(netadr_s from)*

*Defined at line 945 of ./engine/server/sv_client.cpp*

================SV_Ping

Just responds with an acknowledgement================

### Rcon_Validate

*qboolean Rcon_Validate()*

*Defined at line 955 of ./engine/server/sv_client.cpp*

================Rcon_Validate================

### SV_EstablishTimeBase

*void SV_EstablishTimeBase(sv_client_t * cl, usercmd_t * cmds, int dropped, int numbackup, int numcmds)*

*Defined at line 1049 of ./engine/server/sv_client.cpp*

===================SV_EstablishTimeBase

Finangles latency and the like. ===================

### SV_CalcClientTime

*float SV_CalcClientTime(sv_client_t * cl)*

*Defined at line 1083 of ./engine/server/sv_client.cpp*

===================SV_CalcClientTime

compute latency for client===================

### SV_PutClientInServer

*void SV_PutClientInServer(sv_client_t * cl)*

*Defined at line 1282 of ./engine/server/sv_client.cpp*

===========PutClientInServer

Called when a player connects to a server or respawns ina deathmatch.============

### SV_UpdateClientView

*void SV_UpdateClientView(sv_client_t * cl)*

*Defined at line 1410 of ./engine/server/sv_client.cpp*

===========SV_UpdateClientView

Resend the client viewentity (used for demos)============

### SV_WriteDeltaDescriptionToClient

*void SV_WriteDeltaDescriptionToClient(sizebuf_t * msg)*

*Defined at line 1461 of ./engine/server/sv_client.cpp*

==================SV_WriteDeltaDescriptionToClient

send delta communication encoding==================

### SV_New_f

*qboolean SV_New_f(sv_client_t * cl)*

*Defined at line 1555 of ./engine/server/sv_client.cpp*

============================================================

CLIENT COMMAND EXECUTION

============================================================

================SV_New_f

Sends the first message from the server to a connected client.This will be sent on the initial connection and upon each server load.================

### SV_Disconnect_f

*qboolean SV_Disconnect_f(sv_client_t * cl)*

*Defined at line 1618 of ./engine/server/sv_client.cpp*

=================SV_Disconnect_f

The client is going to disconnect, so remove the connection immediately=================

### SV_ShowServerinfo_f

*qboolean SV_ShowServerinfo_f(sv_client_t * cl)*

*Defined at line 1631 of ./engine/server/sv_client.cpp*

==================SV_ShowServerinfo_f

Dumps the serverinfo info string==================

### SV_Pause_f

*qboolean SV_Pause_f(sv_client_t * cl)*

*Defined at line 1642 of ./engine/server/sv_client.cpp*

==================SV_Pause_f==================

### SV_UpdateUserinfo_f

*qboolean SV_UpdateUserinfo_f(sv_client_t * cl)*

*Defined at line 1785 of ./engine/server/sv_client.cpp*

==================SV_UpdateUserinfo_f==================

### SV_SetInfo_f

*qboolean SV_SetInfo_f(sv_client_t * cl)*

*Defined at line 1799 of ./engine/server/sv_client.cpp*

==================SV_SetInfo_f==================

### SV_Noclip_f

*qboolean SV_Noclip_f(sv_client_t * cl)*

*Defined at line 1813 of ./engine/server/sv_client.cpp*

==================SV_Noclip_f==================

### SV_Godmode_f

*qboolean SV_Godmode_f(sv_client_t * cl)*

*Defined at line 1839 of ./engine/server/sv_client.cpp*

==================SV_Godmode_f==================

### SV_Notarget_f

*qboolean SV_Notarget_f(sv_client_t * cl)*

*Defined at line 1863 of ./engine/server/sv_client.cpp*

==================SV_Notarget_f==================

### SV_Kill_f

*qboolean SV_Kill_f(sv_client_t * cl)*

*Defined at line 1884 of ./engine/server/sv_client.cpp*

==================SV_Kill_f==================

### SV_SendRes_f

*qboolean SV_SendRes_f(sv_client_t * cl)*

*Defined at line 1905 of ./engine/server/sv_client.cpp*

==================SV_SendRes_f==================

### SV_DownloadFile_f

*qboolean SV_DownloadFile_f(sv_client_t * cl)*

*Defined at line 1932 of ./engine/server/sv_client.cpp*

==================SV_DownloadFile_f==================

### SV_Spawn_f

*qboolean SV_Spawn_f(sv_client_t * cl)*

*Defined at line 2029 of ./engine/server/sv_client.cpp*

==================SV_Spawn_f==================

### SV_Begin_f

*qboolean SV_Begin_f(sv_client_t * cl)*

*Defined at line 2058 of ./engine/server/sv_client.cpp*

==================SV_Begin_f==================

### SV_SendBuildInfo_f

*qboolean SV_SendBuildInfo_f(sv_client_t * cl)*

*Defined at line 2073 of ./engine/server/sv_client.cpp*

==================SV_SendBuildInfo_f==================

### SV_TSourceEngineQuery

*void SV_TSourceEngineQuery(netadr_s from)*

*Defined at line 2148 of ./engine/server/sv_client.cpp*

==================SV_TSourceEngineQuery==================

### SV_ParseClientMove

*void SV_ParseClientMove(sv_client_t * cl, sizebuf_t * msg)*

*Defined at line 2269 of ./engine/server/sv_client.cpp*

==================SV_ParseClientMove

The message usually contains all the movement commands that were in the last three packets, so that the informationin dropped packets can be recovered.

On very fast clients, there may be multiple usercmd packed intoeach of the backup packets.==================

### SV_ParseResourceList

*void SV_ParseResourceList(sv_client_t * cl, sizebuf_t * msg)*

*Defined at line 2401 of ./engine/server/sv_client.cpp*

===================SV_ParseResourceList

Parse resource list===================

### SV_ParseCvarValue

*void SV_ParseCvarValue(sv_client_t * cl, sizebuf_t * msg)*

*Defined at line 2490 of ./engine/server/sv_client.cpp*

===================SV_ParseCvarValue

Parse a requested value from client cvar ===================

### SV_ParseCvarValue2

*void SV_ParseCvarValue2(sv_client_t * cl, sizebuf_t * msg)*

*Defined at line 2506 of ./engine/server/sv_client.cpp*

===================SV_ParseCvarValue2

Parse a requested value from client cvar ===================

### SV_ExecuteMsgHooks

*void SV_ExecuteMsgHooks(int cmd, sv_client_t * cl, sizebuf_t * msg)*

*Defined at line 2522 of ./engine/server/sv_client.cpp*

### pfnHookServerNetsystemMsg

*void pfnHookServerNetsystemMsg(void (*)(edict_t *, void *) pfnHook)*

*Defined at line 2532 of ./engine/server/sv_client.cpp*

### pfnHookServerMsg

*void pfnHookServerMsg(int cmd, void (*)(edict_t *, void *) pfnHook)*

*Defined at line 2537 of ./engine/server/sv_client.cpp*

### pfnBeginServerCmd

*sizebuf_t * pfnBeginServerCmd(edict_t * client, int msg)*

*Defined at line 2547 of ./engine/server/sv_client.cpp*

### GL_DebugOutput

*void GL_DebugOutput(GLuint source, GLuint type, GLuint id, GLuint severity, GLint length, const GLcharARB * message, GLvoid * userParam)*

*Defined at line 261 of ./rendersystem/r_opengl.cpp*

========================DebugCallback

For ARB_debug_output========================

### GL_SetDefaultTexState

*void GL_SetDefaultTexState()*

*Defined at line 401 of ./rendersystem/r_opengl.cpp*

===============GL_SetDefaultTexState===============

### GL_SetDefaultState

*void GL_SetDefaultState()*

*Defined at line 422 of ./rendersystem/r_opengl.cpp*

===============GL_SetDefaultState===============

### GL_SetDefaults

*void GL_SetDefaults()*

*Defined at line 437 of ./rendersystem/r_opengl.cpp*

===============GL_SetDefaults===============

### R_CheckVBO

*void R_CheckVBO()*

*Defined at line 843 of ./rendersystem/r_opengl.cpp*

===============R_CheckVBO

register VBO cvars and get default value===============

### Sound_LoadWAV

*qboolean Sound_LoadWAV(const char * name, const byte * buffer, fs_offset_t filesize)*

*Defined at line 142 of ./engine/common/soundlib/snd_wav.cpp*

 formats load

=============Sound_LoadWAV=============

### Sound_LoadMPG

*qboolean Sound_LoadMPG(const char * name, const byte * buffer, fs_offset_t filesize)*

*Defined at line 26 of ./engine/common/soundlib/snd_mp3.cpp*

=================================================================

	MPEG decompression

=================================================================

### Stream_OpenWAV

*stream_t * Stream_OpenWAV(const char * filename)*

*Defined at line 310 of ./engine/common/soundlib/snd_wav.cpp*

 stream operate

=================Stream_OpenWAV=================

### Stream_ReadWAV

*int Stream_ReadWAV(stream_t * stream, int bytes, void * buffer)*

*Defined at line 406 of ./engine/common/soundlib/snd_wav.cpp*

=================Stream_ReadWAV

assume stream is valid=================

### Stream_SetPosWAV

*int Stream_SetPosWAV(stream_t * stream, int newpos)*

*Defined at line 429 of ./engine/common/soundlib/snd_wav.cpp*

=================Stream_SetPosWAV

assume stream is valid=================

### Stream_GetPosWAV

*int Stream_GetPosWAV(stream_t * stream)*

*Defined at line 448 of ./engine/common/soundlib/snd_wav.cpp*

=================Stream_GetPosWAV

assume stream is valid=================

### Stream_FreeWAV

*void Stream_FreeWAV(stream_t * stream)*

*Defined at line 460 of ./engine/common/soundlib/snd_wav.cpp*

=================Stream_FreeWAV

assume stream is valid=================

### Stream_OpenMPG

*stream_t * Stream_OpenMPG(const char * filename)*

*Defined at line 113 of ./engine/common/soundlib/snd_mp3.cpp*

=================Stream_OpenMPG=================

### Stream_ReadMPG

*int Stream_ReadMPG(stream_t * stream, int bytes, void * buffer)*

*Defined at line 168 of ./engine/common/soundlib/snd_mp3.cpp*

=================Stream_ReadMPG

assume stream is valid=================

### Stream_SetPosMPG

*int Stream_SetPosMPG(stream_t * stream, int newpos)*

*Defined at line 216 of ./engine/common/soundlib/snd_mp3.cpp*

=================Stream_SetPosMPG

assume stream is valid=================

### Stream_GetPosMPG

*int Stream_GetPosMPG(stream_t * stream)*

*Defined at line 236 of ./engine/common/soundlib/snd_mp3.cpp*

=================Stream_GetPosMPG

assume stream is valid=================

### Stream_FreeMPG

*void Stream_FreeMPG(stream_t * stream)*

*Defined at line 248 of ./engine/common/soundlib/snd_mp3.cpp*

=================Stream_FreeMPG

assume stream is valid=================

### GetLittleShort

*short GetLittleShort()*

*Defined at line 29 of ./engine/common/soundlib/snd_wav.cpp*

=================GetLittleShort=================

### GetLittleLong

*int GetLittleLong()*

*Defined at line 45 of ./engine/common/soundlib/snd_wav.cpp*

=================GetLittleLong=================

### FindNextChunk

*void FindNextChunk(const char * name)*

*Defined at line 63 of ./engine/common/soundlib/snd_wav.cpp*

=================FindNextChunk=================

### FindChunk

*void FindChunk(const char * name)*

*Defined at line 98 of ./engine/common/soundlib/snd_wav.cpp*

=================FindChunk=================

### StreamFindNextChunk

*qboolean StreamFindNextChunk(file_t * file, const char * name, int * last_chunk)*

*Defined at line 109 of ./engine/common/soundlib/snd_wav.cpp*

============StreamFindNextChunk============

### GetEndMask

*unsigned int GetEndMask(int numBits)*

*Defined at line 36 of ./mainui/miniutl/bitstring.h*

### CalcNumIntsForBits

*int CalcNumIntsForBits(int numBits)*

*Defined at line 38 of ./mainui/miniutl/bitstring.h*

### DebugPrintBitStringBits

*void DebugPrintBitStringBits(const int * pInts, int nInts)*

*Defined at line 74 of ./mainui/miniutl/bitstring.cpp*

----------------------------------------------------------------------------- Purpose: Print bits for debugging purposes Input  : Output :-----------------------------------------------------------------------------

### SaveBitString

*void SaveBitString(const int * pInts, int nInts, class CUtlBuffer & buf)*

*Defined at line 91 of ./mainui/miniutl/bitstring.cpp*

----------------------------------------------------------------------------- Purpose: Saves a bit string to the given file Input  : Output :-----------------------------------------------------------------------------

### LoadBitString

*void LoadBitString(int * pInts, int nInts, class CUtlBuffer & buf)*

*Defined at line 106 of ./mainui/miniutl/bitstring.cpp*

----------------------------------------------------------------------------- Purpose: Loads a bit string from the given file Input  : Output :-----------------------------------------------------------------------------

### SaveBuildComment

*void SaveBuildComment(char * text, int maxlength)*

*Defined at line 229 of ./engine/server/sv_save.cpp*

=============SaveBuildComment

build commentary for each savegametypically it writes world message and level time=============

### DirectoryCount

*int DirectoryCount(const char * pPath)*

*Defined at line 265 of ./engine/server/sv_save.cpp*

=============DirectoryCount

counting all the files with HL1-HL3 extensionin save folder=============

### InitEntityTable

*void InitEntityTable(SAVERESTOREDATA * pSaveData, int entityCount)*

*Defined at line 286 of ./engine/server/sv_save.cpp*

=============InitEntityTable

reserve space for ETABLE's=============

### EntryInTable

*int EntryInTable(SAVERESTOREDATA * pSaveData, const char * pMapName, int index)*

*Defined at line 310 of ./engine/server/sv_save.cpp*

=============EntryInTable

check level in transition list=============

### EdictFromTable

*edict_t * EdictFromTable(SAVERESTOREDATA * pSaveData, int entityIndex)*

*Defined at line 330 of ./engine/server/sv_save.cpp*

=============EdictFromTable

get edict from table=============

### LandmarkOrigin

*void LandmarkOrigin(SAVERESTOREDATA * pSaveData, vec3_t output, const char * pLandmarkName)*

*Defined at line 348 of ./engine/server/sv_save.cpp*

=============LandmarkOrigin

find global offset for a given landmark=============

### EntityInSolid

*int EntityInSolid(edict_t * pent)*

*Defined at line 372 of ./engine/server/sv_save.cpp*

=============EntityInSolid

some moved edicts on a next level cause stuckoutside of world. Find them and remove=============

### ClearSaveDir

*void ClearSaveDir()*

*Defined at line 395 of ./engine/server/sv_save.cpp*

=============ClearSaveDir

remove all the temp files HL1-HL3(it will be extracted again from another .sav file)=============

### IsValidSave

*int IsValidSave()*

*Defined at line 417 of ./engine/server/sv_save.cpp*

=============IsValidSave

savegame is allowed?=============

### AgeSaveList

*void AgeSaveList(const char * pName, int count)*

*Defined at line 488 of ./engine/server/sv_save.cpp*

=============AgeSaveList

scroll the name list down=============

### SaveGetName

*qboolean SaveGetName(int lastnum, char * filename)*

*Defined at line 539 of ./engine/server/sv_save.cpp*

================== SaveGetName

build the savename================== 

### DirectoryCopy

*void DirectoryCopy(const char * pPath, file_t * pFile)*

*Defined at line 562 of ./engine/server/sv_save.cpp*

=============DirectoryCopy

put the HL1-HL3 files into .sav file=============

### DirectoryExtract

*void DirectoryExtract(file_t * pFile, int fileCount)*

*Defined at line 594 of ./engine/server/sv_save.cpp*

=============DirectoryExtract

extract the HL1-HL3 files from the .sav file=============

### SaveInit

*SAVERESTOREDATA * SaveInit(int size, int tokenCount)*

*Defined at line 622 of ./engine/server/sv_save.cpp*

=============SaveInit

initialize global save-restore buffer=============

### SaveClear

*void SaveClear(SAVERESTOREDATA * pSaveData)*

*Defined at line 649 of ./engine/server/sv_save.cpp*

=============SaveClear

clearing buffer for reuse=============

### SaveFinish

*void SaveFinish(SAVERESTOREDATA * pSaveData)*

*Defined at line 670 of ./engine/server/sv_save.cpp*

=============SaveFinish

release global save-restore buffer=============

### DumpHashStrings

*void DumpHashStrings(SAVERESTOREDATA * pSaveData, const char * pMessage)*

*Defined at line 699 of ./engine/server/sv_save.cpp*

=============DumpHashStrings

debug thing=============

### StoreHashTable

*char * StoreHashTable(SAVERESTOREDATA * pSaveData)*

*Defined at line 726 of ./engine/server/sv_save.cpp*

=============StoreHashTable

write the stringtable into file=============

### BuildHashTable

*void BuildHashTable(SAVERESTOREDATA * pSaveData, file_t * pFile)*

*Defined at line 757 of ./engine/server/sv_save.cpp*

=============BuildHashTable

build the stringtable from buffer=============

### GetClientDataSize

*int GetClientDataSize(const char * level)*

*Defined at line 788 of ./engine/server/sv_save.cpp*

=============GetClientDataSize

g-cont: this routine is redundanti'm write it just for more readable code=============

### LoadSaveData

*SAVERESTOREDATA * LoadSaveData(const char * level)*

*Defined at line 830 of ./engine/server/sv_save.cpp*

=============LoadSaveData

fill the save resore bufferparse hash strings=============

### ParseSaveTables

*void ParseSaveTables(SAVERESTOREDATA * pSaveData, SAVE_HEADER * pHeader, int updateGlobals)*

*Defined at line 901 of ./engine/server/sv_save.cpp*

=============ParseSaveTables

reading global data, setup ETABLE's=============

### EntityPatchWrite

*void EntityPatchWrite(SAVERESTOREDATA * pSaveData, const char * level)*

*Defined at line 945 of ./engine/server/sv_save.cpp*

=============EntityPatchWrite

write out the list of entities that are no longer in the save file for this level(they've been moved to another level)=============

### EntityPatchRead

*void EntityPatchRead(SAVERESTOREDATA * pSaveData, const char * level)*

*Defined at line 982 of ./engine/server/sv_save.cpp*

=============EntityPatchRead

read the list of entities that are no longer in the save file for this level(they've been moved to another level)=============

### RestoreDecal

*void RestoreDecal(SAVERESTOREDATA * pSaveData, decallist_t * entry, qboolean adjacent)*

*Defined at line 1012 of ./engine/server/sv_save.cpp*

=============RestoreDecal

restore decal**<not a builtin command>**  across transition=============

### RestoreSound

*void RestoreSound(SAVERESTOREDATA * pSaveData, soundlist_t * snd)*

*Defined at line 1085 of ./engine/server/sv_save.cpp*

=============RestoreSound

continue playing sound from saved position=============

### SaveClientState

*void SaveClientState(SAVERESTOREDATA * pSaveData, const char * level, int changelevel)*

*Defined at line 1113 of ./engine/server/sv_save.cpp*

=============SaveClientState

write out the list of premanent decals for this level=============

### LoadClientState

*void LoadClientState(SAVERESTOREDATA * pSaveData, const char * level, qboolean changelevel, qboolean adjacent)*

*Defined at line 1216 of ./engine/server/sv_save.cpp*

=============LoadClientState

read the list of decals and reapply them again=============

### CreateEntitiesInRestoreList

*void CreateEntitiesInRestoreList(SAVERESTOREDATA * pSaveData, int levelMask, qboolean create_world)*

*Defined at line 1334 of ./engine/server/sv_save.cpp*

=============CreateEntitiesInRestoreList

alloc private data for restored entities=============

### SaveGameState

*SAVERESTOREDATA * SaveGameState(int changelevel)*

*Defined at line 1393 of ./engine/server/sv_save.cpp*

=============SaveGameState

save current game state=============

### LoadGameState

*int LoadGameState(const char * level, qboolean changelevel)*

*Defined at line 1546 of ./engine/server/sv_save.cpp*

=============LoadGameState

load current game state=============

### SaveGameSlot

*int SaveGameSlot(const char * pSaveName, const char * pSaveComment)*

*Defined at line 1620 of ./engine/server/sv_save.cpp*

=============SaveGameSlot

do a save game=============

### SaveReadHeader

*int SaveReadHeader(file_t * pFile, GAME_HEADER * pHeader)*

*Defined at line 1696 of ./engine/server/sv_save.cpp*

=============SaveReadHeader

read header of .sav file=============

### CreateEntityTransitionList

*int CreateEntityTransitionList(SAVERESTOREDATA * pSaveData, int levelMask)*

*Defined at line 1749 of ./engine/server/sv_save.cpp*

=============CreateEntityTransitionList

moving edicts to another level=============

### LoadAdjacentEnts

*void LoadAdjacentEnts(const char * pOldLevel, const char * pLandmarkName)*

*Defined at line 1844 of ./engine/server/sv_save.cpp*

=============LoadAdjacentEnts

loading edicts from adjacency levels=============

### UpdateBeams

*void UpdateBeams()*

*Defined at line 35 of ./game/client/hl/hl_objects.cpp*

### NET_AddMaster

*void NET_AddMaster(const char * addr, qboolean save)*

*Defined at line 95 of ./engine/common/masterlist.cpp*

========================NET_AddMaster

Add master to the list========================

### NET_AddMaster_f

*void NET_AddMaster_f()*

*Defined at line 118 of ./engine/common/masterlist.cpp*

### NET_ClearMasters_f

*void NET_ClearMasters_f()*

*Defined at line 137 of ./engine/common/masterlist.cpp*

========================NET_ClearMasters

Clear master list========================

### NET_ListMasters_f

*void NET_ListMasters_f()*

*Defined at line 154 of ./engine/common/masterlist.cpp*

========================NET_ListMasters_f

Display current master linked list========================

### NET_LoadMasters

*void NET_LoadMasters()*

*Defined at line 175 of ./engine/common/masterlist.cpp*

========================NET_LoadMasters

Load master server list from xashcomm.lst========================

### PM_DrawRectangle

*void PM_DrawRectangle(Vector tl, Vector bl, Vector tr, Vector br, int pcolor, float life)*

*Defined at line 133 of ./pm_shared/pm_debug.cpp*

================PM_DrawRectangle(vec3_t tl, vec3_t br)

================

### PM_DrawPhysEntBBox

*void PM_DrawPhysEntBBox(int num, int pcolor, float life)*

*Defined at line 147 of ./pm_shared/pm_debug.cpp*

================PM_DrawPhysEntBBox(int num)

================

### CL_WriteErrorMessage

*void CL_WriteErrorMessage(int current_count, sizebuf_t * msg)*

*Defined at line 187 of ./engine/client/cl_debug.cpp*

=====================CL_WriteErrorMessage

write net_message into buffer.dat for debugging=====================

### UI_Audio_Precache

*void UI_Audio_Precache()*

*Defined at line 203 of ./mainui/menus/Audio.cpp*

=================UI_Audio_Precache=================

### UI_MultiPlayer_Precache

*void UI_MultiPlayer_Precache()*

*Defined at line 92 of ./mainui/menus/Multiplayer.cpp*

=================CMenuMultiplayer::Precache=================

### UI_Video_Precache

*void UI_Video_Precache()*

*Defined at line 32 of ./mainui/menus/Video.cpp*

=================UI_Video_Precache=================

### monster_cockroach

*void monster_cockroach(entvars_t * pev)*

*Defined at line 61 of ./game/server/npc/npc_roach.cpp*

### Cmd_GetMusicList

*qboolean Cmd_GetMusicList(const char * s, char * completedname, int length)*

*Defined at line 298 of ./engine/common/con_utils.cpp*

=====================================Cmd_GetMusicList

Prints or complete background track filename=====================================

### Cmd_GetSavesList

*qboolean Cmd_GetSavesList(const char * s, char * completedname, int length)*

*Defined at line 346 of ./engine/common/con_utils.cpp*

=====================================Cmd_GetSavesList

Prints or complete savegame filename=====================================

### Cmd_GetConfigList

*qboolean Cmd_GetConfigList(const char * s, char * completedname, int length)*

*Defined at line 393 of ./engine/common/con_utils.cpp*

=====================================Cmd_GetConfigList

Prints or complete .cfg filename=====================================

### Cmd_GetSoundList

*qboolean Cmd_GetSoundList(const char * s, char * completedname, int length)*

*Defined at line 440 of ./engine/common/con_utils.cpp*

=====================================Cmd_GetSoundList

Prints or complete sound filename=====================================

### Cmd_GetItemsList

*qboolean Cmd_GetItemsList(const char * s, char * completedname, int length)*

*Defined at line 492 of ./engine/common/con_utils.cpp*

=====================================Cmd_GetItemsList

Prints or complete item classname (weapons only)=====================================

### Cmd_GetKeysList

*qboolean Cmd_GetKeysList(const char * s, char * completedname, int length)*

*Defined at line 539 of ./engine/common/con_utils.cpp*

=====================================Cmd_GetKeysList

Autocomplete for bind command=====================================

### Con_AddCommandToList

*void Con_AddCommandToList(const char * s, const char * unused1, const char * unused2, void * _autocompleteList)*

*Defined at line 587 of ./engine/common/con_utils.cpp*

===============Con_AddCommandToList

===============

### Con_SortCmds

*int Con_SortCmds(const void * arg1, const void * arg2)*

*Defined at line 605 of ./engine/common/con_utils.cpp*

=================Con_SortCmds=================

### Cmd_GetCommandsList

*qboolean Cmd_GetCommandsList(const char * s, char * completedname, int length)*

*Defined at line 617 of ./engine/common/con_utils.cpp*

=====================================Cmd_GetCommandsList

Autocomplete for bind command=====================================

### Cmd_GetCustomList

*qboolean Cmd_GetCustomList(const char * s, char * completedname, int length)*

*Defined at line 682 of ./engine/common/con_utils.cpp*

=====================================Cmd_GetCustomList

Prints or complete .HPK filenames=====================================

### Cmd_GetGamesList

*qboolean Cmd_GetGamesList(const char * s, char * completedname, int length)*

*Defined at line 728 of ./engine/common/con_utils.cpp*

=====================================Cmd_GetGameList

Prints or complete gamedir name=====================================

### Cmd_GetCDList

*qboolean Cmd_GetCDList(const char * s, char * completedname, int length)*

*Defined at line 778 of ./engine/common/con_utils.cpp*

=====================================Cmd_GetCDList

Prints or complete CD command name=====================================

### Cmd_CheckMapsList_R

*qboolean Cmd_CheckMapsList_R(qboolean fRefresh, qboolean onlyingamedir)*

*Defined at line 829 of ./engine/common/con_utils.cpp*

### Cmd_CheckName

*qboolean Cmd_CheckName(const char * name)*

*Defined at line 1012 of ./engine/common/con_utils.cpp*

===============Cmd_CheckName

compare first argument with string===============

### Con_PrintCmdMatches

*void Con_PrintCmdMatches(const char * s, const char * unused1, const char * m, void * unused2)*

*Defined at line 1047 of ./engine/common/con_utils.cpp*

===============Con_PrintCmdMatches===============

### Con_PrintCvarMatches

*void Con_PrintCvarMatches(const char * s, const char * value, const char * m, void * unused2)*

*Defined at line 1061 of ./engine/common/con_utils.cpp*

===============Con_PrintCvarMatches===============

### Con_ConcatRemaining

*void Con_ConcatRemaining(const char * src, const char * start)*

*Defined at line 1075 of ./engine/common/con_utils.cpp*

===============Con_ConcatRemaining===============

### Cmd_WriteOpenGLCvar

*void Cmd_WriteOpenGLCvar(const char * name, const char * string, const char * desc, void * f)*

*Defined at line 1288 of ./engine/common/con_utils.cpp*

============Cmd_WriteVariables

Appends lines containing "set variable value" for all variableswith the archive flag set to true.============

### Cmd_WriteHelp

*void Cmd_WriteHelp(const char * name, const char * unused, const char * desc, void * f)*

*Defined at line 1295 of ./engine/common/con_utils.cpp*

### Cmd_WriteOpenGLVariables

*void Cmd_WriteOpenGLVariables(file_t * f)*

*Defined at line 1312 of ./engine/common/con_utils.cpp*

### Host_FinalizeConfig

*void Host_FinalizeConfig(file_t * f, const char * config)*

*Defined at line 1320 of ./engine/common/con_utils.cpp*

### __MsgFunc_SayText

*int __MsgFunc_SayText(const char * pszName, int iSize, void * pbuf)*

*Defined at line 46 of ./game/client/saytext.cpp*

### ScrollTextUp

*int ScrollTextUp()*

*Defined at line 76 of ./game/client/saytext.cpp*

### __MsgFunc_Train

*int __MsgFunc_Train(const char * pszName, int iSize, void * pbuf)*

*Defined at line 27 of ./game/client/train.cpp*

### UI_AdvControls_Precache

*void UI_AdvControls_Precache()*

*Defined at line 221 of ./mainui/menus/AdvancedControls.cpp*

=================UI_AdvControls_Precache=================

### monster_alien_slave

*void monster_alien_slave(entvars_t * pev)*

*Defined at line 98 of ./game/server/islave.cpp*

### monster_vortigaunt

*void monster_vortigaunt(entvars_t * pev)*

*Defined at line 99 of ./game/server/islave.cpp*

### func_friction

*void func_friction(entvars_t * pev)*

*Defined at line 59 of ./game/server/triggers.cpp*

### trigger_auto

*void trigger_auto(entvars_t * pev)*

*Defined at line 121 of ./game/server/triggers.cpp*

### trigger_relay

*void trigger_relay(entvars_t * pev)*

*Defined at line 198 of ./game/server/triggers.cpp*

### multi_manager

*void multi_manager(entvars_t * pev)*

*Defined at line 288 of ./game/server/triggers.cpp*

### env_render

*void env_render(entvars_t * pev)*

*Defined at line 467 of ./game/server/triggers.cpp*

### trigger

*void trigger(entvars_t * pev)*

*Defined at line 515 of ./game/server/triggers.cpp*

### trigger_hurt

*void trigger_hurt(entvars_t * pev)*

*Defined at line 566 of ./game/server/triggers.cpp*

### trigger_monsterjump

*void trigger_monsterjump(entvars_t * pev)*

*Defined at line 579 of ./game/server/triggers.cpp*

### trigger_cdaudio

*void trigger_cdaudio(entvars_t * pev)*

*Defined at line 645 of ./game/server/triggers.cpp*

### PlayCDTrack

*void PlayCDTrack(int iTrack)*

*Defined at line 672 of ./game/server/triggers.cpp*

### target_cdaudio

*void target_cdaudio(entvars_t * pev)*

*Defined at line 723 of ./game/server/triggers.cpp*

### trigger_multiple

*void trigger_multiple(entvars_t * pev)*

*Defined at line 1036 of ./game/server/triggers.cpp*

### trigger_once

*void trigger_once(entvars_t * pev)*

*Defined at line 1083 of ./game/server/triggers.cpp*

### trigger_counter

*void trigger_counter(entvars_t * pev)*

*Defined at line 1239 of ./game/server/triggers.cpp*

### trigger_transition

*void trigger_transition(entvars_t * pev)*

*Defined at line 1260 of ./game/server/triggers.cpp*

### fireanddie

*void fireanddie(entvars_t * pev)*

*Defined at line 1282 of ./game/server/triggers.cpp*

### trigger_changelevel

*void trigger_changelevel(entvars_t * pev)*

*Defined at line 1330 of ./game/server/triggers.cpp*

### NextLevel

*void NextLevel()*

*Defined at line 1681 of ./game/server/triggers.cpp*

go to the next level for deathmatchonly called if a time or frag limit has expired

### func_ladder

*void func_ladder(entvars_t * pev)*

*Defined at line 1719 of ./game/server/triggers.cpp*

### trigger_push

*void trigger_push(entvars_t * pev)*

*Defined at line 1760 of ./game/server/triggers.cpp*

### trigger_teleport

*void trigger_teleport(entvars_t * pev)*

*Defined at line 1899 of ./game/server/triggers.cpp*

### info_teleport_destination

*void info_teleport_destination(entvars_t * pev)*

*Defined at line 1908 of ./game/server/triggers.cpp*

### FracNoise

*void FracNoise(float * noise, int divs)*

*Defined at line 47 of ./ref_gl/gl_beams.cpp*

 freq2 += step * 0.1; Fractal noise generator, power of 2 wavelength

### SineNoise

*void SineNoise(float * noise, int divs)*

*Defined at line 64 of ./ref_gl/gl_beams.cpp*

### R_BeamComputePerpendicular

*void R_BeamComputePerpendicular(const vec3_t vecBeamDelta, vec3_t pPerp)*

*Defined at line 85 of ./ref_gl/gl_beams.cpp*

==============================================================

BEAM MATHLIB

==============================================================

### R_BeamComputeNormal

*void R_BeamComputeNormal(const vec3_t vStartPos, const vec3_t vNextPos, vec3_t pNormal)*

*Defined at line 95 of ./ref_gl/gl_beams.cpp*

### trigger_autosave

*void trigger_autosave(entvars_t * pev)*

*Defined at line 1917 of ./game/server/triggers.cpp*

### R_DrawSegs

*void R_DrawSegs(vec3_t source, vec3_t delta, float width, float scale, float freq, float speed, int segments, int flags)*

*Defined at line 193 of ./ref_gl/gl_beams.cpp*

==============================================================

BEAM DRAW METHODS

==============================================================

================R_DrawSegs

general code for drawing beams================

### R_BeamComputePoint

*qboolean R_BeamComputePoint(int beamEnt, vec3_t pt)*

*Defined at line 851 of ./ref_gl/gl_beams.cpp*

==============R_BeamComputePoint

compute attachment point for beam==============

### R_BeamSetAttributes

*void R_BeamSetAttributes(BEAM * pbeam, float r, float g, float b, float framerate, int startFrame)*

*Defined at line 1132 of ./ref_gl/gl_beams.cpp*

==============R_BeamSetAttributes

set beam attributes==============

### R_BeamSetup

*void R_BeamSetup(BEAM * pbeam, vec3_t start, vec3_t end, int modelIndex, float life, float width, float amplitude, float brightness, float speed)*

*Defined at line 1149 of ./ref_gl/gl_beams.cpp*

==============R_BeamSetup

generic function. all beams must bepassed through this==============

### trigger_endsection

*void trigger_endsection(entvars_t * pev)*

*Defined at line 1956 of ./game/server/triggers.cpp*

### trigger_gravity

*void trigger_gravity(entvars_t * pev)*

*Defined at line 2025 of ./game/server/triggers.cpp*

### trigger_changetarget

*void trigger_changetarget(entvars_t * pev)*

*Defined at line 2060 of ./game/server/triggers.cpp*

### trigger_camera

*void trigger_camera(entvars_t * pev)*

*Defined at line 2132 of ./game/server/triggers.cpp*

### monster_human_grunt

*void monster_human_grunt(entvars_t * pev)*

*Defined at line 190 of ./game/server/npc/npc_hgrunt.cpp*

### monster_grunt_repel

*void monster_grunt_repel(entvars_t * pev)*

*Defined at line 2358 of ./game/server/npc/npc_hgrunt.cpp*

### monster_hgrunt_dead

*void monster_hgrunt_dead(entvars_t * pev)*

*Defined at line 2430 of ./game/server/npc/npc_hgrunt.cpp*

### light

*void light(entvars_t * pev)*

*Defined at line 44 of ./game/server/lights.cpp*

### light_spot

*void light_spot(entvars_t * pev)*

*Defined at line 134 of ./game/server/lights.cpp*

### light_environment

*void light_environment(entvars_t * pev)*

*Defined at line 143 of ./game/server/lights.cpp*

### SpawnExplosion

*void SpawnExplosion(Vector center, float randomRange, float time, int magnitude)*

*Defined at line 1313 of ./game/server/npc/npc_gargantua.cpp*

 HACKHACK Cut and pasted from explode.cpp

### streak_spiral

*void streak_spiral(entvars_t * pev)*

*Defined at line 77 of ./game/server/npc/npc_gargantua.cpp*

### garg_stomp

*void garg_stomp(entvars_t * pev)*

*Defined at line 91 of ./game/server/npc/npc_gargantua.cpp*

### StreakSplash

*void StreakSplash(const class Vector & origin, const class Vector & direction, int color, int count, int speed, int velocityRange)*

*Defined at line 181 of ./game/server/npc/npc_gargantua.cpp*

### monster_gargantua

*void monster_gargantua(entvars_t * pev)*

*Defined at line 274 of ./game/server/npc/npc_gargantua.cpp*

### NET_ErrorString

*char * NET_ErrorString()*

*Defined at line 182 of ./engine/common/net_ws.cpp*

====================NET_ErrorString====================

### NET_IsSocketError

*qboolean NET_IsSocketError(int retval)*

*Defined at line 243 of ./engine/common/net_ws.cpp*

### NET_IsSocketValid

*qboolean NET_IsSocketValid(int socket)*

*Defined at line 252 of ./engine/common/net_ws.cpp*

### NET_NetadrToSockadr

*void NET_NetadrToSockadr(netadr_t * a, struct sockaddr * s)*

*Defined at line 266 of ./engine/common/net_ws.cpp*

====================NET_NetadrToSockadr====================

### env_smoker

*void env_smoker(entvars_t * pev)*

*Defined at line 1217 of ./game/server/npc/npc_gargantua.cpp*

### NET_SockadrToNetadr

*void NET_SockadrToNetadr(struct sockaddr * s, netadr_t * a)*

*Defined at line 289 of ./engine/common/net_ws.cpp*

====================NET_SockadrToNetAdr====================

### NET_GetHostByName

*int NET_GetHostByName(const char * hostname)*

*Defined at line 304 of ./engine/common/net_ws.cpp*

============NET_GetHostByName============

### NET_ResolveThread

*void NET_ResolveThread()*

*Defined at line 403 of ./engine/common/net_ws.cpp*

### NET_ThreadStart

*void * NET_ThreadStart(void * unused)*

*Defined at line 354 of ./engine/common/net_ws.cpp*

### NET_StringToSockaddr

*int NET_StringToSockaddr(const char * s, struct sockaddr * sadr, qboolean nonblocking)*

*Defined at line 442 of ./engine/common/net_ws.cpp*

=============NET_StringToAdr

localhostidnewtidnewt:28000192.246.40.70192.246.40.70:28000=============

### NET_GetLoopPacket

*qboolean NET_GetLoopPacket(netsrc_t sock, netadr_t * from, byte * data, size_t * length)*

*Defined at line 728 of ./engine/common/net_ws.cpp*

=============================================================================

LOOPBACK BUFFERS FOR LOCAL PLAYER

=============================================================================

====================NET_GetLoopPacket====================

### NET_SendLoopPacket

*void NET_SendLoopPacket(netsrc_t sock, size_t length, const void * data, netadr_s to)*

*Defined at line 760 of ./engine/common/net_ws.cpp*

====================NET_SendLoopPacket====================

### NET_ClearLoopback

*void NET_ClearLoopback()*

*Defined at line 779 of ./engine/common/net_ws.cpp*

====================NET_ClearLoopback====================

### NET_RemoveFromPacketList

*void NET_RemoveFromPacketList(packetlag_t * p)*

*Defined at line 799 of ./engine/common/net_ws.cpp*

=============================================================================

LAG & LOSS SIMULATION SYSTEM (network debugging)

=============================================================================

==================NET_RemoveFromPacketList

double linked list remove entry==================

### NET_ClearLaggedList

*void NET_ClearLaggedList(packetlag_t * list)*

*Defined at line 814 of ./engine/common/net_ws.cpp*

==================NET_ClearLaggedList

double linked list remove queue==================

### NET_AddToLagged

*void NET_AddToLagged(netsrc_t sock, packetlag_t * list, packetlag_t * packet, netadr_t * from, size_t length, const void * data, float timestamp)*

*Defined at line 846 of ./engine/common/net_ws.cpp*

==================NET_AddToLagged

add lagged packet to stream==================

### NET_AdjustLag

*void NET_AdjustLag()*

*Defined at line 873 of ./engine/common/net_ws.cpp*

==================NET_AdjustLag

adjust time to next fake lag==================

### NET_LagPacket

*qboolean NET_LagPacket(qboolean newdata, netsrc_t sock, netadr_t * from, size_t * length, void * data)*

*Defined at line 911 of ./engine/common/net_ws.cpp*

==================NET_LagPacket

add fake lagged packet into rececived message==================

### NET_GetLong

*qboolean NET_GetLong(byte * pData, int size, size_t * outSize, int splitsize)*

*Defined at line 993 of ./engine/common/net_ws.cpp*

==================NET_GetLong

receive long packet from network==================

### NET_QueuePacket

*qboolean NET_QueuePacket(netsrc_t sock, netadr_t * from, byte * data, size_t * length)*

*Defined at line 1084 of ./engine/common/net_ws.cpp*

==================NET_QueuePacket

queue normal and lagged packets==================

### NET_SendLong

*int NET_SendLong(netsrc_t sock, int net_socket, const char * buf, size_t len, int flags, const struct sockaddr * to, size_t tolen, size_t splitsize)*

*Defined at line 1181 of ./engine/common/net_ws.cpp*

==================NET_SendLong

Fragment long packets, send short directly==================

### NET_Isocket

*int NET_Isocket(const char * net_interface, int port, qboolean multicast)*

*Defined at line 1383 of ./engine/common/net_ws.cpp*

====================NET_Isocket====================

### NET_OpenIP

*void NET_OpenIP()*

*Defined at line 1469 of ./engine/common/net_ws.cpp*

====================NET_OpenIP====================

### NET_GetLocalAddress

*void NET_GetLocalAddress()*

*Defined at line 1508 of ./engine/common/net_ws.cpp*

================NET_GetLocalAddress

Returns the servers' ip address as a string.================

### HTTP_FreeFile

*void HTTP_FreeFile(httpfile_t * file, qboolean error)*

*Defined at line 1853 of ./engine/common/net_ws.cpp*

==============HTTP_FreeFile

Skip to next server/file==============

### HTTP_AutoClean

*void HTTP_AutoClean()*

*Defined at line 1915 of ./engine/common/net_ws.cpp*

===================HTTP_AutoClean

remove files with HTTP_FREE state from list===================

### HTTP_ProcessStream

*qboolean HTTP_ProcessStream(httpfile_t * curfile)*

*Defined at line 1955 of ./engine/common/net_ws.cpp*

===================HTTP_ProcessStream

process incoming data===================

### HTTP_Download_f

*void HTTP_Download_f()*

*Defined at line 2342 of ./engine/common/net_ws.cpp*

===============HTTP_Download_f

Console wrapper===============

### HTTP_ParseURL

*httpserver_t * HTTP_ParseURL(const char * url)*

*Defined at line 2358 of ./engine/common/net_ws.cpp*

==============HTTP_ParseURL==============

### HTTP_AddCustomServer_f

*void HTTP_AddCustomServer_f()*

*Defined at line 2434 of ./engine/common/net_ws.cpp*

=======================HTTP_AddCustomServer_f=======================

### HTTP_Clear_f

*void HTTP_Clear_f()*

*Defined at line 2449 of ./engine/common/net_ws.cpp*

============HTTP_Clear_f

Clear all queue============

### HTTP_Cancel_f

*void HTTP_Cancel_f()*

*Defined at line 2477 of ./engine/common/net_ws.cpp*

==============HTTP_Cancel_f

Stop current download, skip to next file==============

### HTTP_Skip_f

*void HTTP_Skip_f()*

*Defined at line 2493 of ./engine/common/net_ws.cpp*

=============HTTP_Skip_f

Stop current download, skip to next server=============

### HTTP_List_f

*void HTTP_List_f()*

*Defined at line 2506 of ./engine/common/net_ws.cpp*

=============HTTP_List_f

Print all pending downloads to console=============

### HTTP_ResetProcessState

*void HTTP_ResetProcessState()*

*Defined at line 2530 of ./engine/common/net_ws.cpp*

================HTTP_ResetProcessState

When connected to new server, all old files should not increase counter================

### func_recharge

*void func_recharge(entvars_t * pev)*

*Defined at line 70 of ./game/server/func_recharge.cpp*

### R_StudioDrawPlayer

*int R_StudioDrawPlayer(int flags, entity_state_t * pplayer)*

*Defined at line 60 of ./game/client/GameStudioModelRenderer.cpp*

====================R_StudioDrawPlayer

====================

### R_StudioDrawModel

*int R_StudioDrawModel(int flags)*

*Defined at line 71 of ./game/client/GameStudioModelRenderer.cpp*

====================R_StudioDrawModel

====================

### HUD_GetStudioModelInterface

*int HUD_GetStudioModelInterface(int version, struct r_studio_interface_s ** ppinterface, struct engine_studio_api_s * pstudio)*

*Defined at line 102 of ./game/client/GameStudioModelRenderer.cpp*

====================HUD_GetStudioModelInterface

Export this function for the engine to use the studio renderer class to render objects.====================

### LM_UploadBlock

*void LM_UploadBlock(qboolean dynamic)*

*Defined at line 671 of ./ref_gl/gl_rsurf.cpp*

### R_AddSurfToVBO

*qboolean R_AddSurfToVBO(msurface_t * surf, qboolean buildlightmaps)*

*Defined at line 2979 of ./ref_gl/gl_rsurf.cpp*

### R_DrawVBO

*void R_DrawVBO(qboolean drawlightmaps, qboolean drawtextures)*

*Defined at line 2647 of ./ref_gl/gl_rsurf.cpp*

=====================R_DrawVBO

Draw generated index arrays=====================

### BoundPoly

*void BoundPoly(int numverts, float * verts, vec3_t mins, vec3_t maxs)*

*Defined at line 64 of ./ref_gl/gl_rsurf.cpp*

### SubdividePolygon_r

*void SubdividePolygon_r(msurface_t * warpface, int numverts, float * verts)*

*Defined at line 81 of ./ref_gl/gl_rsurf.cpp*

### R_TextureAnim

*texture_t * R_TextureAnim(texture_t * b)*

*Defined at line 406 of ./ref_gl/gl_rsurf.cpp*

===============R_TextureAnim

Returns the proper texture for a given time and base texture, do not process random tiling===============

### R_AddDynamicLights

*void R_AddDynamicLights(msurface_t * surf)*

*Defined at line 507 of ./ref_gl/gl_rsurf.cpp*

===============R_AddDynamicLights===============

### R_SetCacheState

*void R_SetCacheState(msurface_t * surf)*

*Defined at line 600 of ./ref_gl/gl_rsurf.cpp*

================R_SetCacheState================

### LM_InitBlock

*void LM_InitBlock()*

*Defined at line 617 of ./ref_gl/gl_rsurf.cpp*

=============================================================================

  LIGHTMAP ALLOCATION

=============================================================================

### LM_AllocBlock

*int LM_AllocBlock(int w, int h, int * x, int * y)*

*Defined at line 622 of ./ref_gl/gl_rsurf.cpp*

### LM_UploadDynamicBlock

*void LM_UploadDynamicBlock()*

*Defined at line 658 of ./ref_gl/gl_rsurf.cpp*

### R_BuildLightMap

*void R_BuildLightMap(msurface_t * surf, byte * dest, int stride, qboolean dynamic)*

*Defined at line 720 of ./ref_gl/gl_rsurf.cpp*

=================R_BuildLightmap

Combine and scale multiple lightmaps into the floatingformat in r_blocklights=================

### DrawGLPolyChain

*void DrawGLPolyChain(glpoly_t * p, float soffset, float toffset)*

*Defined at line 857 of ./ref_gl/gl_rsurf.cpp*

================DrawGLPolyChain

Render lightmaps================

### R_HasLightmap

*qboolean R_HasLightmap()*

*Defined at line 882 of ./ref_gl/gl_rsurf.cpp*

### R_BlendLightmaps

*void R_BlendLightmaps()*

*Defined at line 911 of ./ref_gl/gl_rsurf.cpp*

================R_BlendLightmaps================

### R_RenderFullbrights

*void R_RenderFullbrights()*

*Defined at line 1036 of ./ref_gl/gl_rsurf.cpp*

================R_RenderFullbrights================

### R_RenderDetails

*void R_RenderDetails()*

*Defined at line 1079 of ./ref_gl/gl_rsurf.cpp*

================R_RenderDetails================

### R_RenderBrushPoly

*void R_RenderBrushPoly(msurface_t * fa, int cull_type)*

*Defined at line 1129 of ./ref_gl/gl_rsurf.cpp*

================R_RenderBrushPoly================

### R_DrawTextureChains

*void R_DrawTextureChains()*

*Defined at line 1261 of ./ref_gl/gl_rsurf.cpp*

================R_DrawTextureChains================

### R_SurfaceCompare

*int R_SurfaceCompare(const void * a, const void * b)*

*Defined at line 1440 of ./ref_gl/gl_rsurf.cpp*

=================R_SurfaceCompare

compare translucent surfaces=================

### R_SetRenderMode

*void R_SetRenderMode(cl_entity_t * e)*

*Defined at line 1464 of ./ref_gl/gl_rsurf.cpp*

### R_DisableDetail

*void R_DisableDetail()*

*Defined at line 2082 of ./ref_gl/gl_rsurf.cpp*

===================R_DisableDetail

disable detail tmu===================

### R_EnableDetail

*void R_EnableDetail()*

*Defined at line 2100 of ./ref_gl/gl_rsurf.cpp*

===================R_EnableDetail

enable detail tmu if availiable===================

### R_SetLightmap

*void R_SetLightmap()*

*Defined at line 2132 of ./ref_gl/gl_rsurf.cpp*

==============R_SetLightmap

enable lightmap on current tmu==============

### R_SetDecalMode

*void R_SetDecalMode(qboolean enable)*

*Defined at line 2159 of ./ref_gl/gl_rsurf.cpp*

==============R_SetDecalMode

When drawing decal, disable or restore bump and detailsset tmu to lightmap when enabled==============

### R_SetupVBOTexture

*texture_t * R_SetupVBOTexture(texture_t * tex, int number)*

*Defined at line 2182 of ./ref_gl/gl_rsurf.cpp*

==============R_SetupVBOTexture

setup multitexture mode before drawing VBOsif tex is NULL, load texture by number==============

### R_AdditionalPasses

*void R_AdditionalPasses(vboarray_t * vbo, int indexlen, void * indexarray, texture_t * tex, qboolean resetvbo)*

*Defined at line 2211 of ./ref_gl/gl_rsurf.cpp*

===================R_AdditionalPasses

draw details when not enough tmus===================

### R_DrawLightmappedVBO

*void R_DrawLightmappedVBO(vboarray_t * vbo, vbotexture_t * vbotex, texture_t * texture, int lightmap, qboolean skiplighting)*

*Defined at line 2268 of ./ref_gl/gl_rsurf.cpp*

=====================R_DrawLightmappedVBO

Draw array for given vbotexture_t. build and draw dynamic lightmaps if present=====================

### R_CheckLightMap

*qboolean R_CheckLightMap(msurface_t * fa)*

*Defined at line 2912 of ./ref_gl/gl_rsurf.cpp*

================R_CheckLightMap

update surface's lightmap if needed and return true if it is dynamic================

### R_RecursiveWorldNode

*void R_RecursiveWorldNode(mnode_t * node, uint clipflags)*

*Defined at line 3045 of ./ref_gl/gl_rsurf.cpp*

=============================================================

	WORLD MODEL

=============================================================

================R_RecursiveWorldNode================

### R_CullNodeTopView

*qboolean R_CullNodeTopView(mnode_t * node)*

*Defined at line 3139 of ./ref_gl/gl_rsurf.cpp*

================R_CullNodeTopView

cull node by user rectangle (simple scissor)================

### R_DrawTopViewLeaf

*void R_DrawTopViewLeaf(mleaf_t * pleaf, uint clipflags)*

*Defined at line 3160 of ./ref_gl/gl_rsurf.cpp*

================R_DrawTopViewLeaf================

### R_DrawWorldTopView

*void R_DrawWorldTopView(mnode_t * node, uint clipflags)*

*Defined at line 3197 of ./ref_gl/gl_rsurf.cpp*

================R_DrawWorldTopView================

### R_DrawTriangleOutlines

*void R_DrawTriangleOutlines()*

*Defined at line 3267 of ./ref_gl/gl_rsurf.cpp*

=============R_DrawTriangleOutlines=============

### GL_CreateSurfaceLightmap

*void GL_CreateSurfaceLightmap(msurface_t * surf, model_t * loadmodel)*

*Defined at line 3467 of ./ref_gl/gl_rsurf.cpp*

========================GL_CreateSurfaceLightmap========================

### UI_LoadGame_Precache

*void UI_LoadGame_Precache()*

*Defined at line 368 of ./mainui/menus/LoadGame.cpp*

=================UI_LoadGame_Precache=================

### UI_LoadSaveGame_Menu

*void UI_LoadSaveGame_Menu(_Bool saveMode)*

*Defined at line 374 of ./mainui/menus/LoadGame.cpp*

### LM_UploadBlock

*void LM_UploadBlock(qboolean dynamic)*

*Defined at line 671 of ./rendersystem/r_surf.cpp*

### R_AddSurfToVBO

*qboolean R_AddSurfToVBO(msurface_t * surf, qboolean buildlightmaps)*

*Defined at line 2979 of ./rendersystem/r_surf.cpp*

### R_DrawVBO

*void R_DrawVBO(qboolean drawlightmaps, qboolean drawtextures)*

*Defined at line 2647 of ./rendersystem/r_surf.cpp*

=====================R_DrawVBO

Draw generated index arrays=====================

### BoundPoly

*void BoundPoly(int numverts, float * verts, vec3_t mins, vec3_t maxs)*

*Defined at line 64 of ./rendersystem/r_surf.cpp*

### SubdividePolygon_r

*void SubdividePolygon_r(msurface_t * warpface, int numverts, float * verts)*

*Defined at line 81 of ./rendersystem/r_surf.cpp*

### LM_InitBlock

*void LM_InitBlock()*

*Defined at line 617 of ./rendersystem/r_surf.cpp*

=============================================================================

  LIGHTMAP ALLOCATION

=============================================================================

### LM_AllocBlock

*int LM_AllocBlock(int w, int h, int * x, int * y)*

*Defined at line 622 of ./rendersystem/r_surf.cpp*

### LM_UploadDynamicBlock

*void LM_UploadDynamicBlock()*

*Defined at line 658 of ./rendersystem/r_surf.cpp*

### R_BuildLightMap

*void R_BuildLightMap(msurface_t * surf, byte * dest, int stride, qboolean dynamic)*

*Defined at line 720 of ./rendersystem/r_surf.cpp*

=================R_BuildLightmap

Combine and scale multiple lightmaps into the floatingformat in r_blocklights=================

### R_HasLightmap

*qboolean R_HasLightmap()*

*Defined at line 882 of ./rendersystem/r_surf.cpp*

### R_SurfaceCompare

*int R_SurfaceCompare(const void * a, const void * b)*

*Defined at line 1440 of ./rendersystem/r_surf.cpp*

=================R_SurfaceCompare

compare translucent surfaces=================

### R_DisableDetail

*void R_DisableDetail()*

*Defined at line 2082 of ./rendersystem/r_surf.cpp*

===================R_DisableDetail

disable detail tmu===================

### R_EnableDetail

*void R_EnableDetail()*

*Defined at line 2100 of ./rendersystem/r_surf.cpp*

===================R_EnableDetail

enable detail tmu if availiable===================

### R_SetLightmap

*void R_SetLightmap()*

*Defined at line 2132 of ./rendersystem/r_surf.cpp*

==============R_SetLightmap

enable lightmap on current tmu==============

### R_SetDecalMode

*void R_SetDecalMode(qboolean enable)*

*Defined at line 2159 of ./rendersystem/r_surf.cpp*

==============R_SetDecalMode

When drawing decal, disable or restore bump and detailsset tmu to lightmap when enabled==============

### R_SetupVBOTexture

*texture_t * R_SetupVBOTexture(texture_t * tex, int number)*

*Defined at line 2182 of ./rendersystem/r_surf.cpp*

==============R_SetupVBOTexture

setup multitexture mode before drawing VBOsif tex is NULL, load texture by number==============

### R_AdditionalPasses

*void R_AdditionalPasses(vboarray_t * vbo, int indexlen, void * indexarray, texture_t * tex, qboolean resetvbo)*

*Defined at line 2211 of ./rendersystem/r_surf.cpp*

===================R_AdditionalPasses

draw details when not enough tmus===================

### R_DrawLightmappedVBO

*void R_DrawLightmappedVBO(vboarray_t * vbo, vbotexture_t * vbotex, texture_t * texture, int lightmap, qboolean skiplighting)*

*Defined at line 2268 of ./rendersystem/r_surf.cpp*

=====================R_DrawLightmappedVBO

Draw array for given vbotexture_t. build and draw dynamic lightmaps if present=====================

### R_CheckLightMap

*qboolean R_CheckLightMap(msurface_t * fa)*

*Defined at line 2912 of ./rendersystem/r_surf.cpp*

================R_CheckLightMap

update surface's lightmap if needed and return true if it is dynamic================

### R_DrawTopViewLeaf

*void R_DrawTopViewLeaf(mleaf_t * pleaf, uint clipflags)*

*Defined at line 3160 of ./rendersystem/r_surf.cpp*

================R_DrawTopViewLeaf================

### monster_alien_grunt

*void monster_alien_grunt(entvars_t * pev)*

*Defined at line 124 of ./game/server/npc/npc_agrunt.cpp*

### monster_bloater

*void monster_bloater(entvars_t * pev)*

*Defined at line 50 of ./game/server/npc/npc_bloater.cpp*

### multisource

*void multisource(entvars_t * pev)*

*Defined at line 66 of ./game/shared/c_point_entity.cpp*

### GiveFnptrsToDll

*void GiveFnptrsToDll(enginefuncs_t * pengfuncsFromEngine, globalvars_t * pGlobals)*

*Defined at line 53 of ./game/server/h_export.cpp*

### Netchan_FlushIncoming

*void Netchan_FlushIncoming(netchan_t * chan, int stream)*

*Defined at line 1065 of ./engine/common/net_chan.cpp*

 forward declarations

==============================Netchan_FlushIncoming

==============================

### Netchan_AddBufferToList

*void Netchan_AddBufferToList(fragbuf_t ** pplist, fragbuf_t * pbuf)*

*Defined at line 655 of ./engine/common/net_chan.cpp*

==============================Netchan_AddBufferToList

==============================

### NetSplit_SendLong

*void NetSplit_SendLong(netsrc_t sock, size_t length, void * data, netadr_s to, unsigned int maxpacket, unsigned int id)*

*Defined at line 209 of ./engine/common/net_chan.cpp*

======================NetSplit_SendLong

Send parts that are less or equal maxpacket======================

### Netchan_UnlinkFragment

*void Netchan_UnlinkFragment(fragbuf_t * buf, fragbuf_t ** list)*

*Defined at line 369 of ./engine/common/net_chan.cpp*

==============================Netchan_UnlinkFragment

==============================

### Netchan_ClearFragbufs

*void Netchan_ClearFragbufs(fragbuf_t ** ppbuf)*

*Defined at line 407 of ./engine/common/net_chan.cpp*

==============================Netchan_ClearFragbufs

==============================

### Netchan_ClearFragments

*void Netchan_ClearFragments(netchan_t * chan)*

*Defined at line 432 of ./engine/common/net_chan.cpp*

==============================Netchan_ClearFragments

==============================

### Netchan_AllocFragbuf

*fragbuf_t * Netchan_AllocFragbuf()*

*Defined at line 540 of ./engine/common/net_chan.cpp*

==============================Netchan_AllocFragbuf

==============================

### Netchan_AddFragbufToTail

*void Netchan_AddFragbufToTail(fragbufwaiting_t * wait, fragbuf_t * buf)*

*Defined at line 556 of ./engine/common/net_chan.cpp*

==============================Netchan_AddFragbufToTail

==============================

### Netchan_UpdateFlow

*void Netchan_UpdateFlow(netchan_t * chan)*

*Defined at line 579 of ./engine/common/net_chan.cpp*

==============================Netchan_UpdateFlow

==============================

### Netchan_CreateFragments_

*void Netchan_CreateFragments_(netchan_t * chan, sizebuf_t * msg)*

*Defined at line 700 of ./engine/common/net_chan.cpp*

==============================Netchan_CreateFragments_

==============================

### Netchan_FindBufferById

*fragbuf_t * Netchan_FindBufferById(fragbuf_t ** pplist, int id, qboolean allocate)*

*Defined at line 791 of ./engine/common/net_chan.cpp*

==============================Netchan_FindBufferById

==============================

### Netchan_CheckForCompletion

*void Netchan_CheckForCompletion(netchan_t * chan, int stream, int intotalbuffers)*

*Defined at line 821 of ./engine/common/net_chan.cpp*

==============================Netchan_CheckForCompletion

==============================

### Netchan_Validate

*qboolean Netchan_Validate(netchan_t * chan, sizebuf_t * sb, qboolean * frag_message, uint * fragid, int * frag_offset, int * frag_length)*

*Defined at line 1276 of ./engine/common/net_chan.cpp*

### __CmdFunc_ShowScores

*void __CmdFunc_ShowScores()*

*Defined at line 42 of ./game/client/scoreboard.cpp*

### __CmdFunc_HideScores

*void __CmdFunc_HideScores()*

*Defined at line 43 of ./game/client/scoreboard.cpp*

### __MsgFunc_ScoreInfo

*int __MsgFunc_ScoreInfo(const char * pszName, int iSize, void * pbuf)*

*Defined at line 45 of ./game/client/scoreboard.cpp*

### __MsgFunc_TeamInfo

*int __MsgFunc_TeamInfo(const char * pszName, int iSize, void * pbuf)*

*Defined at line 46 of ./game/client/scoreboard.cpp*

### __MsgFunc_TeamScore

*int __MsgFunc_TeamScore(const char * pszName, int iSize, void * pbuf)*

*Defined at line 47 of ./game/client/scoreboard.cpp*

### monster_leech

*void monster_leech(entvars_t * pev)*

*Defined at line 136 of ./game/server/npc/npc_leech.cpp*

### GlobalCommandLine

*class CCommandLine & GlobalCommandLine()*

*Defined at line 84 of ./public/cmdline.cpp*

### info_node

*void info_node(entvars_t * pev)*

*Defined at line 42 of ./game/server/info_node.cpp*

### info_node_air

*void info_node_air(entvars_t * pev)*

*Defined at line 43 of ./game/server/info_node.cpp*

### Hash

*ULONG Hash(void * p, int len)*

*Defined at line 784 of ./game/server/info_node.cpp*

### CalcBounds

*void CalcBounds(int & Lower, int & Upper, int Goal, int Best)*

*Defined at line 792 of ./game/server/info_node.cpp*

### CALC_RANGE

*int CALC_RANGE(int x, int lower, int upper)*

*Defined at line 809 of ./game/server/info_node.cpp*

 Convert from [-8192,8192] to [0, 255]

### UpdateRange

*void UpdateRange(int & minValue, int & maxValue, int Goal, int Best)*

*Defined at line 814 of ./game/server/info_node.cpp*

### testhull

*void testhull(entvars_t * pev)*

*Defined at line 1496 of ./game/server/info_node.cpp*

### node_viewer

*void node_viewer(entvars_t * pev)*

*Defined at line 3585 of ./game/server/info_node.cpp*

### node_viewer_human

*void node_viewer_human(entvars_t * pev)*

*Defined at line 3586 of ./game/server/info_node.cpp*

### node_viewer_fly

*void node_viewer_fly(entvars_t * pev)*

*Defined at line 3587 of ./game/server/info_node.cpp*

### node_viewer_large

*void node_viewer_large(entvars_t * pev)*

*Defined at line 3588 of ./game/server/info_node.cpp*

### Image_CheckDXT3Alpha

*qboolean Image_CheckDXT3Alpha(dds_t * hdr, byte * fin)*

*Defined at line 19 of ./engine/common/imagelib/img_dds.cpp*

### Image_CheckDXT5Alpha

*qboolean Image_CheckDXT5Alpha(dds_t * hdr, byte * fin)*

*Defined at line 52 of ./engine/common/imagelib/img_dds.cpp*

### Image_DXTGetPixelFormat

*void Image_DXTGetPixelFormat(dds_t * hdr)*

*Defined at line 93 of ./engine/common/imagelib/img_dds.cpp*

### Image_DXTCalcMipmapSize

*size_t Image_DXTCalcMipmapSize(dds_t * hdr)*

*Defined at line 182 of ./engine/common/imagelib/img_dds.cpp*

### Image_DXTCalcSize

*uint Image_DXTCalcSize(const char * name, dds_t * hdr, size_t filesize)*

*Defined at line 198 of ./engine/common/imagelib/img_dds.cpp*

### Image_DXTAdjustVolume

*void Image_DXTAdjustVolume(dds_t * hdr)*

*Defined at line 236 of ./engine/common/imagelib/img_dds.cpp*

### DestroyMapCycle

*void DestroyMapCycle(mapcycle_t * cycle)*

*Defined at line 1187 of ./game/server/multiplay_gamerules.cpp*

==============DestroyMapCycle

Clean up memory used by mapcycle when switching it==============

### COM_Parse

*const char * COM_Parse(const char * data)*

*Defined at line 1217 of ./game/server/multiplay_gamerules.cpp*

==============COM_Parse

Parse a token out of a string==============

### COM_TokenWaiting

*int COM_TokenWaiting(const char * buffer)*

*Defined at line 1293 of ./game/server/multiplay_gamerules.cpp*

==============COM_TokenWaiting

Returns 1 if additional data is waiting to be processed on this line==============

### ReloadMapCycleFile

*int ReloadMapCycleFile(const char * filename, mapcycle_t * cycle)*

*Defined at line 1316 of ./game/server/multiplay_gamerules.cpp*

==============ReloadMapCycleFile

Parses mapcycle.txt file into mapcycle_t structure==============

### CountPlayers

*int CountPlayers()*

*Defined at line 1440 of ./game/server/multiplay_gamerules.cpp*

==============CountPlayers

Determine the current # of active players on the server for map cycling logic==============

### ExtractCommandString

*void ExtractCommandString(char * s, char * szCommand)*

*Defined at line 1465 of ./game/server/multiplay_gamerules.cpp*

==============ExtractCommandString

Parse commands/key value pairs to issue right after map xxx command is issued on server level transition==============

### SV_AddResource

*void SV_AddResource(resourcetype_t type, const char * name, int size, byte flags, int index)*

*Defined at line 36 of ./engine/server/sv_init.cpp*

================SV_AddResource

generic method to put the resources into array================

### SV_SendSingleResource

*void SV_SendSingleResource(const char * name, resourcetype_t type, int index, byte flags)*

*Defined at line 58 of ./engine/server/sv_init.cpp*

================SV_SendSingleResource

hot precache on a flying================

### SV_ReadResourceList

*void SV_ReadResourceList(const char * filename)*

*Defined at line 278 of ./engine/server/sv_init.cpp*

### SV_CreateGenericResources

*void SV_CreateGenericResources()*

*Defined at line 312 of ./engine/server/sv_init.cpp*

================SV_CreateGenericResources

loads external resource list================

### SV_CreateResourceList

*void SV_CreateResourceList()*

*Defined at line 331 of ./engine/server/sv_init.cpp*

================SV_CreateResourceList

add resources to common list================

### SV_CreateBaseline

*void SV_CreateBaseline()*

*Defined at line 402 of ./engine/server/sv_init.cpp*

================SV_CreateBaseline

Entity baselines are used to compress the update messagesto the clients -- only the fields that differ from thebaseline will be transmitted

INTERNAL RESOURCE================

### SV_SetupClients

*void SV_SetupClients()*

*Defined at line 731 of ./engine/server/sv_init.cpp*

================SV_SetupClients

determine the game type and prepare clients================

### CRC32_MapFile

*qboolean CRC32_MapFile(dword * crcvalue, const char * filename, qboolean multiplayer)*

*Defined at line 774 of ./engine/server/sv_init.cpp*

### AllocString

*char * AllocString(const char * pStr, int nMaxChars)*

*Defined at line 20 of ./mainui/miniutl/strtools.cpp*

### V_SplitString2

*void V_SplitString2(const char * pString, const char *const * pSeparators, int nSeparators, CUtlVector<char *> & outStrings, _Bool bIncludeEmptyStrings)*

*Defined at line 335 of ./mainui/miniutl/strtools.cpp*

### Sound_Copy

*byte * Sound_Copy(size_t size)*

*Defined at line 86 of ./engine/common/soundlib/snd_utils.cpp*

### Sound_ConvertToSigned

*void Sound_ConvertToSigned(const byte * data, int channels, int samples)*

*Defined at line 146 of ./engine/common/soundlib/snd_utils.cpp*

================Sound_ConvertToSigned

Convert unsigned data to signed================

### Sound_ResampleInternal

*qboolean Sound_ResampleInternal(wavdata_t * sc, int inrate, int inwidth, int outrate, int outwidth)*

*Defined at line 172 of ./engine/common/soundlib/snd_utils.cpp*

================Sound_ResampleInternal

We need convert sound to signed even if nothing to resample================

### __MsgFunc_Battery

*int __MsgFunc_Battery(const char * pszName, int iSize, void * pbuf)*

*Defined at line 28 of ./game/client/battery.cpp*

### S_CreateDefaultSound

*wavdata_t * S_CreateDefaultSound()*

*Defined at line 105 of ./engine/client/s_load.cpp*

=================S_CreateDefaultSound=================

### Joy_ProcessTrigger

*void Joy_ProcessTrigger(const engineAxis_t engineAxis, short value)*

*Defined at line 132 of ./engine/client/in_joy.cpp*

=============Joy_ProcessTrigger=============

### Joy_GetHatValueForAxis

*int Joy_GetHatValueForAxis(const engineAxis_t engineAxis)*

*Defined at line 167 of ./engine/client/in_joy.cpp*

### Joy_ProcessStick

*void Joy_ProcessStick(const engineAxis_t engineAxis, short value)*

*Defined at line 207 of ./engine/client/in_joy.cpp*

=============Joy_ProcessStick=============

### info_target

*void info_target(entvars_t * pev)*

*Defined at line 32 of ./game/server/effects.cpp*

### env_bubbles

*void env_bubbles(entvars_t * pev)*

*Defined at line 55 of ./game/server/effects.cpp*

### beam

*void beam(entvars_t * pev)*

*Defined at line 159 of ./game/server/effects.cpp*

### env_lightning

*void env_lightning(entvars_t * pev)*

*Defined at line 398 of ./game/server/effects.cpp*

### env_beam

*void env_beam(entvars_t * pev)*

*Defined at line 399 of ./game/server/effects.cpp*

### trip_beam

*void trip_beam(entvars_t * pev)*

*Defined at line 408 of ./game/server/effects.cpp*

### IsPointEntity

*int IsPointEntity(class CBaseEntity * pEnt)*

*Defined at line 603 of ./game/server/effects.cpp*

### env_laser

*void env_laser(entvars_t * pev)*

*Defined at line 915 of ./game/server/effects.cpp*

### env_glow

*void env_glow(entvars_t * pev)*

*Defined at line 1086 of ./game/server/effects.cpp*

### env_sprite

*void env_sprite(entvars_t * pev)*

*Defined at line 1127 of ./game/server/effects.cpp*

### gibshooter

*void gibshooter(entvars_t * pev)*

*Defined at line 1329 of ./game/server/effects.cpp*

### env_shooter

*void env_shooter(entvars_t * pev)*

*Defined at line 1474 of ./game/server/effects.cpp*

### test_effect

*void test_effect(entvars_t * pev)*

*Defined at line 1563 of ./game/server/effects.cpp*

### env_blood

*void env_blood(entvars_t * pev)*

*Defined at line 1680 of ./game/server/effects.cpp*

### env_shake

*void env_shake(entvars_t * pev)*

*Defined at line 1818 of ./game/server/effects.cpp*

### env_fade

*void env_fade(entvars_t * pev)*

*Defined at line 1904 of ./game/server/effects.cpp*

### env_message

*void env_message(entvars_t * pev)*

*Defined at line 1970 of ./game/server/effects.cpp*

### env_funnel

*void env_funnel(entvars_t * pev)*

*Defined at line 2076 of ./game/server/effects.cpp*

### env_beverage

*void env_beverage(entvars_t * pev)*

*Defined at line 2128 of ./game/server/effects.cpp*

### item_sodacan

*void item_sodacan(entvars_t * pev)*

*Defined at line 2188 of ./game/server/effects.cpp*

### monstermaker

*void monstermaker(entvars_t * pev)*

*Defined at line 64 of ./game/server/npc/npc_monstermaker.cpp*

### CL_PlayerTeleported

*qboolean CL_PlayerTeleported(local_state_t * from, local_state_t * to)*

*Defined at line 211 of ./engine/client/cl_pmove.cpp*

==================CL_PlayerTeleported

check for instant movement in casewe don't want interpolate this==================

### CL_CopyEntityToPhysEnt

*void CL_CopyEntityToPhysEnt(physent_t * pe, entity_state_t * state, qboolean visent)*

*Defined at line 346 of ./engine/client/cl_pmove.cpp*

### CL_AddLinksToPmove

*void CL_AddLinksToPmove(frame_t * frame)*

*Defined at line 432 of ./engine/client/cl_pmove.cpp*

====================CL_AddLinksToPmove

collect solid entities====================

### pfnTestPlayerPosition

*int pfnTestPlayerPosition(float * pos, pmtrace_t * ptrace)*

*Defined at line 707 of ./engine/client/cl_pmove.cpp*

### pfnStuckTouch

*void pfnStuckTouch(int hitent, pmtrace_t * tr)*

*Defined at line 712 of ./engine/client/cl_pmove.cpp*

### pfnPointContents

*int pfnPointContents(float * p, int * truecontents)*

*Defined at line 731 of ./engine/client/cl_pmove.cpp*

### pfnTruePointContents

*int pfnTruePointContents(float * p)*

*Defined at line 743 of ./engine/client/cl_pmove.cpp*

### pfnHullPointContents

*int pfnHullPointContents(struct hull_s * hull, int num, float * p)*

*Defined at line 748 of ./engine/client/cl_pmove.cpp*

### pfnPlayerTrace

*pmtrace_s pfnPlayerTrace(float * start, float * end, int traceFlags, int ignore_pe)*

*Defined at line 753 of ./engine/client/cl_pmove.cpp*

### pfnHullForBsp

*hull_t * pfnHullForBsp(physent_t * pe, float * offset)*

*Defined at line 781 of ./engine/client/cl_pmove.cpp*

### pfnTraceModel

*float pfnTraceModel(physent_t * pe, float * start, float * end, trace_t * trace)*

*Defined at line 786 of ./engine/client/cl_pmove.cpp*

### pfnTraceTexture

*const char * pfnTraceTexture(int ground, float * vstart, float * vend)*

*Defined at line 832 of ./engine/client/cl_pmove.cpp*

### pfnPlaySound

*void pfnPlaySound(int channel, const char * sample, float volume, float attenuation, int fFlags, int pitch)*

*Defined at line 843 of ./engine/client/cl_pmove.cpp*

### pfnPlaybackEventFull

*void pfnPlaybackEventFull(int flags, int clientindex, word eventindex, float delay, float * origin, float * angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2)*

*Defined at line 851 of ./engine/client/cl_pmove.cpp*

### pfnPlayerTraceEx

*pmtrace_s pfnPlayerTraceEx(float * start, float * end, int traceFlags, pfnIgnore pmFilter)*

*Defined at line 857 of ./engine/client/cl_pmove.cpp*

### pfnTestPlayerPositionEx

*int pfnTestPlayerPositionEx(float * pos, pmtrace_t * ptrace, pfnIgnore pmFilter)*

*Defined at line 862 of ./engine/client/cl_pmove.cpp*

### pfnTraceLineEx

*pmtrace_t * pfnTraceLineEx(float * start, float * end, int flags, int usehull, pfnIgnore pmFilter)*

*Defined at line 867 of ./engine/client/cl_pmove.cpp*

### PM_CheckMovingGround

*void PM_CheckMovingGround(clientdata_t * cd, entity_state_t * state, float frametime)*

*Defined at line 954 of ./engine/client/cl_pmove.cpp*

### CL_FinishPMove

*void CL_FinishPMove(playermove_t * pmove, local_state_t * to)*

*Defined at line 1027 of ./engine/client/cl_pmove.cpp*

### CL_RunUsercmd

*void CL_RunUsercmd(local_state_t * from, local_state_t * to, usercmd_t * u, qboolean runfuncs, double * time, unsigned int random_seed)*

*Defined at line 1080 of ./engine/client/cl_pmove.cpp*

=================CL_RunUsercmd

Runs prediction code for user cmd=================

### __MsgFunc_DeathMsg

*int __MsgFunc_DeathMsg(const char * pszName, int iSize, void * pbuf)*

*Defined at line 26 of ./game/client/death.cpp*

### monster_headcrab

*void monster_headcrab(entvars_t * pev)*

*Defined at line 110 of ./game/server/npc/npc_headcrab.cpp*

### monster_babycrab

*void monster_babycrab(entvars_t * pev)*

*Defined at line 497 of ./game/server/npc/npc_headcrab.cpp*

### R_Speeds_Printf

*void R_Speeds_Printf(const char * msg)*

*Defined at line 52 of ./rendersystem/r_backend.cpp*

==============R_Speeds_Printf

helper to print into r_speeds message==============

### CSCR_ExpectString

*qboolean CSCR_ExpectString(parserstate_t * ps, const char * pExpect, qboolean skip, qboolean error)*

*Defined at line 55 of ./engine/common/cfgscript.cpp*

===================CSCR_ExpectString

Return true if next token is pExpext and skip it===================

### CSCR_ParseType

*cvartype_t CSCR_ParseType(parserstate_t * ps)*

*Defined at line 78 of ./engine/common/cfgscript.cpp*

===================CSCR_ParseType

Determine script variable type===================

### CSCR_ParseSingleCvar

*qboolean CSCR_ParseSingleCvar(parserstate_t * ps, scrvardef_t * result)*

*Defined at line 99 of ./engine/common/cfgscript.cpp*

=========================CSCR_ParseSingleCvar=========================

### CSCR_ParseHeader

*qboolean CSCR_ParseHeader(parserstate_t * ps)*

*Defined at line 171 of ./engine/common/cfgscript.cpp*

======================CSCR_ParseHeader

Check version and seek to first cvar name======================

### Dictionary_Insert

*void Dictionary_Insert(const char * key, const char * value)*

*Defined at line 75 of ./mainui/MenuStrings.cpp*

### UI_InitAliasStrings

*void UI_InitAliasStrings()*

*Defined at line 85 of ./mainui/MenuStrings.cpp*

### UTFToCP1251

*int UTFToCP1251(char * out, const char * instr, int len, int maxoutlen)*

*Defined at line 124 of ./mainui/MenuStrings.cpp*

### Localize_AddToDictionary

*void Localize_AddToDictionary(const char * name, const char * lang)*

*Defined at line 232 of ./mainui/MenuStrings.cpp*

### Localize_Init

*void Localize_Init()*

*Defined at line 361 of ./mainui/MenuStrings.cpp*

### Localize_Free

*void Localize_Free()*

*Defined at line 401 of ./mainui/MenuStrings.cpp*

### UI_Main_Precache

*void UI_Main_Precache()*

*Defined at line 310 of ./mainui/menus/Main.cpp*

=================UI_Main_Precache=================

### Host_CheckSleep

*void Host_CheckSleep()*

*Defined at line 190 of ./engine/common/host.cpp*

==================Host_CheckSleep==================

### Host_ChangeGame_f

*void Host_ChangeGame_f()*

*Defined at line 235 of ./engine/common/host.cpp*

=================Host_ChangeGame_f

Change game modification=================

### Host_Exec_f

*void Host_Exec_f()*

*Defined at line 274 of ./engine/common/host.cpp*

===============Host_Exec_f===============

### Host_MemStats_f

*void Host_MemStats_f()*

*Defined at line 324 of ./engine/common/host.cpp*

===============Host_MemStats_f===============

### Host_Minimize_f

*void Host_Minimize_f()*

*Defined at line 342 of ./engine/common/host.cpp*

### Host_RegisterDecal

*qboolean Host_RegisterDecal(const char * name, int * count)*

*Defined at line 379 of ./engine/common/host.cpp*

=================Host_RegisterDecal=================

### Host_InitInterfaces

*void Host_InitInterfaces()*

*Defined at line 414 of ./engine/common/host.cpp*

=================Host_InitInterfaces Handles initialization of interfaces=================

### Host_GetCommands

*void Host_GetCommands()*

*Defined at line 486 of ./engine/common/host.cpp*

===================Host_GetCommands

Add them exactly as if they had been typed at the console===================

### Host_CalcFPS

*double Host_CalcFPS()*

*Defined at line 504 of ./engine/common/host.cpp*

===================Host_CalcFPS

compute actual FPS for various modes===================

### Host_FilterTime

*qboolean Host_FilterTime(float time)*

*Defined at line 551 of ./engine/common/host.cpp*

===================Host_FilterTime

Returns false if the time is too short to run a frame===================

### Host_Error_f

*void Host_Error_f()*

*Defined at line 695 of ./engine/common/host.cpp*

### Sys_Error_f

*void Sys_Error_f()*

*Defined at line 703 of ./engine/common/host.cpp*

### Host_Crash_f

*void Host_Crash_f()*

*Defined at line 716 of ./engine/common/host.cpp*

=================Host_Crash_f=================

### Host_InitCommon

*void Host_InitCommon(int argc, char ** argv, const char * progname, qboolean bChangeGame)*

*Defined at line 726 of ./engine/common/host.cpp*

=================Host_InitCommon=================

### Host_FreeCommon

*void Host_FreeCommon()*

*Defined at line 987 of ./engine/common/host.cpp*

### Host_Main

*int Host_Main(int argc, char ** argv, const char * progname, int bChangeGame, pfnChangeGame func)*

*Defined at line 1001 of ./engine/common/host.cpp*

=================Host_Main=================

### PM_DrawRectangle

*void PM_DrawRectangle(const vec3_t tl, const vec3_t bl, const vec3_t tr, const vec3_t br, int pcolor, float life)*

*Defined at line 59 of ./engine/common/pm_debug.cpp*

================PM_DrawRectangle

================

### UI_CreateGame_Precache

*void UI_CreateGame_Precache()*

*Defined at line 325 of ./mainui/menus/CreateGame.cpp*

=================CMenuCreateGame::Precache=================

### SDLash_JoyInit_Old

*int SDLash_JoyInit_Old(int numjoy)*

*Defined at line 108 of ./engine/platform/sdl/in_sdl.cpp*

=============SDLash_JoyInit_Old

=============

### SDLash_JoyInit_New

*int SDLash_JoyInit_New(int numjoy)*

*Defined at line 170 of ./engine/platform/sdl/in_sdl.cpp*

=============SDLash_JoyInit_New

=============

### R_SpriteLoadFrame

*const dframetype_t * R_SpriteLoadFrame(model_t * mod, const void * pin, mspriteframe_t ** ppframe, int num)*

*Defined at line 54 of ./rendersystem/r_sprite.cpp*

====================R_SpriteLoadFrame

upload a single frame====================

### R_SpriteLoadGroup

*const dframetype_t * R_SpriteLoadGroup(model_t * mod, const void * pin, mspriteframe_t ** ppframe, int framenum)*

*Defined at line 101 of ./rendersystem/r_sprite.cpp*

====================R_SpriteLoadGroup

upload a group frames====================

### R_SpriteGlowBlend

*float R_SpriteGlowBlend(vec3_t origin, int rendermode, int renderfx, float * pscale)*

*Defined at line 664 of ./rendersystem/r_sprite.cpp*

================R_GlowSightDistance

Set sprite brightness factor================

### R_DrawSpriteQuad

*void R_DrawSpriteQuad(mspriteframe_t * frame, vec3_t org, vec3_t v_right, vec3_t v_up, float scale)*

*Defined at line 732 of ./rendersystem/r_sprite.cpp*

=================R_DrawSpriteQuad=================

### R_SpriteHasLightmap

*qboolean R_SpriteHasLightmap(cl_entity_t * e, int texFormat)*

*Defined at line 758 of ./rendersystem/r_sprite.cpp*

### R_SpriteAllowLerping

*qboolean R_SpriteAllowLerping(cl_entity_t * e, msprite_t * psprite)*

*Defined at line 790 of ./rendersystem/r_sprite.cpp*

=================R_SpriteAllowLerping=================

### UI_TouchOptions_Precache

*void UI_TouchOptions_Precache()*

*Defined at line 448 of ./mainui/menus/TouchOptions.cpp*

=================UI_TouchOptions_Precache=================

### memfgets

*char * memfgets(byte * pMemFile, int fileSize, int & filePos, char * pBuffer, int bufferSize)*

*Defined at line 1462 of ./game/server/sound.cpp*

 open materials.txt,  get size, alloc space,  save in array.  Only works first time called,  ignored on subsequent calls.

### ambient_generic

*void ambient_generic(entvars_t * pev)*

*Defined at line 134 of ./game/server/sound.cpp*

### env_sound

*void env_sound(entvars_t * pev)*

*Defined at line 821 of ./game/server/sound.cpp*

### FEnvSoundInRange

*BOOL FEnvSoundInRange(entvars_t * pev, entvars_t * pevTarget, float * pflRange)*

*Defined at line 848 of ./game/server/sound.cpp*

 returns TRUE if the given sound entity (pev) is in range  and can see the given player entity (pevTarget)

### speaker

*void speaker(entvars_t * pev)*

*Defined at line 1734 of ./game/server/sound.cpp*

### weapon_hornetgun

*void weapon_hornetgun(entvars_t * pev)*

*Defined at line 43 of ./game/shared/hl1/weapon_hornetgun.cpp*

### CL_GetDemoRecordClock

*float CL_GetDemoRecordClock()*

*Defined at line 159 of ./engine/client/cl_demo.cpp*

====================CL_GetDemoRecordClock

write time while demo is recording====================

### CL_GetDemoPlaybackClock

*float CL_GetDemoPlaybackClock()*

*Defined at line 171 of ./engine/client/cl_demo.cpp*

====================CL_GetDemoPlaybackClock

overwrite host.realtime====================

### CL_WriteDemoCmdHeader

*void CL_WriteDemoCmdHeader(byte cmd, file_t * file)*

*Defined at line 197 of ./engine/client/cl_demo.cpp*

====================CL_WriteDemoCmdHeader

Writes the demo command header and time-delta====================

### CL_WriteDemoSequence

*void CL_WriteDemoSequence(file_t * file)*

*Defined at line 270 of ./engine/client/cl_demo.cpp*

====================CL_WriteDemoSequence

Save state of cls.netchan sequencesso that we can play the demo correctly.====================

### CL_WriteDemoHeader

*void CL_WriteDemoHeader(const char * name)*

*Defined at line 351 of ./engine/client/cl_demo.cpp*

====================CL_WriteDemoHeader

Write demo header====================

### CL_ReadDemoCmdHeader

*void CL_ReadDemoCmdHeader(byte * cmd, float * dt)*

*Defined at line 521 of ./engine/client/cl_demo.cpp*

=======================================================================

CLIENT SIDE DEMO PLAYBACK

=======================================================================

=================CL_ReadDemoCmdHeader

read the demo command=================

### CL_ReadDemoUserCmd

*void CL_ReadDemoUserCmd(qboolean discard)*

*Defined at line 539 of ./engine/client/cl_demo.cpp*

=================CL_ReadDemoUserCmd

read the demo usercmd for predictingand smooth movement during playback the demo=================

### CL_ReadDemoSequence

*void CL_ReadDemoSequence(qboolean discard)*

*Defined at line 601 of ./engine/client/cl_demo.cpp*

=================CL_ReadDemoSequence

read netchan sequences=================

### CL_DemoStartPlayback

*void CL_DemoStartPlayback(int mode)*

*Defined at line 635 of ./engine/client/cl_demo.cpp*

=================CL_DemoStartPlayback=================

### CL_DemoAborted

*void CL_DemoAborted()*

*Defined at line 678 of ./engine/client/cl_demo.cpp*

=================CL_DemoAborted=================

### CL_DemoMoveToNextSection

*qboolean CL_DemoMoveToNextSection()*

*Defined at line 718 of ./engine/client/cl_demo.cpp*

=================CL_DemoMoveToNextSection

returns true on success, false on failureg-cont. probably captain obvious mode is ON=================

### CL_ReadRawNetworkData

*qboolean CL_ReadRawNetworkData(byte * buffer, size_t * length)*

*Defined at line 740 of ./engine/client/cl_demo.cpp*

### CL_DemoReadMessageQuake

*qboolean CL_DemoReadMessageQuake(byte * buffer, size_t * length)*

*Defined at line 791 of ./engine/client/cl_demo.cpp*

=================CL_DemoReadMessageQuake

reads demo data and write it to client=================

### CL_DemoFindInterpolatedViewAngles

*void CL_DemoFindInterpolatedViewAngles(float t, float * frac, demoangle_t ** prev, demoangle_t ** next)*

*Defined at line 1005 of ./engine/client/cl_demo.cpp*

### CL_FinishTimeDemo

*void CL_FinishTimeDemo()*

*Defined at line 1100 of ./engine/client/cl_demo.cpp*

==============CL_FinishTimeDemo

show stats==============

### CL_DemoGetName

*void CL_DemoGetName(int lastnum, char * filename)*

*Defined at line 1305 of ./engine/client/cl_demo.cpp*

================== CL_DemoGetName================== 

### __MsgFunc_HudText

*int __MsgFunc_HudText(const char * pszName, int iSize, void * pbuf)*

*Defined at line 27 of ./game/client/message.cpp*

### __MsgFunc_GameTitle

*int __MsgFunc_GameTitle(const char * pszName, int iSize, void * pbuf)*

*Defined at line 28 of ./game/client/message.cpp*

### Sequence_ParseFile

*void Sequence_ParseFile(const char * fileName, qboolean isGlobal)*

*Defined at line 1554 of ./engine/common/sequence.cpp*

==============Sequence_ParseFile

==============

### Sequence_OnLevelLoad

*void Sequence_OnLevelLoad(const char * mapName)*

*Defined at line 1778 of ./engine/common/sequence.cpp*

==============Sequence_OnLevelLoad

==============

### Sequence_Init

*void Sequence_Init()*

*Defined at line 1580 of ./engine/common/sequence.cpp*

==============Sequence_Init

==============

### Sequence_PurgeEntries

*void Sequence_PurgeEntries(qboolean purgeGlobals)*

*Defined at line 1714 of ./engine/common/sequence.cpp*

==============Sequence_PurgeEntries

==============

### Sequence_GetSentenceByIndex

*sentenceEntry_s * Sequence_GetSentenceByIndex(unsigned int index)*

*Defined at line 1090 of ./engine/common/sequence.cpp*

=============Sequence_GetSentenceByIndex

=============

### Sequence_GetCommandEnumForName

*sequenceCommandEnum_e Sequence_GetCommandEnumForName(const char * commandName, sequenceCommandType_e type)*

*Defined at line 65 of ./engine/common/sequence.cpp*

=============Sequence_GetCommandEnumForName

=============

### Sequence_ResetDefaults

*void Sequence_ResetDefaults(sequenceCommandLine_s * destination, sequenceCommandLine_s * source)*

*Defined at line 85 of ./engine/common/sequence.cpp*

=============Sequence_ResetDefaults

=============

### Sequence_WriteDefaults

*void Sequence_WriteDefaults(sequenceCommandLine_s * source, sequenceCommandLine_s * destination)*

*Defined at line 134 of ./engine/common/sequence.cpp*

=============Sequence_WriteDefaults

=============

### Sequence_BakeDefaults

*void Sequence_BakeDefaults(sequenceCommandLine_s * destination, sequenceCommandLine_s * source)*

*Defined at line 213 of ./engine/common/sequence.cpp*

=============Sequence_BakeDefaults

=============

### Sequence_SkipWhitespace

*qboolean Sequence_SkipWhitespace()*

*Defined at line 246 of ./engine/common/sequence.cpp*

=============Sequence_SkipWhitespace

=============

### Sequence_IsNameValueChar

*qboolean Sequence_IsNameValueChar(char ch)*

*Defined at line 270 of ./engine/common/sequence.cpp*

=============Sequence_IsNameValueChar

=============

### Sequence_IsSymbol

*qboolean Sequence_IsSymbol(char ch)*

*Defined at line 294 of ./engine/common/sequence.cpp*

=============Sequence_IsSymbol

=============

### Sequence_GetNameValueString

*size_t Sequence_GetNameValueString(char * token, size_t len)*

*Defined at line 319 of ./engine/common/sequence.cpp*

=============Sequence_GetNameValueString

=============

### Sequence_GetSymbol

*char Sequence_GetSymbol()*

*Defined at line 349 of ./engine/common/sequence.cpp*

=============Sequence_GetSymbol

=============

### Sequence_ValidateNameValueString

*void Sequence_ValidateNameValueString(char * token)*

*Defined at line 369 of ./engine/common/sequence.cpp*

=============Sequence_ValidateNameValueString

=============

### Sequence_GetToken

*size_t Sequence_GetToken(char * token, size_t size)*

*Defined at line 386 of ./engine/common/sequence.cpp*

=============Sequence_GetToken

=============

### Sequence_GetLine

*size_t Sequence_GetLine(char * line, int lineMaxLen)*

*Defined at line 411 of ./engine/common/sequence.cpp*

=============Sequence_GetLine

=============

### Sequence_StripComments

*void Sequence_StripComments(char * buffer, int * pBufSize)*

*Defined at line 442 of ./engine/common/sequence.cpp*

=============Sequence_StripComments

=============

### Sequence_ReadInt

*int Sequence_ReadInt()*

*Defined at line 509 of ./engine/common/sequence.cpp*

=============Sequence_ReadInt

=============

### Sequence_ReadFloat

*float Sequence_ReadFloat()*

*Defined at line 525 of ./engine/common/sequence.cpp*

=============Sequence_ReadFloat

=============

### Sequence_ReadString

*void Sequence_ReadString(char ** dest, char * string, size_t len)*

*Defined at line 541 of ./engine/common/sequence.cpp*

=============Sequence_ReadFloat

=============

### Sequence_ReadQuotedString

*void Sequence_ReadQuotedString(char ** dest, char * str, size_t len)*

*Defined at line 555 of ./engine/common/sequence.cpp*

=============Sequence_ReadQuotedString

=============

### Sequence_ConfirmCarriageReturnOrSymbol

*qboolean Sequence_ConfirmCarriageReturnOrSymbol(char symbol)*

*Defined at line 588 of ./engine/common/sequence.cpp*

=============Sequence_ConfirmCarriageReturnOrSymbol

=============

### Sequence_IsCommandAModifier

*qboolean Sequence_IsCommandAModifier(sequenceCommandEnum_e commandEnum)*

*Defined at line 602 of ./engine/common/sequence.cpp*

=============Sequence_IsCommandAModifier

=============

### Sequence_ReadCommandData

*void Sequence_ReadCommandData(sequenceCommandEnum_e commandEnum, sequenceCommandLine_s * defaults)*

*Defined at line 622 of ./engine/common/sequence.cpp*

=============Sequence_ReadCommandData

=============

### Sequence_ParseModifier

*char Sequence_ParseModifier(sequenceCommandLine_s * defaults)*

*Defined at line 725 of ./engine/common/sequence.cpp*

=============Sequence_ParseModifier

=============

### Sequence_AddCommandLineToEntry

*void Sequence_AddCommandLineToEntry(sequenceCommandLine_s * commandLine, sequenceEntry_s * entry)*

*Defined at line 759 of ./engine/common/sequence.cpp*

=============Sequence_AddCommandLineToEntry

=============

### Sequence_ParseModifierLine

*char Sequence_ParseModifierLine(sequenceEntry_s * entry, sequenceCommandType_e modifierType)*

*Defined at line 779 of ./engine/common/sequence.cpp*

=============Sequence_ParseModifierLine

=============

### Sequence_ParseCommand

*char Sequence_ParseCommand(sequenceCommandLine_s * newCommandLine)*

*Defined at line 811 of ./engine/common/sequence.cpp*

=============Sequence_ParseCommand

=============

### Sequence_ParseCommandLine

*char Sequence_ParseCommandLine(sequenceEntry_s * entry)*

*Defined at line 850 of ./engine/common/sequence.cpp*

=============Sequence_ParseCommandLine

=============

### Sequence_ParseMacro

*char Sequence_ParseMacro(sequenceEntry_s * entry)*

*Defined at line 877 of ./engine/common/sequence.cpp*

=============Sequence_ParseMacro

=============

### Sequence_ParseLine

*char Sequence_ParseLine(char start, sequenceEntry_s * entry)*

*Defined at line 905 of ./engine/common/sequence.cpp*

=============Sequence_ParseLine

=============

### Sequence_CalcEntryDuration

*float Sequence_CalcEntryDuration(sequenceEntry_s * entry)*

*Defined at line 936 of ./engine/common/sequence.cpp*

=============Sequence_CalcEntryDuration

=============

### Sequence_DoesEntryContainInfiniteLoop

*qboolean Sequence_DoesEntryContainInfiniteLoop(sequenceEntry_s * entry)*

*Defined at line 955 of ./engine/common/sequence.cpp*

=============Sequence_DoesEntryContainInfiniteLoop

=============

### Sequence_IsEntrySafe

*qboolean Sequence_IsEntrySafe(sequenceEntry_s * entry)*

*Defined at line 974 of ./engine/common/sequence.cpp*

=============Sequence_IsEntrySafe

=============

### Sequence_CreateDefaultsCommand

*void Sequence_CreateDefaultsCommand(sequenceEntry_s * entry)*

*Defined at line 1001 of ./engine/common/sequence.cpp*

=============Sequence_CreateDefaultsCommand

=============

### Sequence_ParseEntry

*char Sequence_ParseEntry()*

*Defined at line 1029 of ./engine/common/sequence.cpp*

=============Sequence_ParseEntry

=============

### Sequence_FindSentenceGroup

*sentenceGroupEntry_s * Sequence_FindSentenceGroup(const char * groupName)*

*Defined at line 1071 of ./engine/common/sequence.cpp*

=============Sequence_FindSentenceGroup

=============

### Sequence_AddSentenceGroup

*sentenceGroupEntry_s * Sequence_AddSentenceGroup(char * groupName)*

*Defined at line 1155 of ./engine/common/sequence.cpp*

=============Sequence_AddSentenceGroup

=============

### Sequence_AddSentenceToGroup

*void Sequence_AddSentenceToGroup(char * groupName, char * data)*

*Defined at line 1184 of ./engine/common/sequence.cpp*

=============Sequence_AddSentenceToGroup

=============

### Sequence_ParseSentenceLine

*qboolean Sequence_ParseSentenceLine()*

*Defined at line 1226 of ./engine/common/sequence.cpp*

=============Sequence_ParseSentenceLine

=============

### Sequence_ParseSentenceBlock

*char Sequence_ParseSentenceBlock()*

*Defined at line 1268 of ./engine/common/sequence.cpp*

==============Sequence_ParseSentenceBlock

==============

### Sequence_ParseGlobalDataBlock

*char Sequence_ParseGlobalDataBlock()*

*Defined at line 1289 of ./engine/common/sequence.cpp*

==============Sequence_ParseGlobalDataBlock

==============

### Sequence_GetEntryForName

*sequenceEntry_s * Sequence_GetEntryForName(const char * entryName)*

*Defined at line 1307 of ./engine/common/sequence.cpp*

==============Sequence_GetEntryForName

==============

### Sequence_CopyCommand

*sequenceCommandLine_s * Sequence_CopyCommand(sequenceCommandLine_s * commandOrig)*

*Defined at line 1326 of ./engine/common/sequence.cpp*

==============Sequence_CopyCommand

==============

### Sequence_CopyCommandList

*sequenceCommandLine_s * Sequence_CopyCommandList(sequenceCommandLine_s * list)*

*Defined at line 1357 of ./engine/common/sequence.cpp*

==============Sequence_CopyCommandList

==============

### Sequence_ExpandGosubsForEntry

*qboolean Sequence_ExpandGosubsForEntry(sequenceEntry_s * entry)*

*Defined at line 1392 of ./engine/common/sequence.cpp*

==============Sequence_ExpandGosubsForEntry

==============

### Sequence_ExpandAllGosubs

*void Sequence_ExpandAllGosubs()*

*Defined at line 1440 of ./engine/common/sequence.cpp*

==============Sequence_ExpandAllGosubs

==============

### Sequence_FlattenEntry

*void Sequence_FlattenEntry(sequenceEntry_s * entry)*

*Defined at line 1460 of ./engine/common/sequence.cpp*

==============Sequence_FlattenEntry

==============

### Sequence_FlattenAllEntries

*void Sequence_FlattenAllEntries()*

*Defined at line 1494 of ./engine/common/sequence.cpp*

==============Sequence_FlattenAllEntries

==============

### Sequence_ParseBuffer

*void Sequence_ParseBuffer(char * buffer, int bufferSize)*

*Defined at line 1508 of ./engine/common/sequence.cpp*

==============Sequence_ParseBuffer

==============

### Sequence_FreeCommand

*void Sequence_FreeCommand(sequenceCommandLine_s * kill)*

*Defined at line 1611 of ./engine/common/sequence.cpp*

==============Sequence_FreeCommand

==============

### Sequence_FreeEntry

*void Sequence_FreeEntry(sequenceEntry_s * kill)*

*Defined at line 1628 of ./engine/common/sequence.cpp*

==============Sequence_FreeEntry

==============

### Sequence_FreeSentence

*void Sequence_FreeSentence(sentenceEntry_s * sentenceEntry)*

*Defined at line 1650 of ./engine/common/sequence.cpp*

==============Sequence_FreeSentence

==============

### Sequence_FreeSentenceGroup

*void Sequence_FreeSentenceGroup(sentenceGroupEntry_s * groupEntry)*

*Defined at line 1662 of ./engine/common/sequence.cpp*

==============Sequence_FreeSentenceGroup

==============

### Sequence_FreeSentenceGroupEntries

*void Sequence_FreeSentenceGroupEntries(sentenceGroupEntry_s * groupEntry, qboolean purgeGlobals)*

*Defined at line 1674 of ./engine/common/sequence.cpp*

==============Sequence_FreeSentenceGroupEntries

==============

### VID_Mode_f

*void VID_Mode_f()*

*Defined at line 129 of ./engine/client/vid_common.cpp*

### III_get_side_info

*int III_get_side_info(mpg123_handle_t * fr, III_sideinfo * si, int stereo, int ms_stereo, long sfreq, int single)*

*Defined at line 402 of ./engine/common/soundlib/libmpg/layer3.cpp*

 read additional side information (for MPEG 1 and MPEG 2)

### III_get_scale_factors_1

*int III_get_scale_factors_1(mpg123_handle_t * fr, int * scf, gr_info_t * gr_info)*

*Defined at line 549 of ./engine/common/soundlib/libmpg/layer3.cpp*

 read scalefactors

### III_get_scale_factors_2

*int III_get_scale_factors_2(mpg123_handle_t * fr, int * scf, gr_info_t * gr_info, int i_stereo)*

*Defined at line 649 of ./engine/common/soundlib/libmpg/layer3.cpp*

### III_dequantize_sample

*int III_dequantize_sample(mpg123_handle_t * fr, float [32][18] xr, int * scf, gr_info_t * gr_info, int sfreq, int part2bits)*

*Defined at line 714 of ./engine/common/soundlib/libmpg/layer3.cpp*

### III_i_stereo

*void III_i_stereo(float [2][32][18] xr_buf, int * scalefac, gr_info_t * gr_info, int sfreq, int ms_stereo, int lsf)*

*Defined at line 1175 of ./engine/common/soundlib/libmpg/layer3.cpp*

 calculate float channel values for Joint-I-Stereo-mode

### III_antialias

*void III_antialias(float [32][18] xr, gr_info_t * gr_info)*

*Defined at line 1339 of ./engine/common/soundlib/libmpg/layer3.cpp*

### III_hybrid

*void III_hybrid(float [32][18] fsIn, float [18][32] tsOut, int ch, gr_info_t * gr_info, mpg123_handle_t * fr)*

*Defined at line 1378 of ./engine/common/soundlib/libmpg/layer3.cpp*

### IN_Commands

*void IN_Commands()*

*Defined at line 59 of ./game/client/input_mouse.cpp*

### __MsgFunc_Bhopcap

*int __MsgFunc_Bhopcap(const char * pszName, int iSize, void * pbuf)*

*Defined at line 53 of ./game/client/client_int.cpp*

### Initialize

*int Initialize(cl_enginefunc_t * pEnginefuncs, int iVersion)*

*Defined at line 375 of ./game/client/client_int.cpp*

### HUD_VidInit

*int HUD_VidInit()*

*Defined at line 460 of ./game/client/client_int.cpp*

==========================	HUD_VidInit

Called when the game initializesand whenever the vid_mode is changedso the HUD can reinitialize itself.==========================

### HUD_Init

*void HUD_Init()*

*Defined at line 495 of ./game/client/client_int.cpp*

==========================	HUD_Init

Called whenever the client connectsto a server.  Reinitializes all the hud variables.==========================

### HUD_Redraw

*int HUD_Redraw(float flTime, int intermission)*

*Defined at line 512 of ./game/client/client_int.cpp*

==========================	HUD_Redraw

called every screen frame toredraw the HUD.===========================

### HUD_UpdateClientData

*int HUD_UpdateClientData(client_data_t * cdata, float flTime)*

*Defined at line 532 of ./game/client/client_int.cpp*

==========================	HUD_UpdateClientData

called every time shared clientdll/engine data gets changed,and gives the cdll a chanceto modify the data.

returns 1 if anything has been changed, 0 otherwise.==========================

### HUD_Reset

*void HUD_Reset()*

*Defined at line 547 of ./game/client/client_int.cpp*

==========================	HUD_Reset

Called at start and end of demos to restore to "non"HUD state.==========================

### HUD_PlayerMove

*void HUD_PlayerMove(struct playermove_s * ppmove, int server)*

*Defined at line 370 of ./game/client/client_int.cpp*

### HUD_PlayerMoveInit

*void HUD_PlayerMoveInit(struct playermove_s * ppmove)*

*Defined at line 360 of ./game/client/client_int.cpp*

### HUD_PlayerMoveTexture

*char HUD_PlayerMoveTexture(char * name)*

*Defined at line 365 of ./game/client/client_int.cpp*

### HUD_ConnectionlessPacket

*int HUD_ConnectionlessPacket(const struct netadr_s * net_from, const char * args, char * response_buffer, int * response_buffer_size)*

*Defined at line 346 of ./game/client/client_int.cpp*

================================HUD_ConnectionlessPacket

 Return 1 if the packet is valid.  Set response_buffer_size if you want to send a response packet.  Incoming, it holds the max  size of the response_buffer, so you must zero it out if you choose not to respond.================================

### HUD_GetHullBounds

*int HUD_GetHullBounds(int hullnumber, float * mins, float * maxs)*

*Defined at line 312 of ./game/client/client_int.cpp*

================================HUD_GetHullBounds

  Engine calls this to enumerate player collision hulls, for prediction.  Return 0 if the hullnumber doesn't exist.================================

### HUD_Frame

*void HUD_Frame(double time)*

*Defined at line 560 of ./game/client/client_int.cpp*

==========================HUD_Frame

Called by engine every frame that client .dll is loaded==========================

### HUD_VoiceStatus

*void HUD_VoiceStatus(int entindex, qboolean bTalking)*

*Defined at line 578 of ./game/client/client_int.cpp*

==========================HUD_VoiceStatus

Called when a player starts or stops talking.==========================

### HUD_DirectorMessage

*void HUD_DirectorMessage(int iSize, void * pbuf)*

*Defined at line 591 of ./game/client/client_int.cpp*

==========================HUD_DirectorEvent

Called when a director event message was received==========================

### HUD_MobilityInterface

*void HUD_MobilityInterface(mobile_engfuncs_t * gpMobileEngfuncs)*

*Defined at line 596 of ./game/client/client_int.cpp*

### HUD_DrawNormalTriangles

*void HUD_DrawNormalTriangles()*

*Defined at line 98 of ./game/client/tri.cpp*

=================HUD_DrawNormalTriangles

Non-transparent triangles-- add them here=================

### HUD_DrawTransparentTriangles

*void HUD_DrawTransparentTriangles()*

*Defined at line 113 of ./game/client/tri.cpp*

=================HUD_DrawTransparentTriangles

Render any triangles with transparent rendermode needs here=================

### V_CalcRefdef

*void V_CalcRefdef(struct ref_params_s * pparams)*

*Defined at line 1516 of ./game/client/view.cpp*

### HUD_GetRect

*int * HUD_GetRect()*

*Defined at line 396 of ./game/client/client_int.cpp*

=================HUD_GetRect

VGui stub=================

### spark_shower

*void spark_shower(entvars_t * pev)*

*Defined at line 37 of ./game/server/explode.cpp*

### env_explosion

*void env_explosion(entvars_t * pev)*

*Defined at line 110 of ./game/server/explode.cpp*

### monster_osprey

*void monster_osprey(entvars_t * pev)*

*Defined at line 106 of ./game/server/npc/npc_osprey.cpp*

### S_IsClient

*qboolean S_IsClient(int entnum)*

*Defined at line 93 of ./engine/client/s_main.cpp*

=================S_IsClient=================

### S_UpdateSoundFade

*void S_UpdateSoundFade()*

*Defined at line 126 of ./engine/client/s_main.cpp*

=================S_UpdateSoundFade=================

### SND_FStreamIsPlaying

*qboolean SND_FStreamIsPlaying(sfx_t * sfx)*

*Defined at line 186 of ./engine/client/s_main.cpp*

=================SND_FStreamIsPlaying

Select a channel from the dynamic channel allocation area.  For the given entity, override any other sound playing on the same channel (see code comments below forexceptions).=================

### S_AlterChannel

*int S_AlterChannel(int entnum, int channel, sfx_t * sfx, int vol, int pitch, int flags)*

*Defined at line 346 of ./engine/client/s_main.cpp*

=================S_AlterChannel

search through all channels for a channel that matches thissoundsource, entchannel and sfx, and perform alteration on channelas indicated by 'flags' parameter. If shut down request andsfx contains a sentence name, shut off the sentence.returns TRUE if sound was altered,returns FALSE if sound was not found (sound is not playing)=================

### S_SpatializeChannel

*void S_SpatializeChannel(int * left_vol, int * right_vol, int master_vol, float gain, float dot, float dist)*

*Defined at line 404 of ./engine/client/s_main.cpp*

=================S_SpatializeChannel=================

### SND_Spatialize

*void SND_Spatialize(channel_t * ch)*

*Defined at line 427 of ./engine/client/s_main.cpp*

=================SND_Spatialize=================

### S_InitAmbientChannels

*void S_InitAmbientChannels()*

*Defined at line 912 of ./engine/client/s_main.cpp*

===================S_InitAmbientChannels===================

### S_UpdateAmbientSounds

*void S_UpdateAmbientSounds()*

*Defined at line 934 of ./engine/client/s_main.cpp*

===================S_UpdateAmbientSounds===================

### S_RawSamplesStereo

*uint S_RawSamplesStereo(portable_samplepair_t * rawsamples, uint rawend, uint max_samples, uint samples, uint rate, word width, word channels, const byte * data)*

*Defined at line 1061 of ./engine/client/s_main.cpp*

===================S_RawSamplesStereo===================

### S_RawEntSamples

*void S_RawEntSamples(int entnum, uint samples, uint rate, word width, word channels, const byte * data, int snd_vol)*

*Defined at line 1127 of ./engine/client/s_main.cpp*

===================S_RawEntSamples===================

### S_FreeIdleRawChannels

*void S_FreeIdleRawChannels()*

*Defined at line 1275 of ./engine/client/s_main.cpp*

===================S_FreeIdleRawChannels

Free raw channel that have been idling for too long.===================

### S_ClearRawChannels

*void S_ClearRawChannels()*

*Defined at line 1301 of ./engine/client/s_main.cpp*

===================S_ClearRawChannels===================

### S_SpatializeRawChannels

*void S_SpatializeRawChannels()*

*Defined at line 1320 of ./engine/client/s_main.cpp*

===================S_SpatializeRawChannels===================

### S_FreeRawChannels

*void S_FreeRawChannels()*

*Defined at line 1373 of ./engine/client/s_main.cpp*

===================S_FreeRawChannels===================

### S_ClearBuffer

*void S_ClearBuffer()*

*Defined at line 1394 of ./engine/client/s_main.cpp*

==================S_ClearBuffer==================

### S_UpdateChannels

*void S_UpdateChannels()*

*Defined at line 1454 of ./engine/client/s_main.cpp*

=============================================================================

### S_Play_f

*void S_Play_f()*

*Defined at line 1643 of ./engine/client/s_main.cpp*

===============================================================================

console functions

===============================================================================

### S_Play2_f

*void S_Play2_f()*

*Defined at line 1654 of ./engine/client/s_main.cpp*

### S_PlayVol_f

*void S_PlayVol_f()*

*Defined at line 1671 of ./engine/client/s_main.cpp*

### S_Say_f

*void S_Say_f()*

*Defined at line 1682 of ./engine/client/s_main.cpp*

### S_SayReliable_f

*void S_SayReliable_f()*

*Defined at line 1693 of ./engine/client/s_main.cpp*

### S_Music_f

*void S_Music_f()*

*Defined at line 1709 of ./engine/client/s_main.cpp*

=================S_Music_f=================

### S_StopSound_f

*void S_StopSound_f()*

*Defined at line 1766 of ./engine/client/s_main.cpp*

=================S_StopSound_f=================

### S_SoundFade_f

*void S_SoundFade_f()*

*Defined at line 1776 of ./engine/client/s_main.cpp*

=================S_SoundFade_f=================

### R_StudioSetupTimings

*void R_StudioSetupTimings()*

*Defined at line 180 of ./ref_gl/gl_studio.cpp*

================R_StudioSetupTimings

init current time for a given model================

### R_AllowFlipViewModel

*qboolean R_AllowFlipViewModel(cl_entity_t * e)*

*Defined at line 203 of ./ref_gl/gl_studio.cpp*

================R_AllowFlipViewModel

should a flip the viewmodel if cl_righthand is set to 1================

### R_StudioComputeBBox

*qboolean R_StudioComputeBBox(vec3_t [8] bbox)*

*Defined at line 221 of ./ref_gl/gl_studio.cpp*

================R_StudioComputeBBox

Compute a full bounding box for current sequence================

### pfnGetCurrentEntity

*cl_entity_t * pfnGetCurrentEntity()*

*Defined at line 371 of ./ref_gl/gl_studio.cpp*

===============pfnGetCurrentEntity

===============

### pfnMod_ForName

*model_t * pfnMod_ForName(const char * model, int crash)*

*Defined at line 396 of ./ref_gl/gl_studio.cpp*

===============pfnMod_ForName

===============

### pfnGetViewEntity

*cl_entity_t * pfnGetViewEntity()*

*Defined at line 421 of ./ref_gl/gl_studio.cpp*

===============pfnGetViewEntity

===============

### pfnGetEngineTimes

*void pfnGetEngineTimes(int * framecount, double * current, double * old)*

*Defined at line 432 of ./ref_gl/gl_studio.cpp*

===============pfnGetEngineTimes

===============

### pfnGetViewInfo

*void pfnGetViewInfo(float * origin, float * upv, float * rightv, float * forwardv)*

*Defined at line 445 of ./ref_gl/gl_studio.cpp*

===============pfnGetViewInfo

===============

### R_GetChromeSprite

*model_t * R_GetChromeSprite()*

*Defined at line 459 of ./ref_gl/gl_studio.cpp*

===============R_GetChromeSprite

===============

### pfnGetModelCounters

*void pfnGetModelCounters(int ** s, int ** a)*

*Defined at line 470 of ./ref_gl/gl_studio.cpp*

===============pfnGetModelCounters

===============

### pfnGetAliasScale

*void pfnGetAliasScale(float * x, float * y)*

*Defined at line 482 of ./ref_gl/gl_studio.cpp*

===============pfnGetAliasScale

===============

### pfnStudioGetBoneTransform

*float **** pfnStudioGetBoneTransform()*

*Defined at line 494 of ./ref_gl/gl_studio.cpp*

===============pfnStudioGetBoneTransform

===============

### pfnStudioGetLightTransform

*float **** pfnStudioGetLightTransform()*

*Defined at line 505 of ./ref_gl/gl_studio.cpp*

===============pfnStudioGetLightTransform

===============

### pfnStudioGetAliasTransform

*float *** pfnStudioGetAliasTransform()*

*Defined at line 516 of ./ref_gl/gl_studio.cpp*

===============pfnStudioGetAliasTransform

===============

### pfnStudioGetRotationMatrix

*float *** pfnStudioGetRotationMatrix()*

*Defined at line 527 of ./ref_gl/gl_studio.cpp*

===============pfnStudioGetRotationMatrix

===============

### R_StudioSaveBones

*void R_StudioSaveBones()*

*Defined at line 1094 of ./ref_gl/gl_studio.cpp*

====================StudioSaveBones

====================

### R_StudioCalcAttachments

*void R_StudioCalcAttachments()*

*Defined at line 1306 of ./ref_gl/gl_studio.cpp*

====================StudioCalcAttachments

====================

### R_StudioSetupModel

*void R_StudioSetupModel(int bodypart, void ** ppbodypart, void ** ppsubmodel)*

*Defined at line 1326 of ./ref_gl/gl_studio.cpp*

===============pfnStudioSetupModel

===============

### R_StudioCheckBBox

*int R_StudioCheckBBox()*

*Defined at line 1350 of ./ref_gl/gl_studio.cpp*

===============R_StudioCheckBBox

===============

### R_StudioSetColorBegin

*void R_StudioSetColorBegin(short * ptricmds, vec3_t * pstudionorms)*

*Defined at line 1759 of ./ref_gl/gl_studio.cpp*

### R_StudioSetColorArray

*void R_StudioSetColorArray(short * ptricmds, vec3_t * pstudionorms, byte * color)*

*Defined at line 1782 of ./ref_gl/gl_studio.cpp*

### R_StudioSetupSkin

*void R_StudioSetupSkin(studiohdr_t * ptexturehdr, int index)*

*Defined at line 1837 of ./ref_gl/gl_studio.cpp*

===============R_StudioSetupSkin

===============

### R_StudioMeshCompare

*int R_StudioMeshCompare(const void * a, const void * b)*

*Defined at line 1939 of ./ref_gl/gl_studio.cpp*

===============R_StudioMeshCompare

Sorting opaque entities by model type===============

### R_StudioDrawNormalMesh

*void R_StudioDrawNormalMesh(short * ptricmds, vec3_t * pstudionorms, float s, float t)*

*Defined at line 1957 of ./ref_gl/gl_studio.cpp*

===============R_StudioDrawNormalMesh

generic path===============

### R_StudioDrawFloatMesh

*void R_StudioDrawFloatMesh(short * ptricmds, vec3_t * pstudionorms)*

*Defined at line 1990 of ./ref_gl/gl_studio.cpp*

===============R_StudioDrawNormalMesh

generic path===============

### R_StudioDrawChromeMesh

*void R_StudioDrawChromeMesh(short * ptricmds, vec3_t * pstudionorms, float s, float t, float scale)*

*Defined at line 2022 of ./ref_gl/gl_studio.cpp*

===============R_StudioDrawNormalMesh

generic path===============

### R_StudioBuildIndices

*int R_StudioBuildIndices(qboolean tri_strip, int vertexState)*

*Defined at line 2067 of ./ref_gl/gl_studio.cpp*

### R_StudioBuildArrayNormalMesh

*void R_StudioBuildArrayNormalMesh(short * ptricmds, vec3_t * pstudionorms, float s, float t)*

*Defined at line 2110 of ./ref_gl/gl_studio.cpp*

===============R_StudioDrawNormalMesh

generic path===============

### R_StudioBuildArrayFloatMesh

*void R_StudioBuildArrayFloatMesh(short * ptricmds, vec3_t * pstudionorms)*

*Defined at line 2153 of ./ref_gl/gl_studio.cpp*

===============R_StudioDrawNormalMesh

generic path===============

### R_StudioBuildArrayChromeMesh

*void R_StudioBuildArrayChromeMesh(short * ptricmds, vec3_t * pstudionorms, float s, float t, float scale)*

*Defined at line 2196 of ./ref_gl/gl_studio.cpp*

===============R_StudioDrawNormalMesh

generic path===============

### R_StudioDrawArrays

*void R_StudioDrawArrays(uint startverts, uint startelems)*

*Defined at line 2253 of ./ref_gl/gl_studio.cpp*

### R_StudioDrawPoints

*void R_StudioDrawPoints()*

*Defined at line 2286 of ./ref_gl/gl_studio.cpp*

===============R_StudioDrawPoints

===============

### R_StudioDrawHulls

*void R_StudioDrawHulls()*

*Defined at line 2479 of ./ref_gl/gl_studio.cpp*

===============R_StudioDrawHulls

===============

### R_StudioDrawAbsBBox

*void R_StudioDrawAbsBBox()*

*Defined at line 2532 of ./ref_gl/gl_studio.cpp*

===============R_StudioDrawAbsBBox

===============

### R_StudioDrawBones

*void R_StudioDrawBones()*

*Defined at line 2572 of ./ref_gl/gl_studio.cpp*

===============R_StudioDrawBones

===============

### R_StudioDrawAttachments

*void R_StudioDrawAttachments()*

*Defined at line 2622 of ./ref_gl/gl_studio.cpp*

### R_StudioSetRemapColors

*void R_StudioSetRemapColors(int newTop, int newBottom)*

*Defined at line 2673 of ./ref_gl/gl_studio.cpp*

===============R_StudioSetRemapColors

===============

### R_StudioSetupPlayerModel

*model_t * R_StudioSetupPlayerModel(int index)*

*Defined at line 2695 of ./ref_gl/gl_studio.cpp*

===============R_StudioSetupPlayerModel

===============

### R_StudioClientEvents

*void R_StudioClientEvents()*

*Defined at line 2786 of ./ref_gl/gl_studio.cpp*

===============R_StudioClientEvents

===============

### R_StudioSetupRenderer

*void R_StudioSetupRenderer(int rendermode)*

*Defined at line 2899 of ./ref_gl/gl_studio.cpp*

===============R_StudioSetupRenderer

===============

### R_StudioRestoreRenderer

*void R_StudioRestoreRenderer()*

*Defined at line 2928 of ./ref_gl/gl_studio.cpp*

===============R_StudioRestoreRenderer

===============

### pfnIsHardware

*int pfnIsHardware()*

*Defined at line 2956 of ./ref_gl/gl_studio.cpp*

===============pfnIsHardware

Xash3D is always works in hardware mode===============

### R_StudioDrawPointsShadow

*void R_StudioDrawPointsShadow()*

*Defined at line 2967 of ./ref_gl/gl_studio.cpp*

===============R_StudioDrawPointsShadow

===============

### GL_StudioDrawShadow

*void GL_StudioDrawShadow()*

*Defined at line 3069 of ./ref_gl/gl_studio.cpp*

===============GL_StudioDrawShadow

g-cont: don't modify this code it's 100% matched withoriginal GoldSrc code and used in some mods to enablestudio shadows with some asm tricks===============

### R_StudioDrawPlayer

*int R_StudioDrawPlayer(int flags, entity_state_t * pplayer)*

*Defined at line 3345 of ./ref_gl/gl_studio.cpp*

===============R_StudioDrawPlayer

===============

### R_StudioDrawModel

*int R_StudioDrawModel(int flags)*

*Defined at line 3487 of ./ref_gl/gl_studio.cpp*

===============R_StudioDrawModel

===============

### R_StudioLoadTexture

*void R_StudioLoadTexture(model_t * mod, studiohdr_t * phdr, mstudiotexture_t * ptexture)*

*Defined at line 3757 of ./ref_gl/gl_studio.cpp*

====================R_StudioLoadTexture

load model texture with unique name====================

### pfnModelHandle

*model_t * pfnModelHandle(int modelindex)*

*Defined at line 3891 of ./ref_gl/gl_studio.cpp*

### pfnMod_CacheCheck

*void * pfnMod_CacheCheck(struct cache_user_s * c)*

*Defined at line 3896 of ./ref_gl/gl_studio.cpp*

### pfnMod_StudioExtradata

*void * pfnMod_StudioExtradata(model_t * mod)*

*Defined at line 3901 of ./ref_gl/gl_studio.cpp*

### pfnMod_LoadCacheFile

*void pfnMod_LoadCacheFile(const char * path, struct cache_user_s * cu)*

*Defined at line 3906 of ./ref_gl/gl_studio.cpp*

### pfnGetCvarPointer

*cvar_t * pfnGetCvarPointer(const char * name)*

*Defined at line 3911 of ./ref_gl/gl_studio.cpp*

### pfnMod_Calloc

*void * pfnMod_Calloc(int number, size_t size)*

*Defined at line 3916 of ./ref_gl/gl_studio.cpp*

### MSG_Overflow

*qboolean MSG_Overflow(sizebuf_t * sb, int nBits)*

*Defined at line 98 of ./engine/common/net_buffer.cpp*

### MSG_SeekToByte

*void MSG_SeekToByte(sizebuf_t * sb, int bytePos)*

*Defined at line 135 of ./engine/common/net_buffer.cpp*

### R_ParseDetailTextures

*void R_ParseDetailTextures(const char * filename)*

*Defined at line 21 of ./rendersystem/r_misc.cpp*

### item_healthkit

*void item_healthkit(entvars_t * pev)*

*Defined at line 41 of ./game/server/func_healthcharger.cpp*

### func_healthcharger

*void func_healthcharger(entvars_t * pev)*

*Defined at line 132 of ./game/server/func_healthcharger.cpp*

### R_ParseDetailTextures

*void R_ParseDetailTextures(const char * filename)*

*Defined at line 21 of ./ref_gl/gl_rmisc.cpp*

### __MsgFunc_FlashBat

*int __MsgFunc_FlashBat(const char * pszName, int iSize, void * pbuf)*

*Defined at line 28 of ./game/client/flashlight.cpp*

### __MsgFunc_Flashlight

*int __MsgFunc_Flashlight(const char * pszName, int iSize, void * pbuf)*

*Defined at line 29 of ./game/client/flashlight.cpp*

### UI_ServerBrowser_Precache

*void UI_ServerBrowser_Precache()*

*Defined at line 580 of ./mainui/menus/ServerBrowser.cpp*

=================CMenuServerBrowser::Precache=================

### IN_ClientMoveEvent

*void IN_ClientMoveEvent(float forwardmove, float sidemove)*

*Defined at line 19 of ./game/client/input_mouse.cpp*

### IN_ClientLookEvent

*void IN_ClientLookEvent(float relyaw, float relpitch)*

*Defined at line 24 of ./game/client/input_mouse.cpp*

### IN_MouseEvent

*void IN_MouseEvent(int mstate)*

*Defined at line 34 of ./game/client/input_mouse.cpp*

### IN_ClearStates

*void IN_ClearStates()*

*Defined at line 39 of ./game/client/input_mouse.cpp*

### IN_ActivateMouse

*void IN_ActivateMouse()*

*Defined at line 44 of ./game/client/input_mouse.cpp*

### IN_DeactivateMouse

*void IN_DeactivateMouse()*

*Defined at line 49 of ./game/client/input_mouse.cpp*

### IN_Accumulate

*void IN_Accumulate()*

*Defined at line 54 of ./game/client/input_mouse.cpp*

### func_mortar_field

*void func_mortar_field(entvars_t * pev)*

*Defined at line 57 of ./game/server/func_mortar.cpp*

### monster_mortar

*void monster_mortar(entvars_t * pev)*

*Defined at line 205 of ./game/server/func_mortar.cpp*

### tdefl_radix_sort_syms

*tdefl_sym_freq * tdefl_radix_sort_syms(mz_uint num_syms, tdefl_sym_freq * pSyms0, tdefl_sym_freq * pSyms1)*

*Defined at line 1636 of ./engine/common/miniz.h*

### tdefl_calculate_minimum_redundancy

*void tdefl_calculate_minimum_redundancy(tdefl_sym_freq * A, int n)*

*Defined at line 1670 of ./engine/common/miniz.h*

 tdefl_calculate_minimum_redundancy() originally written by: Alistair Moffat, alistair**c**  Jyrki Katajainen, jyrki**<not a builtin command>** .dk, November 1996. 

### tdefl_huffman_enforce_max_code_size

*void tdefl_huffman_enforce_max_code_size(int * pNum_codes, int code_list_len, int max_code_size)*

*Defined at line 1730 of ./engine/common/miniz.h*

### tdefl_optimize_huffman_table

*void tdefl_optimize_huffman_table(tdefl_compressor * d, int table_num, int table_len, int code_size_limit, int static_table)*

*Defined at line 1754 of ./engine/common/miniz.h*

### tdefl_start_dynamic_block

*void tdefl_start_dynamic_block(tdefl_compressor * d)*

*Defined at line 1873 of ./engine/common/miniz.h*

### tdefl_start_static_block

*void tdefl_start_static_block(tdefl_compressor * d)*

*Defined at line 1960 of ./engine/common/miniz.h*

### tdefl_compress_lz_codes

*mz_bool tdefl_compress_lz_codes(tdefl_compressor * d)*

*Defined at line 1985 of ./engine/common/miniz.h*

### tdefl_compress_block

*mz_bool tdefl_compress_block(tdefl_compressor * d, mz_bool static_block)*

*Defined at line 2127 of ./engine/common/miniz.h*

### tdefl_flush_block

*int tdefl_flush_block(tdefl_compressor * d, int flush)*

*Defined at line 2136 of ./engine/common/miniz.h*

### TDEFL_READ_UNALIGNED_WORD

*mz_uint16 TDEFL_READ_UNALIGNED_WORD(const mz_uint8 * p)*

*Defined at line 2273 of ./engine/common/miniz.h*

### TDEFL_READ_UNALIGNED_WORD2

*mz_uint16 TDEFL_READ_UNALIGNED_WORD2(const mz_uint16 * p)*

*Defined at line 2279 of ./engine/common/miniz.h*

### tdefl_find_match

*void tdefl_find_match(tdefl_compressor * d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint * pMatch_dist, mz_uint * pMatch_len)*

*Defined at line 2289 of ./engine/common/miniz.h*

### TDEFL_READ_UNALIGNED_WORD32

*mz_uint32 TDEFL_READ_UNALIGNED_WORD32(const mz_uint8 * p)*

*Defined at line 2389 of ./engine/common/miniz.h*

### tdefl_compress_fast

*mz_bool tdefl_compress_fast(tdefl_compressor * d)*

*Defined at line 2398 of ./engine/common/miniz.h*

### tdefl_record_literal

*void tdefl_record_literal(tdefl_compressor * d, mz_uint8 lit)*

*Defined at line 2572 of ./engine/common/miniz.h*

### tdefl_record_match

*void tdefl_record_match(tdefl_compressor * d, mz_uint match_len, mz_uint match_dist)*

*Defined at line 2585 of ./engine/common/miniz.h*

### tdefl_compress_normal

*mz_bool tdefl_compress_normal(tdefl_compressor * d)*

*Defined at line 2615 of ./engine/common/miniz.h*

### tdefl_flush_output_buffer

*tdefl_status tdefl_flush_output_buffer(tdefl_compressor * d)*

*Defined at line 2760 of ./engine/common/miniz.h*

### tdefl_output_buffer_putter

*mz_bool tdefl_output_buffer_putter(const void * pBuf, int len, void * pUser)*

*Defined at line 2922 of ./engine/common/miniz.h*

### FS_InitMemory

*void FS_InitMemory()*

*Defined at line 3383 of ./engine/common/filesystem.cpp*

### FS_FindFile

*searchpath_t * FS_FindFile(const char * name, int * index, qboolean gamedironly)*

*Defined at line 2124 of ./engine/common/filesystem.cpp*

====================FS_FindFile

Look for a file in the packages and in the filesystem

Return the searchpath where the file was found (or NULL)and the file index in the package if relevant====================

### W_FindLump

*dlumpinfo_t * W_FindLump(wfile_t * wad, const char * name, const signed char matchtype)*

*Defined at line 3462 of ./engine/common/filesystem.cpp*

===========W_FindLump

Serach for already existed lump===========

### FS_AddFileToPack

*dpackfile_t * FS_AddFileToPack(const char * name, pack_t * pack, fs_offset_t offset, fs_offset_t size)*

*Defined at line 374 of ./engine/common/filesystem.cpp*

====================FS_AddFileToPack

Add a file to the list of files contained into a package====================

### Zip_Close

*void Zip_Close(zip_t * zip)*

*Defined at line 758 of ./engine/common/filesystem.cpp*

### W_LoadFile

*byte * W_LoadFile(const char * path, fs_offset_t * filesizeptr, qboolean gamedironly)*

*Defined at line 3752 of ./engine/common/filesystem.cpp*

=============================================================================

FILESYSTEM IMPLEMENTATION

=============================================================================

===========W_LoadFile

loading lump into the tmp buffer===========

### W_Open

*wfile_t * W_Open(const char * filename, int * errorcode)*

*Defined at line 3602 of ./engine/common/filesystem.cpp*

=============================================================================

WADSYSTEM PUBLIC BASE FUNCTIONS

=============================================================================

===========W_Open

open the wad for reading & writing===========

### FS_SysFolderExists

*qboolean FS_SysFolderExists(const char * path)*

*Defined at line 2088 of ./engine/common/filesystem.cpp*

==================FS_SysFolderExists

Look for a existing folder==================

### FS_SysFileTime

*int FS_SysFileTime(const char * filename)*

*Defined at line 1919 of ./engine/common/filesystem.cpp*

====================FS_SysFileTime

Internal function used to determine filetime====================

### W_TypeFromExt

*signed char W_TypeFromExt(const char * lumpname)*

*Defined at line 3415 of ./engine/common/filesystem.cpp*

===========W_TypeFromExt

Extracts file type from extension===========

### W_ExtFromType

*const char * W_ExtFromType(signed char lumptype)*

*Defined at line 3439 of ./engine/common/filesystem.cpp*

===========W_ExtFromType

Convert type to extension===========

### FS_Purge

*void FS_Purge(file_t * file)*

*Defined at line 2701 of ./engine/common/filesystem.cpp*

====================FS_Purge

Erases any buffered input or output data====================

### stringlistinit

*void stringlistinit(stringlist_t * list)*

*Defined at line 173 of ./engine/common/filesystem.cpp*

=============================================================================

FILEMATCH COMMON SYSTEM

=============================================================================

### stringlistfreecontents

*void stringlistfreecontents(stringlist_t * list)*

*Defined at line 178 of ./engine/common/filesystem.cpp*

### stringlistappend

*void stringlistappend(stringlist_t * list, char * text)*

*Defined at line 197 of ./engine/common/filesystem.cpp*

### stringlistsort

*void stringlistsort(stringlist_t * list)*

*Defined at line 216 of ./engine/common/filesystem.cpp*

### listlowercase

*void listlowercase(stringlist_t * list)*

*Defined at line 237 of ./engine/common/filesystem.cpp*

 convert names to lowercase because windows doesn't care, but pattern matching code often does

### listdirectory

*void listdirectory(stringlist_t * list, const char * path, qboolean lowercase)*

*Defined at line 249 of ./engine/common/filesystem.cpp*

### FS_FixFileCase

*const char * FS_FixFileCase(const char * path)*

*Defined at line 307 of ./engine/common/filesystem.cpp*

=============================================================================

OTHER PRIVATE FUNCTIONS

=============================================================================

==================FS_FixFileCase

emulate WIN32 FS behaviour when opening local file==================

### FS_CreatePath

*void FS_CreatePath(char * path)*

*Defined at line 417 of ./engine/common/filesystem.cpp*

============FS_CreatePath

Only used for FS_Open.============

### FS_Path_f

*void FS_Path_f()*

*Defined at line 441 of ./engine/common/filesystem.cpp*

============FS_Path_f

debug info============

### FS_ClearPaths_f

*void FS_ClearPaths_f()*

*Defined at line 471 of ./engine/common/filesystem.cpp*

============FS_ClearPath_f

only for debug targets============

### FS_LoadPackPAK

*pack_t * FS_LoadPackPAK(const char * packfile, int * error)*

*Defined at line 486 of ./engine/common/filesystem.cpp*

=================FS_LoadPackPAK

Takes an explicit (not game tree related) path to a pak file.

Loads the header and directory, adding the files at the beginningof the list so they override previous pack files.=================

### FS_AddFileToZip

*zipfile_t * FS_AddFileToZip(const char * name, zip_t * zip, fs_offset_t offset, fs_offset_t size, fs_offset_t compressed_size)*

*Defined at line 577 of ./engine/common/filesystem.cpp*

### FS_LoadZip

*zip_t * FS_LoadZip(const char * zipfile, int * error)*

*Defined at line 594 of ./engine/common/filesystem.cpp*

### Zip_LoadFile

*byte * Zip_LoadFile(const char * path, fs_offset_t * sizeptr, qboolean gamedironly)*

*Defined at line 771 of ./engine/common/filesystem.cpp*

### FS_AddWad_Fullpath

*qboolean FS_AddWad_Fullpath(const char * wadfile, qboolean * already_loaded, int flags)*

*Defined at line 908 of ./engine/common/filesystem.cpp*

====================FS_AddWad_Fullpath====================

### FS_AddPak_Fullpath

*qboolean FS_AddPak_Fullpath(const char * pakfile, qboolean * already_loaded, int flags)*

*Defined at line 963 of ./engine/common/filesystem.cpp*

================FS_AddPak_Fullpath

Adds the given pack to the search path.The pack type is autodetected by the file extension.

Returns true if the file was successfully added to thesearch path or if it was already included.

If keep_plain_dirs is set, the pack will be added AFTER the first sequence ofplain directories.================

### FS_AddZip_Fullpath

*qboolean FS_AddZip_Fullpath(const char * zipfile, qboolean * already_loaded, int flags)*

*Defined at line 1017 of ./engine/common/filesystem.cpp*

### FS_CheckNastyPath

*int FS_CheckNastyPath(const char * path, qboolean isgamedir)*

*Defined at line 1228 of ./engine/common/filesystem.cpp*

====================FS_CheckNastyPath

Return true if the path should be rejected due to one of the following:1: path elements that are non-portable2: path elements that would allow access to files outside the game directory,   or are just not a good idea for a mod to be using.====================

### FS_Rescan_f

*void FS_Rescan_f()*

*Defined at line 1308 of ./engine/common/filesystem.cpp*

================FS_Rescan_f================

### FS_WriteGameInfo

*void FS_WriteGameInfo(const char * filepath, gameinfo_t * GameInfo)*

*Defined at line 1320 of ./engine/common/filesystem.cpp*

================FS_WriteGameInfo

assume GameInfo is valid================

### FS_InitGameInfo

*void FS_InitGameInfo(gameinfo_t * GameInfo, const char * gamedir)*

*Defined at line 1428 of ./engine/common/filesystem.cpp*

### FS_ParseGenericGameInfo

*void FS_ParseGenericGameInfo(gameinfo_t * GameInfo, const char * buf, const qboolean isGameInfo)*

*Defined at line 1459 of ./engine/common/filesystem.cpp*

### FS_CreateDefaultGameInfo

*void FS_CreateDefaultGameInfo(const char * filename)*

*Defined at line 1547 of ./engine/common/filesystem.cpp*

================FS_CreateDefaultGameInfo================

### FS_ParseLiblistGam

*qboolean FS_ParseLiblistGam(const char * filename, const char * gamedir, gameinfo_t * GameInfo)*

*Defined at line 1562 of ./engine/common/filesystem.cpp*

================FS_ParseLiblistGam================

### FS_ConvertGameInfo

*qboolean FS_ConvertGameInfo(const char * gamedir, const char * gameinfo_path, const char * liblist_path)*

*Defined at line 1584 of ./engine/common/filesystem.cpp*

================FS_ConvertGameInfo================

### FS_ReadGameInfo

*qboolean FS_ReadGameInfo(const char * filepath, const char * gamedir, gameinfo_t * GameInfo)*

*Defined at line 1606 of ./engine/common/filesystem.cpp*

================FS_ReadGameInfo================

### FS_CheckForGameDir

*qboolean FS_CheckForGameDir(const char * gamedir)*

*Defined at line 1627 of ./engine/common/filesystem.cpp*

================FS_CheckForGameDir================

### FS_ParseGameInfo

*qboolean FS_ParseGameInfo(const char * gamedir, gameinfo_t * GameInfo)*

*Defined at line 1651 of ./engine/common/filesystem.cpp*

================FS_ParseGameInfo================

### FS_SysOpen

*file_t * FS_SysOpen(const char * filepath, const char * mode)*

*Defined at line 1936 of ./engine/common/filesystem.cpp*

====================FS_SysOpen

Internal function used to create a file_t and open the relevant non-packed file on disk====================

### FS_OpenPackedFile

*file_t * FS_OpenPackedFile(pack_t * pack, int pack_ind)*

*Defined at line 2017 of ./engine/common/filesystem.cpp*

===========FS_OpenPackedFile

Open a packed file using its package file descriptor===========

### FS_OpenReadFile

*file_t * FS_OpenReadFile(const char * filename, const char * mode, qboolean gamedironly)*

*Defined at line 2290 of ./engine/common/filesystem.cpp*

===========FS_OpenReadFile

Look for a file in the search paths and open it in read-only mode===========

### FS_CheckForCrypt

*qboolean FS_CheckForCrypt(const char * dllname)*

*Defined at line 2922 of ./engine/common/filesystem.cpp*

==================FS_CheckForCrypt

return true if library is crypted==================

### W_AddFileToWad

*dlumpinfo_t * W_AddFileToWad(const char * name, wfile_t * wad, dlumpinfo_t * newlump)*

*Defined at line 3505 of ./engine/common/filesystem.cpp*

====================W_AddFileToWad

Add a file to the list of files contained into a packageand sort LAT in alpha-bethical order====================

### W_ReadLump

*byte * W_ReadLump(wfile_t * wad, dlumpinfo_t * lump, fs_offset_t * lumpsizeptr)*

*Defined at line 3551 of ./engine/common/filesystem.cpp*

===========W_ReadLump

reading lump into temp buffer===========

### SCR_CreateStartupVids

*void SCR_CreateStartupVids()*

*Defined at line 71 of ./engine/client/cl_video.cpp*

### Cvar_UpdateInfo

*qboolean Cvar_UpdateInfo(convar_t * var, const char * value, qboolean notify)*

*Defined at line 109 of ./engine/common/cvar.cpp*

============Cvar_UpdateInfo

deal with userinfo etc============

### Cvar_ValidateString

*const char * Cvar_ValidateString(convar_t * var, const char * value)*

*Defined at line 159 of ./engine/common/cvar.cpp*

============Cvar_ValidateString

deal with userinfo etc============

### Cvar_UnlinkVar

*int Cvar_UnlinkVar(const char * var_name, int group)*

*Defined at line 224 of ./engine/common/cvar.cpp*

============Cvar_UnlinkVar

unlink the variable============

### Cvar_Changed

*void Cvar_Changed(convar_t * var)*

*Defined at line 280 of ./engine/common/cvar.cpp*

============Cvar_Changed

Tell the engine parts about cvar changing============

### Cvar_SetGL

*void Cvar_SetGL(const char * name, const char * value)*

*Defined at line 731 of ./engine/common/cvar.cpp*

============Cvar_SetGL

As Cvar_Set, but also flags it as glconfig============

### Cvar_Toggle_f

*void Cvar_Toggle_f()*

*Defined at line 821 of ./engine/common/cvar.cpp*

============Cvar_Toggle_f

Toggles a cvar for easy single key binding============

### Cvar_SetGL_f

*void Cvar_SetGL_f()*

*Defined at line 843 of ./engine/common/cvar.cpp*

============Cvar_SetGL_f

As Cvar_Set, but also flags it as glconfig============

### Cvar_Reset_f

*void Cvar_Reset_f()*

*Defined at line 861 of ./engine/common/cvar.cpp*

============Cvar_Reset_f============

### Cvar_List_f

*void Cvar_List_f()*

*Defined at line 877 of ./engine/common/cvar.cpp*

============Cvar_List_f============

### CL_DispatchQuakeMessage

*void CL_DispatchQuakeMessage(const char * name)*

*Defined at line 52 of ./engine/client/cl_qparse.cpp*

==================CL_DispatchQuakeMessage

==================

### CL_ParseQuakeStats

*void CL_ParseQuakeStats(sizebuf_t * msg)*

*Defined at line 65 of ./engine/client/cl_qparse.cpp*

==================CL_ParseQuakeStats

redirect to qwrap->client==================

### CL_QuakeEntityTeleported

*qboolean CL_QuakeEntityTeleported(cl_entity_t * ent, entity_state_t * newstate)*

*Defined at line 80 of ./engine/client/cl_qparse.cpp*

==================CL_EntityTeleported

check for instant movement in casewe don't want interpolate this==================

### CL_UpdateQuakeStats

*int CL_UpdateQuakeStats(sizebuf_t * msg, int statnum, qboolean has_update)*

*Defined at line 101 of ./engine/client/cl_qparse.cpp*

==================CL_ParseQuakeStats

redirect to qwrap->client==================

### CL_UpdateQuakeGameMode

*void CL_UpdateQuakeGameMode(int gamemode)*

*Defined at line 127 of ./engine/client/cl_qparse.cpp*

==================CL_UpdateQuakeGameMode

redirect to qwrap->client==================

### CL_ParseQuakeSound

*void CL_ParseQuakeSound(sizebuf_t * msg)*

*Defined at line 139 of ./engine/client/cl_qparse.cpp*

==================CL_ParseQuakeSound

==================

### CL_ParseQuakeServerInfo

*void CL_ParseQuakeServerInfo(sizebuf_t * msg)*

*Defined at line 181 of ./engine/client/cl_qparse.cpp*

==================CL_ParseQuakeServerInfo

==================

### CL_ParseQuakeClientData

*void CL_ParseQuakeClientData(sizebuf_t * msg)*

*Defined at line 346 of ./engine/client/cl_qparse.cpp*

==================CL_ParseQuakeClientData

==================

### CL_ParseQuakeEntityData

*void CL_ParseQuakeEntityData(sizebuf_t * msg, int bits)*

*Defined at line 423 of ./engine/client/cl_qparse.cpp*

==================CL_ParseQuakeEntityData

Parse an entity update message from the serverIf an entities model or origin changes from frame to frame, it must berelinked.  Other attributes can change without relinking.==================

### CL_ParseQuakeParticle

*void CL_ParseQuakeParticle(sizebuf_t * msg)*

*Defined at line 574 of ./engine/client/cl_qparse.cpp*

==================CL_ParseQuakeParticles

==================

### CL_ParseQuakeStaticSound

*void CL_ParseQuakeStaticSound(sizebuf_t * msg)*

*Defined at line 596 of ./engine/client/cl_qparse.cpp*

===================CL_ParseQuakeStaticSound

===================

### CL_ParseQuakeDamage

*void CL_ParseQuakeDamage(sizebuf_t * msg)*

*Defined at line 617 of ./engine/client/cl_qparse.cpp*

==================CL_ParseQuakeDamage

redirect to qwrap->client==================

### CL_ParseQuakeStaticEntity

*void CL_ParseQuakeStaticEntity(sizebuf_t * msg)*

*Defined at line 633 of ./engine/client/cl_qparse.cpp*

===================CL_ParseQuakeStaticEntity

===================

### CL_ParseQuakeBaseline

*void CL_ParseQuakeBaseline(sizebuf_t * msg)*

*Defined at line 697 of ./engine/client/cl_qparse.cpp*

===================CL_ParseQuakeBaseline

===================

### CL_ParseQuakeTempEntity

*void CL_ParseQuakeTempEntity(sizebuf_t * msg)*

*Defined at line 736 of ./engine/client/cl_qparse.cpp*

===================CL_ParseQuakeTempEntity

===================

### CL_ParseQuakeSignon

*void CL_ParseQuakeSignon(sizebuf_t * msg)*

*Defined at line 784 of ./engine/client/cl_qparse.cpp*

===================CL_ParseQuakeSignon

very important message===================

### CL_ParseNehahraShowLMP

*void CL_ParseNehahraShowLMP(sizebuf_t * msg)*

*Defined at line 799 of ./engine/client/cl_qparse.cpp*

==================CL_ParseNehahraShowLMP

redirect to qwrap->client==================

### CL_ParseNehahraHideLMP

*void CL_ParseNehahraHideLMP(sizebuf_t * msg)*

*Defined at line 815 of ./engine/client/cl_qparse.cpp*

==================CL_ParseNehahraHideLMP

redirect to qwrap->client==================

### CL_QuakeStuffText

*void CL_QuakeStuffText(const char * text)*

*Defined at line 827 of ./engine/client/cl_qparse.cpp*

==================CL_QuakeStuffText

==================

### CL_QuakeExecStuff

*void CL_QuakeExecStuff()*

*Defined at line 839 of ./engine/client/cl_qparse.cpp*

==================CL_QuakeExecStuff

==================

### __MsgFunc_MOTD

*int __MsgFunc_MOTD(const char * pszName, int iSize, void * pbuf)*

*Defined at line 29 of ./game/client/MOTD.cpp*

### Host_SetState

*void Host_SetState(host_state_t newState, qboolean clearNext)*

*Defined at line 24 of ./engine/common/host_state.cpp*

### Host_SetNextState

*void Host_SetNextState(host_state_t nextState)*

*Defined at line 39 of ./engine/common/host_state.cpp*

### Host_ShutdownGame

*void Host_ShutdownGame()*

*Defined at line 120 of ./engine/common/host_state.cpp*

### Host_RunFrame

*void Host_RunFrame(float time)*

*Defined at line 136 of ./engine/common/host_state.cpp*

### CL_ClearResourceList

*void CL_ClearResourceList(resource_t * pList)*

*Defined at line 130 of ./engine/client/cl_custom.cpp*

### CopyToBodyQue

*void CopyToBodyQue(entvars_t * pev)*

*Defined at line 228 of ./game/server/world.cpp*

 make a body que entry for the given ent so the ent can be respawned elsewhere

 GLOBALS ASSUMED SET:  g_eoBodyQueueHead

### LinkUserMessages

*void LinkUserMessages()*

*Defined at line 192 of ./game/server/player.cpp*

### set_suicide_frame

*void set_suicide_frame(entvars_t * pev)*

*Defined at line 68 of ./game/server/client.cpp*

 used by kill command and disconnect command ROBIN: Moved here from player.cpp, to allow multiple player models

### Host_Say

*void Host_Say(edict_t * pEntity, int teamonly)*

*Defined at line 316 of ./game/server/client.cpp*

/ HOST_SAY String comes in as say blah blah blah or as blah blah blah

### Entity_FieldInit

*void Entity_FieldInit(struct delta_s * pFields)*

*Defined at line 1396 of ./game/server/client.cpp*

### Entity_Encode

*void Entity_Encode(struct delta_s * pFields, const unsigned char * from, const unsigned char * to)*

*Defined at line 1414 of ./game/server/client.cpp*

==================Entity_Encode

Callback for sending entity_state_t info over network. FIXME:  Move to script==================

### Player_FieldInit

*void Player_FieldInit(struct delta_s * pFields)*

*Defined at line 1471 of ./game/server/client.cpp*

### Player_Encode

*void Player_Encode(struct delta_s * pFields, const unsigned char * from, const unsigned char * to)*

*Defined at line 1485 of ./game/server/client.cpp*

==================Player_Encode

Callback for sending entity_state_t for players info over network. ==================

### Custom_Entity_FieldInit

*void Custom_Entity_FieldInit(struct delta_s * pFields)*

*Defined at line 1547 of ./game/server/client.cpp*

### Custom_Encode

*void Custom_Encode(struct delta_s * pFields, const unsigned char * from, const unsigned char * to)*

*Defined at line 1568 of ./game/server/client.cpp*

==================Custom_Encode

Callback for sending entity_state_t info ( for custom entities ) over network. FIXME:  Move to script==================

### hornet

*void hornet(entvars_t * pev)*

*Defined at line 31 of ./game/server/npc/npc_hornet.cpp*

### xprof_enabled_callback

*void xprof_enabled_callback(const char * old, const char * _new)*

*Defined at line 71 of ./engine/common/xprof_engine.cpp*

### xprof_frame_time_callback

*void xprof_frame_time_callback(const char * old, const char * _new)*

*Defined at line 85 of ./engine/common/xprof_engine.cpp*

### SV_StepDirection

*qboolean SV_StepDirection(edict_t * ent, float yaw, float dist)*

*Defined at line 432 of ./engine/server/sv_move.cpp*

### SV_FlyDirection

*qboolean SV_FlyDirection(edict_t * ent, vec3_t move)*

*Defined at line 448 of ./engine/server/sv_move.cpp*

### SV_NewChaseDir

*void SV_NewChaseDir(edict_t * actor, vec3_t destination, float dist)*

*Defined at line 458 of ./engine/server/sv_move.cpp*

### __MsgFunc_StatusText

*int __MsgFunc_StatusText(const char * pszName, int iSize, void * pbuf)*

*Defined at line 29 of ./game/client/statusbar.cpp*

### __MsgFunc_StatusValue

*int __MsgFunc_StatusValue(const char * pszName, int iSize, void * pbuf)*

*Defined at line 30 of ./game/client/statusbar.cpp*

### PM_ParticleLine

*void PM_ParticleLine(float * start, float * end, int pcolor, float life, float vert)*

### V_DropPunchAngle

*void V_DropPunchAngle(float frametime, float * ev_punchangle)*

*Defined at line 1557 of ./game/client/view.cpp*

=============V_DropPunchAngle

=============

### V_CalcBob

*float V_CalcBob(struct ref_params_s * pparams)*

*Defined at line 173 of ./game/client/view.cpp*

 Quakeworld bob code, this fixes jitters in the mutliplayer since the clock (pparams->time) isn't quite linear

### V_CalcRoll

*float V_CalcRoll(Vector angles, Vector velocity, float rollangle, float rollspeed)*

*Defined at line 221 of ./game/client/view.cpp*

===============V_CalcRollUsed by view and sv_user===============

### V_CalcGunAngle

*void V_CalcGunAngle(struct ref_params_s * pparams)*

*Defined at line 278 of ./game/client/view.cpp*

==================V_CalcGunAngle==================

### V_AddIdle

*void V_AddIdle(struct ref_params_s * pparams)*

*Defined at line 305 of ./game/client/view.cpp*

==============V_AddIdle

Idle swaying==============

### V_CalcViewRoll

*void V_CalcViewRoll(struct ref_params_s * pparams)*

*Defined at line 319 of ./game/client/view.cpp*

==============V_CalcViewRoll

Roll is induced by movement and damage==============

### V_CalcIntermissionRefdef

*void V_CalcIntermissionRefdef(struct ref_params_s * pparams)*

*Defined at line 347 of ./game/client/view.cpp*

==================V_CalcIntermissionRefdef

==================

### V_CalcNormalRefdef

*void V_CalcNormalRefdef(struct ref_params_s * pparams)*

*Defined at line 404 of ./game/client/view.cpp*

==================V_CalcRefdef

==================

### V_SmoothInterpolateAngles

*void V_SmoothInterpolateAngles(float * startAngle, float * endAngle, float * finalAngle, float degreesPerSec)*

*Defined at line 767 of ./game/client/view.cpp*

### V_GetChaseOrigin

*void V_GetChaseOrigin(float * angles, float * origin, float distance, float * returnvec)*

*Defined at line 824 of ./game/client/view.cpp*

 Get the origin of the Observer based around the target's position and angles

### V_GetSingleTargetCam

*void V_GetSingleTargetCam(cl_entity_t * ent1, float * angle, float * origin)*

*Defined at line 929 of ./game/client/view.cpp*

void V_GetDeathCam( cl_entity_t * ent1, cl_entity_t * ent2, float * angle, float * origin ){	float newAngle[3]; float newOrigin[3];

	float distance = 168.0f;

	v_lastDistance += v_frametime * 96.0f;	// move unit per seconds back

	if( v_resetCamera )		v_lastDistance = 64.0f;

	if( distance > v_lastDistance )		distance = v_lastDistance;

	VectorCopy( ent1->origin, newOrigin );

	if( ent1->player )		newOrigin[2] += 17; // head level of living player

	// get new angle towards second target	if( ent2 )	{		VectorSubtract( ent2->origin, ent1->origin, newAngle );		VectorAngles( newAngle, newAngle );		newAngle[0] = -newAngle[0];	}	else	{		// if no second target is given, look down to dead player		newAngle[0] = 90.0f;		newAngle[1] = 0.0f;		newAngle[2] = 0;	}

	// and smooth view	V_SmoothInterpolateAngles( v_lastAngles, newAngle, angle, 120.0f );

	V_GetChaseOrigin( angle, newOrigin, distance, origin );

	VectorCopy( angle, v_lastAngles );}

### MaxAngleBetweenAngles

*float MaxAngleBetweenAngles(float * a1, float * a2)*

*Defined at line 992 of ./game/client/view.cpp*

### V_GetDoubleTargetsCam

*void V_GetDoubleTargetsCam(cl_entity_t * ent1, cl_entity_t * ent2, float * angle, float * origin)*

*Defined at line 1020 of ./game/client/view.cpp*

### V_GetDirectedChasePosition

*void V_GetDirectedChasePosition(cl_entity_t * ent1, cl_entity_t * ent2, float * angle, float * origin)*

*Defined at line 1104 of ./game/client/view.cpp*

### V_GetMapFreePosition

*void V_GetMapFreePosition(float * cl_angles, float * origin, float * angles)*

*Defined at line 1242 of ./game/client/view.cpp*

### V_GetMapChasePosition

*void V_GetMapChasePosition(int target, float * cl_angles, float * origin, float * angles)*

*Defined at line 1263 of ./game/client/view.cpp*

### V_FindViewModelByWeaponModel

*int V_FindViewModelByWeaponModel(int weaponindex)*

*Defined at line 1306 of ./game/client/view.cpp*

### V_CalcSpectatorRefdef

*void V_CalcSpectatorRefdef(struct ref_params_s * pparams)*

*Defined at line 1356 of ./game/client/view.cpp*

==================V_CalcSpectatorRefdef

==================

### func_wall

*void func_wall(entvars_t * pev)*

*Defined at line 63 of ./game/server/bmodels.cpp*

### func_wall_toggle

*void func_wall_toggle(entvars_t * pev)*

*Defined at line 94 of ./game/server/bmodels.cpp*

### func_conveyor

*void func_conveyor(entvars_t * pev)*

*Defined at line 148 of ./game/server/bmodels.cpp*

### func_illusionary

*void func_illusionary(entvars_t * pev)*

*Defined at line 207 of ./game/server/bmodels.cpp*

### func_monsterclip

*void func_monsterclip(entvars_t * pev)*

*Defined at line 251 of ./game/server/bmodels.cpp*

### func_rotating

*void func_rotating(entvars_t * pev)*

*Defined at line 311 of ./game/server/bmodels.cpp*

### func_pendulum

*void func_pendulum(entvars_t * pev)*

*Defined at line 765 of ./game/server/bmodels.cpp*

### Xash_Error

*void Xash_Error(const char * szFmt)*

*Defined at line 60 of ./launcher/game.cpp*

### Sys_LoadEngine

*void Sys_LoadEngine()*

*Defined at line 90 of ./launcher/game.cpp*

### Sys_UnloadEngine

*void Sys_UnloadEngine()*

*Defined at line 106 of ./launcher/game.cpp*

### Sys_ChangeGame

*void Sys_ChangeGame(const char * progname)*

*Defined at line 115 of ./launcher/game.cpp*

### Sys_Start

*int Sys_Start()*

*Defined at line 131 of ./launcher/game.cpp*

### main

*int main(int argc, char ** argv)*

*Defined at line 143 of ./launcher/game.cpp*

### infodecal

*void infodecal(entvars_t * pev)*

*Defined at line 115 of ./game/server/world.cpp*

### bodyque

*void bodyque(entvars_t * pev)*

*Defined at line 204 of ./game/server/world.cpp*

### InitBodyQue

*void InitBodyQue()*

*Defined at line 206 of ./game/server/world.cpp*

### worldspawn

*void worldspawn(entvars_t * pev)*

*Defined at line 446 of ./game/server/world.cpp*

### DispatchCreateEntity

*int DispatchCreateEntity(edict_t * pent, const char * szName)*

*Defined at line 743 of ./game/server/world.cpp*

 attempt to create custom entity when default method is failed 0 - attempt to create, -1 - reject to create

### DispatchPhysicsEntity

*int DispatchPhysicsEntity(edict_t * pEdict)*

*Defined at line 775 of ./game/server/world.cpp*

 run custom physics for each entity return 0 to use built-in engine physic

### player

*void player(entvars_t * pev)*

*Defined at line 240 of ./game/server/player.cpp*

### VecVelocityForDamage

*Vector VecVelocityForDamage(float flDamage)*

*Defined at line 256 of ./game/server/player.cpp*

### FixPlayerCrouchStuck

*void FixPlayerCrouchStuck(edict_t * pPlayer)*

*Defined at line 1583 of ./game/server/player.cpp*

 This is a glorious hack to find free space when you've crouched into some solid space Our crouching collisions do not work correctly for some reason and this is easier than fixing the problem :(

### CheckPowerups

*void CheckPowerups(entvars_t * pev)*

*Defined at line 2337 of ./game/server/player.cpp*

================CheckPowerups

Check for turning off powerups

GLOBALS ASSUMED SET:  g_ulModelIndexPlayer================

### IsSpawnPointValid

*BOOL IsSpawnPointValid(class CBaseEntity * pPlayer, class CBaseEntity * pSpot)*

*Defined at line 2631 of ./game/server/player.cpp*

 checks if the spot is clear of players

### FNullEnt

*int FNullEnt(class CBaseEntity * ent)*

*Defined at line 2651 of ./game/server/player.cpp*

### monster_hevsuit_dead

*void monster_hevsuit_dead(entvars_t * pev)*

*Defined at line 4583 of ./game/server/player.cpp*

### player_weaponstrip

*void player_weaponstrip(entvars_t * pev)*

*Defined at line 4622 of ./game/server/player.cpp*

### player_loadsaved

*void player_loadsaved(entvars_t * pev)*

*Defined at line 4668 of ./game/server/player.cpp*

### info_intermission

*void info_intermission(entvars_t * pev)*

*Defined at line 4765 of ./game/server/player.cpp*

### monster_generic

*void monster_generic(entvars_t * pev)*

*Defined at line 42 of ./game/server/ai/ai_genericmonster.cpp*

### Sound_Reset

*void Sound_Reset()*

*Defined at line 21 of ./engine/common/soundlib/snd_main.cpp*

### SoundPack

*wavdata_t * SoundPack()*

*Defined at line 33 of ./engine/common/soundlib/snd_main.cpp*

### fi_next

*mpg_off_t fi_next(frame_index_t * fi)*

*Defined at line 20 of ./engine/common/soundlib/libmpg/index.cpp*

 the next expected frame offset, one step ahead.

### fi_shrink

*void fi_shrink(frame_index_t * fi)*

*Defined at line 27 of ./engine/common/soundlib/libmpg/index.cpp*

 shrink down the used index to the half. be careful with size = 1 ... there's no shrinking possible there.

### UI_Controls_Precache

*void UI_Controls_Precache()*

*Defined at line 420 of ./mainui/menus/Controls.cpp*

=================UI_Controls_Precache=================

### pfnVibrate

*void pfnVibrate(float life, char flags)*

*Defined at line 30 of ./engine/client/cl_mobile.cpp*

### Vibrate_f

*void Vibrate_f()*

*Defined at line 47 of ./engine/client/cl_mobile.cpp*

### pfnEnableTextInput

*void pfnEnableTextInput(int enable)*

*Defined at line 58 of ./engine/client/cl_mobile.cpp*

### pfnDrawScaledCharacter

*int pfnDrawScaledCharacter(int x, int y, int number, int r, int g, int b, float scale)*

*Defined at line 63 of ./engine/client/cl_mobile.cpp*

### pfnGetNativeObject

*void * pfnGetNativeObject(const char * obj)*

*Defined at line 89 of ./engine/client/cl_mobile.cpp*

### IN_ToggleButtons

*void IN_ToggleButtons(float forwardmove, float sidemove)*

*Defined at line 49 of ./game/client/input_xash3d.cpp*

### UI_NewGame_Precache

*void UI_NewGame_Precache()*

*Defined at line 119 of ./mainui/menus/NewGame.cpp*

=================UI_NewGame_Precache=================

### SV_EntityNumbers

*int SV_EntityNumbers(const void * a, const void * b)*

*Defined at line 36 of ./engine/server/sv_frame.cpp*

=======================SV_EntityNumbers=======================

### SV_AddEntitiesToPacket

*void SV_AddEntitiesToPacket(edict_t * pViewEnt, edict_t * pClient, client_frame_t * frame, sv_ents_t * ents, qboolean from_client)*

*Defined at line 57 of ./engine/server/sv_frame.cpp*

=============SV_AddEntitiesToPacket

=============

### SV_FindBestBaseline

*int SV_FindBestBaseline(sv_client_t * cl, int index, entity_state_t ** baseline, entity_state_t * to, client_frame_t * frame, qboolean player)*

*Defined at line 182 of ./engine/server/sv_frame.cpp*

=============================================================================

Encode a client frame onto the network channel

=============================================================================

=============SV_FindBestBaseline

trying to deltas with previous entities=============

### SV_EmitPacketEntities

*void SV_EmitPacketEntities(sv_client_t * cl, client_frame_t * to, sizebuf_t * msg)*

*Defined at line 259 of ./engine/server/sv_frame.cpp*

=============SV_EmitPacketEntities

Writes a delta update of an entity_state_t list to the message->=============

### SV_EmitEvents

*void SV_EmitEvents(sv_client_t * cl, client_frame_t * to, sizebuf_t * msg)*

*Defined at line 395 of ./engine/server/sv_frame.cpp*

=============SV_EmitEvents

=============

### SV_EmitPings

*void SV_EmitPings(sizebuf_t * msg)*

*Defined at line 517 of ./engine/server/sv_frame.cpp*

=============SV_EmitPings

=============

### SV_WriteClientdataToMessage

*void SV_WriteClientdataToMessage(sv_client_t * cl, sizebuf_t * msg)*

*Defined at line 549 of ./engine/server/sv_frame.cpp*

==================SV_WriteClientdataToMessage

==================

### SV_WriteEntitiesToClient

*void SV_WriteEntitiesToClient(sv_client_t * cl, sizebuf_t * msg)*

*Defined at line 636 of ./engine/server/sv_frame.cpp*

==================SV_WriteEntitiesToClient

==================

### SV_SendClientDatagram

*void SV_SendClientDatagram(sv_client_t * cl)*

*Defined at line 708 of ./engine/server/sv_frame.cpp*

===============================================================================

FRAME UPDATES

===============================================================================

=======================SV_SendClientDatagram=======================

### SV_UpdateUserInfo

*void SV_UpdateUserInfo(sv_client_t * cl)*

*Defined at line 753 of ./engine/server/sv_frame.cpp*

=======================SV_UpdateUserInfo=======================

### SV_UpdateToReliableMessages

*void SV_UpdateToReliableMessages()*

*Defined at line 765 of ./engine/server/sv_frame.cpp*

=======================SV_UpdateToReliableMessages=======================

### R_SplitEntityOnNode

*void R_SplitEntityOnNode(mnode_t * node)*

*Defined at line 81 of ./engine/client/cl_efrag.cpp*

===================R_SplitEntityOnNode===================

### HandleAbort

*void HandleAbort(int sig, siginfo_t * siginfo, void * pdat)*

*Defined at line 255 of ./public/debug.cpp*

### DbgInit

*void DbgInit()*

*Defined at line 29 of ./public/debug.cpp*

### _CleanName

*const char * _CleanName(const char * file)*

*Defined at line 57 of ./public/debug.cpp*

 Strips off the ../ that all files have appeneded to them 

### _FindOrCreateAssert

*class dbg::CAssert & _FindOrCreateAssert(const char * file, int line, const char * exp)*

*Defined at line 68 of ./public/debug.cpp*

 Internal functions (No locking done) 

### _CreateAssert

*class dbg::CAssert & _CreateAssert(const char * file, int line, const char * exp)*

*Defined at line 81 of ./public/debug.cpp*

### _FindAssert

*class dbg::CAssert * _FindAssert(const char * file, int line)*

*Defined at line 88 of ./public/debug.cpp*



## Enums

| enum EIfaceStatus |

--

| OK |
| FAILED |


*Defined at line 67 of ./public/appframework.h*

 Used for the iface status parameter in pfnCreateInterface 

| enum  |

--

| kRenderNormal |
| kRenderTransColor |
| kRenderTransTexture |
| kRenderGlow |
| kRenderTransAlpha |
| kRenderTransAdd |


*Defined at line 697 of ./common/const.h*

 Rendering constants

| enum  |

--

| kRenderFxNone |
| kRenderFxPulseSlow |
| kRenderFxPulseFast |
| kRenderFxPulseSlowWide |
| kRenderFxPulseFastWide |
| kRenderFxFadeSlow |
| kRenderFxFadeFast |
| kRenderFxSolidSlow |
| kRenderFxSolidFast |
| kRenderFxStrobeSlow |
| kRenderFxStrobeFast |
| kRenderFxStrobeFaster |
| kRenderFxFlickerSlow |
| kRenderFxFlickerFast |
| kRenderFxNoDissipation |
| kRenderFxDistort |
| kRenderFxHologram |
| kRenderFxDeadPlayer |
| kRenderFxExplode |
| kRenderFxGlowShell |
| kRenderFxClampMinScale |


*Defined at line 707 of ./common/const.h*

| enum  |

--

| t_sound |
| t_skin |
| t_model |
| t_decal |
| t_generic |
| t_eventscript |
| t_world |


*Defined at line 26 of ./engine/custom.h*

////////////// Customization passed to pfnPlayerCustomization For automatic downloading.

| enum  |

--

| at_notice |
| at_console |
| at_aiconsole |
| at_warning |
| at_error |
| at_logged |


*Defined at line 43 of ./engine/eiface.h*

| enum  |

--

| print_console |
| print_center |
| print_chat |


*Defined at line 54 of ./engine/eiface.h*

 4-22-98  JOHN: added for use in pfnClientPrintf

| enum  |

--

| force_exactfile |
| force_model_samebounds |
| force_model_specifybounds |


*Defined at line 62 of ./engine/eiface.h*

 For integrity checking of content on clients

| enum _fieldtypes |

--

| FIELD_FLOAT |
| FIELD_STRING |
| FIELD_ENTITY |
| FIELD_CLASSPTR |
| FIELD_EHANDLE |
| FIELD_EVARS |
| FIELD_EDICT |
| FIELD_VECTOR |
| FIELD_POSITION_VECTOR |
| FIELD_POINTER |
| FIELD_INTEGER |
| FIELD_FUNCTION |
| FIELD_BOOLEAN |
| FIELD_SHORT |
| FIELD_CHARACTER |
| FIELD_TIME |
| FIELD_MODELNAME |
| FIELD_SOUNDNAME |
| FIELD_TYPECOUNT |


*Defined at line 344 of ./engine/eiface.h*

| enum class ELogLevel |

--

| INVALID |
| INFO |
| WARNING |
| ERROR |
| FATAL |


*Defined at line 69 of ./engine/log_int.h*

=======================

 Common structures and other definitions

=======================

| enum  |

--

| AMBIENT_WATER |
| AMBIENT_SKY |
| AMBIENT_SLIME |
| AMBIENT_LAVA |
| NUM_AMBIENTS |


*Defined at line 140 of ./common/bspfile.h*

 ambient sound types

| enum  |

--

| mod_bad |
| mod_brush |
| mod_sprite |
| mod_alias |
| mod_studio |
| mod_custom |


*Defined at line 45 of ./common/com_model.h*

 model types

| enum  |

--

| SPR_SINGLE |
| SPR_GROUP |
| SPR_ANGLED |


*Defined at line 414 of ./common/com_model.h*

 sprite representation in memory

| enum  |

--

| SKYBOX_RIGHT |
| SKYBOX_BACK |
| SKYBOX_LEFT |
| SKYBOX_FORWARD |
| SKYBOX_UP |
| SKYBOX_DOWN |


*Defined at line 68 of ./common/render_api.h*

 skybox ordering

| enum  |

--

| TF_COLORMAP |
| TF_NEAREST |
| TF_KEEP_SOURCE |
| TF_NOFLIP_TGA |
| TF_EXPAND_SOURCE |
| TF_ALLOW_EMBOSS |
| TF_RECTANGLE |
| TF_CUBEMAP |
| TF_DEPTHMAP |
| TF_QUAKEPAL |
| TF_LUMINANCE |
| TF_SKYSIDE |
| TF_CLAMP |
| TF_NOMIPMAP |
| TF_HAS_LUMA |
| TF_MAKELUMA |
| TF_NORMALMAP |
| TF_HAS_ALPHA |
| TF_FORCE_COLOR |
| TF_UPDATE |
| TF_BORDER |
| TF_TEXTURE_3D |
| TF_ATLAS_PAGE |
| TF_ALPHACONTRAST |
| TF_IMG_UPLOADED |
| TF_ARB_FLOAT |
| TF_NOCOMPARE |
| TF_ARB_16BIT |


*Defined at line 78 of ./common/render_api.h*

| enum  |

--

| CONTEXT_TYPE_GL |
| CONTEXT_TYPE_GLES_1_X |
| CONTEXT_TYPE_GLES_2_X |


*Defined at line 112 of ./common/render_api.h*

| enum  |

--

| GLES_WRAPPER_NONE |
| GLES_WRAPPER_NANOGL |
| GLES_WRAPPER_WES |


*Defined at line 119 of ./common/render_api.h*

| enum  |

--

| PF_UNKNOWN |
| PF_INDEXED_24 |
| PF_INDEXED_32 |
| PF_RGBA_32 |
| PF_BGRA_32 |
| PF_RGB_24 |
| PF_BGR_24 |
| PF_LUMINANCE |
| PF_DXT1 |
| PF_DXT3 |
| PF_DXT5 |
| PF_ATI2 |
| PF_TOTALCOUNT |


*Defined at line 14 of ./common/com_image.h*

| enum  |

--

| IL_USE_LERPING |
| IL_KEEP_8BIT |
| IL_ALLOW_OVERWRITE |
| IL_DONTFLIP_TGA |
| IL_DDS_HARDWARE |
| IL_LOAD_DECAL |
| IL_OVERVIEW |


*Defined at line 40 of ./common/com_image.h*

 imagelib global settings

| enum  |

--

| IMAGE_CUBEMAP |
| IMAGE_HAS_ALPHA |
| IMAGE_HAS_COLOR |
| IMAGE_COLORINDEX |
| IMAGE_HAS_LUMA |
| IMAGE_SKYBOX |
| IMAGE_QUAKESKY |
| IMAGE_DDS_FORMAT |
| IMAGE_MULTILAYER |
| IMAGE_ONEBIT_ALPHA |
| IMAGE_QUAKEPAL |
| IMAGE_FLIP_X |
| IMAGE_FLIP_Y |
| IMAGE_ROT_90 |
| IMAGE_ROT180 |
| IMAGE_ROT270 |
| IMAGE_EMBOSS |
| IMAGE_RESAMPLE |
| IMAGE_FORCE_RGBA |
| IMAGE_MAKE_LUMA |
| IMAGE_QUANTIZE |
| IMAGE_LIGHTGAMMA |
| IMAGE_REMAP |


*Defined at line 64 of ./common/com_image.h*

 rgbdata output flags

| enum VGUI_MouseCode |

--

| MOUSE_LEFT |
| MOUSE_RIGHT |
| MOUSE_MIDDLE |
| MOUSE_LAST |


*Defined at line 30 of ./engine/vgui_int.h*

 C-Style VGUI enums

| enum VGUI_KeyCode |

--

| KEY_0 |
| KEY_1 |
| KEY_2 |
| KEY_3 |
| KEY_4 |
| KEY_5 |
| KEY_6 |
| KEY_7 |
| KEY_8 |
| KEY_9 |
| KEY_A |
| KEY_B |
| KEY_C |
| KEY_D |
| KEY_E |
| KEY_F |
| KEY_G |
| KEY_H |
| KEY_I |
| KEY_J |
| KEY_K |
| KEY_L |
| KEY_M |
| KEY_N |
| KEY_O |
| KEY_P |
| KEY_Q |
| KEY_R |
| KEY_S |
| KEY_T |
| KEY_U |
| KEY_V |
| KEY_W |
| KEY_X |
| KEY_Y |
| KEY_Z |
| KEY_PAD_0 |
| KEY_PAD_1 |
| KEY_PAD_2 |
| KEY_PAD_3 |
| KEY_PAD_4 |
| KEY_PAD_5 |
| KEY_PAD_6 |
| KEY_PAD_7 |
| KEY_PAD_8 |
| KEY_PAD_9 |
| KEY_PAD_DIVIDE |
| KEY_PAD_MULTIPLY |
| KEY_PAD_MINUS |
| KEY_PAD_PLUS |
| KEY_PAD_ENTER |
| KEY_PAD_DECIMAL |
| KEY_LBRACKET |
| KEY_RBRACKET |
| KEY_SEMICOLON |
| KEY_APOSTROPHE |
| KEY_BACKQUOTE |
| KEY_COMMA |
| KEY_PERIOD |
| KEY_SLASH |
| KEY_BACKSLASH |
| KEY_MINUS |
| KEY_EQUAL |
| KEY_ENTER |
| KEY_SPACE |
| KEY_BACKSPACE |
| KEY_TAB |
| KEY_CAPSLOCK |
| KEY_NUMLOCK |
| KEY_ESCAPE |
| KEY_SCROLLLOCK |
| KEY_INSERT |
| KEY_DELETE |
| KEY_HOME |
| KEY_END |
| KEY_PAGEUP |
| KEY_PAGEDOWN |
| KEY_BREAK |
| KEY_LSHIFT |
| KEY_RSHIFT |
| KEY_LALT |
| KEY_RALT |
| KEY_LCONTROL |
| KEY_RCONTROL |
| KEY_LWIN |
| KEY_RWIN |
| KEY_APP |
| KEY_UP |
| KEY_LEFT |
| KEY_DOWN |
| KEY_RIGHT |
| KEY_F1 |
| KEY_F2 |
| KEY_F3 |
| KEY_F4 |
| KEY_F5 |
| KEY_F6 |
| KEY_F7 |
| KEY_F8 |
| KEY_F9 |
| KEY_F10 |
| KEY_F11 |
| KEY_F12 |
| KEY_LAST |


*Defined at line 38 of ./engine/vgui_int.h*

| enum VGUI_KeyAction |

--

| KA_TYPED |
| KA_PRESSED |
| KA_RELEASED |


*Defined at line 146 of ./engine/vgui_int.h*

| enum VGUI_MouseAction |

--

| MA_PRESSED |
| MA_RELEASED |
| MA_DOUBLE |
| MA_WHEEL |


*Defined at line 152 of ./engine/vgui_int.h*

| enum VGUI_DefaultCursor |

--

| dc_user |
| dc_none |
| dc_arrow |
| dc_ibeam |
| dc_hourglass |
| dc_crosshair |
| dc_up |
| dc_sizenwse |
| dc_sizenesw |
| dc_sizewe |
| dc_sizens |
| dc_sizeall |
| dc_no |
| dc_hand |
| dc_last |


*Defined at line 160 of ./engine/vgui_int.h*

| enum  |

--

| TRI_FRONT |
| TRI_NONE |


*Defined at line 19 of ./common/triangleapi.h*

| enum  |

--

| USE_OFF |
| USE_ON |
| USE_SET |
| USE_TOGGLE |


*Defined at line 8 of ./game/shared/base_defs.h*

| enum class EDamageType |

--

| GENERIC |
| CRUSH |
| BULLET |
| SLASH |
| BURN |
| FREEZE |
| FALL |
| BLAST |
| CLUB |
| SHOCK |
| SONIC |
| ENERGYBEAM |
| NEVERGIB |
| ALWAYSGIB |
| DROWN |
| TIMEBASED |
| PARALYZE |
| NERVEGAS |
| POISON |
| RADIATION |
| DROWNRECOVER |
| ACID |
| SLOWBURN |
| SLOWFREEZE |
| MORTAR |
| GIB_CORPSE |
| SHOWNHUD |


*Defined at line 165 of ./game/shared/base_defs.h*

================================================================================================================================================// New damage type enums

| enum decal_e |

--

| DECAL_GUNSHOT1 |
| DECAL_GUNSHOT2 |
| DECAL_GUNSHOT3 |
| DECAL_GUNSHOT4 |
| DECAL_GUNSHOT5 |
| DECAL_LAMBDA1 |
| DECAL_LAMBDA2 |
| DECAL_LAMBDA3 |
| DECAL_LAMBDA4 |
| DECAL_LAMBDA5 |
| DECAL_LAMBDA6 |
| DECAL_SCORCH1 |
| DECAL_SCORCH2 |
| DECAL_BLOOD1 |
| DECAL_BLOOD2 |
| DECAL_BLOOD3 |
| DECAL_BLOOD4 |
| DECAL_BLOOD5 |
| DECAL_BLOOD6 |
| DECAL_YBLOOD1 |
| DECAL_YBLOOD2 |
| DECAL_YBLOOD3 |
| DECAL_YBLOOD4 |
| DECAL_YBLOOD5 |
| DECAL_YBLOOD6 |
| DECAL_GLASSBREAK1 |
| DECAL_GLASSBREAK2 |
| DECAL_GLASSBREAK3 |
| DECAL_BIGSHOT1 |
| DECAL_BIGSHOT2 |
| DECAL_BIGSHOT3 |
| DECAL_BIGSHOT4 |
| DECAL_BIGSHOT5 |
| DECAL_SPIT1 |
| DECAL_SPIT2 |
| DECAL_BPROOF1 |
| DECAL_GARGSTOMP1 |
| DECAL_SMALLSCORCH1 |
| DECAL_SMALLSCORCH2 |
| DECAL_SMALLSCORCH3 |
| DECAL_MOMMABIRTH |
| DECAL_MOMMASPLAT |


*Defined at line 200 of ./game/shared/base_defs.h*

================================================================================================================================================//

 Dynamic Decals

| enum  |

--

| pt_static |
| pt_grav |
| pt_slowgrav |
| pt_fire |
| pt_explode |
| pt_explode2 |
| pt_blob |
| pt_blob2 |
| pt_vox_slowgrav |
| pt_vox_grav |
| pt_clientcustom |


*Defined at line 19 of ./common/particledef.h*

| enum  |

--

| NA_UNUSED |
| NA_LOOPBACK |
| NA_BROADCAST |
| NA_IP |
| NA_IPX |
| NA_BROADCAST_IPX |


*Defined at line 19 of ./common/netadr.h*

| enum class ENetSourceType |

--

| NETSRC_CLIENT |
| NETSRC_SERVER |


*Defined at line 32 of ./engine/net_int.h*

| enum  |

--

| DEMO_INACTIVE |
| DEMO_XASH3D |
| DEMO_QUAKE1 |


*Defined at line 67 of ./engine/ref_int.h*

| enum  |

--

| GL_KEEP_UNIT |
| XASH_TEXTURE0 |
| XASH_TEXTURE1 |
| XASH_TEXTURE2 |
| XASH_TEXTURE3 |
| XASH_TEXTURE4 |
| MAX_TEXTURE_UNITS |


*Defined at line 111 of ./engine/ref_int.h*

| enum  |

--

| RS_ACTIVE_TENTS |


*Defined at line 122 of ./engine/ref_int.h*

| enum connstate_e |

--

| ca_disconnected |
| ca_connecting |
| ca_connected |
| ca_validate |
| ca_active |
| ca_cinematic |


*Defined at line 136 of ./engine/ref_int.h*

| enum ref_defaultsprite_e |

--

| REF_DOT_SPRITE |
| REF_CHROME_SPRITE |


*Defined at line 146 of ./engine/ref_int.h*

| enum ref_graphic_apis_e |

--

| REF_SOFTWARE |
| REF_GL |
| REF_D3D |


*Defined at line 154 of ./engine/ref_int.h*

 the order of first three is important! so you can use this value in IEngineStudio.StudioIsHardware

| enum  |

--

| SAFE_NO |
| SAFE_NOMSAA |
| SAFE_NOACC |
| SAFE_NOSTENCIL |
| SAFE_NOALPHA |
| SAFE_NODEPTH |
| SAFE_NOCOLOR |
| SAFE_DONTCARE |
| SAFE_LAST |


*Defined at line 161 of ./engine/ref_int.h*

| enum  |

--

| REF_GL_RED_SIZE |
| REF_GL_GREEN_SIZE |
| REF_GL_BLUE_SIZE |
| REF_GL_ALPHA_SIZE |
| REF_GL_DOUBLEBUFFER |
| REF_GL_DEPTH_SIZE |
| REF_GL_STENCIL_SIZE |
| REF_GL_MULTISAMPLEBUFFERS |
| REF_GL_MULTISAMPLESAMPLES |
| REF_GL_ACCELERATED_VISUAL |
| REF_GL_CONTEXT_MAJOR_VERSION |
| REF_GL_CONTEXT_MINOR_VERSION |
| REF_GL_CONTEXT_EGL |
| REF_GL_CONTEXT_FLAGS |
| REF_GL_CONTEXT_PROFILE_MASK |
| REF_GL_SHARE_WITH_CURRENT_CONTEXT |
| REF_GL_FRAMEBUFFER_SRGB_CAPABLE |
| REF_GL_CONTEXT_RELEASE_BEHAVIOR |
| REF_GL_CONTEXT_RESET_NOTIFICATION |
| REF_GL_CONTEXT_NO_ERROR |
| REF_GL_ATTRIBUTES_COUNT |


*Defined at line 174 of ./engine/ref_int.h*

| enum  |

--

| REF_GL_CONTEXT_PROFILE_CORE |
| REF_GL_CONTEXT_PROFILE_COMPATIBILITY |
| REF_GL_CONTEXT_PROFILE_ES |


*Defined at line 199 of ./engine/ref_int.h*

| enum  |

--

| REF_GL_CONTEXT_DEBUG_FLAG |
| REF_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG |
| REF_GL_CONTEXT_ROBUST_ACCESS_FLAG |
| REF_GL_CONTEXT_RESET_ISOLATION_FLAG |


*Defined at line 207 of ./engine/ref_int.h*

 binary compatible with SDL and EGL_KHR_create_context(0x0007 mask)

| enum  |

--

| PARM_DEV_OVERVIEW |
| PARM_THIRDPERSON |
| PARM_QUAKE_COMPATIBLE |
| PARM_PLAYER_INDEX |
| PARM_VIEWENT_INDEX |
| PARM_CONNSTATE |
| PARM_PLAYING_DEMO |
| PARM_WATER_LEVEL |
| PARM_MAX_CLIENTS |
| PARM_LOCAL_HEALTH |
| PARM_LOCAL_GAME |
| PARM_NUMENTITIES |
| PARM_NUMMODELS |


*Defined at line 229 of ./engine/ref_int.h*

| enum mpg123_enc_enum |

--

| MPG123_ENC_8 |
| MPG123_ENC_16 |
| MPG123_ENC_SIGNED |
| MPG123_ENC_SIGNED_16 |
| MPG123_ENC_UNSIGNED_16 |
| MPG123_ENC_UNSIGNED_8 |
| MPG123_ENC_SIGNED_8 |
| MPG123_ENC_ULAW_8 |
| MPG123_ENC_ALAW_8 |


*Defined at line 22 of ./engine/common/soundlib/libmpg/fmt123.h*

| enum synth_channel |

--

| c_plain |
| c_stereo |
| c_m2s |
| c_mono |
| c_limit |


*Defined at line 23 of ./engine/common/soundlib/libmpg/synth.h*

| enum synth_resample |

--

| r_none |
| r_1to1 |
| r_limit |


*Defined at line 32 of ./engine/common/soundlib/libmpg/synth.h*

| enum synth_format |

--

| f_none |
| f_16 |
| f_limit |


*Defined at line 39 of ./engine/common/soundlib/libmpg/synth.h*

| enum mpg123_errors |

--

| MPG123_DONE |
| MPG123_NEW_FORMAT |
| MPG123_NEED_MORE |
| MPG123_ERR |
| MPG123_OK |
| MPG123_BAD_OUTFORMAT |
| MPG123_BAD_CHANNEL |
| MPG123_BAD_RATE |
| MPG123_ERR_16TO8TABLE |
| MPG123_BAD_PARAM |
| MPG123_BAD_BUFFER |
| MPG123_OUT_OF_MEM |
| MPG123_NOT_INITIALIZED |
| MPG123_BAD_DECODER |
| MPG123_BAD_HANDLE |
| MPG123_NO_BUFFERS |
| MPG123_BAD_RVA |
| MPG123_NO_GAPLESS |
| MPG123_NO_SPACE |
| MPG123_BAD_TYPES |
| MPG123_BAD_BAND |
| MPG123_ERR_NULL |
| MPG123_ERR_READER |
| MPG123_NO_SEEK_FROM_END |
| MPG123_BAD_WHENCE |
| MPG123_NO_TIMEOUT |
| MPG123_BAD_FILE |
| MPG123_NO_SEEK |
| MPG123_NO_READER |
| MPG123_BAD_PARS |
| MPG123_BAD_INDEX_PAR |
| MPG123_OUT_OF_SYNC |
| MPG123_RESYNC_FAIL |
| MPG123_NO_8BIT |
| MPG123_BAD_ALIGN |
| MPG123_NULL_BUFFER |
| MPG123_NO_RELSEEK |
| MPG123_NULL_POINTER |
| MPG123_BAD_KEY |
| MPG123_NO_INDEX |
| MPG123_INDEX_FAIL |
| MPG123_BAD_DECODER_SETUP |
| MPG123_MISSING_FEATURE |
| MPG123_BAD_VALUE |
| MPG123_LSEEK_FAILED |
| MPG123_BAD_CUSTOM_IO |
| MPG123_LFS_OVERFLOW |
| MPG123_INT_OVERFLOW |


*Defined at line 111 of ./engine/common/soundlib/libmpg/mpg123.h*

 enumeration of the message and error codes and returned by libmpg123 functions.

| enum mpg123_parms |

--

| MPG123_VERBOSE |
| MPG123_FLAGS |
| MPG123_ADD_FLAGS |
| MPG123_FORCE_RATE |
| MPG123_DOWN_SAMPLE |
| MPG123_RVA |
| MPG123_DOWNSPEED |
| MPG123_UPSPEED |
| MPG123_START_FRAME |
| MPG123_DECODE_FRAMES |
| MPG123_OUTSCALE |
| MPG123_TIMEOUT |
| MPG123_REMOVE_FLAGS |
| MPG123_RESYNC_LIMIT |
| MPG123_INDEX_SIZE |
| MPG123_PREFRAMES |
| MPG123_FEEDPOOL |
| MPG123_FEEDBUFFER |


*Defined at line 164 of ./engine/common/soundlib/libmpg/mpg123.h*

 enumeration of the parameters types that it is possible to set/get.

| enum mpg123_param_flags |

--

| MPG123_FORCE_MONO |
| MPG123_MONO_LEFT |
| MPG123_MONO_RIGHT |
| MPG123_MONO_MIX |
| MPG123_FORCE_STEREO |
| MPG123_QUIET |
| MPG123_GAPLESS |
| MPG123_NO_RESYNC |
| MPG123_SEEKBUFFER |
| MPG123_FUZZY |
| MPG123_IGNORE_STREAMLENGTH |
| MPG123_IGNORE_INFOFRAME |
| MPG123_AUTO_RESAMPLE |


*Defined at line 187 of ./engine/common/soundlib/libmpg/mpg123.h*

 flag bits for MPG123_FLAGS, use the usual binary or to combine.

| enum mpg123_param_rva |

--

| MPG123_RVA_OFF |
| MPG123_RVA_MIX |
| MPG123_RVA_ALBUM |
| MPG123_RVA_MAX |


*Defined at line 205 of ./engine/common/soundlib/libmpg/mpg123.h*

 choices for MPG123_RVA

| enum frame_state_flags |

--

| FRAME_ACCURATE |
| FRAME_FRANKENSTEIN |
| FRAME_FRESH_DECODER |


*Defined at line 213 of ./engine/common/soundlib/libmpg/mpg123.h*

| enum mpg123_vbr |

--

| MPG123_CBR |
| MPG123_VBR |
| MPG123_ABR |


*Defined at line 221 of ./engine/common/soundlib/libmpg/mpg123.h*

 enumeration of the mode types of Variable Bitrate

| enum  |

--

| MAX_PLAYERS |
| MAX_TEAMS |
| MAX_TEAM_NAME |


*Defined at line 45 of ./game/client/hud.h*

| enum  |

--

| GL_OPENGL_110 |
| GL_ARB_MULTITEXTURE |
| GL_TEXTURE_CUBEMAP_EXT |
| GL_ANISOTROPY_EXT |
| GL_TEXTURE_LOD_BIAS |
| GL_TEXTURE_COMPRESSION_EXT |
| GL_SHADER_GLSL100_EXT |
| GL_TEXTURE_2D_RECT_EXT |
| GL_TEXTURE_ARRAY_EXT |
| GL_TEXTURE_3D_EXT |
| GL_CLAMPTOEDGE_EXT |
| GL_ARB_TEXTURE_NPOT_EXT |
| GL_CLAMP_TEXBORDER_EXT |
| GL_ARB_TEXTURE_FLOAT_EXT |
| GL_ARB_DEPTH_FLOAT_EXT |
| GL_ARB_SEAMLESS_CUBEMAP |
| GL_EXT_GPU_SHADER4 |
| GL_DEPTH_TEXTURE |
| GL_DEBUG_OUTPUT |
| GL_ARB_VERTEX_BUFFER_OBJECT_EXT |
| GL_EXTCOUNT |


*Defined at line 601 of ./rendersystem/gl_local.h*

=======================================================================

 GL STATE MACHINE

=======================================================================

| enum  |

--

| GLHW_GENERIC |
| GLHW_RADEON |
| GLHW_NVIDIA |
| GLHW_INTEL |


*Defined at line 626 of ./rendersystem/gl_local.h*

| enum  |

--

| TIME_FULL |
| TIME_DATE_ONLY |
| TIME_TIME_ONLY |
| TIME_NO_SECONDS |
| TIME_YEAR_ONLY |
| TIME_FILENAME |


*Defined at line 36 of ./public/crtlib.h*

 timestamp modes

| enum  |

--

| ACT_RESET |
| ACT_IDLE |
| ACT_GUARD |
| ACT_WALK |
| ACT_RUN |
| ACT_FLY |
| ACT_SWIM |
| ACT_HOP |
| ACT_LEAP |
| ACT_FALL |
| ACT_LAND |
| ACT_STRAFE_LEFT |
| ACT_STRAFE_RIGHT |
| ACT_ROLL_LEFT |
| ACT_ROLL_RIGHT |
| ACT_TURN_LEFT |
| ACT_TURN_RIGHT |
| ACT_CROUCH |
| ACT_CROUCHIDLE |
| ACT_STAND |
| ACT_USE |
| ACT_SIGNAL1 |
| ACT_SIGNAL2 |
| ACT_SIGNAL3 |
| ACT_TWITCH |
| ACT_COWER |
| ACT_SMALL_FLINCH |
| ACT_BIG_FLINCH |
| ACT_RANGE_ATTACK1 |
| ACT_RANGE_ATTACK2 |
| ACT_MELEE_ATTACK1 |
| ACT_MELEE_ATTACK2 |
| ACT_RELOAD |
| ACT_ARM |
| ACT_DISARM |
| ACT_EAT |
| ACT_DIESIMPLE |
| ACT_DIEBACKWARD |
| ACT_DIEFORWARD |
| ACT_DIEVIOLENT |
| ACT_BARNACLE_HIT |
| ACT_BARNACLE_PULL |
| ACT_BARNACLE_CHOMP |
| ACT_BARNACLE_CHEW |
| ACT_SLEEP |
| ACT_INSPECT_FLOOR |
| ACT_INSPECT_WALL |
| ACT_IDLE_ANGRY |
| ACT_WALK_HURT |
| ACT_RUN_HURT |
| ACT_HOVER |
| ACT_GLIDE |
| ACT_FLY_LEFT |
| ACT_FLY_RIGHT |
| ACT_DETECT_SCENT |
| ACT_SNIFF |
| ACT_BITE |
| ACT_THREAT_DISPLAY |
| ACT_FEAR_DISPLAY |
| ACT_EXCITED |
| ACT_SPECIAL_ATTACK1 |
| ACT_SPECIAL_ATTACK2 |
| ACT_COMBAT_IDLE |
| ACT_WALK_SCARED |
| ACT_RUN_SCARED |
| ACT_VICTORY_DANCE |
| ACT_DIE_HEADSHOT |
| ACT_DIE_CHESTSHOT |
| ACT_DIE_GUTSHOT |
| ACT_DIE_BACKSHOT |
| ACT_FLINCH_HEAD |
| ACT_FLINCH_CHEST |
| ACT_FLINCH_STOMACH |
| ACT_FLINCH_LEFTARM |
| ACT_FLINCH_RIGHTARM |
| ACT_FLINCH_LEFTLEG |
| ACT_FLINCH_RIGHTLEG |


*Defined at line 19 of ./game/shared/../server/activity.h*

| enum  |

--

| MONSTERSTATE_NONE |
| MONSTERSTATE_IDLE |
| MONSTERSTATE_COMBAT |
| MONSTERSTATE_ALERT |
| MONSTERSTATE_HUNT |
| MONSTERSTATE_PRONE |
| MONSTERSTATE_SCRIPT |
| MONSTERSTATE_PLAYDEAD |
| MONSTERSTATE_DEAD |


*Defined at line 192 of ./game/shared/util.h*

| enum  |

--

| TS_AT_TOP |
| TS_AT_BOTTOM |
| TS_GOING_UP |
| TS_GOING_DOWN |


*Defined at line 208 of ./game/shared/util.h*

 Things that toggle (buttons/triggers/doors) need this

| enum  |

--

| ignore_monsters |
| dont_ignore_monsters |
| missile |


*Defined at line 275 of ./game/shared/util.h*

| enum  |

--

| ignore_glass |
| dont_ignore_glass |


*Defined at line 282 of ./game/shared/util.h*

| enum  |

--

| point_hull |
| human_hull |
| large_hull |
| head_hull |


*Defined at line 291 of ./game/shared/util.h*

| enum  |

--

| GLOBAL_OFF |
| GLOBAL_ON |
| GLOBAL_DEAD |


*Defined at line 132 of ./game/server/saverestore.h*

| enum  |

--

| SCHED_NONE |
| SCHED_IDLE_STAND |
| SCHED_IDLE_WALK |
| SCHED_WAKE_ANGRY |
| SCHED_WAKE_CALLED |
| SCHED_ALERT_FACE |
| SCHED_ALERT_SMALL_FLINCH |
| SCHED_ALERT_BIG_FLINCH |
| SCHED_ALERT_STAND |
| SCHED_INVESTIGATE_SOUND |
| SCHED_COMBAT_FACE |
| SCHED_COMBAT_STAND |
| SCHED_CHASE_ENEMY |
| SCHED_CHASE_ENEMY_FAILED |
| SCHED_VICTORY_DANCE |
| SCHED_TARGET_FACE |
| SCHED_TARGET_CHASE |
| SCHED_SMALL_FLINCH |
| SCHED_TAKE_COVER_FROM_ENEMY |
| SCHED_TAKE_COVER_FROM_BEST_SOUND |
| SCHED_TAKE_COVER_FROM_ORIGIN |
| SCHED_COWER |
| SCHED_MELEE_ATTACK1 |
| SCHED_MELEE_ATTACK2 |
| SCHED_RANGE_ATTACK1 |
| SCHED_RANGE_ATTACK2 |
| SCHED_SPECIAL_ATTACK1 |
| SCHED_SPECIAL_ATTACK2 |
| SCHED_STANDOFF |
| SCHED_ARM_WEAPON |
| SCHED_RELOAD |
| SCHED_GUARD |
| SCHED_AMBUSH |
| SCHED_DIE |
| SCHED_WAIT_TRIGGER |
| SCHED_FOLLOW |
| SCHED_SLEEP |
| SCHED_WAKE |
| SCHED_BARNACLE_VICTIM_GRAB |
| SCHED_BARNACLE_VICTIM_CHOMP |
| SCHED_AISCRIPT |
| SCHED_FAIL |
| LAST_COMMON_SCHEDULE |


*Defined at line 12 of ./game/shared/ai_shared.h*

========================================================= These are the schedule types=========================================================

| enum  |

--

| TASK_INVALID |
| TASK_WAIT |
| TASK_WAIT_FACE_ENEMY |
| TASK_WAIT_PVS |
| TASK_SUGGEST_STATE |
| TASK_WALK_TO_TARGET |
| TASK_RUN_TO_TARGET |
| TASK_MOVE_TO_TARGET_RANGE |
| TASK_GET_PATH_TO_ENEMY |
| TASK_GET_PATH_TO_ENEMY_LKP |
| TASK_GET_PATH_TO_ENEMY_CORPSE |
| TASK_GET_PATH_TO_LEADER |
| TASK_GET_PATH_TO_SPOT |
| TASK_GET_PATH_TO_TARGET |
| TASK_GET_PATH_TO_HINTNODE |
| TASK_GET_PATH_TO_LASTPOSITION |
| TASK_GET_PATH_TO_BESTSOUND |
| TASK_GET_PATH_TO_BESTSCENT |
| TASK_RUN_PATH |
| TASK_WALK_PATH |
| TASK_STRAFE_PATH |
| TASK_CLEAR_MOVE_WAIT |
| TASK_STORE_LASTPOSITION |
| TASK_CLEAR_LASTPOSITION |
| TASK_PLAY_ACTIVE_IDLE |
| TASK_FIND_HINTNODE |
| TASK_CLEAR_HINTNODE |
| TASK_SMALL_FLINCH |
| TASK_FACE_IDEAL |
| TASK_FACE_ROUTE |
| TASK_FACE_ENEMY |
| TASK_FACE_HINTNODE |
| TASK_FACE_TARGET |
| TASK_FACE_LASTPOSITION |
| TASK_RANGE_ATTACK1 |
| TASK_RANGE_ATTACK2 |
| TASK_MELEE_ATTACK1 |
| TASK_MELEE_ATTACK2 |
| TASK_RELOAD |
| TASK_RANGE_ATTACK1_NOTURN |
| TASK_RANGE_ATTACK2_NOTURN |
| TASK_MELEE_ATTACK1_NOTURN |
| TASK_MELEE_ATTACK2_NOTURN |
| TASK_RELOAD_NOTURN |
| TASK_SPECIAL_ATTACK1 |
| TASK_SPECIAL_ATTACK2 |
| TASK_CROUCH |
| TASK_STAND |
| TASK_GUARD |
| TASK_STEP_LEFT |
| TASK_STEP_RIGHT |
| TASK_STEP_FORWARD |
| TASK_STEP_BACK |
| TASK_DODGE_LEFT |
| TASK_DODGE_RIGHT |
| TASK_SOUND_ANGRY |
| TASK_SOUND_DEATH |
| TASK_SET_ACTIVITY |
| TASK_SET_SCHEDULE |
| TASK_SET_FAIL_SCHEDULE |
| TASK_CLEAR_FAIL_SCHEDULE |
| TASK_PLAY_SEQUENCE |
| TASK_PLAY_SEQUENCE_FACE_ENEMY |
| TASK_PLAY_SEQUENCE_FACE_TARGET |
| TASK_SOUND_IDLE |
| TASK_SOUND_WAKE |
| TASK_SOUND_PAIN |
| TASK_SOUND_DIE |
| TASK_FIND_COVER_FROM_BEST_SOUND |
| TASK_FIND_COVER_FROM_ENEMY |
| TASK_FIND_LATERAL_COVER_FROM_ENEMY |
| TASK_FIND_NODE_COVER_FROM_ENEMY |
| TASK_FIND_NEAR_NODE_COVER_FROM_ENEMY |
| TASK_FIND_FAR_NODE_COVER_FROM_ENEMY |
| TASK_FIND_COVER_FROM_ORIGIN |
| TASK_EAT |
| TASK_DIE |
| TASK_WAIT_FOR_SCRIPT |
| TASK_PLAY_SCRIPT |
| TASK_ENABLE_SCRIPT |
| TASK_PLANT_ON_SCRIPT |
| TASK_FACE_SCRIPT |
| TASK_WAIT_RANDOM |
| TASK_WAIT_INDEFINITE |
| TASK_STOP_MOVING |
| TASK_TURN_LEFT |
| TASK_TURN_RIGHT |
| TASK_REMEMBER |
| TASK_FORGET |
| TASK_WAIT_FOR_MOVEMENT |
| LAST_COMMON_TASK |


*Defined at line 63 of ./game/shared/ai_shared.h*

========================================================= These are the shared tasks=========================================================

| enum  |

--

| TARGET_MOVE_NORMAL |
| TARGET_MOVE_SCRIPTED |


*Defined at line 160 of ./game/shared/ai_shared.h*

 These go in the flData member of the TASK_WALK_TO_TARGET, TASK_RUN_TO_TARGET

| enum  |

--

| GOAL_ATTACK_ENEMY |
| GOAL_MOVE |
| GOAL_TAKE_COVER |
| GOAL_MOVE_TARGET |
| GOAL_EAT |


*Defined at line 171 of ./game/shared/ai_shared.h*

 A goal should be used for a task that requires several schedules to complete. The goal index should indicate which schedule (ordinally) the monster is running. That way, when tasks fail, the AI can make decisions based on the context of the current goal and sequence rather than just the current schedule.

| enum  |

--

| PLAYER_IDLE |
| PLAYER_WALK |
| PLAYER_JUMP |
| PLAYER_SUPERJUMP |
| PLAYER_DIE |
| PLAYER_ATTACK1 |


*Defined at line 52 of ./game/shared/c_base_player.h*

| enum sbar_data |

--

| SBAR_ID_TARGETNAME |
| SBAR_ID_TARGETHEALTH |
| SBAR_ID_TARGETARMOR |
| SBAR_END |


*Defined at line 65 of ./game/shared/c_base_player.h*

| enum  |

--

| BULLET_NONE |
| BULLET_PLAYER_9MM |
| BULLET_PLAYER_MP5 |
| BULLET_PLAYER_357 |
| BULLET_PLAYER_BUCKSHOT |
| BULLET_PLAYER_CROWBAR |
| BULLET_MONSTER_9MM |
| BULLET_MONSTER_MP5 |
| BULLET_MONSTER_12MM |


*Defined at line 114 of ./game/shared/weapon_shared.h*

 bullet types

| enum  |

--

| AITRIGGER_NONE |
| AITRIGGER_SEEPLAYER_ANGRY_AT_PLAYER |
| AITRIGGER_TAKEDAMAGE |
| AITRIGGER_HALFHEALTH |
| AITRIGGER_DEATH |
| AITRIGGER_SQUADMEMBERDIE |
| AITRIGGER_SQUADLEADERDIE |
| AITRIGGER_HEARWORLD |
| AITRIGGER_HEARPLAYER |
| AITRIGGER_HEARCOMBAT |
| AITRIGGER_SEEPLAYER_UNCONDITIONAL |
| AITRIGGER_SEEPLAYER_NOT_IN_COMBAT |


*Defined at line 109 of ./game/server/ai/ai_monsters.h*

 trigger conditions for scripted AI these MUST match the CHOICES interface in halflife.fgd for the base monster

| enum  |

--

| HINT_NONE |
| HINT_WORLD_DOOR |
| HINT_WORLD_WINDOW |
| HINT_WORLD_BUTTON |
| HINT_WORLD_MACHINERY |
| HINT_WORLD_LEDGE |
| HINT_WORLD_LIGHT_SOURCE |
| HINT_WORLD_HEAT_SOURCE |
| HINT_WORLD_BLINKING_LIGHT |
| HINT_WORLD_BRIGHT_COLORS |
| HINT_WORLD_HUMAN_BLOOD |
| HINT_WORLD_ALIEN_BLOOD |
| HINT_TACTICAL_EXIT |
| HINT_TACTICAL_VANTAGE |
| HINT_TACTICAL_AMBUSH |
| HINT_STUKA_PERCH |
| HINT_STUKA_LANDING |


*Defined at line 358 of ./game/server/info_node.h*

========================================================= hints - these MUST coincide with the HINTS listed under info_node in the FGD file!=========================================================

| enum  |

--

| TASK_HOUND_CLOSE_EYE |
| TASK_HOUND_OPEN_EYE |
| TASK_HOUND_THREAT_DISPLAY |
| TASK_HOUND_FALL_ASLEEP |
| TASK_HOUND_WAKE_UP |
| TASK_HOUND_HOP_BACK |


*Defined at line 45 of ./game/server/npc/npc_houndeye.cpp*

========================================================= monster-specific tasks=========================================================

| enum  |

--

| SCHED_HOUND_AGITATED |
| SCHED_HOUND_HOP_RETREAT |
| SCHED_HOUND_FAIL |


*Defined at line 58 of ./game/server/npc/npc_houndeye.cpp*

========================================================= monster-specific schedule types=========================================================

| enum class EGrenateTrigger |

--

| TIMED |
| CONTACT |
| REMOTE |


*Defined at line 38 of ./game/shared/base_grenade.h*

| enum  |

--

| SDL_FALSE |
| SDL_TRUE |


*Defined at line 161 of /usr/include/SDL2/SDL_stdinc.h*

| enum  |

--

| DUMMY_ENUM_VALUE |


*Defined at line 337 of /usr/include/SDL2/SDL_stdinc.h*

 TODO: include/SDL_stdinc.h:174: error: size of array 'SDL_dummy_enum' is negative 

| enum  |

--

| SDL_ASSERTION_RETRY |
| SDL_ASSERTION_BREAK |
| SDL_ASSERTION_ABORT |
| SDL_ASSERTION_IGNORE |
| SDL_ASSERTION_ALWAYS_IGNORE |


*Defined at line 102 of /usr/include/SDL2/SDL_assert.h*

| enum  |

--

| SDL_ENOMEM |
| SDL_EFREAD |
| SDL_EFWRITE |
| SDL_EFSEEK |
| SDL_UNSUPPORTED |
| SDL_LASTERROR |


*Defined at line 55 of /usr/include/SDL2/SDL_error.h*

| enum  |

--

| SDL_THREAD_PRIORITY_LOW |
| SDL_THREAD_PRIORITY_NORMAL |
| SDL_THREAD_PRIORITY_HIGH |
| SDL_THREAD_PRIORITY_TIME_CRITICAL |


*Defined at line 59 of /usr/include/SDL2/SDL_thread.h*

  The SDL thread priority.



**note** On many systems you require special privileges to set high or time critical priority.

| enum  |

--

| SDL_AUDIO_STOPPED |
| SDL_AUDIO_PLAYING |
| SDL_AUDIO_PAUSED |


*Defined at line 395 of /usr/include/SDL2/SDL_audio.h*



 Audio state

  Get the current audio state.

@{ 

| enum  |

--

| SDL_PIXELTYPE_UNKNOWN |
| SDL_PIXELTYPE_INDEX1 |
| SDL_PIXELTYPE_INDEX4 |
| SDL_PIXELTYPE_INDEX8 |
| SDL_PIXELTYPE_PACKED8 |
| SDL_PIXELTYPE_PACKED16 |
| SDL_PIXELTYPE_PACKED32 |
| SDL_PIXELTYPE_ARRAYU8 |
| SDL_PIXELTYPE_ARRAYU16 |
| SDL_PIXELTYPE_ARRAYU32 |
| SDL_PIXELTYPE_ARRAYF16 |
| SDL_PIXELTYPE_ARRAYF32 |


*Defined at line 51 of /usr/include/SDL2/SDL_pixels.h*

 Pixel type. 

| enum  |

--

| SDL_BITMAPORDER_NONE |
| SDL_BITMAPORDER_4321 |
| SDL_BITMAPORDER_1234 |


*Defined at line 68 of /usr/include/SDL2/SDL_pixels.h*

 Bitmap pixel order, high bit -> low bit. 

| enum  |

--

| SDL_PACKEDORDER_NONE |
| SDL_PACKEDORDER_XRGB |
| SDL_PACKEDORDER_RGBX |
| SDL_PACKEDORDER_ARGB |
| SDL_PACKEDORDER_RGBA |
| SDL_PACKEDORDER_XBGR |
| SDL_PACKEDORDER_BGRX |
| SDL_PACKEDORDER_ABGR |
| SDL_PACKEDORDER_BGRA |


*Defined at line 76 of /usr/include/SDL2/SDL_pixels.h*

 Packed component order, high bit -> low bit. 

| enum  |

--

| SDL_ARRAYORDER_NONE |
| SDL_ARRAYORDER_RGB |
| SDL_ARRAYORDER_RGBA |
| SDL_ARRAYORDER_ARGB |
| SDL_ARRAYORDER_BGR |
| SDL_ARRAYORDER_BGRA |
| SDL_ARRAYORDER_ABGR |


*Defined at line 92 of /usr/include/SDL2/SDL_pixels.h*

 Array component order, low byte -> high byte. 

 !!! FIXME: in 2.1, make these not overlap differently with   !!! FIXME:  SDL_PACKEDORDER_*, so we can simplify SDL_ISPIXELFORMAT_ALPHA 

| enum  |

--

| SDL_PACKEDLAYOUT_NONE |
| SDL_PACKEDLAYOUT_332 |
| SDL_PACKEDLAYOUT_4444 |
| SDL_PACKEDLAYOUT_1555 |
| SDL_PACKEDLAYOUT_5551 |
| SDL_PACKEDLAYOUT_565 |
| SDL_PACKEDLAYOUT_8888 |
| SDL_PACKEDLAYOUT_2101010 |
| SDL_PACKEDLAYOUT_1010102 |


*Defined at line 104 of /usr/include/SDL2/SDL_pixels.h*

 Packed component layout. 

| enum  |

--

| SDL_PIXELFORMAT_UNKNOWN |
| SDL_PIXELFORMAT_INDEX1LSB |
| SDL_PIXELFORMAT_INDEX1MSB |
| SDL_PIXELFORMAT_INDEX4LSB |
| SDL_PIXELFORMAT_INDEX4MSB |
| SDL_PIXELFORMAT_INDEX8 |
| SDL_PIXELFORMAT_RGB332 |
| SDL_PIXELFORMAT_RGB444 |
| SDL_PIXELFORMAT_BGR444 |
| SDL_PIXELFORMAT_RGB555 |
| SDL_PIXELFORMAT_BGR555 |
| SDL_PIXELFORMAT_ARGB4444 |
| SDL_PIXELFORMAT_RGBA4444 |
| SDL_PIXELFORMAT_ABGR4444 |
| SDL_PIXELFORMAT_BGRA4444 |
| SDL_PIXELFORMAT_ARGB1555 |
| SDL_PIXELFORMAT_RGBA5551 |
| SDL_PIXELFORMAT_ABGR1555 |
| SDL_PIXELFORMAT_BGRA5551 |
| SDL_PIXELFORMAT_RGB565 |
| SDL_PIXELFORMAT_BGR565 |
| SDL_PIXELFORMAT_RGB24 |
| SDL_PIXELFORMAT_BGR24 |
| SDL_PIXELFORMAT_RGB888 |
| SDL_PIXELFORMAT_RGBX8888 |
| SDL_PIXELFORMAT_BGR888 |
| SDL_PIXELFORMAT_BGRX8888 |
| SDL_PIXELFORMAT_ARGB8888 |
| SDL_PIXELFORMAT_RGBA8888 |
| SDL_PIXELFORMAT_ABGR8888 |
| SDL_PIXELFORMAT_BGRA8888 |
| SDL_PIXELFORMAT_ARGB2101010 |
| SDL_PIXELFORMAT_RGBA32 |
| SDL_PIXELFORMAT_ARGB32 |
| SDL_PIXELFORMAT_BGRA32 |
| SDL_PIXELFORMAT_ABGR32 |
| SDL_PIXELFORMAT_YV12 |
| SDL_PIXELFORMAT_IYUV |
| SDL_PIXELFORMAT_YUY2 |
| SDL_PIXELFORMAT_UYVY |
| SDL_PIXELFORMAT_YVYU |
| SDL_PIXELFORMAT_NV12 |
| SDL_PIXELFORMAT_NV21 |
| SDL_PIXELFORMAT_EXTERNAL_OES |


*Defined at line 171 of /usr/include/SDL2/SDL_pixels.h*

 Note: If you modify this list, update SDL_GetPixelFormatName() 

| enum  |

--

| SDL_BLENDMODE_NONE |
| SDL_BLENDMODE_BLEND |
| SDL_BLENDMODE_ADD |
| SDL_BLENDMODE_MOD |
| SDL_BLENDMODE_MUL |
| SDL_BLENDMODE_INVALID |


*Defined at line 40 of /usr/include/SDL2/SDL_blendmode.h*



**brief** The blend mode used in SDL_RenderCopy() and drawing operations.

| enum  |

--

| SDL_BLENDOPERATION_ADD |
| SDL_BLENDOPERATION_SUBTRACT |
| SDL_BLENDOPERATION_REV_SUBTRACT |
| SDL_BLENDOPERATION_MINIMUM |
| SDL_BLENDOPERATION_MAXIMUM |


*Defined at line 65 of /usr/include/SDL2/SDL_blendmode.h*



**brief** The blend operation used when combining source and destination pixel components

| enum  |

--

| SDL_BLENDFACTOR_ZERO |
| SDL_BLENDFACTOR_ONE |
| SDL_BLENDFACTOR_SRC_COLOR |
| SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR |
| SDL_BLENDFACTOR_SRC_ALPHA |
| SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA |
| SDL_BLENDFACTOR_DST_COLOR |
| SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR |
| SDL_BLENDFACTOR_DST_ALPHA |
| SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA |


*Defined at line 78 of /usr/include/SDL2/SDL_blendmode.h*



**brief** The normalized factor used to multiply pixel components

| enum  |

--

| SDL_YUV_CONVERSION_JPEG |
| SDL_YUV_CONVERSION_BT601 |
| SDL_YUV_CONVERSION_BT709 |
| SDL_YUV_CONVERSION_AUTOMATIC |


*Defined at line 104 of /usr/include/SDL2/SDL_surface.h*



**brief** The formula used for converting between YUV and RGB

| enum  |

--

| SDL_WINDOW_FULLSCREEN |
| SDL_WINDOW_OPENGL |
| SDL_WINDOW_SHOWN |
| SDL_WINDOW_HIDDEN |
| SDL_WINDOW_BORDERLESS |
| SDL_WINDOW_RESIZABLE |
| SDL_WINDOW_MINIMIZED |
| SDL_WINDOW_MAXIMIZED |
| SDL_WINDOW_INPUT_GRABBED |
| SDL_WINDOW_INPUT_FOCUS |
| SDL_WINDOW_MOUSE_FOCUS |
| SDL_WINDOW_FULLSCREEN_DESKTOP |
| SDL_WINDOW_FOREIGN |
| SDL_WINDOW_ALLOW_HIGHDPI |
| SDL_WINDOW_MOUSE_CAPTURE |
| SDL_WINDOW_ALWAYS_ON_TOP |
| SDL_WINDOW_SKIP_TASKBAR |
| SDL_WINDOW_UTILITY |
| SDL_WINDOW_TOOLTIP |
| SDL_WINDOW_POPUP_MENU |
| SDL_WINDOW_VULKAN |


*Defined at line 97 of /usr/include/SDL2/SDL_video.h*



**brief** The flags on a window



**sa** SDL_GetWindowFlags()

| enum  |

--

| SDL_WINDOWEVENT_NONE |
| SDL_WINDOWEVENT_SHOWN |
| SDL_WINDOWEVENT_HIDDEN |
| SDL_WINDOWEVENT_EXPOSED |
| SDL_WINDOWEVENT_MOVED |
| SDL_WINDOWEVENT_RESIZED |
| SDL_WINDOWEVENT_SIZE_CHANGED |
| SDL_WINDOWEVENT_MINIMIZED |
| SDL_WINDOWEVENT_MAXIMIZED |
| SDL_WINDOWEVENT_RESTORED |
| SDL_WINDOWEVENT_ENTER |
| SDL_WINDOWEVENT_LEAVE |
| SDL_WINDOWEVENT_FOCUS_GAINED |
| SDL_WINDOWEVENT_FOCUS_LOST |
| SDL_WINDOWEVENT_CLOSE |
| SDL_WINDOWEVENT_TAKE_FOCUS |
| SDL_WINDOWEVENT_HIT_TEST |


*Defined at line 145 of /usr/include/SDL2/SDL_video.h*



**brief** Event subtype for window events

| enum  |

--

| SDL_DISPLAYEVENT_NONE |
| SDL_DISPLAYEVENT_ORIENTATION |


*Defined at line 174 of /usr/include/SDL2/SDL_video.h*



**brief** Event subtype for display events

| enum  |

--

| SDL_ORIENTATION_UNKNOWN |
| SDL_ORIENTATION_LANDSCAPE |
| SDL_ORIENTATION_LANDSCAPE_FLIPPED |
| SDL_ORIENTATION_PORTRAIT |
| SDL_ORIENTATION_PORTRAIT_FLIPPED |


*Defined at line 180 of /usr/include/SDL2/SDL_video.h*

| enum  |

--

| SDL_GL_RED_SIZE |
| SDL_GL_GREEN_SIZE |
| SDL_GL_BLUE_SIZE |
| SDL_GL_ALPHA_SIZE |
| SDL_GL_BUFFER_SIZE |
| SDL_GL_DOUBLEBUFFER |
| SDL_GL_DEPTH_SIZE |
| SDL_GL_STENCIL_SIZE |
| SDL_GL_ACCUM_RED_SIZE |
| SDL_GL_ACCUM_GREEN_SIZE |
| SDL_GL_ACCUM_BLUE_SIZE |
| SDL_GL_ACCUM_ALPHA_SIZE |
| SDL_GL_STEREO |
| SDL_GL_MULTISAMPLEBUFFERS |
| SDL_GL_MULTISAMPLESAMPLES |
| SDL_GL_ACCELERATED_VISUAL |
| SDL_GL_RETAINED_BACKING |
| SDL_GL_CONTEXT_MAJOR_VERSION |
| SDL_GL_CONTEXT_MINOR_VERSION |
| SDL_GL_CONTEXT_EGL |
| SDL_GL_CONTEXT_FLAGS |
| SDL_GL_CONTEXT_PROFILE_MASK |
| SDL_GL_SHARE_WITH_CURRENT_CONTEXT |
| SDL_GL_FRAMEBUFFER_SRGB_CAPABLE |
| SDL_GL_CONTEXT_RELEASE_BEHAVIOR |
| SDL_GL_CONTEXT_RESET_NOTIFICATION |
| SDL_GL_CONTEXT_NO_ERROR |


*Defined at line 197 of /usr/include/SDL2/SDL_video.h*



**brief** OpenGL configuration attributes

| enum  |

--

| SDL_GL_CONTEXT_PROFILE_CORE |
| SDL_GL_CONTEXT_PROFILE_COMPATIBILITY |
| SDL_GL_CONTEXT_PROFILE_ES |


*Defined at line 228 of /usr/include/SDL2/SDL_video.h*

| enum  |

--

| SDL_GL_CONTEXT_DEBUG_FLAG |
| SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG |
| SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG |
| SDL_GL_CONTEXT_RESET_ISOLATION_FLAG |


*Defined at line 235 of /usr/include/SDL2/SDL_video.h*

| enum  |

--

| SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE |
| SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH |


*Defined at line 243 of /usr/include/SDL2/SDL_video.h*

| enum  |

--

| SDL_GL_CONTEXT_RESET_NO_NOTIFICATION |
| SDL_GL_CONTEXT_RESET_LOSE_CONTEXT |


*Defined at line 249 of /usr/include/SDL2/SDL_video.h*

| enum  |

--

| SDL_HITTEST_NORMAL |
| SDL_HITTEST_DRAGGABLE |
| SDL_HITTEST_RESIZE_TOPLEFT |
| SDL_HITTEST_RESIZE_TOP |
| SDL_HITTEST_RESIZE_TOPRIGHT |
| SDL_HITTEST_RESIZE_RIGHT |
| SDL_HITTEST_RESIZE_BOTTOMRIGHT |
| SDL_HITTEST_RESIZE_BOTTOM |
| SDL_HITTEST_RESIZE_BOTTOMLEFT |
| SDL_HITTEST_RESIZE_LEFT |


*Defined at line 1019 of /usr/include/SDL2/SDL_video.h*



**brief** Possible return values from the SDL_HitTest callback.



**sa** SDL_HitTest

| enum  |

--

| SDL_SCANCODE_UNKNOWN |
| SDL_SCANCODE_A |
| SDL_SCANCODE_B |
| SDL_SCANCODE_C |
| SDL_SCANCODE_D |
| SDL_SCANCODE_E |
| SDL_SCANCODE_F |
| SDL_SCANCODE_G |
| SDL_SCANCODE_H |
| SDL_SCANCODE_I |
| SDL_SCANCODE_J |
| SDL_SCANCODE_K |
| SDL_SCANCODE_L |
| SDL_SCANCODE_M |
| SDL_SCANCODE_N |
| SDL_SCANCODE_O |
| SDL_SCANCODE_P |
| SDL_SCANCODE_Q |
| SDL_SCANCODE_R |
| SDL_SCANCODE_S |
| SDL_SCANCODE_T |
| SDL_SCANCODE_U |
| SDL_SCANCODE_V |
| SDL_SCANCODE_W |
| SDL_SCANCODE_X |
| SDL_SCANCODE_Y |
| SDL_SCANCODE_Z |
| SDL_SCANCODE_1 |
| SDL_SCANCODE_2 |
| SDL_SCANCODE_3 |
| SDL_SCANCODE_4 |
| SDL_SCANCODE_5 |
| SDL_SCANCODE_6 |
| SDL_SCANCODE_7 |
| SDL_SCANCODE_8 |
| SDL_SCANCODE_9 |
| SDL_SCANCODE_0 |
| SDL_SCANCODE_RETURN |
| SDL_SCANCODE_ESCAPE |
| SDL_SCANCODE_BACKSPACE |
| SDL_SCANCODE_TAB |
| SDL_SCANCODE_SPACE |
| SDL_SCANCODE_MINUS |
| SDL_SCANCODE_EQUALS |
| SDL_SCANCODE_LEFTBRACKET |
| SDL_SCANCODE_RIGHTBRACKET |
| SDL_SCANCODE_BACKSLASH |
| SDL_SCANCODE_NONUSHASH |
| SDL_SCANCODE_SEMICOLON |
| SDL_SCANCODE_APOSTROPHE |
| SDL_SCANCODE_GRAVE |
| SDL_SCANCODE_COMMA |
| SDL_SCANCODE_PERIOD |
| SDL_SCANCODE_SLASH |
| SDL_SCANCODE_CAPSLOCK |
| SDL_SCANCODE_F1 |
| SDL_SCANCODE_F2 |
| SDL_SCANCODE_F3 |
| SDL_SCANCODE_F4 |
| SDL_SCANCODE_F5 |
| SDL_SCANCODE_F6 |
| SDL_SCANCODE_F7 |
| SDL_SCANCODE_F8 |
| SDL_SCANCODE_F9 |
| SDL_SCANCODE_F10 |
| SDL_SCANCODE_F11 |
| SDL_SCANCODE_F12 |
| SDL_SCANCODE_PRINTSCREEN |
| SDL_SCANCODE_SCROLLLOCK |
| SDL_SCANCODE_PAUSE |
| SDL_SCANCODE_INSERT |
| SDL_SCANCODE_HOME |
| SDL_SCANCODE_PAGEUP |
| SDL_SCANCODE_DELETE |
| SDL_SCANCODE_END |
| SDL_SCANCODE_PAGEDOWN |
| SDL_SCANCODE_RIGHT |
| SDL_SCANCODE_LEFT |
| SDL_SCANCODE_DOWN |
| SDL_SCANCODE_UP |
| SDL_SCANCODE_NUMLOCKCLEAR |
| SDL_SCANCODE_KP_DIVIDE |
| SDL_SCANCODE_KP_MULTIPLY |
| SDL_SCANCODE_KP_MINUS |
| SDL_SCANCODE_KP_PLUS |
| SDL_SCANCODE_KP_ENTER |
| SDL_SCANCODE_KP_1 |
| SDL_SCANCODE_KP_2 |
| SDL_SCANCODE_KP_3 |
| SDL_SCANCODE_KP_4 |
| SDL_SCANCODE_KP_5 |
| SDL_SCANCODE_KP_6 |
| SDL_SCANCODE_KP_7 |
| SDL_SCANCODE_KP_8 |
| SDL_SCANCODE_KP_9 |
| SDL_SCANCODE_KP_0 |
| SDL_SCANCODE_KP_PERIOD |
| SDL_SCANCODE_NONUSBACKSLASH |
| SDL_SCANCODE_APPLICATION |
| SDL_SCANCODE_POWER |
| SDL_SCANCODE_KP_EQUALS |
| SDL_SCANCODE_F13 |
| SDL_SCANCODE_F14 |
| SDL_SCANCODE_F15 |
| SDL_SCANCODE_F16 |
| SDL_SCANCODE_F17 |
| SDL_SCANCODE_F18 |
| SDL_SCANCODE_F19 |
| SDL_SCANCODE_F20 |
| SDL_SCANCODE_F21 |
| SDL_SCANCODE_F22 |
| SDL_SCANCODE_F23 |
| SDL_SCANCODE_F24 |
| SDL_SCANCODE_EXECUTE |
| SDL_SCANCODE_HELP |
| SDL_SCANCODE_MENU |
| SDL_SCANCODE_SELECT |
| SDL_SCANCODE_STOP |
| SDL_SCANCODE_AGAIN |
| SDL_SCANCODE_UNDO |
| SDL_SCANCODE_CUT |
| SDL_SCANCODE_COPY |
| SDL_SCANCODE_PASTE |
| SDL_SCANCODE_FIND |
| SDL_SCANCODE_MUTE |
| SDL_SCANCODE_VOLUMEUP |
| SDL_SCANCODE_VOLUMEDOWN |
| SDL_SCANCODE_KP_COMMA |
| SDL_SCANCODE_KP_EQUALSAS400 |
| SDL_SCANCODE_INTERNATIONAL1 |
| SDL_SCANCODE_INTERNATIONAL2 |
| SDL_SCANCODE_INTERNATIONAL3 |
| SDL_SCANCODE_INTERNATIONAL4 |
| SDL_SCANCODE_INTERNATIONAL5 |
| SDL_SCANCODE_INTERNATIONAL6 |
| SDL_SCANCODE_INTERNATIONAL7 |
| SDL_SCANCODE_INTERNATIONAL8 |
| SDL_SCANCODE_INTERNATIONAL9 |
| SDL_SCANCODE_LANG1 |
| SDL_SCANCODE_LANG2 |
| SDL_SCANCODE_LANG3 |
| SDL_SCANCODE_LANG4 |
| SDL_SCANCODE_LANG5 |
| SDL_SCANCODE_LANG6 |
| SDL_SCANCODE_LANG7 |
| SDL_SCANCODE_LANG8 |
| SDL_SCANCODE_LANG9 |
| SDL_SCANCODE_ALTERASE |
| SDL_SCANCODE_SYSREQ |
| SDL_SCANCODE_CANCEL |
| SDL_SCANCODE_CLEAR |
| SDL_SCANCODE_PRIOR |
| SDL_SCANCODE_RETURN2 |
| SDL_SCANCODE_SEPARATOR |
| SDL_SCANCODE_OUT |
| SDL_SCANCODE_OPER |
| SDL_SCANCODE_CLEARAGAIN |
| SDL_SCANCODE_CRSEL |
| SDL_SCANCODE_EXSEL |
| SDL_SCANCODE_KP_00 |
| SDL_SCANCODE_KP_000 |
| SDL_SCANCODE_THOUSANDSSEPARATOR |
| SDL_SCANCODE_DECIMALSEPARATOR |
| SDL_SCANCODE_CURRENCYUNIT |
| SDL_SCANCODE_CURRENCYSUBUNIT |
| SDL_SCANCODE_KP_LEFTPAREN |
| SDL_SCANCODE_KP_RIGHTPAREN |
| SDL_SCANCODE_KP_LEFTBRACE |
| SDL_SCANCODE_KP_RIGHTBRACE |
| SDL_SCANCODE_KP_TAB |
| SDL_SCANCODE_KP_BACKSPACE |
| SDL_SCANCODE_KP_A |
| SDL_SCANCODE_KP_B |
| SDL_SCANCODE_KP_C |
| SDL_SCANCODE_KP_D |
| SDL_SCANCODE_KP_E |
| SDL_SCANCODE_KP_F |
| SDL_SCANCODE_KP_XOR |
| SDL_SCANCODE_KP_POWER |
| SDL_SCANCODE_KP_PERCENT |
| SDL_SCANCODE_KP_LESS |
| SDL_SCANCODE_KP_GREATER |
| SDL_SCANCODE_KP_AMPERSAND |
| SDL_SCANCODE_KP_DBLAMPERSAND |
| SDL_SCANCODE_KP_VERTICALBAR |
| SDL_SCANCODE_KP_DBLVERTICALBAR |
| SDL_SCANCODE_KP_COLON |
| SDL_SCANCODE_KP_HASH |
| SDL_SCANCODE_KP_SPACE |
| SDL_SCANCODE_KP_AT |
| SDL_SCANCODE_KP_EXCLAM |
| SDL_SCANCODE_KP_MEMSTORE |
| SDL_SCANCODE_KP_MEMRECALL |
| SDL_SCANCODE_KP_MEMCLEAR |
| SDL_SCANCODE_KP_MEMADD |
| SDL_SCANCODE_KP_MEMSUBTRACT |
| SDL_SCANCODE_KP_MEMMULTIPLY |
| SDL_SCANCODE_KP_MEMDIVIDE |
| SDL_SCANCODE_KP_PLUSMINUS |
| SDL_SCANCODE_KP_CLEAR |
| SDL_SCANCODE_KP_CLEARENTRY |
| SDL_SCANCODE_KP_BINARY |
| SDL_SCANCODE_KP_OCTAL |
| SDL_SCANCODE_KP_DECIMAL |
| SDL_SCANCODE_KP_HEXADECIMAL |
| SDL_SCANCODE_LCTRL |
| SDL_SCANCODE_LSHIFT |
| SDL_SCANCODE_LALT |
| SDL_SCANCODE_LGUI |
| SDL_SCANCODE_RCTRL |
| SDL_SCANCODE_RSHIFT |
| SDL_SCANCODE_RALT |
| SDL_SCANCODE_RGUI |
| SDL_SCANCODE_MODE |
| SDL_SCANCODE_AUDIONEXT |
| SDL_SCANCODE_AUDIOPREV |
| SDL_SCANCODE_AUDIOSTOP |
| SDL_SCANCODE_AUDIOPLAY |
| SDL_SCANCODE_AUDIOMUTE |
| SDL_SCANCODE_MEDIASELECT |
| SDL_SCANCODE_WWW |
| SDL_SCANCODE_MAIL |
| SDL_SCANCODE_CALCULATOR |
| SDL_SCANCODE_COMPUTER |
| SDL_SCANCODE_AC_SEARCH |
| SDL_SCANCODE_AC_HOME |
| SDL_SCANCODE_AC_BACK |
| SDL_SCANCODE_AC_FORWARD |
| SDL_SCANCODE_AC_STOP |
| SDL_SCANCODE_AC_REFRESH |
| SDL_SCANCODE_AC_BOOKMARKS |
| SDL_SCANCODE_BRIGHTNESSDOWN |
| SDL_SCANCODE_BRIGHTNESSUP |
| SDL_SCANCODE_DISPLAYSWITCH |
| SDL_SCANCODE_KBDILLUMTOGGLE |
| SDL_SCANCODE_KBDILLUMDOWN |
| SDL_SCANCODE_KBDILLUMUP |
| SDL_SCANCODE_EJECT |
| SDL_SCANCODE_SLEEP |
| SDL_SCANCODE_APP1 |
| SDL_SCANCODE_APP2 |
| SDL_SCANCODE_AUDIOREWIND |
| SDL_SCANCODE_AUDIOFASTFORWARD |
| SDL_NUM_SCANCODES |


*Defined at line 43 of /usr/include/SDL2/SDL_scancode.h*



**brief** The SDL keyboard scancode representation.

  Values of this type are used to represent keyboard keys, among other places  in the 

 SDL_Keysym::scancode key.keysym.scancode \endlink field of the

  SDL_Event structure.



  The values in this enumeration are based on the USB usage page standard:

  https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf





| enum  |

--

| SDLK_UNKNOWN |
| SDLK_RETURN |
| SDLK_ESCAPE |
| SDLK_BACKSPACE |
| SDLK_TAB |
| SDLK_SPACE |
| SDLK_EXCLAIM |
| SDLK_QUOTEDBL |
| SDLK_HASH |
| SDLK_PERCENT |
| SDLK_DOLLAR |
| SDLK_AMPERSAND |
| SDLK_QUOTE |
| SDLK_LEFTPAREN |
| SDLK_RIGHTPAREN |
| SDLK_ASTERISK |
| SDLK_PLUS |
| SDLK_COMMA |
| SDLK_MINUS |
| SDLK_PERIOD |
| SDLK_SLASH |
| SDLK_0 |
| SDLK_1 |
| SDLK_2 |
| SDLK_3 |
| SDLK_4 |
| SDLK_5 |
| SDLK_6 |
| SDLK_7 |
| SDLK_8 |
| SDLK_9 |
| SDLK_COLON |
| SDLK_SEMICOLON |
| SDLK_LESS |
| SDLK_EQUALS |
| SDLK_GREATER |
| SDLK_QUESTION |
| SDLK_AT |
| SDLK_LEFTBRACKET |
| SDLK_BACKSLASH |
| SDLK_RIGHTBRACKET |
| SDLK_CARET |
| SDLK_UNDERSCORE |
| SDLK_BACKQUOTE |
| SDLK_a |
| SDLK_b |
| SDLK_c |
| SDLK_d |
| SDLK_e |
| SDLK_f |
| SDLK_g |
| SDLK_h |
| SDLK_i |
| SDLK_j |
| SDLK_k |
| SDLK_l |
| SDLK_m |
| SDLK_n |
| SDLK_o |
| SDLK_p |
| SDLK_q |
| SDLK_r |
| SDLK_s |
| SDLK_t |
| SDLK_u |
| SDLK_v |
| SDLK_w |
| SDLK_x |
| SDLK_y |
| SDLK_z |
| SDLK_CAPSLOCK |
| SDLK_F1 |
| SDLK_F2 |
| SDLK_F3 |
| SDLK_F4 |
| SDLK_F5 |
| SDLK_F6 |
| SDLK_F7 |
| SDLK_F8 |
| SDLK_F9 |
| SDLK_F10 |
| SDLK_F11 |
| SDLK_F12 |
| SDLK_PRINTSCREEN |
| SDLK_SCROLLLOCK |
| SDLK_PAUSE |
| SDLK_INSERT |
| SDLK_HOME |
| SDLK_PAGEUP |
| SDLK_DELETE |
| SDLK_END |
| SDLK_PAGEDOWN |
| SDLK_RIGHT |
| SDLK_LEFT |
| SDLK_DOWN |
| SDLK_UP |
| SDLK_NUMLOCKCLEAR |
| SDLK_KP_DIVIDE |
| SDLK_KP_MULTIPLY |
| SDLK_KP_MINUS |
| SDLK_KP_PLUS |
| SDLK_KP_ENTER |
| SDLK_KP_1 |
| SDLK_KP_2 |
| SDLK_KP_3 |
| SDLK_KP_4 |
| SDLK_KP_5 |
| SDLK_KP_6 |
| SDLK_KP_7 |
| SDLK_KP_8 |
| SDLK_KP_9 |
| SDLK_KP_0 |
| SDLK_KP_PERIOD |
| SDLK_APPLICATION |
| SDLK_POWER |
| SDLK_KP_EQUALS |
| SDLK_F13 |
| SDLK_F14 |
| SDLK_F15 |
| SDLK_F16 |
| SDLK_F17 |
| SDLK_F18 |
| SDLK_F19 |
| SDLK_F20 |
| SDLK_F21 |
| SDLK_F22 |
| SDLK_F23 |
| SDLK_F24 |
| SDLK_EXECUTE |
| SDLK_HELP |
| SDLK_MENU |
| SDLK_SELECT |
| SDLK_STOP |
| SDLK_AGAIN |
| SDLK_UNDO |
| SDLK_CUT |
| SDLK_COPY |
| SDLK_PASTE |
| SDLK_FIND |
| SDLK_MUTE |
| SDLK_VOLUMEUP |
| SDLK_VOLUMEDOWN |
| SDLK_KP_COMMA |
| SDLK_KP_EQUALSAS400 |
| SDLK_ALTERASE |
| SDLK_SYSREQ |
| SDLK_CANCEL |
| SDLK_CLEAR |
| SDLK_PRIOR |
| SDLK_RETURN2 |
| SDLK_SEPARATOR |
| SDLK_OUT |
| SDLK_OPER |
| SDLK_CLEARAGAIN |
| SDLK_CRSEL |
| SDLK_EXSEL |
| SDLK_KP_00 |
| SDLK_KP_000 |
| SDLK_THOUSANDSSEPARATOR |
| SDLK_DECIMALSEPARATOR |
| SDLK_CURRENCYUNIT |
| SDLK_CURRENCYSUBUNIT |
| SDLK_KP_LEFTPAREN |
| SDLK_KP_RIGHTPAREN |
| SDLK_KP_LEFTBRACE |
| SDLK_KP_RIGHTBRACE |
| SDLK_KP_TAB |
| SDLK_KP_BACKSPACE |
| SDLK_KP_A |
| SDLK_KP_B |
| SDLK_KP_C |
| SDLK_KP_D |
| SDLK_KP_E |
| SDLK_KP_F |
| SDLK_KP_XOR |
| SDLK_KP_POWER |
| SDLK_KP_PERCENT |
| SDLK_KP_LESS |
| SDLK_KP_GREATER |
| SDLK_KP_AMPERSAND |
| SDLK_KP_DBLAMPERSAND |
| SDLK_KP_VERTICALBAR |
| SDLK_KP_DBLVERTICALBAR |
| SDLK_KP_COLON |
| SDLK_KP_HASH |
| SDLK_KP_SPACE |
| SDLK_KP_AT |
| SDLK_KP_EXCLAM |
| SDLK_KP_MEMSTORE |
| SDLK_KP_MEMRECALL |
| SDLK_KP_MEMCLEAR |
| SDLK_KP_MEMADD |
| SDLK_KP_MEMSUBTRACT |
| SDLK_KP_MEMMULTIPLY |
| SDLK_KP_MEMDIVIDE |
| SDLK_KP_PLUSMINUS |
| SDLK_KP_CLEAR |
| SDLK_KP_CLEARENTRY |
| SDLK_KP_BINARY |
| SDLK_KP_OCTAL |
| SDLK_KP_DECIMAL |
| SDLK_KP_HEXADECIMAL |
| SDLK_LCTRL |
| SDLK_LSHIFT |
| SDLK_LALT |
| SDLK_LGUI |
| SDLK_RCTRL |
| SDLK_RSHIFT |
| SDLK_RALT |
| SDLK_RGUI |
| SDLK_MODE |
| SDLK_AUDIONEXT |
| SDLK_AUDIOPREV |
| SDLK_AUDIOSTOP |
| SDLK_AUDIOPLAY |
| SDLK_AUDIOMUTE |
| SDLK_MEDIASELECT |
| SDLK_WWW |
| SDLK_MAIL |
| SDLK_CALCULATOR |
| SDLK_COMPUTER |
| SDLK_AC_SEARCH |
| SDLK_AC_HOME |
| SDLK_AC_BACK |
| SDLK_AC_FORWARD |
| SDLK_AC_STOP |
| SDLK_AC_REFRESH |
| SDLK_AC_BOOKMARKS |
| SDLK_BRIGHTNESSDOWN |
| SDLK_BRIGHTNESSUP |
| SDLK_DISPLAYSWITCH |
| SDLK_KBDILLUMTOGGLE |
| SDLK_KBDILLUMDOWN |
| SDLK_KBDILLUMUP |
| SDLK_EJECT |
| SDLK_SLEEP |
| SDLK_APP1 |
| SDLK_APP2 |
| SDLK_AUDIOREWIND |
| SDLK_AUDIOFASTFORWARD |


*Defined at line 50 of /usr/include/SDL2/SDL_keycode.h*

| enum  |

--

| KMOD_NONE |
| KMOD_LSHIFT |
| KMOD_RSHIFT |
| KMOD_LCTRL |
| KMOD_RCTRL |
| KMOD_LALT |
| KMOD_RALT |
| KMOD_LGUI |
| KMOD_RGUI |
| KMOD_NUM |
| KMOD_CAPS |
| KMOD_MODE |
| KMOD_RESERVED |


*Defined at line 325 of /usr/include/SDL2/SDL_keycode.h*



**brief** Enumeration of valid key mods (possibly OR'd together).

| enum  |

--

| SDL_SYSTEM_CURSOR_ARROW |
| SDL_SYSTEM_CURSOR_IBEAM |
| SDL_SYSTEM_CURSOR_WAIT |
| SDL_SYSTEM_CURSOR_CROSSHAIR |
| SDL_SYSTEM_CURSOR_WAITARROW |
| SDL_SYSTEM_CURSOR_SIZENWSE |
| SDL_SYSTEM_CURSOR_SIZENESW |
| SDL_SYSTEM_CURSOR_SIZEWE |
| SDL_SYSTEM_CURSOR_SIZENS |
| SDL_SYSTEM_CURSOR_SIZEALL |
| SDL_SYSTEM_CURSOR_NO |
| SDL_SYSTEM_CURSOR_HAND |
| SDL_NUM_SYSTEM_CURSORS |


*Defined at line 46 of /usr/include/SDL2/SDL_mouse.h*



**brief** Cursor types for SDL_CreateSystemCursor().

| enum  |

--

| SDL_MOUSEWHEEL_NORMAL |
| SDL_MOUSEWHEEL_FLIPPED |


*Defined at line 66 of /usr/include/SDL2/SDL_mouse.h*



**brief** Scroll direction types for the Scroll event

| enum  |

--

| SDL_JOYSTICK_TYPE_UNKNOWN |
| SDL_JOYSTICK_TYPE_GAMECONTROLLER |
| SDL_JOYSTICK_TYPE_WHEEL |
| SDL_JOYSTICK_TYPE_ARCADE_STICK |
| SDL_JOYSTICK_TYPE_FLIGHT_STICK |
| SDL_JOYSTICK_TYPE_DANCE_PAD |
| SDL_JOYSTICK_TYPE_GUITAR |
| SDL_JOYSTICK_TYPE_DRUM_KIT |
| SDL_JOYSTICK_TYPE_ARCADE_PAD |
| SDL_JOYSTICK_TYPE_THROTTLE |


*Defined at line 83 of /usr/include/SDL2/SDL_joystick.h*

| enum  |

--

| SDL_JOYSTICK_POWER_UNKNOWN |
| SDL_JOYSTICK_POWER_EMPTY |
| SDL_JOYSTICK_POWER_LOW |
| SDL_JOYSTICK_POWER_MEDIUM |
| SDL_JOYSTICK_POWER_FULL |
| SDL_JOYSTICK_POWER_WIRED |
| SDL_JOYSTICK_POWER_MAX |


*Defined at line 97 of /usr/include/SDL2/SDL_joystick.h*

| enum  |

--

| SDL_CONTROLLER_TYPE_UNKNOWN |
| SDL_CONTROLLER_TYPE_XBOX360 |
| SDL_CONTROLLER_TYPE_XBOXONE |
| SDL_CONTROLLER_TYPE_PS3 |
| SDL_CONTROLLER_TYPE_PS4 |
| SDL_CONTROLLER_TYPE_NINTENDO_SWITCH_PRO |


*Defined at line 60 of /usr/include/SDL2/SDL_gamecontroller.h*

| enum  |

--

| SDL_CONTROLLER_BINDTYPE_NONE |
| SDL_CONTROLLER_BINDTYPE_BUTTON |
| SDL_CONTROLLER_BINDTYPE_AXIS |
| SDL_CONTROLLER_BINDTYPE_HAT |


*Defined at line 70 of /usr/include/SDL2/SDL_gamecontroller.h*

| enum  |

--

| SDL_CONTROLLER_AXIS_INVALID |
| SDL_CONTROLLER_AXIS_LEFTX |
| SDL_CONTROLLER_AXIS_LEFTY |
| SDL_CONTROLLER_AXIS_RIGHTX |
| SDL_CONTROLLER_AXIS_RIGHTY |
| SDL_CONTROLLER_AXIS_TRIGGERLEFT |
| SDL_CONTROLLER_AXIS_TRIGGERRIGHT |
| SDL_CONTROLLER_AXIS_MAX |


*Defined at line 302 of /usr/include/SDL2/SDL_gamecontroller.h*

  The list of axes available from a controller

  Thumbstick axis values range from SDL_JOYSTICK_AXIS_MIN to SDL_JOYSTICK_AXIS_MAX,  and are centered within ~8000 of zero, though advanced UI will allow users to set  or autodetect the dead zone, which varies between controllers.

  Trigger axis values range from 0 to SDL_JOYSTICK_AXIS_MAX.

| enum  |

--

| SDL_CONTROLLER_BUTTON_INVALID |
| SDL_CONTROLLER_BUTTON_A |
| SDL_CONTROLLER_BUTTON_B |
| SDL_CONTROLLER_BUTTON_X |
| SDL_CONTROLLER_BUTTON_Y |
| SDL_CONTROLLER_BUTTON_BACK |
| SDL_CONTROLLER_BUTTON_GUIDE |
| SDL_CONTROLLER_BUTTON_START |
| SDL_CONTROLLER_BUTTON_LEFTSTICK |
| SDL_CONTROLLER_BUTTON_RIGHTSTICK |
| SDL_CONTROLLER_BUTTON_LEFTSHOULDER |
| SDL_CONTROLLER_BUTTON_RIGHTSHOULDER |
| SDL_CONTROLLER_BUTTON_DPAD_UP |
| SDL_CONTROLLER_BUTTON_DPAD_DOWN |
| SDL_CONTROLLER_BUTTON_DPAD_LEFT |
| SDL_CONTROLLER_BUTTON_DPAD_RIGHT |
| SDL_CONTROLLER_BUTTON_MAX |


*Defined at line 346 of /usr/include/SDL2/SDL_gamecontroller.h*

  The list of buttons available from a controller

| enum  |

--

| SDL_TOUCH_DEVICE_INVALID |
| SDL_TOUCH_DEVICE_DIRECT |
| SDL_TOUCH_DEVICE_INDIRECT_ABSOLUTE |
| SDL_TOUCH_DEVICE_INDIRECT_RELATIVE |


*Defined at line 44 of /usr/include/SDL2/SDL_touch.h*

| enum  |

--

| SDL_FIRSTEVENT |
| SDL_QUIT |
| SDL_APP_TERMINATING |
| SDL_APP_LOWMEMORY |
| SDL_APP_WILLENTERBACKGROUND |
| SDL_APP_DIDENTERBACKGROUND |
| SDL_APP_WILLENTERFOREGROUND |
| SDL_APP_DIDENTERFOREGROUND |
| SDL_DISPLAYEVENT |
| SDL_WINDOWEVENT |
| SDL_SYSWMEVENT |
| SDL_KEYDOWN |
| SDL_KEYUP |
| SDL_TEXTEDITING |
| SDL_TEXTINPUT |
| SDL_KEYMAPCHANGED |
| SDL_MOUSEMOTION |
| SDL_MOUSEBUTTONDOWN |
| SDL_MOUSEBUTTONUP |
| SDL_MOUSEWHEEL |
| SDL_JOYAXISMOTION |
| SDL_JOYBALLMOTION |
| SDL_JOYHATMOTION |
| SDL_JOYBUTTONDOWN |
| SDL_JOYBUTTONUP |
| SDL_JOYDEVICEADDED |
| SDL_JOYDEVICEREMOVED |
| SDL_CONTROLLERAXISMOTION |
| SDL_CONTROLLERBUTTONDOWN |
| SDL_CONTROLLERBUTTONUP |
| SDL_CONTROLLERDEVICEADDED |
| SDL_CONTROLLERDEVICEREMOVED |
| SDL_CONTROLLERDEVICEREMAPPED |
| SDL_FINGERDOWN |
| SDL_FINGERUP |
| SDL_FINGERMOTION |
| SDL_DOLLARGESTURE |
| SDL_DOLLARRECORD |
| SDL_MULTIGESTURE |
| SDL_CLIPBOARDUPDATE |
| SDL_DROPFILE |
| SDL_DROPTEXT |
| SDL_DROPBEGIN |
| SDL_DROPCOMPLETE |
| SDL_AUDIODEVICEADDED |
| SDL_AUDIODEVICEREMOVED |
| SDL_SENSORUPDATE |
| SDL_RENDER_TARGETS_RESET |
| SDL_RENDER_DEVICE_RESET |
| SDL_USEREVENT |
| SDL_LASTEVENT |


*Defined at line 55 of /usr/include/SDL2/SDL_events.h*



**brief** The types of events that can be delivered.

| enum  |

--

| SDL_ADDEVENT |
| SDL_PEEKEVENT |
| SDL_GETEVENT |


*Defined at line 614 of /usr/include/SDL2/SDL_events.h*

@{ 

| enum  |

--

| SDL_HINT_DEFAULT |
| SDL_HINT_NORMAL |
| SDL_HINT_OVERRIDE |


*Defined at line 1278 of /usr/include/SDL2/SDL_hints.h*



**brief**  An enumeration of hint priorities

| enum  |

--

| SDL_LOG_CATEGORY_APPLICATION |
| SDL_LOG_CATEGORY_ERROR |
| SDL_LOG_CATEGORY_ASSERT |
| SDL_LOG_CATEGORY_SYSTEM |
| SDL_LOG_CATEGORY_AUDIO |
| SDL_LOG_CATEGORY_VIDEO |
| SDL_LOG_CATEGORY_RENDER |
| SDL_LOG_CATEGORY_INPUT |
| SDL_LOG_CATEGORY_TEST |
| SDL_LOG_CATEGORY_RESERVED1 |
| SDL_LOG_CATEGORY_RESERVED2 |
| SDL_LOG_CATEGORY_RESERVED3 |
| SDL_LOG_CATEGORY_RESERVED4 |
| SDL_LOG_CATEGORY_RESERVED5 |
| SDL_LOG_CATEGORY_RESERVED6 |
| SDL_LOG_CATEGORY_RESERVED7 |
| SDL_LOG_CATEGORY_RESERVED8 |
| SDL_LOG_CATEGORY_RESERVED9 |
| SDL_LOG_CATEGORY_RESERVED10 |
| SDL_LOG_CATEGORY_CUSTOM |


*Defined at line 64 of /usr/include/SDL2/SDL_log.h*



**brief** The predefined log categories

  By default the application category is enabled at the INFO level,  the assert category is enabled at the WARN level, test is enabled  at the VERBOSE level and all other categories are enabled at the  CRITICAL level.

| enum  |

--

| SDL_LOG_PRIORITY_VERBOSE |
| SDL_LOG_PRIORITY_DEBUG |
| SDL_LOG_PRIORITY_INFO |
| SDL_LOG_PRIORITY_WARN |
| SDL_LOG_PRIORITY_ERROR |
| SDL_LOG_PRIORITY_CRITICAL |
| SDL_NUM_LOG_PRIORITIES |


*Defined at line 102 of /usr/include/SDL2/SDL_log.h*



**brief** The predefined log priorities

| enum  |

--

| SDL_MESSAGEBOX_ERROR |
| SDL_MESSAGEBOX_WARNING |
| SDL_MESSAGEBOX_INFORMATION |
| SDL_MESSAGEBOX_BUTTONS_LEFT_TO_RIGHT |
| SDL_MESSAGEBOX_BUTTONS_RIGHT_TO_LEFT |


*Defined at line 37 of /usr/include/SDL2/SDL_messagebox.h*



**brief** SDL_MessageBox flags. If supported will display warning icon, etc.

| enum  |

--

| SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT |
| SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT |


*Defined at line 49 of /usr/include/SDL2/SDL_messagebox.h*



**brief** Flags for SDL_MessageBoxButtonData.

| enum  |

--

| SDL_MESSAGEBOX_COLOR_BACKGROUND |
| SDL_MESSAGEBOX_COLOR_TEXT |
| SDL_MESSAGEBOX_COLOR_BUTTON_BORDER |
| SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND |
| SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED |
| SDL_MESSAGEBOX_COLOR_MAX |


*Defined at line 73 of /usr/include/SDL2/SDL_messagebox.h*

| enum  |

--

| SDL_POWERSTATE_UNKNOWN |
| SDL_POWERSTATE_ON_BATTERY |
| SDL_POWERSTATE_NO_BATTERY |
| SDL_POWERSTATE_CHARGING |
| SDL_POWERSTATE_CHARGED |


*Defined at line 42 of /usr/include/SDL2/SDL_power.h*



**brief** The basic state for the system's power supply.

| enum  |

--

| SDL_RENDERER_SOFTWARE |
| SDL_RENDERER_ACCELERATED |
| SDL_RENDERER_PRESENTVSYNC |
| SDL_RENDERER_TARGETTEXTURE |


*Defined at line 64 of /usr/include/SDL2/SDL_render.h*



**brief** Flags used when creating a rendering context

| enum  |

--

| SDL_ScaleModeNearest |
| SDL_ScaleModeLinear |
| SDL_ScaleModeBest |


*Defined at line 91 of /usr/include/SDL2/SDL_render.h*



**brief** The scaling mode for a texture.

| enum  |

--

| SDL_TEXTUREACCESS_STATIC |
| SDL_TEXTUREACCESS_STREAMING |
| SDL_TEXTUREACCESS_TARGET |


*Defined at line 101 of /usr/include/SDL2/SDL_render.h*



**brief** The access pattern allowed for a texture.

| enum  |

--

| SDL_TEXTUREMODULATE_NONE |
| SDL_TEXTUREMODULATE_COLOR |
| SDL_TEXTUREMODULATE_ALPHA |


*Defined at line 111 of /usr/include/SDL2/SDL_render.h*



**brief** The texture channel modulation used in SDL_RenderCopy().

| enum  |

--

| SDL_FLIP_NONE |
| SDL_FLIP_HORIZONTAL |
| SDL_FLIP_VERTICAL |


*Defined at line 121 of /usr/include/SDL2/SDL_render.h*



**brief** Flip constants for SDL_RenderCopyEx

| enum  |

--

| SDL_SENSOR_INVALID |
| SDL_SENSOR_UNKNOWN |
| SDL_SENSOR_ACCEL |
| SDL_SENSOR_GYRO |


*Defined at line 69 of /usr/include/SDL2/SDL_sensor.h*

 The different sensors defined by SDL

 Additional sensors may be available, using platform dependent semantics.

 Hare are the additional Android sensors: https://developer.android.com/reference/android/hardware/SensorEvent.html#values

| enum  |

--

| ShapeModeDefault |
| ShapeModeBinarizeAlpha |
| ShapeModeReverseBinarizeAlpha |
| ShapeModeColorKey |


*Defined at line 80 of /usr/include/SDL2/SDL_shape.h*



**brief** An enum denoting the specific type of contents present in an SDL_WindowShapeParams union. 

| enum  |

--

| DEV_NONE |
| DEV_NORMAL |
| DEV_EXTENDED |


*Defined at line 93 of ./engine/common/common.h*

| enum  |

--

| D_INFO |
| D_WARN |
| D_ERROR |
| D_REPORT |
| D_NOTE |


*Defined at line 100 of ./engine/common/common.h*

| enum  |

--

| HOST_NORMAL |
| HOST_DEDICATED |


*Defined at line 109 of ./engine/common/common.h*

| enum  |

--

| rserr_ok |
| rserr_invalid_fullscreen |
| rserr_invalid_mode |
| rserr_unknown |


*Defined at line 88 of ./engine/platform/platform.h*

============================================================================== 

			WINDOW MANAGEMENT 

============================================================================== 

| enum  |

--

| GAME_NORMAL |
| GAME_SINGLEPLAYER_ONLY |
| GAME_MULTIPLAYER_ONLY |


*Defined at line 253 of ./engine/common/common.h*

| enum  |

--

| HOST_INIT |
| HOST_FRAME |
| HOST_SHUTDOWN |
| HOST_ERR_FATAL |
| HOST_SLEEP |
| HOST_NOFOCUS |
| HOST_CRASHED |


*Defined at line 272 of ./engine/common/common.h*

| enum  |

--

| STATE_RUNFRAME |
| STATE_LOAD_LEVEL |
| STATE_LOAD_GAME |
| STATE_CHANGELEVEL |
| STATE_GAME_SHUTDOWN |


*Defined at line 283 of ./engine/common/common.h*

| enum  |

--

| key_console |
| key_game |
| key_menu |
| key_message |


*Defined at line 303 of ./engine/common/common.h*

| enum  |

--

| RD_NONE |
| RD_CLIENT |
| RD_PACKET |


*Defined at line 311 of ./engine/common/common.h*

| enum  |

--

| NS_CLIENT |
| NS_SERVER |
| NS_COUNT |


*Defined at line 19 of ./engine/common/net_ws.h*

| enum  |

--

| WF_UNKNOWN |
| WF_PCMDATA |
| WF_MPGDATA |
| WF_TOTALCOUNT |


*Defined at line 622 of ./engine/common/common.h*

========================================================================

internal sound format

typically expanded to wav buffer========================================================================

| enum  |

--

| SL_USE_LERPING |
| SL_KEEP_8BIT |
| SL_ALLOW_OVERWRITE |


*Defined at line 631 of ./engine/common/common.h*

 soundlib global settings

| enum  |

--

| SOUND_LOOPED |
| SOUND_STREAM |
| SOUND_RESAMPLE |
| SOUND_CONVERT16BIT |


*Defined at line 639 of ./engine/common/common.h*

 wavdata output flags

| enum EStringConvertErrorPolicy |

--

| _STRINGCONVERTFLAG_SKIP |
| _STRINGCONVERTFLAG_FAIL |
| _STRINGCONVERTFLAG_ASSERT |
| STRINGCONVERT_REPLACE |
| STRINGCONVERT_SKIP |
| STRINGCONVERT_FAIL |
| STRINGCONVERT_ASSERT_REPLACE |
| STRINGCONVERT_ASSERT_SKIP |
| STRINGCONVERT_ASSERT_FAIL |


*Defined at line 45 of ./mainui/unicode_strtools.h*

| enum  |

--

| GR_NONE |
| GR_WEAPON_RESPAWN_YES |
| GR_WEAPON_RESPAWN_NO |
| GR_AMMO_RESPAWN_YES |
| GR_AMMO_RESPAWN_NO |
| GR_ITEM_RESPAWN_YES |
| GR_ITEM_RESPAWN_NO |
| GR_PLR_DROP_GUN_ALL |
| GR_PLR_DROP_GUN_ACTIVE |
| GR_PLR_DROP_GUN_NO |
| GR_PLR_DROP_AMMO_ALL |
| GR_PLR_DROP_AMMO_ACTIVE |
| GR_PLR_DROP_AMMO_NO |


*Defined at line 29 of ./game/server/gamerules.h*

 weapon respawning return codes

| enum  |

--

| GR_NOTTEAMMATE |
| GR_TEAMMATE |
| GR_ENEMY |
| GR_ALLY |
| GR_NEUTRAL |


*Defined at line 52 of ./game/server/gamerules.h*

 Player relationship return codes

| enum w_squeak_e |

--

| WSQUEAK_IDLE1 |
| WSQUEAK_FIDGET |
| WSQUEAK_JUMP |
| WSQUEAK_RUN |


*Defined at line 28 of ./game/shared/hl1/weapon_squeakgrenade.cpp*

| enum squeak_e |

--

| SQUEAK_IDLE1 |
| SQUEAK_FIDGETFIT |
| SQUEAK_FIDGETNIP |
| SQUEAK_DOWN |
| SQUEAK_UP |
| SQUEAK_THROW |


*Defined at line 36 of ./game/shared/hl1/weapon_squeakgrenade.cpp*

======================	   SQUEAK START======================

| enum  |

--

| GAME_NORMAL |
| GAME_SINGLEPLAYER_ONLY |
| GAME_MULTIPLAYER_ONLY |


*Defined at line 42 of ./mainui/Primitive.h*

 engine constants

| enum  |

--

| KEY_CONSOLE |
| KEY_GAME |
| KEY_MENU |


*Defined at line 49 of ./mainui/Primitive.h*

| enum  |

--

| QMF_GRAYED |
| QMF_INACTIVE |
| QMF_DROPSHADOW |
| QMF_SILENT |
| QMF_HASMOUSEFOCUS |
| QMF_MOUSEONLY |
| QMF_NOTIFY |
| QMF_HASKEYBOARDFOCUS |
| QMF_DIALOG |
| QMF_DISABLESCAILING |
| QMF_EVENTSIGNOREFOCUS |
| QMF_CLOSING |
| QMF_HIDDENBYPARENT |
| QMF_HIDDEN |


*Defined at line 56 of ./mainui/Primitive.h*

| enum ETextAlignment |

--

| QM_CENTER |
| QM_TOP |
| QM_BOTTOM |
| QM_LEFT |
| QM_RIGHT |
| QM_TOPLEFT |
| QM_TOPRIGHT |
| QM_BOTTOMLEFT |
| QM_BOTTOMRIGHT |


*Defined at line 77 of ./mainui/Primitive.h*

| enum EFocusAnimation |

--

| QM_NOFOCUSANIMATION |
| QM_HIGHLIGHTIFFOCUS |
| QM_PULSEIFFOCUS |


*Defined at line 91 of ./mainui/Primitive.h*

| enum ELetterCase |

--

| QM_NOLETTERCASE |
| QM_LOWERCASE |
| QM_UPPERCASE |


*Defined at line 98 of ./mainui/Primitive.h*

| enum ERenderMode |

--

| QM_DRAWNORMAL |
| QM_DRAWHOLES |
| QM_DRAWTRANS |
| QM_DRAWADDITIVE |


*Defined at line 105 of ./mainui/Primitive.h*

| enum EFontFlags |

--

| FONT_NONE |
| FONT_ITALIC |
| FONT_UNDERLINE |
| FONT_STRIKEOUT |


*Defined at line 7 of ./mainui/font/FontRenderer.h*

| enum EFontSizes |

--

| QM_DEFAULTFONT |
| QM_SMALLFONT |
| QM_BIGFONT |
| QM_BOLDFONT |


*Defined at line 47 of ./mainui/font/FontRenderer.h*

| enum menuEvent_e |

--

| QM_GOTFOCUS |
| QM_LOSTFOCUS |
| QM_RELEASED |
| QM_CHANGED |
| QM_PRESSED |
| QM_IMRESIZED |


*Defined at line 67 of ./mainui/EventSystem.h*

| enum EDefaultBtns |

--

| PC_NEW_GAME |
| PC_RESUME_GAME |
| PC_HAZARD_COURSE |
| PC_CONFIG |
| PC_LOAD_GAME |
| PC_SAVE_LOAD_GAME |
| PC_VIEW_README |
| PC_QUIT |
| PC_MULTIPLAYER |
| PC_EASY |
| PC_MEDIUM |
| PC_DIFFICULT |
| PC_SAVE_GAME |
| PC_LOAD_GAME2 |
| PC_CANCEL |
| PC_GAME_OPTIONS |
| PC_VIDEO |
| PC_AUDIO |
| PC_CONTROLS |
| PC_DONE |
| PC_QUICKSTART |
| PC_USE_DEFAULTS |
| PC_OK |
| PC_VID_OPT |
| PC_VID_MODES |
| PC_ADV_CONTROLS |
| PC_ORDER_HL |
| PC_DELETE |
| PC_INET_GAME |
| PC_CHAT_ROOMS |
| PC_LAN_GAME |
| PC_CUSTOMIZE |
| PC_SKIP |
| PC_EXIT |
| PC_CONNECT |
| PC_REFRESH |
| PC_FILTER |
| PC_FILTER2 |
| PC_CREATE |
| PC_CREATE_GAME |
| PC_CHAT_ROOMS2 |
| PC_LIST_ROOMS |
| PC_SEARCH |
| PC_SERVERS |
| PC_JOIN |
| PC_FIND |
| PC_CREATE_ROOM |
| PC_JOIN_GAME |
| PC_SEARCH_GAMES |
| PC_FIND_GAME |
| PC_START_GAME |
| PC_VIEW_GAME_INFO |
| PC_UPDATE |
| PC_ADD_SERVER |
| PC_DISCONNECT |
| PC_CONSOLE |
| PC_CONTENT_CONTROL |
| PC_UPDATE2 |
| PC_VISIT_WON |
| PC_PREVIEWS |
| PC_ADV_OPT |
| PC_3DINFO_SITE |
| PC_CUSTOM_GAME |
| PC_ACTIVATE |
| PC_INSTALL |
| PC_VISIT_WEB_SITE |
| PC_REFRESH_LIST |
| PC_DEACTIVATE |
| PC_ADV_OPT2 |
| PC_SPECTATE_GAME |
| PC_SPECTATE_GAMES |
| PC_BUTTONCOUNT |


*Defined at line 19 of ./mainui/BtnsBMPTable.h*

| enum class EGuiRenderMode |

--

| DRAWNORMAL |
| DRAWHOLES |
| DRAWTRANS |
| DRAWADDITIVE |


*Defined at line 14 of ./engine/gui_int.h*

 Redefined from Primitive.h in mainui 

| enum ETextFlags |

--

| ETF_FORCECOL |
| ETF_SHADOW |
| ETF_NOSIZELIMIT |
| ETF_ADDITIVE |


*Defined at line 210 of ./mainui/BaseMenu.h*

| enum class EModelType |

--

| UNKNOWN |
| NORMAL |
| MAP |


*Defined at line 165 of ./engine/common/mod_local.h*

 Model type enums 

| enum fragsize_e |

--

| FRAGSIZE_FRAG |
| FRAGSIZE_SPLIT |
| FRAGSIZE_UNRELIABLE |


*Defined at line 185 of ./engine/common/netchan.h*

| enum  |

--

| scrshot_inactive |
| scrshot_normal |
| scrshot_snapshot |
| scrshot_plaque |
| scrshot_savegame |
| scrshot_envshot |
| scrshot_skyshot |
| scrshot_mapshot |


*Defined at line 281 of ./engine/client/client.h*

==================================================================

the client_static_t structure is persistant through an arbitrary numberof server connections

==================================================================

| enum  |

--

| CL_LOADING |
| CL_ACTIVE |
| CL_PAUSED |
| CL_CHANGELEVEL |


*Defined at line 294 of ./engine/client/client.h*

 client screen state

| enum  |

--

| NET_REQUEST_CANCEL |
| NET_REQUEST_GAMEUI |
| NET_REQUEST_CLIENT |


*Defined at line 414 of ./engine/client/client.h*

| enum  |

--

| ss_dead |
| ss_loading |
| ss_active |


*Defined at line 80 of ./engine/server/server.h*

| enum  |

--

| cs_free |
| cs_zombie |
| cs_connected |
| cs_spawned |


*Defined at line 87 of ./engine/server/server.h*

| enum  |

--

| us_inactive |
| us_processing |
| us_complete |


*Defined at line 95 of ./engine/server/server.h*

| enum base_command_type |

--

| HM_DONTCARE |
| HM_CVAR |
| HM_CMD |
| HM_CMDALIAS |


*Defined at line 26 of ./engine/common/base_cmd.h*

| enum  |

--

| MZ_DEFAULT_STRATEGY |
| MZ_FILTERED |
| MZ_HUFFMAN_ONLY |
| MZ_RLE |
| MZ_FIXED |


*Defined at line 212 of ./engine/common/miniz.h*

 Compression strategies. 

| enum  |

--

| MZ_NO_COMPRESSION |
| MZ_BEST_SPEED |
| MZ_BEST_COMPRESSION |
| MZ_UBER_COMPRESSION |
| MZ_DEFAULT_LEVEL |
| MZ_DEFAULT_COMPRESSION |


*Defined at line 231 of ./engine/common/miniz.h*

 Compression levels: 0-9 are the standard zlib-style levels, 10 is best possible compression (not zlib compatible, and may be very slow), MZ_DEFAULT_COMPRESSION=MZ_DEFAULT_LEVEL. 

| enum  |

--

| MZ_NO_FLUSH |
| MZ_PARTIAL_FLUSH |
| MZ_SYNC_FLUSH |
| MZ_FULL_FLUSH |
| MZ_FINISH |
| MZ_BLOCK |


*Defined at line 251 of ./engine/common/miniz.h*

 Flush values. For typical usage you only need MZ_NO_FLUSH and MZ_FINISH. The other values are for advanced use (refer to the zlib docs). 

| enum  |

--

| MZ_OK |
| MZ_STREAM_END |
| MZ_NEED_DICT |
| MZ_ERRNO |
| MZ_STREAM_ERROR |
| MZ_DATA_ERROR |
| MZ_MEM_ERROR |
| MZ_BUF_ERROR |
| MZ_VERSION_ERROR |
| MZ_PARAM_ERROR |


*Defined at line 262 of ./engine/common/miniz.h*

 Return status codes. MZ_PARAM_ERROR is non-standard. 

| enum  |

--

| TDEFL_HUFFMAN_ONLY |
| TDEFL_DEFAULT_MAX_PROBES |
| TDEFL_MAX_PROBES_MASK |


*Defined at line 582 of ./engine/common/miniz.h*

 tdefl_init() compression flags logically OR'd together (low 12 bits contain the max. number of probes per dictionary search): 

 TDEFL_DEFAULT_MAX_PROBES: The compressor defaults to 128 dictionary probes per dictionary search. 0=Huffman only, 1=Huffman+LZ (fastest/crap compression), 4095=Huffman+LZ (slowest/best compression). 

| enum  |

--

| TDEFL_WRITE_ZLIB_HEADER |
| TDEFL_COMPUTE_ADLER32 |
| TDEFL_GREEDY_PARSING_FLAG |
| TDEFL_NONDETERMINISTIC_PARSING_FLAG |
| TDEFL_RLE_MATCHES |
| TDEFL_FILTER_MATCHES |
| TDEFL_FORCE_ALL_STATIC_BLOCKS |
| TDEFL_FORCE_ALL_RAW_BLOCKS |


*Defined at line 598 of ./engine/common/miniz.h*

 TDEFL_WRITE_ZLIB_HEADER: If set, the compressor outputs a zlib header before the deflate data, and the Adler-32 of the source data at the end. Otherwise, you'll get raw deflate data. 

 TDEFL_COMPUTE_ADLER32: Always compute the adler-32 of the input data (even when not writing zlib headers). 

 TDEFL_GREEDY_PARSING_FLAG: Set to use faster greedy parsing, instead of more efficient lazy parsing. 

 TDEFL_NONDETERMINISTIC_PARSING_FLAG: Enable to decrease the compressor's initialization time to the minimum, but the output may vary from run to run given the same input (depending on the contents of memory). 

 TDEFL_RLE_MATCHES: Only look for RLE matches (matches with a distance of 1) 

 TDEFL_FILTER_MATCHES: Discards matches <= 5 chars if enabled. 

 TDEFL_FORCE_ALL_STATIC_BLOCKS: Disable usage of optimized Huffman tables. 

 TDEFL_FORCE_ALL_RAW_BLOCKS: Only use raw (uncompressed) deflate blocks. 

 The low 12 bits are reserved to control the max # of hash probes per dictionary lookup (see TDEFL_MAX_PROBES_MASK). 

| enum  |

--

| TDEFL_MAX_HUFF_TABLES |
| TDEFL_MAX_HUFF_SYMBOLS_0 |
| TDEFL_MAX_HUFF_SYMBOLS_1 |
| TDEFL_MAX_HUFF_SYMBOLS_2 |
| TDEFL_LZ_DICT_SIZE |
| TDEFL_LZ_DICT_SIZE_MASK |
| TDEFL_MIN_MATCH_LEN |
| TDEFL_MAX_MATCH_LEN |


*Defined at line 644 of ./engine/common/miniz.h*

| enum  |

--

| TDEFL_LZ_CODE_BUF_SIZE |
| TDEFL_OUT_BUF_SIZE |
| TDEFL_MAX_HUFF_SYMBOLS |
| TDEFL_LZ_HASH_BITS |
| TDEFL_LEVEL1_HASH_SIZE_MASK |
| TDEFL_LZ_HASH_SHIFT |
| TDEFL_LZ_HASH_SIZE |


*Defined at line 669 of ./engine/common/miniz.h*

| enum  |

--

| TDEFL_STATUS_BAD_PARAM |
| TDEFL_STATUS_PUT_BUF_FAILED |
| TDEFL_STATUS_OKAY |
| TDEFL_STATUS_DONE |


*Defined at line 682 of ./engine/common/miniz.h*

 The low-level tdefl functions below may be used directly if the above helper functions aren't flexible enough. The low-level functions don't make any heap allocations, unlike the above helper functions. 

| enum  |

--

| TDEFL_NO_FLUSH |
| TDEFL_SYNC_FLUSH |
| TDEFL_FULL_FLUSH |
| TDEFL_FINISH |


*Defined at line 690 of ./engine/common/miniz.h*

 Must map to MZ_NO_FLUSH, MZ_SYNC_FLUSH, etc. enums 

| enum  |

--

| TINFL_FLAG_PARSE_ZLIB_HEADER |
| TINFL_FLAG_HAS_MORE_INPUT |
| TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF |
| TINFL_FLAG_COMPUTE_ADLER32 |


*Defined at line 771 of ./engine/common/miniz.h*

 Decompression flags used by tinfl_decompress(). 

 TINFL_FLAG_PARSE_ZLIB_HEADER: If set, the input has a valid zlib header and ends with an adler32 checksum (it's a valid zlib stream). Otherwise, the input is a raw deflate stream. 

 TINFL_FLAG_HAS_MORE_INPUT: If set, there are more input bytes available beyond the end of the supplied input buffer. If clear, the input buffer contains all remaining input. 

 TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF: If set, the output buffer is large enough to hold the entire decompressed stream. If clear, the output buffer is at least the size of the dictionary (typically 32KB). 

 TINFL_FLAG_COMPUTE_ADLER32: Force adler-32 checksum computation of the decompressed bytes. 

| enum  |

--

| TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS |
| TINFL_STATUS_BAD_PARAM |
| TINFL_STATUS_ADLER32_MISMATCH |
| TINFL_STATUS_FAILED |
| TINFL_STATUS_DONE |
| TINFL_STATUS_NEEDS_MORE_INPUT |
| TINFL_STATUS_HAS_MORE_OUTPUT |


*Defined at line 814 of ./engine/common/miniz.h*

 Return status. 

| enum  |

--

| TINFL_MAX_HUFF_TABLES |
| TINFL_MAX_HUFF_SYMBOLS_0 |
| TINFL_MAX_HUFF_SYMBOLS_1 |
| TINFL_MAX_HUFF_SYMBOLS_2 |
| TINFL_FAST_LOOKUP_BITS |
| TINFL_FAST_LOOKUP_SIZE |


*Defined at line 861 of ./engine/common/miniz.h*

 Internal/private bits follow. 

| enum  |

--

| CB_HINT_NO |
| CB_HINT_POSX |
| CB_HINT_NEGX |
| CB_HINT_POSZ |
| CB_HINT_NEGZ |
| CB_HINT_POSY |
| CB_HINT_NEGY |
| CB_FACECOUNT |


*Defined at line 25 of ./engine/common/imagelib/imagelib.h*

 cubemap hints

| enum  |

--

| IL_HINT_NO |
| IL_HINT_Q1 |
| IL_HINT_HL |


*Defined at line 39 of ./engine/common/imagelib/imagelib.h*

| enum  |

--

| PNG_CT_GREY |
| PNG_CT_PALLETE |
| PNG_CT_RGB |
| PNG_CT_ALPHA |
| PNG_CT_RGBA |


*Defined at line 162 of ./engine/common/imagelib/imagelib.h*

========================================================================

.PNG image format	(Portable Network Graphics)

========================================================================

| enum  |

--

| PNG_F_NONE |
| PNG_F_SUB |
| PNG_F_UP |
| PNG_F_AVERAGE |
| PNG_F_PAETH |


*Defined at line 171 of ./engine/common/imagelib/imagelib.h*

| enum  |

--

| LUMP_NORMAL |
| LUMP_MASKED |
| LUMP_GRADIENT |
| LUMP_EXTENDED |
| LUMP_HALFLIFE |
| LUMP_QUAKE1 |


*Defined at line 315 of ./engine/common/imagelib/imagelib.h*

| enum  |

--

| PAL_INVALID |
| PAL_CUSTOM |
| PAL_QUAKE1 |
| PAL_HALFLIFE |


*Defined at line 325 of ./engine/common/imagelib/imagelib.h*

| enum  |

--

| LIBRARY_CLIENT |
| LIBRARY_SERVER |
| LIBRARY_GAMEUI |


*Defined at line 52 of ./engine/common/library.h*

| enum  |

--

| SCHED_SQUID_HURTHOP |
| SCHED_SQUID_SMELLFOOD |
| SCHED_SQUID_SEECRAB |
| SCHED_SQUID_EAT |
| SCHED_SQUID_SNIFF_AND_EAT |
| SCHED_SQUID_WALLOW |


*Defined at line 37 of ./game/server/npc/npc_bullsquid.cpp*

========================================================= monster-specific schedule types=========================================================

| enum  |

--

| TASK_SQUID_HOPTURN |


*Defined at line 50 of ./game/server/npc/npc_bullsquid.cpp*

========================================================= monster-specific tasks=========================================================

| enum  |

--

| BEAM_POINTS |
| BEAM_ENTPOINT |
| BEAM_ENTS |
| BEAM_HOSE |


*Defined at line 26 of ./engine/customentity.h*

 Beam types, encoded as a byte

| enum  |

--

| ST_SYNC |
| ST_RAND |


*Defined at line 37 of ./engine/sprite.h*

| enum  |

--

| FRAME_SINGLE |
| FRAME_GROUP |
| FRAME_ANGLED |


*Defined at line 44 of ./engine/sprite.h*

| enum  |

--

| SPR_NORMAL |
| SPR_ADDITIVE |
| SPR_INDEXALPHA |
| SPR_ALPHTEST |


*Defined at line 51 of ./engine/sprite.h*

| enum  |

--

| SPR_FWD_PARALLEL_UPRIGHT |
| SPR_FACING_UPRIGHT |
| SPR_FWD_PARALLEL |
| SPR_ORIENTED |
| SPR_FWD_PARALLEL_ORIENTED |


*Defined at line 59 of ./engine/sprite.h*

| enum  |

--

| SPR_CULL_FRONT |
| SPR_CULL_NONE |


*Defined at line 68 of ./engine/sprite.h*

| enum  |

--

| ALIAS_SINGLE |
| ALIAS_GROUP |


*Defined at line 52 of ./engine/alias.h*

| enum  |

--

| ALIAS_SKIN_SINGLE |
| ALIAS_SKIN_GROUP |


*Defined at line 58 of ./engine/alias.h*

| enum  |

--

| TLK_ANSWER |
| TLK_QUESTION |
| TLK_IDLE |
| TLK_STARE |
| TLK_USE |
| TLK_UNUSE |
| TLK_STOP |
| TLK_NOSHOOT |
| TLK_HELLO |
| TLK_PHELLO |
| TLK_PIDLE |
| TLK_PQUESTION |
| TLK_PLHURT1 |
| TLK_PLHURT2 |
| TLK_PLHURT3 |
| TLK_SMELL |
| TLK_WOUND |
| TLK_MORTAL |
| TLK_CGROUPS |


*Defined at line 43 of ./game/server/ai/ai_talkmonster.h*

| enum  |

--

| SCHED_CANT_FOLLOW |
| SCHED_MOVE_AWAY |
| SCHED_MOVE_AWAY_FOLLOW |
| SCHED_MOVE_AWAY_FAIL |
| LAST_TALKMONSTER_SCHEDULE |


*Defined at line 67 of ./game/server/ai/ai_talkmonster.h*

| enum  |

--

| TASK_CANT_FOLLOW |
| TASK_MOVE_AWAY_PATH |
| TASK_WALK_PATH_FOR_UNITS |
| TASK_TLK_RESPOND |
| TASK_TLK_SPEAK |
| TASK_TLK_HELLO |
| TASK_TLK_HEADRESET |
| TASK_TLK_STOPSHOOTING |
| TASK_TLK_STARE |
| TASK_TLK_LOOK_AT_CLIENT |
| TASK_TLK_CLIENT_STARE |
| TASK_TLK_EYECONTACT |
| TASK_TLK_IDEALYAW |
| TASK_FACE_PLAYER |
| LAST_TALKMONSTER_TASK |


*Defined at line 77 of ./game/server/ai/ai_talkmonster.h*

| enum SS_INTERRUPT |

--

| SS_INTERRUPT_IDLE |
| SS_INTERRUPT_BY_NAME |
| SS_INTERRUPT_AI |


*Defined at line 34 of ./game/server/ai/ai_scripted.h*

| enum  |

--

| HEAD_GLASSES |
| HEAD_EINSTEIN |
| HEAD_LUTHER |
| HEAD_SLICK |


*Defined at line 32 of ./game/server/npc/npc_scientist.cpp*

| enum  |

--

| SCHED_HIDE |
| SCHED_FEAR |
| SCHED_PANIC |
| SCHED_STARTLE |
| SCHED_TARGET_CHASE_SCARED |
| SCHED_TARGET_FACE_SCARED |


*Defined at line 40 of ./game/server/npc/npc_scientist.cpp*

| enum  |

--

| TASK_SAY_HEAL |
| TASK_HEAL |
| TASK_SAY_FEAR |
| TASK_RUN_PATH_SCARED |
| TASK_SCREAM |
| TASK_RANDOM_SCREAM |
| TASK_MOVE_TO_TARGET_RANGE_SCARED |


*Defined at line 50 of ./game/server/npc/npc_scientist.cpp*

| enum  |

--

| SITTING_ANIM_sitlookleft |
| SITTING_ANIM_sitlookright |
| SITTING_ANIM_sitscared |
| SITTING_ANIM_sitting2 |
| SITTING_ANIM_sitting3 |


*Defined at line 1193 of ./game/server/npc/npc_scientist.cpp*

 animation sequence aliases 

| enum mp5_e |

--

| MP5_LONGIDLE |
| MP5_IDLE1 |
| MP5_LAUNCH |
| MP5_RELOAD |
| MP5_DEPLOY |
| MP5_FIRE1 |
| MP5_FIRE2 |
| MP5_FIRE3 |


*Defined at line 27 of ./game/shared/hl1/weapon_mp5.cpp*

| enum  |

--

| CUSTOM_NONE |
| CUSTOM_SERVER_ENCODE |
| CUSTOM_CLIENT_ENCODE |


*Defined at line 41 of ./engine/common/net_encode.h*

| enum  |

--

| DELTA_ENTITY |
| DELTA_PLAYER |
| DELTA_STATIC |


*Defined at line 49 of ./engine/common/net_encode.h*

 don't change order!

| enum python_e |

--

| PYTHON_IDLE1 |
| PYTHON_FIDGET |
| PYTHON_FIRE1 |
| PYTHON_RELOAD |
| PYTHON_HOLSTER |
| PYTHON_DRAW |
| PYTHON_IDLE2 |
| PYTHON_IDLE3 |


*Defined at line 25 of ./game/shared/hl1/weapon_python.cpp*

| enum ECellType |

--

| CELL_TEXT |
| CELL_IMAGE_DEFAULT |
| CELL_IMAGE_ADDITIVE |
| CELL_IMAGE_TRANS |
| CELL_IMAGE_HOLES |


*Defined at line 20 of ./mainui/model/BaseModel.h*

| enum optdec |

--

| autodec |
| generic |
| nodec |


*Defined at line 238 of ./engine/common/soundlib/libmpg/synth.cpp*

| enum glock_e |

--

| GLOCK_IDLE1 |
| GLOCK_IDLE2 |
| GLOCK_IDLE3 |
| GLOCK_SHOOT |
| GLOCK_SHOOT_EMPTY |
| GLOCK_RELOAD |
| GLOCK_RELOAD_NOT_EMPTY |
| GLOCK_DRAW |
| GLOCK_HOLSTER |
| GLOCK_ADD_SILENCER |


*Defined at line 24 of ./game/shared/hl1/weapon_glock.cpp*

| enum TANKBULLET |

--

| TANK_BULLET_NONE |
| TANK_BULLET_9MM |
| TANK_BULLET_MP5 |
| TANK_BULLET_12MM |


*Defined at line 33 of ./game/server/func_tank.cpp*

| enum mpg123_channelcount |

--

| MPG123_MONO |
| MPG123_STEREO |


*Defined at line 18 of ./engine/common/soundlib/libmpg/format.cpp*

| enum crowbar_e |

--

| CROWBAR_IDLE |
| CROWBAR_DRAW |
| CROWBAR_HOLSTER |
| CROWBAR_ATTACK1HIT |
| CROWBAR_ATTACK1MISS |
| CROWBAR_ATTACK2MISS |
| CROWBAR_ATTACK2HIT |
| CROWBAR_ATTACK3MISS |
| CROWBAR_ATTACK3HIT |


*Defined at line 30 of ./game/shared/hl1/weapon_crowbar.cpp*

======================	   CROWBAR START======================

| enum  |

--

| event_down |
| event_up |
| event_motion |


*Defined at line 51 of ./engine/client/input.h*

 in_touch.c

| enum  |

--

| JOY_HAT_CENTERED |
| JOY_HAT_UP |
| JOY_HAT_RIGHT |
| JOY_HAT_DOWN |
| JOY_HAT_LEFT |
| JOY_HAT_RIGHTUP |
| JOY_HAT_RIGHTDOWN |
| JOY_HAT_LEFTUP |
| JOY_HAT_LEFTDOWN |


*Defined at line 81 of ./engine/client/input.h*

 in_joy.c

| enum class ENetworkedFieldType |

--

| SERVER_TO_CLIENT |
| CLIENT_TO_SERVER |


*Defined at line 37 of ./public/reflection.h*

| enum class ENetworkType |

--

| BYTE |
| SHORT |
| INT |
| LONG |
| FLOAT |
| DOUBLE |
| STRING |


*Defined at line 66 of ./networksystem/networksystem.h*

| enum satchel_state |

--

| SATCHEL_IDLE |
| SATCHEL_READY |
| SATCHEL_RELOAD |


*Defined at line 27 of ./game/shared/hl1/weapon_satchel.cpp*

| enum satchel_e |

--

| SATCHEL_IDLE1 |
| SATCHEL_FIDGET1 |
| SATCHEL_DRAW |
| SATCHEL_DROP |


*Defined at line 34 of ./game/shared/hl1/weapon_satchel.cpp*

| enum satchel_radio_e |

--

| SATCHEL_RADIO_IDLE1 |
| SATCHEL_RADIO_FIDGET1 |
| SATCHEL_RADIO_DRAW |
| SATCHEL_RADIO_FIRE |
| SATCHEL_RADIO_HOLSTER |


*Defined at line 42 of ./game/shared/hl1/weapon_satchel.cpp*

| enum tripmine_e |

--

| TRIPMINE_IDLE1 |
| TRIPMINE_IDLE2 |
| TRIPMINE_ARM1 |
| TRIPMINE_ARM2 |
| TRIPMINE_FIDGET |
| TRIPMINE_HOLSTER |
| TRIPMINE_DRAW |
| TRIPMINE_WORLD |
| TRIPMINE_GROUND |


*Defined at line 29 of ./game/shared/hl1/weapon_tripmine.cpp*

======================	   TRIPMINE START======================

| enum crossbow_e |

--

| CROSSBOW_IDLE1 |
| CROSSBOW_IDLE2 |
| CROSSBOW_FIDGET1 |
| CROSSBOW_FIDGET2 |
| CROSSBOW_FIRE1 |
| CROSSBOW_FIRE2 |
| CROSSBOW_FIRE3 |
| CROSSBOW_RELOAD |
| CROSSBOW_DRAW1 |
| CROSSBOW_DRAW2 |
| CROSSBOW_HOLSTER1 |
| CROSSBOW_HOLSTER2 |


*Defined at line 243 of ./game/shared/hl1/weapon_crossbow.cpp*

======================	  CROSSBOW START======================

| enum shotgun_e |

--

| SHOTGUN_IDLE |
| SHOTGUN_FIRE |
| SHOTGUN_FIRE2 |
| SHOTGUN_RELOAD |
| SHOTGUN_PUMP |
| SHOTGUN_START_RELOAD |
| SHOTGUN_DRAW |
| SHOTGUN_HOLSTER |
| SHOTGUN_IDLE4 |
| SHOTGUN_IDLE_DEEP |


*Defined at line 29 of ./game/shared/hl1/weapon_shotgun.cpp*

| enum parse_codes |

--

| PARSE_MORE |
| PARSE_ERR |
| PARSE_END |
| PARSE_GOOD |
| PARSE_BAD |
| PARSE_RESYNC |
| PARSE_AGAIN |


*Defined at line 33 of ./engine/common/soundlib/libmpg/parse.cpp*

 PARSE_GOOD and PARSE_BAD have to be 1 and 0 (TRUE and FALSE), others can vary.

| enum  |

--

| T_NONE |
| T_BOOL |
| T_NUMBER |
| T_LIST |
| T_STRING |
| T_COUNT |


*Defined at line 23 of ./mainui/CFGScript.h*

| enum gauss_e |

--

| GAUSS_IDLE |
| GAUSS_IDLE2 |
| GAUSS_FIDGET |
| GAUSS_SPINUP |
| GAUSS_SPIN |
| GAUSS_FIRE |
| GAUSS_FIRE2 |
| GAUSS_HOLSTER |
| GAUSS_DRAW |


*Defined at line 82 of ./game/client/ev_hldm.h*

| enum rpg_e |

--

| RPG_IDLE |
| RPG_FIDGET |
| RPG_RELOAD |
| RPG_FIRE2 |
| RPG_HOLSTER1 |
| RPG_DRAW1 |
| RPG_HOLSTER2 |
| RPG_DRAW_UL |
| RPG_IDLE_UL |
| RPG_FIDGET_UL |


*Defined at line 1336 of ./game/client/ev_hldm.cpp*

======================	    RPG START ======================

| enum egon_e |

--

| EGON_IDLE1 |
| EGON_FIDGET1 |
| EGON_ALTFIREON |
| EGON_ALTFIRECYCLE |
| EGON_ALTFIREOFF |
| EGON_FIRE1 |
| EGON_FIRE2 |
| EGON_FIRE3 |
| EGON_FIRE4 |
| EGON_DRAW |
| EGON_HOLSTER |


*Defined at line 1376 of ./game/client/ev_hldm.cpp*

======================	    EGON END ======================

| enum EGON_FIRESTATE |

--

| FIRE_OFF |
| FIRE_CHARGE |


*Defined at line 1394 of ./game/client/ev_hldm.cpp*

| enum EGON_FIREMODE |

--

| FIRE_NARROW |
| FIRE_WIDE |


*Defined at line 1400 of ./game/client/ev_hldm.cpp*

| enum hgun_e |

--

| HGUN_IDLE1 |
| HGUN_FIDGETSWAY |
| HGUN_FIDGETSHAKE |
| HGUN_DOWN |
| HGUN_UP |
| HGUN_SHOOT |


*Defined at line 1580 of ./game/client/ev_hldm.cpp*

======================	   HORNET START======================

| enum  |

--

| HISTSLOT_EMPTY |
| HISTSLOT_AMMO |
| HISTSLOT_WEAP |
| HISTSLOT_ITEM |


*Defined at line 101 of ./game/client/ammohistory.h*

| enum CompareOperands_t |

--

| k_EEqual |
| k_EGreaterThan |
| k_ELessThan |
| k_EGreaterThanOrEqualTo |
| k_ELessThanOrEqualTo |


*Defined at line 170 of ./mainui/miniutl/utlrbtree.h*

 For use with FindClosest Move these to a common area if anyone else ever uses them

| enum FT_Pixel_Mode_ |

--

| FT_PIXEL_MODE_NONE |
| FT_PIXEL_MODE_MONO |
| FT_PIXEL_MODE_GRAY |
| FT_PIXEL_MODE_GRAY2 |
| FT_PIXEL_MODE_GRAY4 |
| FT_PIXEL_MODE_LCD |
| FT_PIXEL_MODE_LCD_V |
| FT_PIXEL_MODE_BGRA |
| FT_PIXEL_MODE_MAX |


*Defined at line 181 of /usr/include/freetype2/freetype/ftimage.h*

************************************************************************



:

   FT_Pixel_Mode

**<not a builtin command>** :   An enumeration type used to describe the format of pixels in a given   bitmap.  Note that additional formats may be added in the future.

**<not a builtin command>** :   FT_PIXEL_MODE_NONE ::     Value~0 is reserved.

   FT_PIXEL_MODE_MONO ::     A monochrome bitmap, using 1~bit per pixel.  Note that pixels are     stored in most-significant order (MSB), which means that the     left-most pixel in a byte has value 128.

   FT_PIXEL_MODE_GRAY ::     An 8-bit bitmap, generally used to represent anti-aliased glyph     images.  Each pixel is stored in one byte.  Note that the number of     'gray' levels is stored in the `num_grays` field of the **<not a builtin command>** _Bitmap     structure (it generally is 256).

   FT_PIXEL_MODE_GRAY2 ::     A 2-bit per pixel bitmap, used to represent embedded anti-aliased     bitmaps in font files according to the OpenType specification.  We     haven't found a single font using this format, however.

   FT_PIXEL_MODE_GRAY4 ::     A 4-bit per pixel bitmap, representing embedded anti-aliased bitmaps     in font files according to the OpenType specification.  We haven't     found a single font using this format, however.

   FT_PIXEL_MODE_LCD ::     An 8-bit bitmap, representing RGB or BGR decimated glyph images used     for display on LCD displays; the bitmap is three times wider than     the original glyph image.  See also **<not a builtin command>** _RENDER_MODE_LCD.

   FT_PIXEL_MODE_LCD_V ::     An 8-bit bitmap, representing RGB or BGR decimated glyph images used     for display on rotated LCD displays; the bitmap is three times     taller than the original glyph image.  See also**<not a builtin command>** _RENDER_MODE_LCD_V.

   FT_PIXEL_MODE_BGRA ::     [Since 2.5] An image with four 8-bit channels per pixel,     representing a color image (such as emoticons) with alpha channel.     For each pixel, the format is BGRA, which means, the blue channel     comes first in memory.  The color channels are pre-multiplied and in     the sRGB colorspace.  For example, full red at half-translucent     opacity will be represented as '00,00,80,80', not '00,00,FF,80'.     See also **<not a builtin command>** _LOAD_COLOR.

| enum FT_Glyph_Format_ |

--

| FT_GLYPH_FORMAT_NONE |
| FT_GLYPH_FORMAT_COMPOSITE |
| FT_GLYPH_FORMAT_BITMAP |
| FT_GLYPH_FORMAT_OUTLINE |
| FT_GLYPH_FORMAT_PLOTTER |


*Defined at line 736 of /usr/include/freetype2/freetype/ftimage.h*

************************************************************************



:

   FT_Glyph_Format

**<not a builtin command>** :   An enumeration type used to describe the format of a given glyph   image.  Note that this version of FreeType only supports two image   formats, even though future font drivers will be able to register   their own format.

**<not a builtin command>** :   FT_GLYPH_FORMAT_NONE ::     The value~0 is reserved.

   FT_GLYPH_FORMAT_COMPOSITE ::     The glyph image is a composite of several other images.  This format     is _only_ used with **<not a builtin command>** _LOAD_NO_RECURSE, and is used to report     compound glyphs (like accented characters).

   FT_GLYPH_FORMAT_BITMAP ::     The glyph image is a bitmap, and can be described as an **<not a builtin command>** _Bitmap.     You generally need to access the `bitmap` field of the**<not a builtin command>** _GlyphSlotRec structure to read it.

   FT_GLYPH_FORMAT_OUTLINE ::     The glyph image is a vectorial outline made of line segments and     Bezier arcs; it can be described as an **<not a builtin command>** _Outline; you generally     want to access the `outline` field of the **<not a builtin command>** _GlyphSlotRec structure     to read it.

   FT_GLYPH_FORMAT_PLOTTER ::     The glyph image is a vectorial path with no inside and outside     contours.  Some Type~1 fonts, like those in the Hershey family,     contain glyphs in this format.  These are described as **<not a builtin command>** _Outline,     but FreeType isn't currently capable of rendering them correctly.

| enum  |

--

| FT_Mod_Err_Base |
| FT_Mod_Err_Autofit |
| FT_Mod_Err_BDF |
| FT_Mod_Err_Bzip2 |
| FT_Mod_Err_Cache |
| FT_Mod_Err_CFF |
| FT_Mod_Err_CID |
| FT_Mod_Err_Gzip |
| FT_Mod_Err_LZW |
| FT_Mod_Err_OTvalid |
| FT_Mod_Err_PCF |
| FT_Mod_Err_PFR |
| FT_Mod_Err_PSaux |
| FT_Mod_Err_PShinter |
| FT_Mod_Err_PSnames |
| FT_Mod_Err_Raster |
| FT_Mod_Err_SFNT |
| FT_Mod_Err_Smooth |
| FT_Mod_Err_TrueType |
| FT_Mod_Err_Type1 |
| FT_Mod_Err_Type42 |
| FT_Mod_Err_Winfonts |
| FT_Mod_Err_GXvalid |
| FT_Mod_Err_Max |


*Defined at line 147 of /usr/include/freetype2/freetype/ftmoderr.h*

| enum  |

--

| FT_Err_Ok |
| FT_Err_Cannot_Open_Resource |
| FT_Err_Unknown_File_Format |
| FT_Err_Invalid_File_Format |
| FT_Err_Invalid_Version |
| FT_Err_Lower_Module_Version |
| FT_Err_Invalid_Argument |
| FT_Err_Unimplemented_Feature |
| FT_Err_Invalid_Table |
| FT_Err_Invalid_Offset |
| FT_Err_Array_Too_Large |
| FT_Err_Missing_Module |
| FT_Err_Missing_Property |
| FT_Err_Invalid_Glyph_Index |
| FT_Err_Invalid_Character_Code |
| FT_Err_Invalid_Glyph_Format |
| FT_Err_Cannot_Render_Glyph |
| FT_Err_Invalid_Outline |
| FT_Err_Invalid_Composite |
| FT_Err_Too_Many_Hints |
| FT_Err_Invalid_Pixel_Size |
| FT_Err_Invalid_Handle |
| FT_Err_Invalid_Library_Handle |
| FT_Err_Invalid_Driver_Handle |
| FT_Err_Invalid_Face_Handle |
| FT_Err_Invalid_Size_Handle |
| FT_Err_Invalid_Slot_Handle |
| FT_Err_Invalid_CharMap_Handle |
| FT_Err_Invalid_Cache_Handle |
| FT_Err_Invalid_Stream_Handle |
| FT_Err_Too_Many_Drivers |
| FT_Err_Too_Many_Extensions |
| FT_Err_Out_Of_Memory |
| FT_Err_Unlisted_Object |
| FT_Err_Cannot_Open_Stream |
| FT_Err_Invalid_Stream_Seek |
| FT_Err_Invalid_Stream_Skip |
| FT_Err_Invalid_Stream_Read |
| FT_Err_Invalid_Stream_Operation |
| FT_Err_Invalid_Frame_Operation |
| FT_Err_Nested_Frame_Access |
| FT_Err_Invalid_Frame_Read |
| FT_Err_Raster_Uninitialized |
| FT_Err_Raster_Corrupted |
| FT_Err_Raster_Overflow |
| FT_Err_Raster_Negative_Height |
| FT_Err_Too_Many_Caches |
| FT_Err_Invalid_Opcode |
| FT_Err_Too_Few_Arguments |
| FT_Err_Stack_Overflow |
| FT_Err_Code_Overflow |
| FT_Err_Bad_Argument |
| FT_Err_Divide_By_Zero |
| FT_Err_Invalid_Reference |
| FT_Err_Debug_OpCode |
| FT_Err_ENDF_In_Exec_Stream |
| FT_Err_Nested_DEFS |
| FT_Err_Invalid_CodeRange |
| FT_Err_Execution_Too_Long |
| FT_Err_Too_Many_Function_Defs |
| FT_Err_Too_Many_Instruction_Defs |
| FT_Err_Table_Missing |
| FT_Err_Horiz_Header_Missing |
| FT_Err_Locations_Missing |
| FT_Err_Name_Table_Missing |
| FT_Err_CMap_Table_Missing |
| FT_Err_Hmtx_Table_Missing |
| FT_Err_Post_Table_Missing |
| FT_Err_Invalid_Horiz_Metrics |
| FT_Err_Invalid_CharMap_Format |
| FT_Err_Invalid_PPem |
| FT_Err_Invalid_Vert_Metrics |
| FT_Err_Could_Not_Find_Context |
| FT_Err_Invalid_Post_Table_Format |
| FT_Err_Invalid_Post_Table |
| FT_Err_DEF_In_Glyf_Bytecode |
| FT_Err_Missing_Bitmap |
| FT_Err_Syntax_Error |
| FT_Err_Stack_Underflow |
| FT_Err_Ignore |
| FT_Err_No_Unicode_Glyph_Name |
| FT_Err_Glyph_Too_Big |
| FT_Err_Missing_Startfont_Field |
| FT_Err_Missing_Font_Field |
| FT_Err_Missing_Size_Field |
| FT_Err_Missing_Fontboundingbox_Field |
| FT_Err_Missing_Chars_Field |
| FT_Err_Missing_Startchar_Field |
| FT_Err_Missing_Encoding_Field |
| FT_Err_Missing_Bbx_Field |
| FT_Err_Bbx_Too_Big |
| FT_Err_Corrupted_Font_Header |
| FT_Err_Corrupted_Font_Glyphs |
| FT_Err_Max |


*Defined at line 195 of /usr/include/freetype2/freetype/fterrors.h*

| enum FT_Encoding_ |

--

| FT_ENCODING_NONE |
| FT_ENCODING_MS_SYMBOL |
| FT_ENCODING_UNICODE |
| FT_ENCODING_SJIS |
| FT_ENCODING_PRC |
| FT_ENCODING_BIG5 |
| FT_ENCODING_WANSUNG |
| FT_ENCODING_JOHAB |
| FT_ENCODING_GB2312 |
| FT_ENCODING_MS_SJIS |
| FT_ENCODING_MS_GB2312 |
| FT_ENCODING_MS_BIG5 |
| FT_ENCODING_MS_WANSUNG |
| FT_ENCODING_MS_JOHAB |
| FT_ENCODING_ADOBE_STANDARD |
| FT_ENCODING_ADOBE_EXPERT |
| FT_ENCODING_ADOBE_CUSTOM |
| FT_ENCODING_ADOBE_LATIN_1 |
| FT_ENCODING_OLD_LATIN_2 |
| FT_ENCODING_APPLE_ROMAN |


*Defined at line 756 of /usr/include/freetype2/freetype/freetype.h*

************************************************************************



:

   FT_Encoding

**<not a builtin command>** :   An enumeration to specify character sets supported by charmaps.  Used   in the **<not a builtin command>** _Select_Charmap API function.



**note**:   Despite the name, this enumeration lists specific character   repertories (i.e., charsets), and not text encoding methods (e.g.,   UTF-8, UTF-16, etc.).

   Other encodings might be defined in the future.

**<not a builtin command>** :   FT_ENCODING_NONE ::     The encoding value~0 is reserved for all formats except BDF, PCF,     and Windows FNT; see below for more information.

   FT_ENCODING_UNICODE ::     The Unicode character set.  This value covers all versions of the     Unicode repertoire, including ASCII and Latin-1.  Most fonts include     a Unicode charmap, but not all of them.

     For example, if you want to access Unicode value U+1F028 (and the     font contains it), use value 0x1F028 as the input value for**<not a builtin command>** _Get_Char_Index.

   FT_ENCODING_MS_SYMBOL ::     Microsoft Symbol encoding, used to encode mathematical symbols and     wingdings.  For more information, see     'https://www.microsoft.com/typography/otspec/recom.htm#non-standard-symbol-fonts',     'http://www.kostis.net/charsets/symbol.htm', and     'http://www.kostis.net/charsets/wingding.htm'.

     This encoding uses character codes from the PUA (Private Unicode     Area) in the range U+F020-U+F0FF.

   FT_ENCODING_SJIS ::     Shift JIS encoding for Japanese.  More info at     'https://en.wikipedia.org/wiki/Shift_JIS'.  See note on multi-byte     encodings below.

   FT_ENCODING_PRC ::     Corresponds to encoding systems mainly for Simplified Chinese as     used in People's Republic of China (PRC).  The encoding layout is     based on GB~2312 and its supersets GBK and GB~18030.

   FT_ENCODING_BIG5 ::     Corresponds to an encoding system for Traditional Chinese as used in     Taiwan and Hong Kong.

   FT_ENCODING_WANSUNG ::     Corresponds to the Korean encoding system known as Extended Wansung     (MS Windows code page 949).  For more information see     'https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/bestfit949.txt'.

   FT_ENCODING_JOHAB ::     The Korean standard character set (KS~C 5601-1992), which     corresponds to MS Windows code page 1361.  This character set     includes all possible Hangul character combinations.

   FT_ENCODING_ADOBE_LATIN_1 ::     Corresponds to a Latin-1 encoding as defined in a Type~1 PostScript     font.  It is limited to 256 character codes.

   FT_ENCODING_ADOBE_STANDARD ::     Adobe Standard encoding, as found in Type~1, CFF, and OpenType/CFF     fonts.  It is limited to 256 character codes.

   FT_ENCODING_ADOBE_EXPERT ::     Adobe Expert encoding, as found in Type~1, CFF, and OpenType/CFF     fonts.  It is limited to 256 character codes.

   FT_ENCODING_ADOBE_CUSTOM ::     Corresponds to a custom encoding, as found in Type~1, CFF, and     OpenType/CFF fonts.  It is limited to 256 character codes.

   FT_ENCODING_APPLE_ROMAN ::     Apple roman encoding.  Many TrueType and OpenType fonts contain a     charmap for this 8-bit encoding, since older versions of Mac OS are     able to use it.

   FT_ENCODING_OLD_LATIN_2 ::     This value is deprecated and was neither used nor reported by     FreeType.  Don't use or test for it.

   FT_ENCODING_MS_SJIS ::     Same as FT_ENCODING_SJIS.  Deprecated.

   FT_ENCODING_MS_GB2312 ::     Same as FT_ENCODING_PRC.  Deprecated.

   FT_ENCODING_MS_BIG5 ::     Same as FT_ENCODING_BIG5.  Deprecated.

   FT_ENCODING_MS_WANSUNG ::     Same as FT_ENCODING_WANSUNG.  Deprecated.

   FT_ENCODING_MS_JOHAB ::     Same as FT_ENCODING_JOHAB.  Deprecated.



**note**:   By default, FreeType enables a Unicode charmap and tags it with   `FT_ENCODING_UNICODE` when it is either provided or can be generated   from PostScript glyph name dictionaries in the font file.  All other   encodings are considered legacy and tagged only if explicitly defined   in the font file.  Otherwise, `FT_ENCODING_NONE` is used.

   `FT_ENCODING_NONE` is set by the BDF and PCF drivers if the charmap is   neither Unicode nor ISO-8859-1 (otherwise it is set to   `FT_ENCODING_UNICODE`).  Use **<not a builtin command>** _Get_BDF_Charset_ID to find out which   encoding is really present.  If, for example, the `cs_registry` field   is 'KOI8' and the `cs_encoding` field is 'R', the font is encoded in   KOI8-R.

   `FT_ENCODING_NONE` is always set (with a single exception) by the   winfonts driver.  Use **<not a builtin command>** _Get_WinFNT_Header and examine the `charset`   field of the **<not a builtin command>** _WinFNT_HeaderRec structure to find out which encoding   is really present.  For example, **<not a builtin command>** _WinFNT_ID_CP1251 (204) means   Windows code page 1251 (for Russian).

   `FT_ENCODING_NONE` is set if `platform_id` is **<not a builtin command>** _PLATFORM_MACINTOSH   and `encoding_id` is not `TT_MAC_ID_ROMAN` (otherwise it is set to   `FT_ENCODING_APPLE_ROMAN`).

   If `platform_id` is **<not a builtin command>** _PLATFORM_MACINTOSH, use the function**<not a builtin command>** _Get_CMap_Language_ID to query the Mac language ID that may be   needed to be able to distinguish Apple encoding variants.  See

     https://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt

   to get an idea how to do that.  Basically, if the language ID is~0,   don't use it, otherwise subtract 1 from the language ID.  Then examine   `encoding_id`.  If, for example, `encoding_id` is `TT_MAC_ID_ROMAN`   and the language ID (minus~1) is `TT_MAC_LANGID_GREEK`, it is the   Greek encoding, not Roman.  `TT_MAC_ID_ARABIC` with   `TT_MAC_LANGID_FARSI` means the Farsi variant the Arabic encoding.

| enum FT_Size_Request_Type_ |

--

| FT_SIZE_REQUEST_TYPE_NOMINAL |
| FT_SIZE_REQUEST_TYPE_REAL_DIM |
| FT_SIZE_REQUEST_TYPE_BBOX |
| FT_SIZE_REQUEST_TYPE_CELL |
| FT_SIZE_REQUEST_TYPE_SCALES |
| FT_SIZE_REQUEST_TYPE_MAX |


*Defined at line 2563 of /usr/include/freetype2/freetype/freetype.h*

************************************************************************



:

   FT_Size_Request_Type

**<not a builtin command>** :   An enumeration type that lists the supported size request types, i.e.,   what input size (in font units) maps to the requested output size (in   pixels, as computed from the arguments of **<not a builtin command>** _Size_Request).

**<not a builtin command>** :   FT_SIZE_REQUEST_TYPE_NOMINAL ::     The nominal size.  The `units_per_EM` field of **<not a builtin command>** _FaceRec is used     to determine both scaling values.

     This is the standard scaling found in most applications.  In     particular, use this size request type for TrueType fonts if they     provide optical scaling or something similar.  Note, however, that     `units_per_EM` is a rather abstract value which bears no relation to     the actual size of the glyphs in a font.

   FT_SIZE_REQUEST_TYPE_REAL_DIM ::     The real dimension.  The sum of the `ascender` and (minus of) the     `descender` fields of **<not a builtin command>** _FaceRec is used to determine both scaling     values.

   FT_SIZE_REQUEST_TYPE_BBOX ::     The font bounding box.  The width and height of the `bbox` field of**<not a builtin command>** _FaceRec are used to determine the horizontal and vertical     scaling value, respectively.

   FT_SIZE_REQUEST_TYPE_CELL ::     The `max_advance_width` field of **<not a builtin command>** _FaceRec is used to determine     the horizontal scaling value; the vertical scaling value is     determined the same way as **<not a builtin command>** _SIZE_REQUEST_TYPE_REAL_DIM does.     Finally, both scaling values are set to the smaller one.  This type     is useful if you want to specify the font size for, say, a window of     a given dimension and 80x24 cells.

   FT_SIZE_REQUEST_TYPE_SCALES ::     Specify the scaling values directly.



**note**:   The above descriptions only apply to scalable formats.  For bitmap   formats, the behaviour is up to the driver.

   See the note section of **<not a builtin command>** _Size_Metrics if you wonder how size   requesting relates to scaling values.

| enum FT_Render_Mode_ |

--

| FT_RENDER_MODE_NORMAL |
| FT_RENDER_MODE_LIGHT |
| FT_RENDER_MODE_MONO |
| FT_RENDER_MODE_LCD |
| FT_RENDER_MODE_LCD_V |
| FT_RENDER_MODE_MAX |


*Defined at line 3262 of /usr/include/freetype2/freetype/freetype.h*

************************************************************************



:

   FT_Render_Mode

**<not a builtin command>** :   Render modes supported by FreeType~2.  Each mode corresponds to a   specific type of scanline conversion performed on the outline.

   For bitmap fonts and embedded bitmaps the `bitmap->pixel_mode` field   in the **<not a builtin command>** _GlyphSlotRec structure gives the format of the returned   bitmap.

   All modes except **<not a builtin command>** _RENDER_MODE_MONO use 256 levels of opacity,   indicating pixel coverage.  Use linear alpha blending and gamma   correction to correctly render non-monochrome glyph bitmaps onto a   surface; see **<not a builtin command>** _Render_Glyph.

**<not a builtin command>** :   FT_RENDER_MODE_NORMAL ::     Default render mode; it corresponds to 8-bit anti-aliased bitmaps.

   FT_RENDER_MODE_LIGHT ::     This is equivalent to **<not a builtin command>** _RENDER_MODE_NORMAL.  It is only defined as     a separate value because render modes are also used indirectly to     define hinting algorithm selectors.  See **<not a builtin command>** _LOAD_TARGET_XXX for     details.

   FT_RENDER_MODE_MONO ::     This mode corresponds to 1-bit bitmaps (with 2~levels of opacity).

   FT_RENDER_MODE_LCD ::     This mode corresponds to horizontal RGB and BGR subpixel displays     like LCD screens.  It produces 8-bit bitmaps that are 3~times the     width of the original glyph outline in pixels, and which use the**<not a builtin command>** _PIXEL_MODE_LCD mode.

   FT_RENDER_MODE_LCD_V ::     This mode corresponds to vertical RGB and BGR subpixel displays     (like PDA screens, rotated LCD displays, etc.).  It produces 8-bit     bitmaps that are 3~times the height of the original glyph outline in     pixels and use the **<not a builtin command>** _PIXEL_MODE_LCD_V mode.



**note**:   Should you define `FT_CONFIG_OPTION_SUBPIXEL_RENDERING` in your   `ftoption.h`, which enables patented ClearType-style rendering, the   LCD-optimized glyph bitmaps should be filtered to reduce color fringes   inherent to this technology.  You can either set up LCD filtering with**<not a builtin command>** _Library_SetLcdFilter or **<not a builtin command>** _Face_Properties, or do the filtering   yourself.  The default FreeType LCD rendering technology does not   require filtering.

   The selected render mode only affects vector glyphs of a font.   Embedded bitmaps often have a different pixel mode like**<not a builtin command>** _PIXEL_MODE_MONO.  You can use **<not a builtin command>** _Bitmap_Convert to transform them   into 8-bit pixmaps.

| enum FT_Kerning_Mode_ |

--

| FT_KERNING_DEFAULT |
| FT_KERNING_UNFITTED |
| FT_KERNING_UNSCALED |


*Defined at line 3419 of /usr/include/freetype2/freetype/freetype.h*

************************************************************************



:

   FT_Kerning_Mode

**<not a builtin command>** :   An enumeration to specify the format of kerning values returned by**<not a builtin command>** _Get_Kerning.

**<not a builtin command>** :   FT_KERNING_DEFAULT ::     Return grid-fitted kerning distances in 26.6 fractional pixels.

   FT_KERNING_UNFITTED ::     Return un-grid-fitted kerning distances in 26.6 fractional pixels.

   FT_KERNING_UNSCALED ::     Return the kerning vector in original font units.



**note**:   `FT_KERNING_DEFAULT` returns full pixel values; it also makes FreeType   heuristically scale down kerning distances at small ppem values so   that they don't become too big.

   Both `FT_KERNING_DEFAULT` and `FT_KERNING_UNFITTED` use the current   horizontal scaling factor (as set e.g. with **<not a builtin command>** _Set_Char_Size) to   convert font units to pixels.

| enum  |

--

| SCHED_BIG_NODE |
| SCHED_NODE_FAIL |


*Defined at line 771 of ./game/server/npc/npc_bigmomma.cpp*

========================================================= AI Schedules Specific to this monster=========================================================

| enum  |

--

| TASK_MOVE_TO_NODE_RANGE |
| TASK_FIND_NODE |
| TASK_PLAY_NODE_PRESEQUENCE |
| TASK_PLAY_NODE_SEQUENCE |
| TASK_PROCESS_NODE |
| TASK_WAIT_NODE |
| TASK_NODE_DELAY |
| TASK_NODE_YAW |


*Defined at line 777 of ./game/server/npc/npc_bigmomma.cpp*

| enum EPresets |

--

| EPRESET_NORMAL |
| EPRESET_DSL |
| EPRESET_SLOW |
| EPRESET_LAST |


*Defined at line 6 of ./mainui/menus/ConnectionWarning.cpp*

| enum  |

--

| SCHED_ASSASSIN_EXPOSED |
| SCHED_ASSASSIN_JUMP |
| SCHED_ASSASSIN_JUMP_ATTACK |
| SCHED_ASSASSIN_JUMP_LAND |


*Defined at line 37 of ./game/server/npc/npc_hassassin.cpp*

========================================================= monster-specific schedule types=========================================================

| enum  |

--

| TASK_ASSASSIN_FALL_TO_GROUND |


*Defined at line 49 of ./game/server/npc/npc_hassassin.cpp*

========================================================= monster-specific tasks=========================================================

| enum  |

--

| touch_command |
| touch_move |
| touch_joy |
| touch_dpad |
| touch_look |


*Defined at line 24 of ./engine/client/in_touch.cpp*

| enum  |

--

| state_none |
| state_edit |
| state_edit_move |


*Defined at line 33 of ./engine/client/in_touch.cpp*

| enum  |

--

| round_none |
| round_grid |
| round_aspect |


*Defined at line 40 of ./engine/client/in_touch.cpp*

| enum  |

--

| TENTACLE_ANIM_Pit_Idle |
| TENTACLE_ANIM_rise_to_Temp1 |
| TENTACLE_ANIM_Temp1_to_Floor |
| TENTACLE_ANIM_Floor_Idle |
| TENTACLE_ANIM_Floor_Fidget_Pissed |
| TENTACLE_ANIM_Floor_Fidget_SmallRise |
| TENTACLE_ANIM_Floor_Fidget_Wave |
| TENTACLE_ANIM_Floor_Strike |
| TENTACLE_ANIM_Floor_Tap |
| TENTACLE_ANIM_Floor_Rotate |
| TENTACLE_ANIM_Floor_Rear |
| TENTACLE_ANIM_Floor_Rear_Idle |
| TENTACLE_ANIM_Floor_to_Lev1 |
| TENTACLE_ANIM_Lev1_Idle |
| TENTACLE_ANIM_Lev1_Fidget_Claw |
| TENTACLE_ANIM_Lev1_Fidget_Shake |
| TENTACLE_ANIM_Lev1_Fidget_Snap |
| TENTACLE_ANIM_Lev1_Strike |
| TENTACLE_ANIM_Lev1_Tap |
| TENTACLE_ANIM_Lev1_Rotate |
| TENTACLE_ANIM_Lev1_Rear |
| TENTACLE_ANIM_Lev1_Rear_Idle |
| TENTACLE_ANIM_Lev1_to_Lev2 |
| TENTACLE_ANIM_Lev2_Idle |
| TENTACLE_ANIM_Lev2_Fidget_Shake |
| TENTACLE_ANIM_Lev2_Fidget_Swing |
| TENTACLE_ANIM_Lev2_Fidget_Tut |
| TENTACLE_ANIM_Lev2_Strike |
| TENTACLE_ANIM_Lev2_Tap |
| TENTACLE_ANIM_Lev2_Rotate |
| TENTACLE_ANIM_Lev2_Rear |
| TENTACLE_ANIM_Lev2_Rear_Idle |
| TENTACLE_ANIM_Lev2_to_Lev3 |
| TENTACLE_ANIM_Lev3_Idle |
| TENTACLE_ANIM_Lev3_Fidget_Shake |
| TENTACLE_ANIM_Lev3_Fidget_Side |
| TENTACLE_ANIM_Lev3_Fidget_Swipe |
| TENTACLE_ANIM_Lev3_Strike |
| TENTACLE_ANIM_Lev3_Tap |
| TENTACLE_ANIM_Lev3_Rotate |
| TENTACLE_ANIM_Lev3_Rear |
| TENTACLE_ANIM_Lev3_Rear_Idle |
| TENTACLE_ANIM_Lev1_Door_reach |
| TENTACLE_ANIM_Lev3_to_Engine |
| TENTACLE_ANIM_Engine_Idle |
| TENTACLE_ANIM_Engine_Sway |
| TENTACLE_ANIM_Engine_Swat |
| TENTACLE_ANIM_Engine_Bob |
| TENTACLE_ANIM_Engine_Death1 |
| TENTACLE_ANIM_Engine_Death2 |
| TENTACLE_ANIM_Engine_Death3 |
| TENTACLE_ANIM_none |


*Defined at line 167 of ./game/server/npc/npc_tentacle.cpp*

 animation sequence aliases 

| enum ECAM_Command |

--

| CAM_COMMAND_NONE |
| CAM_COMMAND_TOTHIRDPERSON |
| CAM_COMMAND_TOFIRSTPERSON |


*Defined at line 42 of ./game/client/in_camera.cpp*

| enum  |

--

| TYPE_SNIPERDOT |
| TYPE_ZOOM |


*Defined at line 13 of ./game/client/demo.h*

 Types of demo messages we can write/parse

| enum  |

--

| TRAIN_SAFE |
| TRAIN_BLOCKING |
| TRAIN_FOLLOWING |


*Defined at line 1579 of ./game/server/plats.cpp*

 This entity is a rotating/moving platform that will carry a train to a new track. It must be larger in X-Y planar area than the train, since it must contain the train within these dimensions in order to operate when the train is near it.

| enum  |

--

| MicrophoneVolume |
| OtherSpeakerScale |


*Defined at line 20 of ./common/ivoicetweak.h*

 These provide access to the voice controls.

| enum  |

--

| VID_NOMODE |
| VID_AUTOMODE |
| VID_NOMODE_POS |
| VID_AUTOMODE_POS |
| VID_MODES_POS |


*Defined at line 34 of ./mainui/menus/VideoModes.cpp*

| enum handgrenade_e |

--

| HANDGRENADE_IDLE |
| HANDGRENADE_FIDGET |
| HANDGRENADE_PINPULL |
| HANDGRENADE_THROW1 |
| HANDGRENADE_THROW2 |
| HANDGRENADE_THROW3 |
| HANDGRENADE_HOLSTER |
| HANDGRENADE_DRAW |


*Defined at line 26 of ./game/shared/hl1/weapon_frag.cpp*

| enum engineAxis_t |

--

| JOY_AXIS_SIDE |
| JOY_AXIS_FWD |
| JOY_AXIS_PITCH |
| JOY_AXIS_YAW |
| JOY_AXIS_RT |
| JOY_AXIS_LT |
| JOY_AXIS_NULL |


*Defined at line 32 of ./mainui/menus/Gamepad.cpp*

| enum  |

--

| TASK_ICHTHYOSAUR_CIRCLE_ENEMY |
| TASK_ICHTHYOSAUR_SWIM |
| TASK_ICHTHYOSAUR_FLOAT |


*Defined at line 216 of ./game/server/npc/npc_ichthyosaur.cpp*

========================================================= monster-specific tasks and states=========================================================

| enum cgltf_file_type |

--

| cgltf_file_type_invalid |
| cgltf_file_type_gltf |
| cgltf_file_type_glb |


*Defined at line 107 of ./thirdparty/cgltf/cgltf.h*

| enum cgltf_result |

--

| cgltf_result_success |
| cgltf_result_data_too_short |
| cgltf_result_unknown_format |
| cgltf_result_invalid_json |
| cgltf_result_invalid_gltf |
| cgltf_result_invalid_options |
| cgltf_result_file_not_found |
| cgltf_result_io_error |
| cgltf_result_out_of_memory |
| cgltf_result_legacy_gltf |


*Defined at line 114 of ./thirdparty/cgltf/cgltf.h*

| enum cgltf_buffer_view_type |

--

| cgltf_buffer_view_type_invalid |
| cgltf_buffer_view_type_indices |
| cgltf_buffer_view_type_vertices |


*Defined at line 150 of ./thirdparty/cgltf/cgltf.h*

| enum cgltf_attribute_type |

--

| cgltf_attribute_type_invalid |
| cgltf_attribute_type_position |
| cgltf_attribute_type_normal |
| cgltf_attribute_type_tangent |
| cgltf_attribute_type_texcoord |
| cgltf_attribute_type_color |
| cgltf_attribute_type_joints |
| cgltf_attribute_type_weights |


*Defined at line 157 of ./thirdparty/cgltf/cgltf.h*

| enum cgltf_component_type |

--

| cgltf_component_type_invalid |
| cgltf_component_type_r_8 |
| cgltf_component_type_r_8u |
| cgltf_component_type_r_16 |
| cgltf_component_type_r_16u |
| cgltf_component_type_r_32u |
| cgltf_component_type_r_32f |


*Defined at line 169 of ./thirdparty/cgltf/cgltf.h*

| enum cgltf_type |

--

| cgltf_type_invalid |
| cgltf_type_scalar |
| cgltf_type_vec2 |
| cgltf_type_vec3 |
| cgltf_type_vec4 |
| cgltf_type_mat2 |
| cgltf_type_mat3 |
| cgltf_type_mat4 |


*Defined at line 180 of ./thirdparty/cgltf/cgltf.h*

| enum cgltf_primitive_type |

--

| cgltf_primitive_type_points |
| cgltf_primitive_type_lines |
| cgltf_primitive_type_line_loop |
| cgltf_primitive_type_line_strip |
| cgltf_primitive_type_triangles |
| cgltf_primitive_type_triangle_strip |
| cgltf_primitive_type_triangle_fan |


*Defined at line 192 of ./thirdparty/cgltf/cgltf.h*

| enum cgltf_alpha_mode |

--

| cgltf_alpha_mode_opaque |
| cgltf_alpha_mode_mask |
| cgltf_alpha_mode_blend |


*Defined at line 203 of ./thirdparty/cgltf/cgltf.h*

| enum cgltf_animation_path_type |

--

| cgltf_animation_path_type_invalid |
| cgltf_animation_path_type_translation |
| cgltf_animation_path_type_rotation |
| cgltf_animation_path_type_scale |
| cgltf_animation_path_type_weights |


*Defined at line 210 of ./thirdparty/cgltf/cgltf.h*

| enum cgltf_interpolation_type |

--

| cgltf_interpolation_type_linear |
| cgltf_interpolation_type_step |
| cgltf_interpolation_type_cubic_spline |


*Defined at line 218 of ./thirdparty/cgltf/cgltf.h*

| enum cgltf_camera_type |

--

| cgltf_camera_type_invalid |
| cgltf_camera_type_perspective |
| cgltf_camera_type_orthographic |


*Defined at line 224 of ./thirdparty/cgltf/cgltf.h*

| enum cgltf_light_type |

--

| cgltf_light_type_invalid |
| cgltf_light_type_directional |
| cgltf_light_type_point |
| cgltf_light_type_spot |


*Defined at line 230 of ./thirdparty/cgltf/cgltf.h*

| enum  |

--

| JSMN_UNDEFINED |
| JSMN_OBJECT |
| JSMN_ARRAY |
| JSMN_STRING |
| JSMN_PRIMITIVE |


*Defined at line 683 of ./thirdparty/cgltf/cgltf.h*

 -- jsmn.h start -- Source: https://github.com/zserge/jsmn License: MIT

| enum jsmnerr |

--

| JSMN_ERROR_NOMEM |
| JSMN_ERROR_INVAL |
| JSMN_ERROR_PART |


*Defined at line 690 of ./thirdparty/cgltf/cgltf.h*

| enum  |

--

| expRandom |
| expDirected |


*Defined at line 19 of ./game/server/func_break.h*

| enum  |

--

| matGlass |
| matWood |
| matMetal |
| matFlesh |
| matCinderBlock |
| matCeilingTile |
| matComputer |
| matUnbreakableGlass |
| matRocks |
| matNone |
| matLastMaterial |


*Defined at line 24 of ./game/server/func_break.h*

| enum  |

--

| TURRET_ANIM_NONE |
| TURRET_ANIM_FIRE |
| TURRET_ANIM_SPIN |
| TURRET_ANIM_DEPLOY |
| TURRET_ANIM_RETIRE |
| TURRET_ANIM_DIE |


*Defined at line 44 of ./game/server/npc/npc_turret.cpp*

| enum EState |

--

| STATE_NONE |
| STATE_MENU |
| STATE_DOWNLOAD |
| STATE_CONNECTING |
| STATE_CONSOLE |


*Defined at line 29 of ./mainui/menus/ConnectionProgress.cpp*

| enum ESource |

--

| SOURCE_CONSOLE |
| SOURCE_SERVERBROWSER |
| SOURCE_CREATEGAME |


*Defined at line 38 of ./mainui/menus/ConnectionProgress.cpp*

| enum  |

--

| SCHED_GRUNT_SUPPRESS |
| SCHED_GRUNT_ESTABLISH_LINE_OF_FIRE |
| SCHED_GRUNT_COVER_AND_RELOAD |
| SCHED_GRUNT_SWEEP |
| SCHED_GRUNT_FOUND_ENEMY |
| SCHED_GRUNT_REPEL |
| SCHED_GRUNT_REPEL_ATTACK |
| SCHED_GRUNT_REPEL_LAND |
| SCHED_GRUNT_WAIT_FACE_ENEMY |
| SCHED_GRUNT_TAKECOVER_FAILED |
| SCHED_GRUNT_ELOF_FAIL |


*Defined at line 93 of ./game/server/npc/npc_hgrunt.cpp*

========================================================= monster-specific schedule types=========================================================

| enum  |

--

| TASK_GRUNT_FACE_TOSS_DIR |
| TASK_GRUNT_SPEAK_SENTENCE |
| TASK_GRUNT_CHECK_FIRE |


*Defined at line 111 of ./game/server/npc/npc_hgrunt.cpp*

========================================================= monster-specific tasks=========================================================

| enum  |

--

| HGRUNT_SENT_NONE |
| HGRUNT_SENT_GREN |
| HGRUNT_SENT_ALERT |
| HGRUNT_SENT_MONSTER |
| HGRUNT_SENT_COVER |
| HGRUNT_SENT_THROW |
| HGRUNT_SENT_CHARGE |
| HGRUNT_SENT_TAUNT |


*Defined at line 221 of ./game/server/npc/npc_hgrunt.cpp*

| enum  |

--

| TASK_SOUND_ATTACK |
| TASK_FLAME_SWEEP |


*Defined at line 384 of ./game/server/npc/npc_gargantua.cpp*

| enum connectionstate |

--

| HTTP_QUEUE |
| HTTP_OPENED |
| HTTP_SOCKET |
| HTTP_NS_RESOLVED |
| HTTP_CONNECTED |
| HTTP_REQUEST |
| HTTP_REQUEST_SENT |
| HTTP_RESPONSE_RECEIVED |
| HTTP_FREE |


*Defined at line 1778 of ./engine/common/net_ws.cpp*

| enum class EDockMode |

--

| NONE |
| FILL |


*Defined at line 14 of ./mainui/controls/Frame.h*

| enum  |

--

| SCHED_AGRUNT_SUPPRESS |
| SCHED_AGRUNT_THREAT_DISPLAY |


*Defined at line 32 of ./game/server/npc/npc_agrunt.cpp*

========================================================= monster-specific schedule types=========================================================

| enum  |

--

| TASK_AGRUNT_SETUP_HIDE_ATTACK |
| TASK_AGRUNT_GET_PATH_TO_ENEMY_CORPSE |


*Defined at line 41 of ./game/server/npc/npc_agrunt.cpp*

========================================================= monster-specific tasks=========================================================

| enum engineAxis_e |

--

| JOY_AXIS_SIDE |
| JOY_AXIS_FWD |
| JOY_AXIS_PITCH |
| JOY_AXIS_YAW |
| JOY_AXIS_RT |
| JOY_AXIS_LT |
| JOY_AXIS_NULL |


*Defined at line 29 of ./engine/client/in_joy.cpp*

| enum firemode_e |

--

| FIREMODE_TRACK |
| FIREMODE_FAST |


*Defined at line 37 of ./game/shared/hl1/weapon_hornetgun.cpp*

| enum sequenceCommandEnum_ |

--

| SEQUENCE_COMMAND_ERROR |
| SEQUENCE_COMMAND_PAUSE |
| SEQUENCE_COMMAND_FIRETARGETS |
| SEQUENCE_COMMAND_KILLTARGETS |
| SEQUENCE_COMMAND_TEXT |
| SEQUENCE_COMMAND_SOUND |
| SEQUENCE_COMMAND_GOSUB |
| SEQUENCE_COMMAND_SENTENCE |
| SEQUENCE_COMMAND_REPEAT |
| SEQUENCE_COMMAND_SETDEFAULTS |
| SEQUENCE_COMMAND_MODIFIER |
| SEQUENCE_COMMAND_POSTMODIFIER |
| SEQUENCE_COMMAND_NOOP |
| SEQUENCE_MODIFIER_EFFECT |
| SEQUENCE_MODIFIER_POSITION |
| SEQUENCE_MODIFIER_COLOR |
| SEQUENCE_MODIFIER_COLOR2 |
| SEQUENCE_MODIFIER_FADEIN |
| SEQUENCE_MODIFIER_FADEOUT |
| SEQUENCE_MODIFIER_HOLDTIME |
| SEQUENCE_MODIFIER_FXTIME |
| SEQUENCE_MODIFIER_SPEAKER |
| SEQUENCE_MODIFIER_LISTENER |
| SEQUENCE_MODIFIER_TEXTCHANNEL |


*Defined at line 40 of ./engine/sequence.h*

--------------------------------------------------------------------------- sequenceCommandEnum_e

 Enumerated sequence command types.---------------------------------------------------------------------------

| enum sequenceModifierBits |

--

| SEQUENCE_MODIFIER_EFFECT_BIT |
| SEQUENCE_MODIFIER_POSITION_BIT |
| SEQUENCE_MODIFIER_COLOR_BIT |
| SEQUENCE_MODIFIER_COLOR2_BIT |
| SEQUENCE_MODIFIER_FADEIN_BIT |
| SEQUENCE_MODIFIER_FADEOUT_BIT |
| SEQUENCE_MODIFIER_HOLDTIME_BIT |
| SEQUENCE_MODIFIER_FXTIME_BIT |
| SEQUENCE_MODIFIER_SPEAKER_BIT |
| SEQUENCE_MODIFIER_LISTENER_BIT |
| SEQUENCE_MODIFIER_TEXTCHANNEL_BIT |


*Defined at line 76 of ./engine/sequence.h*

-------------------------------------------------------------------------- sequenceDefaultBits_e

 Enumerated list of possible modifiers for a command.  This enumeration is used in a bitarray controlling what modifiers are specified for a command.---------------------------------------------------------------------------

| enum sequenceCommandType_ |

--

| SEQUENCE_TYPE_COMMAND |
| SEQUENCE_TYPE_MODIFIER |


*Defined at line 98 of ./engine/sequence.h*

--------------------------------------------------------------------------- sequenceCommandType_e

 Typeerated sequence command types.---------------------------------------------------------------------------

| enum  |

--

| TDEFL_MAX_SUPPORTED_HUFF_CODESIZE |


*Defined at line 1726 of ./engine/common/miniz.h*

 Limits canonical Huffman code table's max code size. 



